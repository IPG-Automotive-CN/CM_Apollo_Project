// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/data/proto/static_info.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fdata_2fproto_2fstatic_5finfo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fdata_2fproto_2fstatic_5finfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/canbus/proto/canbus_conf.pb.h"
#include "modules/canbus/proto/chassis.pb.h"
#include "modules/common/configs/proto/vehicle_config.pb.h"
#include "modules/control/proto/control_conf.pb.h"
#include "modules/routing/proto/routing.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fdata_2fproto_2fstatic_5finfo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
namespace apollo {
namespace data {
class EnvironmentInfo;
class EnvironmentInfoDefaultTypeInternal;
extern EnvironmentInfoDefaultTypeInternal _EnvironmentInfo_default_instance_;
class HardwareInfo;
class HardwareInfoDefaultTypeInternal;
extern HardwareInfoDefaultTypeInternal _HardwareInfo_default_instance_;
class HardwareInfo_ConfigsEntry_DoNotUse;
class HardwareInfo_ConfigsEntry_DoNotUseDefaultTypeInternal;
extern HardwareInfo_ConfigsEntry_DoNotUseDefaultTypeInternal _HardwareInfo_ConfigsEntry_DoNotUse_default_instance_;
class SoftwareInfo;
class SoftwareInfoDefaultTypeInternal;
extern SoftwareInfoDefaultTypeInternal _SoftwareInfo_default_instance_;
class SoftwareInfo_ConfigsEntry_DoNotUse;
class SoftwareInfo_ConfigsEntry_DoNotUseDefaultTypeInternal;
extern SoftwareInfo_ConfigsEntry_DoNotUseDefaultTypeInternal _SoftwareInfo_ConfigsEntry_DoNotUse_default_instance_;
class StaticInfo;
class StaticInfoDefaultTypeInternal;
extern StaticInfoDefaultTypeInternal _StaticInfo_default_instance_;
class StaticInfoConf;
class StaticInfoConfDefaultTypeInternal;
extern StaticInfoConfDefaultTypeInternal _StaticInfoConf_default_instance_;
class UserInfo;
class UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
class VehicleInfo;
class VehicleInfoDefaultTypeInternal;
extern VehicleInfoDefaultTypeInternal _VehicleInfo_default_instance_;
}  // namespace data
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::data::EnvironmentInfo* Arena::CreateMaybeMessage<::apollo::data::EnvironmentInfo>(Arena*);
template<> ::apollo::data::HardwareInfo* Arena::CreateMaybeMessage<::apollo::data::HardwareInfo>(Arena*);
template<> ::apollo::data::HardwareInfo_ConfigsEntry_DoNotUse* Arena::CreateMaybeMessage<::apollo::data::HardwareInfo_ConfigsEntry_DoNotUse>(Arena*);
template<> ::apollo::data::SoftwareInfo* Arena::CreateMaybeMessage<::apollo::data::SoftwareInfo>(Arena*);
template<> ::apollo::data::SoftwareInfo_ConfigsEntry_DoNotUse* Arena::CreateMaybeMessage<::apollo::data::SoftwareInfo_ConfigsEntry_DoNotUse>(Arena*);
template<> ::apollo::data::StaticInfo* Arena::CreateMaybeMessage<::apollo::data::StaticInfo>(Arena*);
template<> ::apollo::data::StaticInfoConf* Arena::CreateMaybeMessage<::apollo::data::StaticInfoConf>(Arena*);
template<> ::apollo::data::UserInfo* Arena::CreateMaybeMessage<::apollo::data::UserInfo>(Arena*);
template<> ::apollo::data::VehicleInfo* Arena::CreateMaybeMessage<::apollo::data::VehicleInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace data {

enum VehicleInfo_Brand : int {
  VehicleInfo_Brand_LINCOLN = 1,
  VehicleInfo_Brand_FORD = 2
};
bool VehicleInfo_Brand_IsValid(int value);
constexpr VehicleInfo_Brand VehicleInfo_Brand_Brand_MIN = VehicleInfo_Brand_LINCOLN;
constexpr VehicleInfo_Brand VehicleInfo_Brand_Brand_MAX = VehicleInfo_Brand_FORD;
constexpr int VehicleInfo_Brand_Brand_ARRAYSIZE = VehicleInfo_Brand_Brand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleInfo_Brand_descriptor();
template<typename T>
inline const std::string& VehicleInfo_Brand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehicleInfo_Brand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehicleInfo_Brand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehicleInfo_Brand_descriptor(), enum_t_value);
}
inline bool VehicleInfo_Brand_Parse(
    const std::string& name, VehicleInfo_Brand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehicleInfo_Brand>(
    VehicleInfo_Brand_descriptor(), name, value);
}
enum VehicleInfo_Model : int {
  VehicleInfo_Model_MKZ = 1,
  VehicleInfo_Model_TRANSIT = 2
};
bool VehicleInfo_Model_IsValid(int value);
constexpr VehicleInfo_Model VehicleInfo_Model_Model_MIN = VehicleInfo_Model_MKZ;
constexpr VehicleInfo_Model VehicleInfo_Model_Model_MAX = VehicleInfo_Model_TRANSIT;
constexpr int VehicleInfo_Model_Model_ARRAYSIZE = VehicleInfo_Model_Model_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleInfo_Model_descriptor();
template<typename T>
inline const std::string& VehicleInfo_Model_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehicleInfo_Model>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehicleInfo_Model_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehicleInfo_Model_descriptor(), enum_t_value);
}
inline bool VehicleInfo_Model_Parse(
    const std::string& name, VehicleInfo_Model* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehicleInfo_Model>(
    VehicleInfo_Model_descriptor(), name, value);
}
// ===================================================================

class VehicleInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.VehicleInfo) */ {
 public:
  VehicleInfo();
  virtual ~VehicleInfo();

  VehicleInfo(const VehicleInfo& from);
  VehicleInfo(VehicleInfo&& from) noexcept
    : VehicleInfo() {
    *this = ::std::move(from);
  }

  inline VehicleInfo& operator=(const VehicleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleInfo& operator=(VehicleInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VehicleInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleInfo* internal_default_instance() {
    return reinterpret_cast<const VehicleInfo*>(
               &_VehicleInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VehicleInfo& a, VehicleInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VehicleInfo* New() const final {
    return CreateMaybeMessage<VehicleInfo>(nullptr);
  }

  VehicleInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VehicleInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VehicleInfo& from);
  void MergeFrom(const VehicleInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.VehicleInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto);
    return ::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VehicleInfo_Brand Brand;
  static constexpr Brand LINCOLN =
    VehicleInfo_Brand_LINCOLN;
  static constexpr Brand FORD =
    VehicleInfo_Brand_FORD;
  static inline bool Brand_IsValid(int value) {
    return VehicleInfo_Brand_IsValid(value);
  }
  static constexpr Brand Brand_MIN =
    VehicleInfo_Brand_Brand_MIN;
  static constexpr Brand Brand_MAX =
    VehicleInfo_Brand_Brand_MAX;
  static constexpr int Brand_ARRAYSIZE =
    VehicleInfo_Brand_Brand_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Brand_descriptor() {
    return VehicleInfo_Brand_descriptor();
  }
  template<typename T>
  static inline const std::string& Brand_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Brand>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Brand_Name.");
    return VehicleInfo_Brand_Name(enum_t_value);
  }
  static inline bool Brand_Parse(const std::string& name,
      Brand* value) {
    return VehicleInfo_Brand_Parse(name, value);
  }

  typedef VehicleInfo_Model Model;
  static constexpr Model MKZ =
    VehicleInfo_Model_MKZ;
  static constexpr Model TRANSIT =
    VehicleInfo_Model_TRANSIT;
  static inline bool Model_IsValid(int value) {
    return VehicleInfo_Model_IsValid(value);
  }
  static constexpr Model Model_MIN =
    VehicleInfo_Model_Model_MIN;
  static constexpr Model Model_MAX =
    VehicleInfo_Model_Model_MAX;
  static constexpr int Model_ARRAYSIZE =
    VehicleInfo_Model_Model_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Model_descriptor() {
    return VehicleInfo_Model_descriptor();
  }
  template<typename T>
  static inline const std::string& Model_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Model>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Model_Name.");
    return VehicleInfo_Model_Name(enum_t_value);
  }
  static inline bool Model_Parse(const std::string& name,
      Model* value) {
    return VehicleInfo_Model_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLicenseFieldNumber = 4,
    kCanbusConfFieldNumber = 5,
    kVehicleConfigFieldNumber = 6,
    kControlConfigFieldNumber = 7,
    kBrandFieldNumber = 2,
    kModelFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .apollo.canbus.License license = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_license() const;
  private:
  bool _internal_has_license() const;
  public:
  PROTOBUF_DEPRECATED void clear_license();
  PROTOBUF_DEPRECATED const ::apollo::canbus::License& license() const;
  PROTOBUF_DEPRECATED ::apollo::canbus::License* release_license();
  PROTOBUF_DEPRECATED ::apollo::canbus::License* mutable_license();
  PROTOBUF_DEPRECATED void set_allocated_license(::apollo::canbus::License* license);
  private:
  const ::apollo::canbus::License& _internal_license() const;
  ::apollo::canbus::License* _internal_mutable_license();
  public:

  // optional .apollo.canbus.CanbusConf canbus_conf = 5;
  bool has_canbus_conf() const;
  private:
  bool _internal_has_canbus_conf() const;
  public:
  void clear_canbus_conf();
  const ::apollo::canbus::CanbusConf& canbus_conf() const;
  ::apollo::canbus::CanbusConf* release_canbus_conf();
  ::apollo::canbus::CanbusConf* mutable_canbus_conf();
  void set_allocated_canbus_conf(::apollo::canbus::CanbusConf* canbus_conf);
  private:
  const ::apollo::canbus::CanbusConf& _internal_canbus_conf() const;
  ::apollo::canbus::CanbusConf* _internal_mutable_canbus_conf();
  public:

  // optional .apollo.common.VehicleConfig vehicle_config = 6;
  bool has_vehicle_config() const;
  private:
  bool _internal_has_vehicle_config() const;
  public:
  void clear_vehicle_config();
  const ::apollo::common::VehicleConfig& vehicle_config() const;
  ::apollo::common::VehicleConfig* release_vehicle_config();
  ::apollo::common::VehicleConfig* mutable_vehicle_config();
  void set_allocated_vehicle_config(::apollo::common::VehicleConfig* vehicle_config);
  private:
  const ::apollo::common::VehicleConfig& _internal_vehicle_config() const;
  ::apollo::common::VehicleConfig* _internal_mutable_vehicle_config();
  public:

  // optional .apollo.control.ControlConf control_config = 7;
  bool has_control_config() const;
  private:
  bool _internal_has_control_config() const;
  public:
  void clear_control_config();
  const ::apollo::control::ControlConf& control_config() const;
  ::apollo::control::ControlConf* release_control_config();
  ::apollo::control::ControlConf* mutable_control_config();
  void set_allocated_control_config(::apollo::control::ControlConf* control_config);
  private:
  const ::apollo::control::ControlConf& _internal_control_config() const;
  ::apollo::control::ControlConf* _internal_mutable_control_config();
  public:

  // optional .apollo.data.VehicleInfo.Brand brand = 2;
  bool has_brand() const;
  private:
  bool _internal_has_brand() const;
  public:
  void clear_brand();
  ::apollo::data::VehicleInfo_Brand brand() const;
  void set_brand(::apollo::data::VehicleInfo_Brand value);
  private:
  ::apollo::data::VehicleInfo_Brand _internal_brand() const;
  void _internal_set_brand(::apollo::data::VehicleInfo_Brand value);
  public:

  // optional .apollo.data.VehicleInfo.Model model = 3;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  ::apollo::data::VehicleInfo_Model model() const;
  void set_model(::apollo::data::VehicleInfo_Model value);
  private:
  ::apollo::data::VehicleInfo_Model _internal_model() const;
  void _internal_set_model(::apollo::data::VehicleInfo_Model value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.data.VehicleInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::apollo::canbus::License* license_;
  ::apollo::canbus::CanbusConf* canbus_conf_;
  ::apollo::common::VehicleConfig* vehicle_config_;
  ::apollo::control::ControlConf* control_config_;
  int brand_;
  int model_;
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// -------------------------------------------------------------------

class EnvironmentInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.EnvironmentInfo) */ {
 public:
  EnvironmentInfo();
  virtual ~EnvironmentInfo();

  EnvironmentInfo(const EnvironmentInfo& from);
  EnvironmentInfo(EnvironmentInfo&& from) noexcept
    : EnvironmentInfo() {
    *this = ::std::move(from);
  }

  inline EnvironmentInfo& operator=(const EnvironmentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnvironmentInfo& operator=(EnvironmentInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnvironmentInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnvironmentInfo* internal_default_instance() {
    return reinterpret_cast<const EnvironmentInfo*>(
               &_EnvironmentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EnvironmentInfo& a, EnvironmentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EnvironmentInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnvironmentInfo* New() const final {
    return CreateMaybeMessage<EnvironmentInfo>(nullptr);
  }

  EnvironmentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnvironmentInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnvironmentInfo& from);
  void MergeFrom(const EnvironmentInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnvironmentInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.EnvironmentInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto);
    return ::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapNameFieldNumber = 1,
    kTemperatureFieldNumber = 2,
  };
  // optional string map_name = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_map_name() const;
  private:
  bool _internal_has_map_name() const;
  public:
  PROTOBUF_DEPRECATED void clear_map_name();
  PROTOBUF_DEPRECATED const std::string& map_name() const;
  PROTOBUF_DEPRECATED void set_map_name(const std::string& value);
  PROTOBUF_DEPRECATED void set_map_name(std::string&& value);
  PROTOBUF_DEPRECATED void set_map_name(const char* value);
  PROTOBUF_DEPRECATED void set_map_name(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_map_name();
  PROTOBUF_DEPRECATED std::string* release_map_name();
  PROTOBUF_DEPRECATED void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // optional float temperature = 2;
  bool has_temperature() const;
  private:
  bool _internal_has_temperature() const;
  public:
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.data.EnvironmentInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
  float temperature_;
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// -------------------------------------------------------------------

class HardwareInfo_ConfigsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HardwareInfo_ConfigsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HardwareInfo_ConfigsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  HardwareInfo_ConfigsEntry_DoNotUse();
  HardwareInfo_ConfigsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HardwareInfo_ConfigsEntry_DoNotUse& other);
  static const HardwareInfo_ConfigsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HardwareInfo_ConfigsEntry_DoNotUse*>(&_HardwareInfo_ConfigsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "apollo.data.HardwareInfo.ConfigsEntry.key");
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "apollo.data.HardwareInfo.ConfigsEntry.value");
#endif
    return true;
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto);
    return ::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto.file_level_metadata[2];
  }

  public:
};

// -------------------------------------------------------------------

class HardwareInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.HardwareInfo) */ {
 public:
  HardwareInfo();
  virtual ~HardwareInfo();

  HardwareInfo(const HardwareInfo& from);
  HardwareInfo(HardwareInfo&& from) noexcept
    : HardwareInfo() {
    *this = ::std::move(from);
  }

  inline HardwareInfo& operator=(const HardwareInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HardwareInfo& operator=(HardwareInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HardwareInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HardwareInfo* internal_default_instance() {
    return reinterpret_cast<const HardwareInfo*>(
               &_HardwareInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HardwareInfo& a, HardwareInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(HardwareInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HardwareInfo* New() const final {
    return CreateMaybeMessage<HardwareInfo>(nullptr);
  }

  HardwareInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HardwareInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HardwareInfo& from);
  void MergeFrom(const HardwareInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HardwareInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.HardwareInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto);
    return ::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigsFieldNumber = 1,
  };
  // map<string, string> configs = 1;
  int configs_size() const;
  private:
  int _internal_configs_size() const;
  public:
  void clear_configs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_configs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_configs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      configs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_configs();

  // @@protoc_insertion_point(class_scope:apollo.data.HardwareInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      HardwareInfo_ConfigsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > configs_;
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// -------------------------------------------------------------------

class SoftwareInfo_ConfigsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SoftwareInfo_ConfigsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SoftwareInfo_ConfigsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  SoftwareInfo_ConfigsEntry_DoNotUse();
  SoftwareInfo_ConfigsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SoftwareInfo_ConfigsEntry_DoNotUse& other);
  static const SoftwareInfo_ConfigsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SoftwareInfo_ConfigsEntry_DoNotUse*>(&_SoftwareInfo_ConfigsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "apollo.data.SoftwareInfo.ConfigsEntry.key");
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "apollo.data.SoftwareInfo.ConfigsEntry.value");
#endif
    return true;
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto);
    return ::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto.file_level_metadata[4];
  }

  public:
};

// -------------------------------------------------------------------

class SoftwareInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.SoftwareInfo) */ {
 public:
  SoftwareInfo();
  virtual ~SoftwareInfo();

  SoftwareInfo(const SoftwareInfo& from);
  SoftwareInfo(SoftwareInfo&& from) noexcept
    : SoftwareInfo() {
    *this = ::std::move(from);
  }

  inline SoftwareInfo& operator=(const SoftwareInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoftwareInfo& operator=(SoftwareInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SoftwareInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SoftwareInfo* internal_default_instance() {
    return reinterpret_cast<const SoftwareInfo*>(
               &_SoftwareInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SoftwareInfo& a, SoftwareInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SoftwareInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SoftwareInfo* New() const final {
    return CreateMaybeMessage<SoftwareInfo>(nullptr);
  }

  SoftwareInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SoftwareInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SoftwareInfo& from);
  void MergeFrom(const SoftwareInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoftwareInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.SoftwareInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto);
    return ::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigsFieldNumber = 4,
    kDockerImageFieldNumber = 1,
    kCommitIdFieldNumber = 2,
    kModeFieldNumber = 3,
    kLatestRoutingRequestFieldNumber = 5,
  };
  // map<string, string> configs = 4;
  int configs_size() const;
  private:
  int _internal_configs_size() const;
  public:
  void clear_configs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_configs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_configs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      configs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_configs();

  // optional string docker_image = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_docker_image() const;
  private:
  bool _internal_has_docker_image() const;
  public:
  PROTOBUF_DEPRECATED void clear_docker_image();
  PROTOBUF_DEPRECATED const std::string& docker_image() const;
  PROTOBUF_DEPRECATED void set_docker_image(const std::string& value);
  PROTOBUF_DEPRECATED void set_docker_image(std::string&& value);
  PROTOBUF_DEPRECATED void set_docker_image(const char* value);
  PROTOBUF_DEPRECATED void set_docker_image(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_docker_image();
  PROTOBUF_DEPRECATED std::string* release_docker_image();
  PROTOBUF_DEPRECATED void set_allocated_docker_image(std::string* docker_image);
  private:
  const std::string& _internal_docker_image() const;
  void _internal_set_docker_image(const std::string& value);
  std::string* _internal_mutable_docker_image();
  public:

  // optional string commit_id = 2;
  bool has_commit_id() const;
  private:
  bool _internal_has_commit_id() const;
  public:
  void clear_commit_id();
  const std::string& commit_id() const;
  void set_commit_id(const std::string& value);
  void set_commit_id(std::string&& value);
  void set_commit_id(const char* value);
  void set_commit_id(const char* value, size_t size);
  std::string* mutable_commit_id();
  std::string* release_commit_id();
  void set_allocated_commit_id(std::string* commit_id);
  private:
  const std::string& _internal_commit_id() const;
  void _internal_set_commit_id(const std::string& value);
  std::string* _internal_mutable_commit_id();
  public:

  // optional string mode = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  PROTOBUF_DEPRECATED void clear_mode();
  PROTOBUF_DEPRECATED const std::string& mode() const;
  PROTOBUF_DEPRECATED void set_mode(const std::string& value);
  PROTOBUF_DEPRECATED void set_mode(std::string&& value);
  PROTOBUF_DEPRECATED void set_mode(const char* value);
  PROTOBUF_DEPRECATED void set_mode(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_mode();
  PROTOBUF_DEPRECATED std::string* release_mode();
  PROTOBUF_DEPRECATED void set_allocated_mode(std::string* mode);
  private:
  const std::string& _internal_mode() const;
  void _internal_set_mode(const std::string& value);
  std::string* _internal_mutable_mode();
  public:

  // optional .apollo.routing.RoutingRequest latest_routing_request = 5;
  bool has_latest_routing_request() const;
  private:
  bool _internal_has_latest_routing_request() const;
  public:
  void clear_latest_routing_request();
  const ::apollo::routing::RoutingRequest& latest_routing_request() const;
  ::apollo::routing::RoutingRequest* release_latest_routing_request();
  ::apollo::routing::RoutingRequest* mutable_latest_routing_request();
  void set_allocated_latest_routing_request(::apollo::routing::RoutingRequest* latest_routing_request);
  private:
  const ::apollo::routing::RoutingRequest& _internal_latest_routing_request() const;
  ::apollo::routing::RoutingRequest* _internal_mutable_latest_routing_request();
  public:

  // @@protoc_insertion_point(class_scope:apollo.data.SoftwareInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SoftwareInfo_ConfigsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > configs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr docker_image_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commit_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_;
  ::apollo::routing::RoutingRequest* latest_routing_request_;
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// -------------------------------------------------------------------

class UserInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.UserInfo) */ {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserInfo* New() const final {
    return CreateMaybeMessage<UserInfo>(nullptr);
  }

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.UserInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto);
    return ::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityFieldNumber = 1,
    kDriverFieldNumber = 2,
    kCoDriverFieldNumber = 3,
  };
  // optional string entity = 1;
  bool has_entity() const;
  private:
  bool _internal_has_entity() const;
  public:
  void clear_entity();
  const std::string& entity() const;
  void set_entity(const std::string& value);
  void set_entity(std::string&& value);
  void set_entity(const char* value);
  void set_entity(const char* value, size_t size);
  std::string* mutable_entity();
  std::string* release_entity();
  void set_allocated_entity(std::string* entity);
  private:
  const std::string& _internal_entity() const;
  void _internal_set_entity(const std::string& value);
  std::string* _internal_mutable_entity();
  public:

  // optional string driver = 2;
  bool has_driver() const;
  private:
  bool _internal_has_driver() const;
  public:
  void clear_driver();
  const std::string& driver() const;
  void set_driver(const std::string& value);
  void set_driver(std::string&& value);
  void set_driver(const char* value);
  void set_driver(const char* value, size_t size);
  std::string* mutable_driver();
  std::string* release_driver();
  void set_allocated_driver(std::string* driver);
  private:
  const std::string& _internal_driver() const;
  void _internal_set_driver(const std::string& value);
  std::string* _internal_mutable_driver();
  public:

  // optional string co_driver = 3;
  bool has_co_driver() const;
  private:
  bool _internal_has_co_driver() const;
  public:
  void clear_co_driver();
  const std::string& co_driver() const;
  void set_co_driver(const std::string& value);
  void set_co_driver(std::string&& value);
  void set_co_driver(const char* value);
  void set_co_driver(const char* value, size_t size);
  std::string* mutable_co_driver();
  std::string* release_co_driver();
  void set_allocated_co_driver(std::string* co_driver);
  private:
  const std::string& _internal_co_driver() const;
  void _internal_set_co_driver(const std::string& value);
  std::string* _internal_mutable_co_driver();
  public:

  // @@protoc_insertion_point(class_scope:apollo.data.UserInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr co_driver_;
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// -------------------------------------------------------------------

class StaticInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.StaticInfo) */ {
 public:
  StaticInfo();
  virtual ~StaticInfo();

  StaticInfo(const StaticInfo& from);
  StaticInfo(StaticInfo&& from) noexcept
    : StaticInfo() {
    *this = ::std::move(from);
  }

  inline StaticInfo& operator=(const StaticInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaticInfo& operator=(StaticInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StaticInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StaticInfo* internal_default_instance() {
    return reinterpret_cast<const StaticInfo*>(
               &_StaticInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StaticInfo& a, StaticInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StaticInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StaticInfo* New() const final {
    return CreateMaybeMessage<StaticInfo>(nullptr);
  }

  StaticInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StaticInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StaticInfo& from);
  void MergeFrom(const StaticInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaticInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.StaticInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto);
    return ::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleFieldNumber = 1,
    kEnvironmentFieldNumber = 2,
    kHardwareFieldNumber = 3,
    kSoftwareFieldNumber = 4,
    kUserFieldNumber = 5,
  };
  // optional .apollo.data.VehicleInfo vehicle = 1;
  bool has_vehicle() const;
  private:
  bool _internal_has_vehicle() const;
  public:
  void clear_vehicle();
  const ::apollo::data::VehicleInfo& vehicle() const;
  ::apollo::data::VehicleInfo* release_vehicle();
  ::apollo::data::VehicleInfo* mutable_vehicle();
  void set_allocated_vehicle(::apollo::data::VehicleInfo* vehicle);
  private:
  const ::apollo::data::VehicleInfo& _internal_vehicle() const;
  ::apollo::data::VehicleInfo* _internal_mutable_vehicle();
  public:

  // optional .apollo.data.EnvironmentInfo environment = 2;
  bool has_environment() const;
  private:
  bool _internal_has_environment() const;
  public:
  void clear_environment();
  const ::apollo::data::EnvironmentInfo& environment() const;
  ::apollo::data::EnvironmentInfo* release_environment();
  ::apollo::data::EnvironmentInfo* mutable_environment();
  void set_allocated_environment(::apollo::data::EnvironmentInfo* environment);
  private:
  const ::apollo::data::EnvironmentInfo& _internal_environment() const;
  ::apollo::data::EnvironmentInfo* _internal_mutable_environment();
  public:

  // optional .apollo.data.HardwareInfo hardware = 3;
  bool has_hardware() const;
  private:
  bool _internal_has_hardware() const;
  public:
  void clear_hardware();
  const ::apollo::data::HardwareInfo& hardware() const;
  ::apollo::data::HardwareInfo* release_hardware();
  ::apollo::data::HardwareInfo* mutable_hardware();
  void set_allocated_hardware(::apollo::data::HardwareInfo* hardware);
  private:
  const ::apollo::data::HardwareInfo& _internal_hardware() const;
  ::apollo::data::HardwareInfo* _internal_mutable_hardware();
  public:

  // optional .apollo.data.SoftwareInfo software = 4;
  bool has_software() const;
  private:
  bool _internal_has_software() const;
  public:
  void clear_software();
  const ::apollo::data::SoftwareInfo& software() const;
  ::apollo::data::SoftwareInfo* release_software();
  ::apollo::data::SoftwareInfo* mutable_software();
  void set_allocated_software(::apollo::data::SoftwareInfo* software);
  private:
  const ::apollo::data::SoftwareInfo& _internal_software() const;
  ::apollo::data::SoftwareInfo* _internal_mutable_software();
  public:

  // optional .apollo.data.UserInfo user = 5;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::apollo::data::UserInfo& user() const;
  ::apollo::data::UserInfo* release_user();
  ::apollo::data::UserInfo* mutable_user();
  void set_allocated_user(::apollo::data::UserInfo* user);
  private:
  const ::apollo::data::UserInfo& _internal_user() const;
  ::apollo::data::UserInfo* _internal_mutable_user();
  public:

  // @@protoc_insertion_point(class_scope:apollo.data.StaticInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::data::VehicleInfo* vehicle_;
  ::apollo::data::EnvironmentInfo* environment_;
  ::apollo::data::HardwareInfo* hardware_;
  ::apollo::data::SoftwareInfo* software_;
  ::apollo::data::UserInfo* user_;
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// -------------------------------------------------------------------

class StaticInfoConf :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.StaticInfoConf) */ {
 public:
  StaticInfoConf();
  virtual ~StaticInfoConf();

  StaticInfoConf(const StaticInfoConf& from);
  StaticInfoConf(StaticInfoConf&& from) noexcept
    : StaticInfoConf() {
    *this = ::std::move(from);
  }

  inline StaticInfoConf& operator=(const StaticInfoConf& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaticInfoConf& operator=(StaticInfoConf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StaticInfoConf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StaticInfoConf* internal_default_instance() {
    return reinterpret_cast<const StaticInfoConf*>(
               &_StaticInfoConf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StaticInfoConf& a, StaticInfoConf& b) {
    a.Swap(&b);
  }
  inline void Swap(StaticInfoConf* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StaticInfoConf* New() const final {
    return CreateMaybeMessage<StaticInfoConf>(nullptr);
  }

  StaticInfoConf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StaticInfoConf>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StaticInfoConf& from);
  void MergeFrom(const StaticInfoConf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaticInfoConf* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.StaticInfoConf";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto);
    return ::descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHardwareConfigsFieldNumber = 1,
    kSoftwareConfigsFieldNumber = 2,
  };
  // repeated string hardware_configs = 1;
  int hardware_configs_size() const;
  private:
  int _internal_hardware_configs_size() const;
  public:
  void clear_hardware_configs();
  const std::string& hardware_configs(int index) const;
  std::string* mutable_hardware_configs(int index);
  void set_hardware_configs(int index, const std::string& value);
  void set_hardware_configs(int index, std::string&& value);
  void set_hardware_configs(int index, const char* value);
  void set_hardware_configs(int index, const char* value, size_t size);
  std::string* add_hardware_configs();
  void add_hardware_configs(const std::string& value);
  void add_hardware_configs(std::string&& value);
  void add_hardware_configs(const char* value);
  void add_hardware_configs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hardware_configs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hardware_configs();
  private:
  const std::string& _internal_hardware_configs(int index) const;
  std::string* _internal_add_hardware_configs();
  public:

  // repeated string software_configs = 2;
  int software_configs_size() const;
  private:
  int _internal_software_configs_size() const;
  public:
  void clear_software_configs();
  const std::string& software_configs(int index) const;
  std::string* mutable_software_configs(int index);
  void set_software_configs(int index, const std::string& value);
  void set_software_configs(int index, std::string&& value);
  void set_software_configs(int index, const char* value);
  void set_software_configs(int index, const char* value, size_t size);
  std::string* add_software_configs();
  void add_software_configs(const std::string& value);
  void add_software_configs(std::string&& value);
  void add_software_configs(const char* value);
  void add_software_configs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& software_configs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_software_configs();
  private:
  const std::string& _internal_software_configs(int index) const;
  std::string* _internal_add_software_configs();
  public:

  // @@protoc_insertion_point(class_scope:apollo.data.StaticInfoConf)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hardware_configs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> software_configs_;
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VehicleInfo

// optional string name = 1;
inline bool VehicleInfo::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VehicleInfo::has_name() const {
  return _internal_has_name();
}
inline void VehicleInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleInfo::name() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.name)
  return _internal_name();
}
inline void VehicleInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:apollo.data.VehicleInfo.name)
}
inline std::string* VehicleInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:apollo.data.VehicleInfo.name)
  return _internal_mutable_name();
}
inline const std::string& VehicleInfo::_internal_name() const {
  return name_.GetNoArena();
}
inline void VehicleInfo::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void VehicleInfo::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.data.VehicleInfo.name)
}
inline void VehicleInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.VehicleInfo.name)
}
inline void VehicleInfo::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.VehicleInfo.name)
}
inline std::string* VehicleInfo::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VehicleInfo::release_name() {
  // @@protoc_insertion_point(field_release:apollo.data.VehicleInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.VehicleInfo.name)
}

// optional .apollo.data.VehicleInfo.Brand brand = 2;
inline bool VehicleInfo::_internal_has_brand() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool VehicleInfo::has_brand() const {
  return _internal_has_brand();
}
inline void VehicleInfo::clear_brand() {
  brand_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::apollo::data::VehicleInfo_Brand VehicleInfo::_internal_brand() const {
  return static_cast< ::apollo::data::VehicleInfo_Brand >(brand_);
}
inline ::apollo::data::VehicleInfo_Brand VehicleInfo::brand() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.brand)
  return _internal_brand();
}
inline void VehicleInfo::_internal_set_brand(::apollo::data::VehicleInfo_Brand value) {
  assert(::apollo::data::VehicleInfo_Brand_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  brand_ = value;
}
inline void VehicleInfo::set_brand(::apollo::data::VehicleInfo_Brand value) {
  _internal_set_brand(value);
  // @@protoc_insertion_point(field_set:apollo.data.VehicleInfo.brand)
}

// optional .apollo.data.VehicleInfo.Model model = 3;
inline bool VehicleInfo::_internal_has_model() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool VehicleInfo::has_model() const {
  return _internal_has_model();
}
inline void VehicleInfo::clear_model() {
  model_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::apollo::data::VehicleInfo_Model VehicleInfo::_internal_model() const {
  return static_cast< ::apollo::data::VehicleInfo_Model >(model_);
}
inline ::apollo::data::VehicleInfo_Model VehicleInfo::model() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.model)
  return _internal_model();
}
inline void VehicleInfo::_internal_set_model(::apollo::data::VehicleInfo_Model value) {
  assert(::apollo::data::VehicleInfo_Model_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  model_ = value;
}
inline void VehicleInfo::set_model(::apollo::data::VehicleInfo_Model value) {
  _internal_set_model(value);
  // @@protoc_insertion_point(field_set:apollo.data.VehicleInfo.model)
}

// optional .apollo.canbus.License license = 4 [deprecated = true];
inline bool VehicleInfo::_internal_has_license() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || license_ != nullptr);
  return value;
}
inline bool VehicleInfo::has_license() const {
  return _internal_has_license();
}
inline const ::apollo::canbus::License& VehicleInfo::_internal_license() const {
  const ::apollo::canbus::License* p = license_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::License*>(
      &::apollo::canbus::_License_default_instance_);
}
inline const ::apollo::canbus::License& VehicleInfo::license() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.license)
  return _internal_license();
}
inline ::apollo::canbus::License* VehicleInfo::release_license() {
  // @@protoc_insertion_point(field_release:apollo.data.VehicleInfo.license)
  _has_bits_[0] &= ~0x00000002u;
  ::apollo::canbus::License* temp = license_;
  license_ = nullptr;
  return temp;
}
inline ::apollo::canbus::License* VehicleInfo::_internal_mutable_license() {
  _has_bits_[0] |= 0x00000002u;
  if (license_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::License>(GetArenaNoVirtual());
    license_ = p;
  }
  return license_;
}
inline ::apollo::canbus::License* VehicleInfo::mutable_license() {
  // @@protoc_insertion_point(field_mutable:apollo.data.VehicleInfo.license)
  return _internal_mutable_license();
}
inline void VehicleInfo::set_allocated_license(::apollo::canbus::License* license) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(license_);
  }
  if (license) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      license = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, license, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  license_ = license;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.VehicleInfo.license)
}

// optional .apollo.canbus.CanbusConf canbus_conf = 5;
inline bool VehicleInfo::_internal_has_canbus_conf() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || canbus_conf_ != nullptr);
  return value;
}
inline bool VehicleInfo::has_canbus_conf() const {
  return _internal_has_canbus_conf();
}
inline const ::apollo::canbus::CanbusConf& VehicleInfo::_internal_canbus_conf() const {
  const ::apollo::canbus::CanbusConf* p = canbus_conf_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::CanbusConf*>(
      &::apollo::canbus::_CanbusConf_default_instance_);
}
inline const ::apollo::canbus::CanbusConf& VehicleInfo::canbus_conf() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.canbus_conf)
  return _internal_canbus_conf();
}
inline ::apollo::canbus::CanbusConf* VehicleInfo::release_canbus_conf() {
  // @@protoc_insertion_point(field_release:apollo.data.VehicleInfo.canbus_conf)
  _has_bits_[0] &= ~0x00000004u;
  ::apollo::canbus::CanbusConf* temp = canbus_conf_;
  canbus_conf_ = nullptr;
  return temp;
}
inline ::apollo::canbus::CanbusConf* VehicleInfo::_internal_mutable_canbus_conf() {
  _has_bits_[0] |= 0x00000004u;
  if (canbus_conf_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::CanbusConf>(GetArenaNoVirtual());
    canbus_conf_ = p;
  }
  return canbus_conf_;
}
inline ::apollo::canbus::CanbusConf* VehicleInfo::mutable_canbus_conf() {
  // @@protoc_insertion_point(field_mutable:apollo.data.VehicleInfo.canbus_conf)
  return _internal_mutable_canbus_conf();
}
inline void VehicleInfo::set_allocated_canbus_conf(::apollo::canbus::CanbusConf* canbus_conf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(canbus_conf_);
  }
  if (canbus_conf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      canbus_conf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, canbus_conf, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  canbus_conf_ = canbus_conf;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.VehicleInfo.canbus_conf)
}

// optional .apollo.common.VehicleConfig vehicle_config = 6;
inline bool VehicleInfo::_internal_has_vehicle_config() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || vehicle_config_ != nullptr);
  return value;
}
inline bool VehicleInfo::has_vehicle_config() const {
  return _internal_has_vehicle_config();
}
inline const ::apollo::common::VehicleConfig& VehicleInfo::_internal_vehicle_config() const {
  const ::apollo::common::VehicleConfig* p = vehicle_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::common::VehicleConfig*>(
      &::apollo::common::_VehicleConfig_default_instance_);
}
inline const ::apollo::common::VehicleConfig& VehicleInfo::vehicle_config() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.vehicle_config)
  return _internal_vehicle_config();
}
inline ::apollo::common::VehicleConfig* VehicleInfo::release_vehicle_config() {
  // @@protoc_insertion_point(field_release:apollo.data.VehicleInfo.vehicle_config)
  _has_bits_[0] &= ~0x00000008u;
  ::apollo::common::VehicleConfig* temp = vehicle_config_;
  vehicle_config_ = nullptr;
  return temp;
}
inline ::apollo::common::VehicleConfig* VehicleInfo::_internal_mutable_vehicle_config() {
  _has_bits_[0] |= 0x00000008u;
  if (vehicle_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::VehicleConfig>(GetArenaNoVirtual());
    vehicle_config_ = p;
  }
  return vehicle_config_;
}
inline ::apollo::common::VehicleConfig* VehicleInfo::mutable_vehicle_config() {
  // @@protoc_insertion_point(field_mutable:apollo.data.VehicleInfo.vehicle_config)
  return _internal_mutable_vehicle_config();
}
inline void VehicleInfo::set_allocated_vehicle_config(::apollo::common::VehicleConfig* vehicle_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehicle_config_);
  }
  if (vehicle_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vehicle_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  vehicle_config_ = vehicle_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.VehicleInfo.vehicle_config)
}

// optional .apollo.control.ControlConf control_config = 7;
inline bool VehicleInfo::_internal_has_control_config() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || control_config_ != nullptr);
  return value;
}
inline bool VehicleInfo::has_control_config() const {
  return _internal_has_control_config();
}
inline const ::apollo::control::ControlConf& VehicleInfo::_internal_control_config() const {
  const ::apollo::control::ControlConf* p = control_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::control::ControlConf*>(
      &::apollo::control::_ControlConf_default_instance_);
}
inline const ::apollo::control::ControlConf& VehicleInfo::control_config() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.control_config)
  return _internal_control_config();
}
inline ::apollo::control::ControlConf* VehicleInfo::release_control_config() {
  // @@protoc_insertion_point(field_release:apollo.data.VehicleInfo.control_config)
  _has_bits_[0] &= ~0x00000010u;
  ::apollo::control::ControlConf* temp = control_config_;
  control_config_ = nullptr;
  return temp;
}
inline ::apollo::control::ControlConf* VehicleInfo::_internal_mutable_control_config() {
  _has_bits_[0] |= 0x00000010u;
  if (control_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::control::ControlConf>(GetArenaNoVirtual());
    control_config_ = p;
  }
  return control_config_;
}
inline ::apollo::control::ControlConf* VehicleInfo::mutable_control_config() {
  // @@protoc_insertion_point(field_mutable:apollo.data.VehicleInfo.control_config)
  return _internal_mutable_control_config();
}
inline void VehicleInfo::set_allocated_control_config(::apollo::control::ControlConf* control_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(control_config_);
  }
  if (control_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      control_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  control_config_ = control_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.VehicleInfo.control_config)
}

// -------------------------------------------------------------------

// EnvironmentInfo

// optional string map_name = 1 [deprecated = true];
inline bool EnvironmentInfo::_internal_has_map_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EnvironmentInfo::has_map_name() const {
  return _internal_has_map_name();
}
inline void EnvironmentInfo::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EnvironmentInfo::map_name() const {
  // @@protoc_insertion_point(field_get:apollo.data.EnvironmentInfo.map_name)
  return _internal_map_name();
}
inline void EnvironmentInfo::set_map_name(const std::string& value) {
  _internal_set_map_name(value);
  // @@protoc_insertion_point(field_set:apollo.data.EnvironmentInfo.map_name)
}
inline std::string* EnvironmentInfo::mutable_map_name() {
  // @@protoc_insertion_point(field_mutable:apollo.data.EnvironmentInfo.map_name)
  return _internal_mutable_map_name();
}
inline const std::string& EnvironmentInfo::_internal_map_name() const {
  return map_name_.GetNoArena();
}
inline void EnvironmentInfo::_internal_set_map_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void EnvironmentInfo::set_map_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  map_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.data.EnvironmentInfo.map_name)
}
inline void EnvironmentInfo::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.EnvironmentInfo.map_name)
}
inline void EnvironmentInfo::set_map_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.EnvironmentInfo.map_name)
}
inline std::string* EnvironmentInfo::_internal_mutable_map_name() {
  _has_bits_[0] |= 0x00000001u;
  return map_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EnvironmentInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:apollo.data.EnvironmentInfo.map_name)
  if (!_internal_has_map_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return map_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EnvironmentInfo::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  map_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.EnvironmentInfo.map_name)
}

// optional float temperature = 2;
inline bool EnvironmentInfo::_internal_has_temperature() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EnvironmentInfo::has_temperature() const {
  return _internal_has_temperature();
}
inline void EnvironmentInfo::clear_temperature() {
  temperature_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float EnvironmentInfo::_internal_temperature() const {
  return temperature_;
}
inline float EnvironmentInfo::temperature() const {
  // @@protoc_insertion_point(field_get:apollo.data.EnvironmentInfo.temperature)
  return _internal_temperature();
}
inline void EnvironmentInfo::_internal_set_temperature(float value) {
  _has_bits_[0] |= 0x00000002u;
  temperature_ = value;
}
inline void EnvironmentInfo::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:apollo.data.EnvironmentInfo.temperature)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HardwareInfo

// map<string, string> configs = 1;
inline int HardwareInfo::_internal_configs_size() const {
  return configs_.size();
}
inline int HardwareInfo::configs_size() const {
  return _internal_configs_size();
}
inline void HardwareInfo::clear_configs() {
  configs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HardwareInfo::_internal_configs() const {
  return configs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HardwareInfo::configs() const {
  // @@protoc_insertion_point(field_map:apollo.data.HardwareInfo.configs)
  return _internal_configs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HardwareInfo::_internal_mutable_configs() {
  return configs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HardwareInfo::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_map:apollo.data.HardwareInfo.configs)
  return _internal_mutable_configs();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SoftwareInfo

// optional string docker_image = 1 [deprecated = true];
inline bool SoftwareInfo::_internal_has_docker_image() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SoftwareInfo::has_docker_image() const {
  return _internal_has_docker_image();
}
inline void SoftwareInfo::clear_docker_image() {
  docker_image_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SoftwareInfo::docker_image() const {
  // @@protoc_insertion_point(field_get:apollo.data.SoftwareInfo.docker_image)
  return _internal_docker_image();
}
inline void SoftwareInfo::set_docker_image(const std::string& value) {
  _internal_set_docker_image(value);
  // @@protoc_insertion_point(field_set:apollo.data.SoftwareInfo.docker_image)
}
inline std::string* SoftwareInfo::mutable_docker_image() {
  // @@protoc_insertion_point(field_mutable:apollo.data.SoftwareInfo.docker_image)
  return _internal_mutable_docker_image();
}
inline const std::string& SoftwareInfo::_internal_docker_image() const {
  return docker_image_.GetNoArena();
}
inline void SoftwareInfo::_internal_set_docker_image(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  docker_image_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SoftwareInfo::set_docker_image(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  docker_image_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.data.SoftwareInfo.docker_image)
}
inline void SoftwareInfo::set_docker_image(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  docker_image_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.SoftwareInfo.docker_image)
}
inline void SoftwareInfo::set_docker_image(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  docker_image_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.SoftwareInfo.docker_image)
}
inline std::string* SoftwareInfo::_internal_mutable_docker_image() {
  _has_bits_[0] |= 0x00000001u;
  return docker_image_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SoftwareInfo::release_docker_image() {
  // @@protoc_insertion_point(field_release:apollo.data.SoftwareInfo.docker_image)
  if (!_internal_has_docker_image()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return docker_image_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SoftwareInfo::set_allocated_docker_image(std::string* docker_image) {
  if (docker_image != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  docker_image_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), docker_image);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.SoftwareInfo.docker_image)
}

// optional string commit_id = 2;
inline bool SoftwareInfo::_internal_has_commit_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SoftwareInfo::has_commit_id() const {
  return _internal_has_commit_id();
}
inline void SoftwareInfo::clear_commit_id() {
  commit_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SoftwareInfo::commit_id() const {
  // @@protoc_insertion_point(field_get:apollo.data.SoftwareInfo.commit_id)
  return _internal_commit_id();
}
inline void SoftwareInfo::set_commit_id(const std::string& value) {
  _internal_set_commit_id(value);
  // @@protoc_insertion_point(field_set:apollo.data.SoftwareInfo.commit_id)
}
inline std::string* SoftwareInfo::mutable_commit_id() {
  // @@protoc_insertion_point(field_mutable:apollo.data.SoftwareInfo.commit_id)
  return _internal_mutable_commit_id();
}
inline const std::string& SoftwareInfo::_internal_commit_id() const {
  return commit_id_.GetNoArena();
}
inline void SoftwareInfo::_internal_set_commit_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  commit_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SoftwareInfo::set_commit_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  commit_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.data.SoftwareInfo.commit_id)
}
inline void SoftwareInfo::set_commit_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  commit_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.SoftwareInfo.commit_id)
}
inline void SoftwareInfo::set_commit_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  commit_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.SoftwareInfo.commit_id)
}
inline std::string* SoftwareInfo::_internal_mutable_commit_id() {
  _has_bits_[0] |= 0x00000002u;
  return commit_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SoftwareInfo::release_commit_id() {
  // @@protoc_insertion_point(field_release:apollo.data.SoftwareInfo.commit_id)
  if (!_internal_has_commit_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return commit_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SoftwareInfo::set_allocated_commit_id(std::string* commit_id) {
  if (commit_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  commit_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), commit_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.SoftwareInfo.commit_id)
}

// optional string mode = 3 [deprecated = true];
inline bool SoftwareInfo::_internal_has_mode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SoftwareInfo::has_mode() const {
  return _internal_has_mode();
}
inline void SoftwareInfo::clear_mode() {
  mode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SoftwareInfo::mode() const {
  // @@protoc_insertion_point(field_get:apollo.data.SoftwareInfo.mode)
  return _internal_mode();
}
inline void SoftwareInfo::set_mode(const std::string& value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:apollo.data.SoftwareInfo.mode)
}
inline std::string* SoftwareInfo::mutable_mode() {
  // @@protoc_insertion_point(field_mutable:apollo.data.SoftwareInfo.mode)
  return _internal_mutable_mode();
}
inline const std::string& SoftwareInfo::_internal_mode() const {
  return mode_.GetNoArena();
}
inline void SoftwareInfo::_internal_set_mode(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SoftwareInfo::set_mode(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  mode_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.data.SoftwareInfo.mode)
}
inline void SoftwareInfo::set_mode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.SoftwareInfo.mode)
}
inline void SoftwareInfo::set_mode(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.SoftwareInfo.mode)
}
inline std::string* SoftwareInfo::_internal_mutable_mode() {
  _has_bits_[0] |= 0x00000004u;
  return mode_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SoftwareInfo::release_mode() {
  // @@protoc_insertion_point(field_release:apollo.data.SoftwareInfo.mode)
  if (!_internal_has_mode()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return mode_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SoftwareInfo::set_allocated_mode(std::string* mode) {
  if (mode != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  mode_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.SoftwareInfo.mode)
}

// map<string, string> configs = 4;
inline int SoftwareInfo::_internal_configs_size() const {
  return configs_.size();
}
inline int SoftwareInfo::configs_size() const {
  return _internal_configs_size();
}
inline void SoftwareInfo::clear_configs() {
  configs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SoftwareInfo::_internal_configs() const {
  return configs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SoftwareInfo::configs() const {
  // @@protoc_insertion_point(field_map:apollo.data.SoftwareInfo.configs)
  return _internal_configs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SoftwareInfo::_internal_mutable_configs() {
  return configs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SoftwareInfo::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_map:apollo.data.SoftwareInfo.configs)
  return _internal_mutable_configs();
}

// optional .apollo.routing.RoutingRequest latest_routing_request = 5;
inline bool SoftwareInfo::_internal_has_latest_routing_request() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || latest_routing_request_ != nullptr);
  return value;
}
inline bool SoftwareInfo::has_latest_routing_request() const {
  return _internal_has_latest_routing_request();
}
inline const ::apollo::routing::RoutingRequest& SoftwareInfo::_internal_latest_routing_request() const {
  const ::apollo::routing::RoutingRequest* p = latest_routing_request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::routing::RoutingRequest*>(
      &::apollo::routing::_RoutingRequest_default_instance_);
}
inline const ::apollo::routing::RoutingRequest& SoftwareInfo::latest_routing_request() const {
  // @@protoc_insertion_point(field_get:apollo.data.SoftwareInfo.latest_routing_request)
  return _internal_latest_routing_request();
}
inline ::apollo::routing::RoutingRequest* SoftwareInfo::release_latest_routing_request() {
  // @@protoc_insertion_point(field_release:apollo.data.SoftwareInfo.latest_routing_request)
  _has_bits_[0] &= ~0x00000008u;
  ::apollo::routing::RoutingRequest* temp = latest_routing_request_;
  latest_routing_request_ = nullptr;
  return temp;
}
inline ::apollo::routing::RoutingRequest* SoftwareInfo::_internal_mutable_latest_routing_request() {
  _has_bits_[0] |= 0x00000008u;
  if (latest_routing_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::routing::RoutingRequest>(GetArenaNoVirtual());
    latest_routing_request_ = p;
  }
  return latest_routing_request_;
}
inline ::apollo::routing::RoutingRequest* SoftwareInfo::mutable_latest_routing_request() {
  // @@protoc_insertion_point(field_mutable:apollo.data.SoftwareInfo.latest_routing_request)
  return _internal_mutable_latest_routing_request();
}
inline void SoftwareInfo::set_allocated_latest_routing_request(::apollo::routing::RoutingRequest* latest_routing_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(latest_routing_request_);
  }
  if (latest_routing_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      latest_routing_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latest_routing_request, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  latest_routing_request_ = latest_routing_request;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.SoftwareInfo.latest_routing_request)
}

// -------------------------------------------------------------------

// UserInfo

// optional string entity = 1;
inline bool UserInfo::_internal_has_entity() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserInfo::has_entity() const {
  return _internal_has_entity();
}
inline void UserInfo::clear_entity() {
  entity_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserInfo::entity() const {
  // @@protoc_insertion_point(field_get:apollo.data.UserInfo.entity)
  return _internal_entity();
}
inline void UserInfo::set_entity(const std::string& value) {
  _internal_set_entity(value);
  // @@protoc_insertion_point(field_set:apollo.data.UserInfo.entity)
}
inline std::string* UserInfo::mutable_entity() {
  // @@protoc_insertion_point(field_mutable:apollo.data.UserInfo.entity)
  return _internal_mutable_entity();
}
inline const std::string& UserInfo::_internal_entity() const {
  return entity_.GetNoArena();
}
inline void UserInfo::_internal_set_entity(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  entity_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void UserInfo::set_entity(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  entity_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.data.UserInfo.entity)
}
inline void UserInfo::set_entity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  entity_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.UserInfo.entity)
}
inline void UserInfo::set_entity(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  entity_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.UserInfo.entity)
}
inline std::string* UserInfo::_internal_mutable_entity() {
  _has_bits_[0] |= 0x00000001u;
  return entity_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserInfo::release_entity() {
  // @@protoc_insertion_point(field_release:apollo.data.UserInfo.entity)
  if (!_internal_has_entity()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return entity_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_entity(std::string* entity) {
  if (entity != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  entity_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.UserInfo.entity)
}

// optional string driver = 2;
inline bool UserInfo::_internal_has_driver() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserInfo::has_driver() const {
  return _internal_has_driver();
}
inline void UserInfo::clear_driver() {
  driver_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserInfo::driver() const {
  // @@protoc_insertion_point(field_get:apollo.data.UserInfo.driver)
  return _internal_driver();
}
inline void UserInfo::set_driver(const std::string& value) {
  _internal_set_driver(value);
  // @@protoc_insertion_point(field_set:apollo.data.UserInfo.driver)
}
inline std::string* UserInfo::mutable_driver() {
  // @@protoc_insertion_point(field_mutable:apollo.data.UserInfo.driver)
  return _internal_mutable_driver();
}
inline const std::string& UserInfo::_internal_driver() const {
  return driver_.GetNoArena();
}
inline void UserInfo::_internal_set_driver(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  driver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void UserInfo::set_driver(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  driver_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.data.UserInfo.driver)
}
inline void UserInfo::set_driver(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  driver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.UserInfo.driver)
}
inline void UserInfo::set_driver(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  driver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.UserInfo.driver)
}
inline std::string* UserInfo::_internal_mutable_driver() {
  _has_bits_[0] |= 0x00000002u;
  return driver_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserInfo::release_driver() {
  // @@protoc_insertion_point(field_release:apollo.data.UserInfo.driver)
  if (!_internal_has_driver()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return driver_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_driver(std::string* driver) {
  if (driver != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  driver_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), driver);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.UserInfo.driver)
}

// optional string co_driver = 3;
inline bool UserInfo::_internal_has_co_driver() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserInfo::has_co_driver() const {
  return _internal_has_co_driver();
}
inline void UserInfo::clear_co_driver() {
  co_driver_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserInfo::co_driver() const {
  // @@protoc_insertion_point(field_get:apollo.data.UserInfo.co_driver)
  return _internal_co_driver();
}
inline void UserInfo::set_co_driver(const std::string& value) {
  _internal_set_co_driver(value);
  // @@protoc_insertion_point(field_set:apollo.data.UserInfo.co_driver)
}
inline std::string* UserInfo::mutable_co_driver() {
  // @@protoc_insertion_point(field_mutable:apollo.data.UserInfo.co_driver)
  return _internal_mutable_co_driver();
}
inline const std::string& UserInfo::_internal_co_driver() const {
  return co_driver_.GetNoArena();
}
inline void UserInfo::_internal_set_co_driver(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  co_driver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void UserInfo::set_co_driver(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  co_driver_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.data.UserInfo.co_driver)
}
inline void UserInfo::set_co_driver(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  co_driver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.UserInfo.co_driver)
}
inline void UserInfo::set_co_driver(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  co_driver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.UserInfo.co_driver)
}
inline std::string* UserInfo::_internal_mutable_co_driver() {
  _has_bits_[0] |= 0x00000004u;
  return co_driver_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserInfo::release_co_driver() {
  // @@protoc_insertion_point(field_release:apollo.data.UserInfo.co_driver)
  if (!_internal_has_co_driver()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return co_driver_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_co_driver(std::string* co_driver) {
  if (co_driver != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  co_driver_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), co_driver);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.UserInfo.co_driver)
}

// -------------------------------------------------------------------

// StaticInfo

// optional .apollo.data.VehicleInfo vehicle = 1;
inline bool StaticInfo::_internal_has_vehicle() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || vehicle_ != nullptr);
  return value;
}
inline bool StaticInfo::has_vehicle() const {
  return _internal_has_vehicle();
}
inline void StaticInfo::clear_vehicle() {
  if (vehicle_ != nullptr) vehicle_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::data::VehicleInfo& StaticInfo::_internal_vehicle() const {
  const ::apollo::data::VehicleInfo* p = vehicle_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::data::VehicleInfo*>(
      &::apollo::data::_VehicleInfo_default_instance_);
}
inline const ::apollo::data::VehicleInfo& StaticInfo::vehicle() const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfo.vehicle)
  return _internal_vehicle();
}
inline ::apollo::data::VehicleInfo* StaticInfo::release_vehicle() {
  // @@protoc_insertion_point(field_release:apollo.data.StaticInfo.vehicle)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::data::VehicleInfo* temp = vehicle_;
  vehicle_ = nullptr;
  return temp;
}
inline ::apollo::data::VehicleInfo* StaticInfo::_internal_mutable_vehicle() {
  _has_bits_[0] |= 0x00000001u;
  if (vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::data::VehicleInfo>(GetArenaNoVirtual());
    vehicle_ = p;
  }
  return vehicle_;
}
inline ::apollo::data::VehicleInfo* StaticInfo::mutable_vehicle() {
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfo.vehicle)
  return _internal_mutable_vehicle();
}
inline void StaticInfo::set_allocated_vehicle(::apollo::data::VehicleInfo* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.StaticInfo.vehicle)
}

// optional .apollo.data.EnvironmentInfo environment = 2;
inline bool StaticInfo::_internal_has_environment() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || environment_ != nullptr);
  return value;
}
inline bool StaticInfo::has_environment() const {
  return _internal_has_environment();
}
inline void StaticInfo::clear_environment() {
  if (environment_ != nullptr) environment_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::data::EnvironmentInfo& StaticInfo::_internal_environment() const {
  const ::apollo::data::EnvironmentInfo* p = environment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::data::EnvironmentInfo*>(
      &::apollo::data::_EnvironmentInfo_default_instance_);
}
inline const ::apollo::data::EnvironmentInfo& StaticInfo::environment() const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfo.environment)
  return _internal_environment();
}
inline ::apollo::data::EnvironmentInfo* StaticInfo::release_environment() {
  // @@protoc_insertion_point(field_release:apollo.data.StaticInfo.environment)
  _has_bits_[0] &= ~0x00000002u;
  ::apollo::data::EnvironmentInfo* temp = environment_;
  environment_ = nullptr;
  return temp;
}
inline ::apollo::data::EnvironmentInfo* StaticInfo::_internal_mutable_environment() {
  _has_bits_[0] |= 0x00000002u;
  if (environment_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::data::EnvironmentInfo>(GetArenaNoVirtual());
    environment_ = p;
  }
  return environment_;
}
inline ::apollo::data::EnvironmentInfo* StaticInfo::mutable_environment() {
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfo.environment)
  return _internal_mutable_environment();
}
inline void StaticInfo::set_allocated_environment(::apollo::data::EnvironmentInfo* environment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete environment_;
  }
  if (environment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      environment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, environment, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  environment_ = environment;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.StaticInfo.environment)
}

// optional .apollo.data.HardwareInfo hardware = 3;
inline bool StaticInfo::_internal_has_hardware() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || hardware_ != nullptr);
  return value;
}
inline bool StaticInfo::has_hardware() const {
  return _internal_has_hardware();
}
inline void StaticInfo::clear_hardware() {
  if (hardware_ != nullptr) hardware_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::data::HardwareInfo& StaticInfo::_internal_hardware() const {
  const ::apollo::data::HardwareInfo* p = hardware_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::data::HardwareInfo*>(
      &::apollo::data::_HardwareInfo_default_instance_);
}
inline const ::apollo::data::HardwareInfo& StaticInfo::hardware() const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfo.hardware)
  return _internal_hardware();
}
inline ::apollo::data::HardwareInfo* StaticInfo::release_hardware() {
  // @@protoc_insertion_point(field_release:apollo.data.StaticInfo.hardware)
  _has_bits_[0] &= ~0x00000004u;
  ::apollo::data::HardwareInfo* temp = hardware_;
  hardware_ = nullptr;
  return temp;
}
inline ::apollo::data::HardwareInfo* StaticInfo::_internal_mutable_hardware() {
  _has_bits_[0] |= 0x00000004u;
  if (hardware_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::data::HardwareInfo>(GetArenaNoVirtual());
    hardware_ = p;
  }
  return hardware_;
}
inline ::apollo::data::HardwareInfo* StaticInfo::mutable_hardware() {
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfo.hardware)
  return _internal_mutable_hardware();
}
inline void StaticInfo::set_allocated_hardware(::apollo::data::HardwareInfo* hardware) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete hardware_;
  }
  if (hardware) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      hardware = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hardware, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  hardware_ = hardware;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.StaticInfo.hardware)
}

// optional .apollo.data.SoftwareInfo software = 4;
inline bool StaticInfo::_internal_has_software() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || software_ != nullptr);
  return value;
}
inline bool StaticInfo::has_software() const {
  return _internal_has_software();
}
inline void StaticInfo::clear_software() {
  if (software_ != nullptr) software_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::data::SoftwareInfo& StaticInfo::_internal_software() const {
  const ::apollo::data::SoftwareInfo* p = software_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::data::SoftwareInfo*>(
      &::apollo::data::_SoftwareInfo_default_instance_);
}
inline const ::apollo::data::SoftwareInfo& StaticInfo::software() const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfo.software)
  return _internal_software();
}
inline ::apollo::data::SoftwareInfo* StaticInfo::release_software() {
  // @@protoc_insertion_point(field_release:apollo.data.StaticInfo.software)
  _has_bits_[0] &= ~0x00000008u;
  ::apollo::data::SoftwareInfo* temp = software_;
  software_ = nullptr;
  return temp;
}
inline ::apollo::data::SoftwareInfo* StaticInfo::_internal_mutable_software() {
  _has_bits_[0] |= 0x00000008u;
  if (software_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::data::SoftwareInfo>(GetArenaNoVirtual());
    software_ = p;
  }
  return software_;
}
inline ::apollo::data::SoftwareInfo* StaticInfo::mutable_software() {
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfo.software)
  return _internal_mutable_software();
}
inline void StaticInfo::set_allocated_software(::apollo::data::SoftwareInfo* software) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete software_;
  }
  if (software) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      software = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, software, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  software_ = software;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.StaticInfo.software)
}

// optional .apollo.data.UserInfo user = 5;
inline bool StaticInfo::_internal_has_user() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || user_ != nullptr);
  return value;
}
inline bool StaticInfo::has_user() const {
  return _internal_has_user();
}
inline void StaticInfo::clear_user() {
  if (user_ != nullptr) user_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::apollo::data::UserInfo& StaticInfo::_internal_user() const {
  const ::apollo::data::UserInfo* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::data::UserInfo*>(
      &::apollo::data::_UserInfo_default_instance_);
}
inline const ::apollo::data::UserInfo& StaticInfo::user() const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfo.user)
  return _internal_user();
}
inline ::apollo::data::UserInfo* StaticInfo::release_user() {
  // @@protoc_insertion_point(field_release:apollo.data.StaticInfo.user)
  _has_bits_[0] &= ~0x00000010u;
  ::apollo::data::UserInfo* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::apollo::data::UserInfo* StaticInfo::_internal_mutable_user() {
  _has_bits_[0] |= 0x00000010u;
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::data::UserInfo>(GetArenaNoVirtual());
    user_ = p;
  }
  return user_;
}
inline ::apollo::data::UserInfo* StaticInfo::mutable_user() {
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfo.user)
  return _internal_mutable_user();
}
inline void StaticInfo::set_allocated_user(::apollo::data::UserInfo* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.StaticInfo.user)
}

// -------------------------------------------------------------------

// StaticInfoConf

// repeated string hardware_configs = 1;
inline int StaticInfoConf::_internal_hardware_configs_size() const {
  return hardware_configs_.size();
}
inline int StaticInfoConf::hardware_configs_size() const {
  return _internal_hardware_configs_size();
}
inline void StaticInfoConf::clear_hardware_configs() {
  hardware_configs_.Clear();
}
inline std::string* StaticInfoConf::add_hardware_configs() {
  // @@protoc_insertion_point(field_add_mutable:apollo.data.StaticInfoConf.hardware_configs)
  return _internal_add_hardware_configs();
}
inline const std::string& StaticInfoConf::_internal_hardware_configs(int index) const {
  return hardware_configs_.Get(index);
}
inline const std::string& StaticInfoConf::hardware_configs(int index) const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfoConf.hardware_configs)
  return _internal_hardware_configs(index);
}
inline std::string* StaticInfoConf::mutable_hardware_configs(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfoConf.hardware_configs)
  return hardware_configs_.Mutable(index);
}
inline void StaticInfoConf::set_hardware_configs(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:apollo.data.StaticInfoConf.hardware_configs)
  hardware_configs_.Mutable(index)->assign(value);
}
inline void StaticInfoConf::set_hardware_configs(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:apollo.data.StaticInfoConf.hardware_configs)
  hardware_configs_.Mutable(index)->assign(std::move(value));
}
inline void StaticInfoConf::set_hardware_configs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hardware_configs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.data.StaticInfoConf.hardware_configs)
}
inline void StaticInfoConf::set_hardware_configs(int index, const char* value, size_t size) {
  hardware_configs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.data.StaticInfoConf.hardware_configs)
}
inline std::string* StaticInfoConf::_internal_add_hardware_configs() {
  return hardware_configs_.Add();
}
inline void StaticInfoConf::add_hardware_configs(const std::string& value) {
  hardware_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.data.StaticInfoConf.hardware_configs)
}
inline void StaticInfoConf::add_hardware_configs(std::string&& value) {
  hardware_configs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.data.StaticInfoConf.hardware_configs)
}
inline void StaticInfoConf::add_hardware_configs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hardware_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.data.StaticInfoConf.hardware_configs)
}
inline void StaticInfoConf::add_hardware_configs(const char* value, size_t size) {
  hardware_configs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.data.StaticInfoConf.hardware_configs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StaticInfoConf::hardware_configs() const {
  // @@protoc_insertion_point(field_list:apollo.data.StaticInfoConf.hardware_configs)
  return hardware_configs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StaticInfoConf::mutable_hardware_configs() {
  // @@protoc_insertion_point(field_mutable_list:apollo.data.StaticInfoConf.hardware_configs)
  return &hardware_configs_;
}

// repeated string software_configs = 2;
inline int StaticInfoConf::_internal_software_configs_size() const {
  return software_configs_.size();
}
inline int StaticInfoConf::software_configs_size() const {
  return _internal_software_configs_size();
}
inline void StaticInfoConf::clear_software_configs() {
  software_configs_.Clear();
}
inline std::string* StaticInfoConf::add_software_configs() {
  // @@protoc_insertion_point(field_add_mutable:apollo.data.StaticInfoConf.software_configs)
  return _internal_add_software_configs();
}
inline const std::string& StaticInfoConf::_internal_software_configs(int index) const {
  return software_configs_.Get(index);
}
inline const std::string& StaticInfoConf::software_configs(int index) const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfoConf.software_configs)
  return _internal_software_configs(index);
}
inline std::string* StaticInfoConf::mutable_software_configs(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfoConf.software_configs)
  return software_configs_.Mutable(index);
}
inline void StaticInfoConf::set_software_configs(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:apollo.data.StaticInfoConf.software_configs)
  software_configs_.Mutable(index)->assign(value);
}
inline void StaticInfoConf::set_software_configs(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:apollo.data.StaticInfoConf.software_configs)
  software_configs_.Mutable(index)->assign(std::move(value));
}
inline void StaticInfoConf::set_software_configs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  software_configs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.data.StaticInfoConf.software_configs)
}
inline void StaticInfoConf::set_software_configs(int index, const char* value, size_t size) {
  software_configs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.data.StaticInfoConf.software_configs)
}
inline std::string* StaticInfoConf::_internal_add_software_configs() {
  return software_configs_.Add();
}
inline void StaticInfoConf::add_software_configs(const std::string& value) {
  software_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.data.StaticInfoConf.software_configs)
}
inline void StaticInfoConf::add_software_configs(std::string&& value) {
  software_configs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.data.StaticInfoConf.software_configs)
}
inline void StaticInfoConf::add_software_configs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  software_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.data.StaticInfoConf.software_configs)
}
inline void StaticInfoConf::add_software_configs(const char* value, size_t size) {
  software_configs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.data.StaticInfoConf.software_configs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StaticInfoConf::software_configs() const {
  // @@protoc_insertion_point(field_list:apollo.data.StaticInfoConf.software_configs)
  return software_configs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StaticInfoConf::mutable_software_configs() {
  // @@protoc_insertion_point(field_mutable_list:apollo.data.StaticInfoConf.software_configs)
  return &software_configs_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace data
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::data::VehicleInfo_Brand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::data::VehicleInfo_Brand>() {
  return ::apollo::data::VehicleInfo_Brand_descriptor();
}
template <> struct is_proto_enum< ::apollo::data::VehicleInfo_Model> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::data::VehicleInfo_Model>() {
  return ::apollo::data::VehicleInfo_Model_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fdata_2fproto_2fstatic_5finfo_2eproto
