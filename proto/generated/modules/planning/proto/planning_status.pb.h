// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/planning_status.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/common/proto/drive_state.pb.h"
#include "modules/common/proto/geometry.pb.h"
#include "modules/common/proto/pnc_point.pb.h"
#include "modules/planning/proto/planning_config.pb.h"
#include "modules/routing/proto/routing.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
namespace apollo {
namespace planning {
class BareIntersectionStatus;
class BareIntersectionStatusDefaultTypeInternal;
extern BareIntersectionStatusDefaultTypeInternal _BareIntersectionStatus_default_instance_;
class ChangeLaneStatus;
class ChangeLaneStatusDefaultTypeInternal;
extern ChangeLaneStatusDefaultTypeInternal _ChangeLaneStatus_default_instance_;
class CrosswalkStatus;
class CrosswalkStatusDefaultTypeInternal;
extern CrosswalkStatusDefaultTypeInternal _CrosswalkStatus_default_instance_;
class DestinationStatus;
class DestinationStatusDefaultTypeInternal;
extern DestinationStatusDefaultTypeInternal _DestinationStatus_default_instance_;
class PedestrianStatus;
class PedestrianStatusDefaultTypeInternal;
extern PedestrianStatusDefaultTypeInternal _PedestrianStatus_default_instance_;
class PlanningStatus;
class PlanningStatusDefaultTypeInternal;
extern PlanningStatusDefaultTypeInternal _PlanningStatus_default_instance_;
class PullOverStatus;
class PullOverStatusDefaultTypeInternal;
extern PullOverStatusDefaultTypeInternal _PullOverStatus_default_instance_;
class ReroutingStatus;
class ReroutingStatusDefaultTypeInternal;
extern ReroutingStatusDefaultTypeInternal _ReroutingStatus_default_instance_;
class RightOfWayStatus;
class RightOfWayStatusDefaultTypeInternal;
extern RightOfWayStatusDefaultTypeInternal _RightOfWayStatus_default_instance_;
class RightOfWayStatus_JunctionEntry_DoNotUse;
class RightOfWayStatus_JunctionEntry_DoNotUseDefaultTypeInternal;
extern RightOfWayStatus_JunctionEntry_DoNotUseDefaultTypeInternal _RightOfWayStatus_JunctionEntry_DoNotUse_default_instance_;
class ScenarioStatus;
class ScenarioStatusDefaultTypeInternal;
extern ScenarioStatusDefaultTypeInternal _ScenarioStatus_default_instance_;
class SidePassStatus;
class SidePassStatusDefaultTypeInternal;
extern SidePassStatusDefaultTypeInternal _SidePassStatus_default_instance_;
class SidePassStopStatus;
class SidePassStopStatusDefaultTypeInternal;
extern SidePassStopStatusDefaultTypeInternal _SidePassStopStatus_default_instance_;
class StopSignStatus;
class StopSignStatusDefaultTypeInternal;
extern StopSignStatusDefaultTypeInternal _StopSignStatus_default_instance_;
class StopTime;
class StopTimeDefaultTypeInternal;
extern StopTimeDefaultTypeInternal _StopTime_default_instance_;
class TrafficLightStatus;
class TrafficLightStatusDefaultTypeInternal;
extern TrafficLightStatusDefaultTypeInternal _TrafficLightStatus_default_instance_;
}  // namespace planning
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::planning::BareIntersectionStatus* Arena::CreateMaybeMessage<::apollo::planning::BareIntersectionStatus>(Arena*);
template<> ::apollo::planning::ChangeLaneStatus* Arena::CreateMaybeMessage<::apollo::planning::ChangeLaneStatus>(Arena*);
template<> ::apollo::planning::CrosswalkStatus* Arena::CreateMaybeMessage<::apollo::planning::CrosswalkStatus>(Arena*);
template<> ::apollo::planning::DestinationStatus* Arena::CreateMaybeMessage<::apollo::planning::DestinationStatus>(Arena*);
template<> ::apollo::planning::PedestrianStatus* Arena::CreateMaybeMessage<::apollo::planning::PedestrianStatus>(Arena*);
template<> ::apollo::planning::PlanningStatus* Arena::CreateMaybeMessage<::apollo::planning::PlanningStatus>(Arena*);
template<> ::apollo::planning::PullOverStatus* Arena::CreateMaybeMessage<::apollo::planning::PullOverStatus>(Arena*);
template<> ::apollo::planning::ReroutingStatus* Arena::CreateMaybeMessage<::apollo::planning::ReroutingStatus>(Arena*);
template<> ::apollo::planning::RightOfWayStatus* Arena::CreateMaybeMessage<::apollo::planning::RightOfWayStatus>(Arena*);
template<> ::apollo::planning::RightOfWayStatus_JunctionEntry_DoNotUse* Arena::CreateMaybeMessage<::apollo::planning::RightOfWayStatus_JunctionEntry_DoNotUse>(Arena*);
template<> ::apollo::planning::ScenarioStatus* Arena::CreateMaybeMessage<::apollo::planning::ScenarioStatus>(Arena*);
template<> ::apollo::planning::SidePassStatus* Arena::CreateMaybeMessage<::apollo::planning::SidePassStatus>(Arena*);
template<> ::apollo::planning::SidePassStopStatus* Arena::CreateMaybeMessage<::apollo::planning::SidePassStopStatus>(Arena*);
template<> ::apollo::planning::StopSignStatus* Arena::CreateMaybeMessage<::apollo::planning::StopSignStatus>(Arena*);
template<> ::apollo::planning::StopTime* Arena::CreateMaybeMessage<::apollo::planning::StopTime>(Arena*);
template<> ::apollo::planning::TrafficLightStatus* Arena::CreateMaybeMessage<::apollo::planning::TrafficLightStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace planning {

enum ChangeLaneStatus_Status : int {
  ChangeLaneStatus_Status_IN_CHANGE_LANE = 1,
  ChangeLaneStatus_Status_CHANGE_LANE_FAILED = 2,
  ChangeLaneStatus_Status_CHANGE_LANE_SUCCESS = 3
};
bool ChangeLaneStatus_Status_IsValid(int value);
constexpr ChangeLaneStatus_Status ChangeLaneStatus_Status_Status_MIN = ChangeLaneStatus_Status_IN_CHANGE_LANE;
constexpr ChangeLaneStatus_Status ChangeLaneStatus_Status_Status_MAX = ChangeLaneStatus_Status_CHANGE_LANE_SUCCESS;
constexpr int ChangeLaneStatus_Status_Status_ARRAYSIZE = ChangeLaneStatus_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeLaneStatus_Status_descriptor();
template<typename T>
inline const std::string& ChangeLaneStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChangeLaneStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChangeLaneStatus_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChangeLaneStatus_Status_descriptor(), enum_t_value);
}
inline bool ChangeLaneStatus_Status_Parse(
    const std::string& name, ChangeLaneStatus_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeLaneStatus_Status>(
    ChangeLaneStatus_Status_descriptor(), name, value);
}
// ===================================================================

class BareIntersectionStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.BareIntersectionStatus) */ {
 public:
  BareIntersectionStatus();
  virtual ~BareIntersectionStatus();

  BareIntersectionStatus(const BareIntersectionStatus& from);
  BareIntersectionStatus(BareIntersectionStatus&& from) noexcept
    : BareIntersectionStatus() {
    *this = ::std::move(from);
  }

  inline BareIntersectionStatus& operator=(const BareIntersectionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline BareIntersectionStatus& operator=(BareIntersectionStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BareIntersectionStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BareIntersectionStatus* internal_default_instance() {
    return reinterpret_cast<const BareIntersectionStatus*>(
               &_BareIntersectionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BareIntersectionStatus& a, BareIntersectionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(BareIntersectionStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BareIntersectionStatus* New() const final {
    return CreateMaybeMessage<BareIntersectionStatus>(nullptr);
  }

  BareIntersectionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BareIntersectionStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BareIntersectionStatus& from);
  void MergeFrom(const BareIntersectionStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BareIntersectionStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.BareIntersectionStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentPncJunctionOverlapIdFieldNumber = 1,
    kDonePncJunctionOverlapIdFieldNumber = 2,
  };
  // optional string current_pnc_junction_overlap_id = 1;
  bool has_current_pnc_junction_overlap_id() const;
  private:
  bool _internal_has_current_pnc_junction_overlap_id() const;
  public:
  void clear_current_pnc_junction_overlap_id();
  const std::string& current_pnc_junction_overlap_id() const;
  void set_current_pnc_junction_overlap_id(const std::string& value);
  void set_current_pnc_junction_overlap_id(std::string&& value);
  void set_current_pnc_junction_overlap_id(const char* value);
  void set_current_pnc_junction_overlap_id(const char* value, size_t size);
  std::string* mutable_current_pnc_junction_overlap_id();
  std::string* release_current_pnc_junction_overlap_id();
  void set_allocated_current_pnc_junction_overlap_id(std::string* current_pnc_junction_overlap_id);
  private:
  const std::string& _internal_current_pnc_junction_overlap_id() const;
  void _internal_set_current_pnc_junction_overlap_id(const std::string& value);
  std::string* _internal_mutable_current_pnc_junction_overlap_id();
  public:

  // optional string done_pnc_junction_overlap_id = 2;
  bool has_done_pnc_junction_overlap_id() const;
  private:
  bool _internal_has_done_pnc_junction_overlap_id() const;
  public:
  void clear_done_pnc_junction_overlap_id();
  const std::string& done_pnc_junction_overlap_id() const;
  void set_done_pnc_junction_overlap_id(const std::string& value);
  void set_done_pnc_junction_overlap_id(std::string&& value);
  void set_done_pnc_junction_overlap_id(const char* value);
  void set_done_pnc_junction_overlap_id(const char* value, size_t size);
  std::string* mutable_done_pnc_junction_overlap_id();
  std::string* release_done_pnc_junction_overlap_id();
  void set_allocated_done_pnc_junction_overlap_id(std::string* done_pnc_junction_overlap_id);
  private:
  const std::string& _internal_done_pnc_junction_overlap_id() const;
  void _internal_set_done_pnc_junction_overlap_id(const std::string& value);
  std::string* _internal_mutable_done_pnc_junction_overlap_id();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.BareIntersectionStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_pnc_junction_overlap_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr done_pnc_junction_overlap_id_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class ChangeLaneStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ChangeLaneStatus) */ {
 public:
  ChangeLaneStatus();
  virtual ~ChangeLaneStatus();

  ChangeLaneStatus(const ChangeLaneStatus& from);
  ChangeLaneStatus(ChangeLaneStatus&& from) noexcept
    : ChangeLaneStatus() {
    *this = ::std::move(from);
  }

  inline ChangeLaneStatus& operator=(const ChangeLaneStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeLaneStatus& operator=(ChangeLaneStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChangeLaneStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeLaneStatus* internal_default_instance() {
    return reinterpret_cast<const ChangeLaneStatus*>(
               &_ChangeLaneStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChangeLaneStatus& a, ChangeLaneStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeLaneStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeLaneStatus* New() const final {
    return CreateMaybeMessage<ChangeLaneStatus>(nullptr);
  }

  ChangeLaneStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeLaneStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChangeLaneStatus& from);
  void MergeFrom(const ChangeLaneStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeLaneStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ChangeLaneStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ChangeLaneStatus_Status Status;
  static constexpr Status IN_CHANGE_LANE =
    ChangeLaneStatus_Status_IN_CHANGE_LANE;
  static constexpr Status CHANGE_LANE_FAILED =
    ChangeLaneStatus_Status_CHANGE_LANE_FAILED;
  static constexpr Status CHANGE_LANE_SUCCESS =
    ChangeLaneStatus_Status_CHANGE_LANE_SUCCESS;
  static inline bool Status_IsValid(int value) {
    return ChangeLaneStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ChangeLaneStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ChangeLaneStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ChangeLaneStatus_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ChangeLaneStatus_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ChangeLaneStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(const std::string& name,
      Status* value) {
    return ChangeLaneStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathIdFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional string path_id = 2;
  bool has_path_id() const;
  private:
  bool _internal_has_path_id() const;
  public:
  void clear_path_id();
  const std::string& path_id() const;
  void set_path_id(const std::string& value);
  void set_path_id(std::string&& value);
  void set_path_id(const char* value);
  void set_path_id(const char* value, size_t size);
  std::string* mutable_path_id();
  std::string* release_path_id();
  void set_allocated_path_id(std::string* path_id);
  private:
  const std::string& _internal_path_id() const;
  void _internal_set_path_id(const std::string& value);
  std::string* _internal_mutable_path_id();
  public:

  // optional double timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  double timestamp() const;
  void set_timestamp(double value);
  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);
  public:

  // optional .apollo.planning.ChangeLaneStatus.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::apollo::planning::ChangeLaneStatus_Status status() const;
  void set_status(::apollo::planning::ChangeLaneStatus_Status value);
  private:
  ::apollo::planning::ChangeLaneStatus_Status _internal_status() const;
  void _internal_set_status(::apollo::planning::ChangeLaneStatus_Status value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ChangeLaneStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_id_;
  double timestamp_;
  int status_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class StopTime :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopTime) */ {
 public:
  StopTime();
  virtual ~StopTime();

  StopTime(const StopTime& from);
  StopTime(StopTime&& from) noexcept
    : StopTime() {
    *this = ::std::move(from);
  }

  inline StopTime& operator=(const StopTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopTime& operator=(StopTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopTime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopTime* internal_default_instance() {
    return reinterpret_cast<const StopTime*>(
               &_StopTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StopTime& a, StopTime& b) {
    a.Swap(&b);
  }
  inline void Swap(StopTime* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopTime* New() const final {
    return CreateMaybeMessage<StopTime>(nullptr);
  }

  StopTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopTime>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopTime& from);
  void MergeFrom(const StopTime& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopTime* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.StopTime";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstacleIdFieldNumber = 1,
    kObstacleStopTimestampFieldNumber = 2,
  };
  // optional string obstacle_id = 1;
  bool has_obstacle_id() const;
  private:
  bool _internal_has_obstacle_id() const;
  public:
  void clear_obstacle_id();
  const std::string& obstacle_id() const;
  void set_obstacle_id(const std::string& value);
  void set_obstacle_id(std::string&& value);
  void set_obstacle_id(const char* value);
  void set_obstacle_id(const char* value, size_t size);
  std::string* mutable_obstacle_id();
  std::string* release_obstacle_id();
  void set_allocated_obstacle_id(std::string* obstacle_id);
  private:
  const std::string& _internal_obstacle_id() const;
  void _internal_set_obstacle_id(const std::string& value);
  std::string* _internal_mutable_obstacle_id();
  public:

  // optional double obstacle_stop_timestamp = 2;
  bool has_obstacle_stop_timestamp() const;
  private:
  bool _internal_has_obstacle_stop_timestamp() const;
  public:
  void clear_obstacle_stop_timestamp();
  double obstacle_stop_timestamp() const;
  void set_obstacle_stop_timestamp(double value);
  private:
  double _internal_obstacle_stop_timestamp() const;
  void _internal_set_obstacle_stop_timestamp(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.StopTime)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obstacle_id_;
  double obstacle_stop_timestamp_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class CrosswalkStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CrosswalkStatus) */ {
 public:
  CrosswalkStatus();
  virtual ~CrosswalkStatus();

  CrosswalkStatus(const CrosswalkStatus& from);
  CrosswalkStatus(CrosswalkStatus&& from) noexcept
    : CrosswalkStatus() {
    *this = ::std::move(from);
  }

  inline CrosswalkStatus& operator=(const CrosswalkStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrosswalkStatus& operator=(CrosswalkStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CrosswalkStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrosswalkStatus* internal_default_instance() {
    return reinterpret_cast<const CrosswalkStatus*>(
               &_CrosswalkStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CrosswalkStatus& a, CrosswalkStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CrosswalkStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CrosswalkStatus* New() const final {
    return CreateMaybeMessage<CrosswalkStatus>(nullptr);
  }

  CrosswalkStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CrosswalkStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CrosswalkStatus& from);
  void MergeFrom(const CrosswalkStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrosswalkStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.CrosswalkStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopTimeFieldNumber = 2,
    kFinishedCrosswalkFieldNumber = 3,
    kCrosswalkIdFieldNumber = 1,
  };
  // repeated .apollo.planning.StopTime stop_time = 2;
  int stop_time_size() const;
  private:
  int _internal_stop_time_size() const;
  public:
  void clear_stop_time();
  ::apollo::planning::StopTime* mutable_stop_time(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >*
      mutable_stop_time();
  private:
  const ::apollo::planning::StopTime& _internal_stop_time(int index) const;
  ::apollo::planning::StopTime* _internal_add_stop_time();
  public:
  const ::apollo::planning::StopTime& stop_time(int index) const;
  ::apollo::planning::StopTime* add_stop_time();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >&
      stop_time() const;

  // repeated string finished_crosswalk = 3;
  int finished_crosswalk_size() const;
  private:
  int _internal_finished_crosswalk_size() const;
  public:
  void clear_finished_crosswalk();
  const std::string& finished_crosswalk(int index) const;
  std::string* mutable_finished_crosswalk(int index);
  void set_finished_crosswalk(int index, const std::string& value);
  void set_finished_crosswalk(int index, std::string&& value);
  void set_finished_crosswalk(int index, const char* value);
  void set_finished_crosswalk(int index, const char* value, size_t size);
  std::string* add_finished_crosswalk();
  void add_finished_crosswalk(const std::string& value);
  void add_finished_crosswalk(std::string&& value);
  void add_finished_crosswalk(const char* value);
  void add_finished_crosswalk(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& finished_crosswalk() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_finished_crosswalk();
  private:
  const std::string& _internal_finished_crosswalk(int index) const;
  std::string* _internal_add_finished_crosswalk();
  public:

  // optional string crosswalk_id = 1;
  bool has_crosswalk_id() const;
  private:
  bool _internal_has_crosswalk_id() const;
  public:
  void clear_crosswalk_id();
  const std::string& crosswalk_id() const;
  void set_crosswalk_id(const std::string& value);
  void set_crosswalk_id(std::string&& value);
  void set_crosswalk_id(const char* value);
  void set_crosswalk_id(const char* value, size_t size);
  std::string* mutable_crosswalk_id();
  std::string* release_crosswalk_id();
  void set_allocated_crosswalk_id(std::string* crosswalk_id);
  private:
  const std::string& _internal_crosswalk_id() const;
  void _internal_set_crosswalk_id(const std::string& value);
  std::string* _internal_mutable_crosswalk_id();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.CrosswalkStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime > stop_time_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> finished_crosswalk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crosswalk_id_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class DestinationStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.DestinationStatus) */ {
 public:
  DestinationStatus();
  virtual ~DestinationStatus();

  DestinationStatus(const DestinationStatus& from);
  DestinationStatus(DestinationStatus&& from) noexcept
    : DestinationStatus() {
    *this = ::std::move(from);
  }

  inline DestinationStatus& operator=(const DestinationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestinationStatus& operator=(DestinationStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DestinationStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DestinationStatus* internal_default_instance() {
    return reinterpret_cast<const DestinationStatus*>(
               &_DestinationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DestinationStatus& a, DestinationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(DestinationStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DestinationStatus* New() const final {
    return CreateMaybeMessage<DestinationStatus>(nullptr);
  }

  DestinationStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DestinationStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DestinationStatus& from);
  void MergeFrom(const DestinationStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestinationStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.DestinationStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHasPassedDestinationFieldNumber = 1,
  };
  // optional bool has_passed_destination = 1 [default = false];
  bool has_has_passed_destination() const;
  private:
  bool _internal_has_has_passed_destination() const;
  public:
  void clear_has_passed_destination();
  bool has_passed_destination() const;
  void set_has_passed_destination(bool value);
  private:
  bool _internal_has_passed_destination() const;
  void _internal_set_has_passed_destination(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.DestinationStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool has_passed_destination_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class PedestrianStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PedestrianStatus) */ {
 public:
  PedestrianStatus();
  virtual ~PedestrianStatus();

  PedestrianStatus(const PedestrianStatus& from);
  PedestrianStatus(PedestrianStatus&& from) noexcept
    : PedestrianStatus() {
    *this = ::std::move(from);
  }

  inline PedestrianStatus& operator=(const PedestrianStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PedestrianStatus& operator=(PedestrianStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PedestrianStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PedestrianStatus* internal_default_instance() {
    return reinterpret_cast<const PedestrianStatus*>(
               &_PedestrianStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PedestrianStatus& a, PedestrianStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PedestrianStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PedestrianStatus* New() const final {
    return CreateMaybeMessage<PedestrianStatus>(nullptr);
  }

  PedestrianStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PedestrianStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PedestrianStatus& from);
  void MergeFrom(const PedestrianStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PedestrianStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PedestrianStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopTimeFieldNumber = 1,
  };
  // repeated .apollo.planning.StopTime stop_time = 1;
  int stop_time_size() const;
  private:
  int _internal_stop_time_size() const;
  public:
  void clear_stop_time();
  ::apollo::planning::StopTime* mutable_stop_time(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >*
      mutable_stop_time();
  private:
  const ::apollo::planning::StopTime& _internal_stop_time(int index) const;
  ::apollo::planning::StopTime* _internal_add_stop_time();
  public:
  const ::apollo::planning::StopTime& stop_time(int index) const;
  ::apollo::planning::StopTime* add_stop_time();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >&
      stop_time() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.PedestrianStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime > stop_time_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class PullOverStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PullOverStatus) */ {
 public:
  PullOverStatus();
  virtual ~PullOverStatus();

  PullOverStatus(const PullOverStatus& from);
  PullOverStatus(PullOverStatus&& from) noexcept
    : PullOverStatus() {
    *this = ::std::move(from);
  }

  inline PullOverStatus& operator=(const PullOverStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullOverStatus& operator=(PullOverStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PullOverStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PullOverStatus* internal_default_instance() {
    return reinterpret_cast<const PullOverStatus*>(
               &_PullOverStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PullOverStatus& a, PullOverStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PullOverStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PullOverStatus* New() const final {
    return CreateMaybeMessage<PullOverStatus>(nullptr);
  }

  PullOverStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PullOverStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PullOverStatus& from);
  void MergeFrom(const PullOverStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullOverStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PullOverStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kThetaFieldNumber = 3,
    kLengthFrontFieldNumber = 4,
    kLengthBackFieldNumber = 5,
    kWidthLeftFieldNumber = 6,
    kIsFeasibleFieldNumber = 1,
    kIsInPullOverScenarioFieldNumber = 9,
    kIdxFieldNumber = 8,
    kWidthRightFieldNumber = 7,
  };
  // optional .apollo.common.PointENU position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::apollo::common::PointENU& position() const;
  ::apollo::common::PointENU* release_position();
  ::apollo::common::PointENU* mutable_position();
  void set_allocated_position(::apollo::common::PointENU* position);
  private:
  const ::apollo::common::PointENU& _internal_position() const;
  ::apollo::common::PointENU* _internal_mutable_position();
  public:

  // optional double theta = 3;
  bool has_theta() const;
  private:
  bool _internal_has_theta() const;
  public:
  void clear_theta();
  double theta() const;
  void set_theta(double value);
  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);
  public:

  // optional double length_front = 4;
  bool has_length_front() const;
  private:
  bool _internal_has_length_front() const;
  public:
  void clear_length_front();
  double length_front() const;
  void set_length_front(double value);
  private:
  double _internal_length_front() const;
  void _internal_set_length_front(double value);
  public:

  // optional double length_back = 5;
  bool has_length_back() const;
  private:
  bool _internal_has_length_back() const;
  public:
  void clear_length_back();
  double length_back() const;
  void set_length_back(double value);
  private:
  double _internal_length_back() const;
  void _internal_set_length_back(double value);
  public:

  // optional double width_left = 6;
  bool has_width_left() const;
  private:
  bool _internal_has_width_left() const;
  public:
  void clear_width_left();
  double width_left() const;
  void set_width_left(double value);
  private:
  double _internal_width_left() const;
  void _internal_set_width_left(double value);
  public:

  // optional bool is_feasible = 1 [default = false];
  bool has_is_feasible() const;
  private:
  bool _internal_has_is_feasible() const;
  public:
  void clear_is_feasible();
  bool is_feasible() const;
  void set_is_feasible(bool value);
  private:
  bool _internal_is_feasible() const;
  void _internal_set_is_feasible(bool value);
  public:

  // optional bool is_in_pull_over_scenario = 9 [default = false];
  bool has_is_in_pull_over_scenario() const;
  private:
  bool _internal_has_is_in_pull_over_scenario() const;
  public:
  void clear_is_in_pull_over_scenario();
  bool is_in_pull_over_scenario() const;
  void set_is_in_pull_over_scenario(bool value);
  private:
  bool _internal_is_in_pull_over_scenario() const;
  void _internal_set_is_in_pull_over_scenario(bool value);
  public:

  // optional int32 idx = 8;
  bool has_idx() const;
  private:
  bool _internal_has_idx() const;
  public:
  void clear_idx();
  ::PROTOBUF_NAMESPACE_ID::int32 idx() const;
  void set_idx(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_idx() const;
  void _internal_set_idx(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double width_right = 7;
  bool has_width_right() const;
  private:
  bool _internal_has_width_right() const;
  public:
  void clear_width_right();
  double width_right() const;
  void set_width_right(double value);
  private:
  double _internal_width_right() const;
  void _internal_set_width_right(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.PullOverStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::common::PointENU* position_;
  double theta_;
  double length_front_;
  double length_back_;
  double width_left_;
  bool is_feasible_;
  bool is_in_pull_over_scenario_;
  ::PROTOBUF_NAMESPACE_ID::int32 idx_;
  double width_right_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class ReroutingStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ReroutingStatus) */ {
 public:
  ReroutingStatus();
  virtual ~ReroutingStatus();

  ReroutingStatus(const ReroutingStatus& from);
  ReroutingStatus(ReroutingStatus&& from) noexcept
    : ReroutingStatus() {
    *this = ::std::move(from);
  }

  inline ReroutingStatus& operator=(const ReroutingStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReroutingStatus& operator=(ReroutingStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReroutingStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReroutingStatus* internal_default_instance() {
    return reinterpret_cast<const ReroutingStatus*>(
               &_ReroutingStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReroutingStatus& a, ReroutingStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ReroutingStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReroutingStatus* New() const final {
    return CreateMaybeMessage<ReroutingStatus>(nullptr);
  }

  ReroutingStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReroutingStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReroutingStatus& from);
  void MergeFrom(const ReroutingStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReroutingStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ReroutingStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutingRequestFieldNumber = 3,
    kLastReroutingTimeFieldNumber = 1,
    kNeedReroutingFieldNumber = 2,
  };
  // optional .apollo.routing.RoutingRequest routing_request = 3;
  bool has_routing_request() const;
  private:
  bool _internal_has_routing_request() const;
  public:
  void clear_routing_request();
  const ::apollo::routing::RoutingRequest& routing_request() const;
  ::apollo::routing::RoutingRequest* release_routing_request();
  ::apollo::routing::RoutingRequest* mutable_routing_request();
  void set_allocated_routing_request(::apollo::routing::RoutingRequest* routing_request);
  private:
  const ::apollo::routing::RoutingRequest& _internal_routing_request() const;
  ::apollo::routing::RoutingRequest* _internal_mutable_routing_request();
  public:

  // optional double last_rerouting_time = 1;
  bool has_last_rerouting_time() const;
  private:
  bool _internal_has_last_rerouting_time() const;
  public:
  void clear_last_rerouting_time();
  double last_rerouting_time() const;
  void set_last_rerouting_time(double value);
  private:
  double _internal_last_rerouting_time() const;
  void _internal_set_last_rerouting_time(double value);
  public:

  // optional bool need_rerouting = 2 [default = false];
  bool has_need_rerouting() const;
  private:
  bool _internal_has_need_rerouting() const;
  public:
  void clear_need_rerouting();
  bool need_rerouting() const;
  void set_need_rerouting(bool value);
  private:
  bool _internal_need_rerouting() const;
  void _internal_set_need_rerouting(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ReroutingStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::routing::RoutingRequest* routing_request_;
  double last_rerouting_time_;
  bool need_rerouting_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class RightOfWayStatus_JunctionEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RightOfWayStatus_JunctionEntry_DoNotUse, 
    std::string, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RightOfWayStatus_JunctionEntry_DoNotUse, 
    std::string, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL,
    0 > SuperType;
  RightOfWayStatus_JunctionEntry_DoNotUse();
  RightOfWayStatus_JunctionEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RightOfWayStatus_JunctionEntry_DoNotUse& other);
  static const RightOfWayStatus_JunctionEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RightOfWayStatus_JunctionEntry_DoNotUse*>(&_RightOfWayStatus_JunctionEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "apollo.planning.RightOfWayStatus.JunctionEntry.key");
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[8];
  }

  public:
};

// -------------------------------------------------------------------

class RightOfWayStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.RightOfWayStatus) */ {
 public:
  RightOfWayStatus();
  virtual ~RightOfWayStatus();

  RightOfWayStatus(const RightOfWayStatus& from);
  RightOfWayStatus(RightOfWayStatus&& from) noexcept
    : RightOfWayStatus() {
    *this = ::std::move(from);
  }

  inline RightOfWayStatus& operator=(const RightOfWayStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightOfWayStatus& operator=(RightOfWayStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightOfWayStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightOfWayStatus* internal_default_instance() {
    return reinterpret_cast<const RightOfWayStatus*>(
               &_RightOfWayStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RightOfWayStatus& a, RightOfWayStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RightOfWayStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightOfWayStatus* New() const final {
    return CreateMaybeMessage<RightOfWayStatus>(nullptr);
  }

  RightOfWayStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightOfWayStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightOfWayStatus& from);
  void MergeFrom(const RightOfWayStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightOfWayStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.RightOfWayStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kJunctionFieldNumber = 1,
  };
  // map<string, bool> junction = 1;
  int junction_size() const;
  private:
  int _internal_junction_size() const;
  public:
  void clear_junction();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
      _internal_junction() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
      _internal_mutable_junction();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
      junction() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
      mutable_junction();

  // @@protoc_insertion_point(class_scope:apollo.planning.RightOfWayStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      RightOfWayStatus_JunctionEntry_DoNotUse,
      std::string, bool,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL,
      0 > junction_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class ScenarioStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioStatus) */ {
 public:
  ScenarioStatus();
  virtual ~ScenarioStatus();

  ScenarioStatus(const ScenarioStatus& from);
  ScenarioStatus(ScenarioStatus&& from) noexcept
    : ScenarioStatus() {
    *this = ::std::move(from);
  }

  inline ScenarioStatus& operator=(const ScenarioStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioStatus& operator=(ScenarioStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioStatus* internal_default_instance() {
    return reinterpret_cast<const ScenarioStatus*>(
               &_ScenarioStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ScenarioStatus& a, ScenarioStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioStatus* New() const final {
    return CreateMaybeMessage<ScenarioStatus>(nullptr);
  }

  ScenarioStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioStatus& from);
  void MergeFrom(const ScenarioStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScenarioTypeFieldNumber = 1,
    kStageTypeFieldNumber = 2,
  };
  // optional .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  bool has_scenario_type() const;
  private:
  bool _internal_has_scenario_type() const;
  public:
  void clear_scenario_type();
  ::apollo::planning::ScenarioConfig_ScenarioType scenario_type() const;
  void set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value);
  private:
  ::apollo::planning::ScenarioConfig_ScenarioType _internal_scenario_type() const;
  void _internal_set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value);
  public:

  // optional .apollo.planning.ScenarioConfig.StageType stage_type = 2;
  bool has_stage_type() const;
  private:
  bool _internal_has_stage_type() const;
  public:
  void clear_stage_type();
  ::apollo::planning::ScenarioConfig_StageType stage_type() const;
  void set_stage_type(::apollo::planning::ScenarioConfig_StageType value);
  private:
  ::apollo::planning::ScenarioConfig_StageType _internal_stage_type() const;
  void _internal_set_stage_type(::apollo::planning::ScenarioConfig_StageType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int scenario_type_;
  int stage_type_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class SidePassStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.SidePassStatus) */ {
 public:
  SidePassStatus();
  virtual ~SidePassStatus();

  SidePassStatus(const SidePassStatus& from);
  SidePassStatus(SidePassStatus&& from) noexcept
    : SidePassStatus() {
    *this = ::std::move(from);
  }

  inline SidePassStatus& operator=(const SidePassStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SidePassStatus& operator=(SidePassStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SidePassStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SidePassStatus* internal_default_instance() {
    return reinterpret_cast<const SidePassStatus*>(
               &_SidePassStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SidePassStatus& a, SidePassStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SidePassStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SidePassStatus* New() const final {
    return CreateMaybeMessage<SidePassStatus>(nullptr);
  }

  SidePassStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SidePassStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SidePassStatus& from);
  void MergeFrom(const SidePassStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SidePassStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.SidePassStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrontBlockingObstacleIdFieldNumber = 1,
  };
  // optional string front_blocking_obstacle_id = 1;
  bool has_front_blocking_obstacle_id() const;
  private:
  bool _internal_has_front_blocking_obstacle_id() const;
  public:
  void clear_front_blocking_obstacle_id();
  const std::string& front_blocking_obstacle_id() const;
  void set_front_blocking_obstacle_id(const std::string& value);
  void set_front_blocking_obstacle_id(std::string&& value);
  void set_front_blocking_obstacle_id(const char* value);
  void set_front_blocking_obstacle_id(const char* value, size_t size);
  std::string* mutable_front_blocking_obstacle_id();
  std::string* release_front_blocking_obstacle_id();
  void set_allocated_front_blocking_obstacle_id(std::string* front_blocking_obstacle_id);
  private:
  const std::string& _internal_front_blocking_obstacle_id() const;
  void _internal_set_front_blocking_obstacle_id(const std::string& value);
  std::string* _internal_mutable_front_blocking_obstacle_id();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.SidePassStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr front_blocking_obstacle_id_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class StopSignStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopSignStatus) */ {
 public:
  StopSignStatus();
  virtual ~StopSignStatus();

  StopSignStatus(const StopSignStatus& from);
  StopSignStatus(StopSignStatus&& from) noexcept
    : StopSignStatus() {
    *this = ::std::move(from);
  }

  inline StopSignStatus& operator=(const StopSignStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSignStatus& operator=(StopSignStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopSignStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopSignStatus* internal_default_instance() {
    return reinterpret_cast<const StopSignStatus*>(
               &_StopSignStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StopSignStatus& a, StopSignStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSignStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopSignStatus* New() const final {
    return CreateMaybeMessage<StopSignStatus>(nullptr);
  }

  StopSignStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopSignStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopSignStatus& from);
  void MergeFrom(const StopSignStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSignStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.StopSignStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWaitForObstacleIdFieldNumber = 3,
    kCurrentStopSignOverlapIdFieldNumber = 1,
    kDoneStopSignOverlapIdFieldNumber = 2,
  };
  // repeated string wait_for_obstacle_id = 3;
  int wait_for_obstacle_id_size() const;
  private:
  int _internal_wait_for_obstacle_id_size() const;
  public:
  void clear_wait_for_obstacle_id();
  const std::string& wait_for_obstacle_id(int index) const;
  std::string* mutable_wait_for_obstacle_id(int index);
  void set_wait_for_obstacle_id(int index, const std::string& value);
  void set_wait_for_obstacle_id(int index, std::string&& value);
  void set_wait_for_obstacle_id(int index, const char* value);
  void set_wait_for_obstacle_id(int index, const char* value, size_t size);
  std::string* add_wait_for_obstacle_id();
  void add_wait_for_obstacle_id(const std::string& value);
  void add_wait_for_obstacle_id(std::string&& value);
  void add_wait_for_obstacle_id(const char* value);
  void add_wait_for_obstacle_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wait_for_obstacle_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wait_for_obstacle_id();
  private:
  const std::string& _internal_wait_for_obstacle_id(int index) const;
  std::string* _internal_add_wait_for_obstacle_id();
  public:

  // optional string current_stop_sign_overlap_id = 1;
  bool has_current_stop_sign_overlap_id() const;
  private:
  bool _internal_has_current_stop_sign_overlap_id() const;
  public:
  void clear_current_stop_sign_overlap_id();
  const std::string& current_stop_sign_overlap_id() const;
  void set_current_stop_sign_overlap_id(const std::string& value);
  void set_current_stop_sign_overlap_id(std::string&& value);
  void set_current_stop_sign_overlap_id(const char* value);
  void set_current_stop_sign_overlap_id(const char* value, size_t size);
  std::string* mutable_current_stop_sign_overlap_id();
  std::string* release_current_stop_sign_overlap_id();
  void set_allocated_current_stop_sign_overlap_id(std::string* current_stop_sign_overlap_id);
  private:
  const std::string& _internal_current_stop_sign_overlap_id() const;
  void _internal_set_current_stop_sign_overlap_id(const std::string& value);
  std::string* _internal_mutable_current_stop_sign_overlap_id();
  public:

  // optional string done_stop_sign_overlap_id = 2;
  bool has_done_stop_sign_overlap_id() const;
  private:
  bool _internal_has_done_stop_sign_overlap_id() const;
  public:
  void clear_done_stop_sign_overlap_id();
  const std::string& done_stop_sign_overlap_id() const;
  void set_done_stop_sign_overlap_id(const std::string& value);
  void set_done_stop_sign_overlap_id(std::string&& value);
  void set_done_stop_sign_overlap_id(const char* value);
  void set_done_stop_sign_overlap_id(const char* value, size_t size);
  std::string* mutable_done_stop_sign_overlap_id();
  std::string* release_done_stop_sign_overlap_id();
  void set_allocated_done_stop_sign_overlap_id(std::string* done_stop_sign_overlap_id);
  private:
  const std::string& _internal_done_stop_sign_overlap_id() const;
  void _internal_set_done_stop_sign_overlap_id(const std::string& value);
  std::string* _internal_mutable_done_stop_sign_overlap_id();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.StopSignStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wait_for_obstacle_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_stop_sign_overlap_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr done_stop_sign_overlap_id_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class TrafficLightStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficLightStatus) */ {
 public:
  TrafficLightStatus();
  virtual ~TrafficLightStatus();

  TrafficLightStatus(const TrafficLightStatus& from);
  TrafficLightStatus(TrafficLightStatus&& from) noexcept
    : TrafficLightStatus() {
    *this = ::std::move(from);
  }

  inline TrafficLightStatus& operator=(const TrafficLightStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficLightStatus& operator=(TrafficLightStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficLightStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightStatus* internal_default_instance() {
    return reinterpret_cast<const TrafficLightStatus*>(
               &_TrafficLightStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TrafficLightStatus& a, TrafficLightStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficLightStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightStatus* New() const final {
    return CreateMaybeMessage<TrafficLightStatus>(nullptr);
  }

  TrafficLightStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficLightStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficLightStatus& from);
  void MergeFrom(const TrafficLightStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLightStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrafficLightStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentTrafficLightOverlapIdFieldNumber = 1,
    kDoneTrafficLightOverlapIdFieldNumber = 2,
  };
  // repeated string current_traffic_light_overlap_id = 1;
  int current_traffic_light_overlap_id_size() const;
  private:
  int _internal_current_traffic_light_overlap_id_size() const;
  public:
  void clear_current_traffic_light_overlap_id();
  const std::string& current_traffic_light_overlap_id(int index) const;
  std::string* mutable_current_traffic_light_overlap_id(int index);
  void set_current_traffic_light_overlap_id(int index, const std::string& value);
  void set_current_traffic_light_overlap_id(int index, std::string&& value);
  void set_current_traffic_light_overlap_id(int index, const char* value);
  void set_current_traffic_light_overlap_id(int index, const char* value, size_t size);
  std::string* add_current_traffic_light_overlap_id();
  void add_current_traffic_light_overlap_id(const std::string& value);
  void add_current_traffic_light_overlap_id(std::string&& value);
  void add_current_traffic_light_overlap_id(const char* value);
  void add_current_traffic_light_overlap_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& current_traffic_light_overlap_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_current_traffic_light_overlap_id();
  private:
  const std::string& _internal_current_traffic_light_overlap_id(int index) const;
  std::string* _internal_add_current_traffic_light_overlap_id();
  public:

  // repeated string done_traffic_light_overlap_id = 2;
  int done_traffic_light_overlap_id_size() const;
  private:
  int _internal_done_traffic_light_overlap_id_size() const;
  public:
  void clear_done_traffic_light_overlap_id();
  const std::string& done_traffic_light_overlap_id(int index) const;
  std::string* mutable_done_traffic_light_overlap_id(int index);
  void set_done_traffic_light_overlap_id(int index, const std::string& value);
  void set_done_traffic_light_overlap_id(int index, std::string&& value);
  void set_done_traffic_light_overlap_id(int index, const char* value);
  void set_done_traffic_light_overlap_id(int index, const char* value, size_t size);
  std::string* add_done_traffic_light_overlap_id();
  void add_done_traffic_light_overlap_id(const std::string& value);
  void add_done_traffic_light_overlap_id(std::string&& value);
  void add_done_traffic_light_overlap_id(const char* value);
  void add_done_traffic_light_overlap_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& done_traffic_light_overlap_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_done_traffic_light_overlap_id();
  private:
  const std::string& _internal_done_traffic_light_overlap_id(int index) const;
  std::string* _internal_add_done_traffic_light_overlap_id();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficLightStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> current_traffic_light_overlap_id_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> done_traffic_light_overlap_id_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class SidePassStopStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.SidePassStopStatus) */ {
 public:
  SidePassStopStatus();
  virtual ~SidePassStopStatus();

  SidePassStopStatus(const SidePassStopStatus& from);
  SidePassStopStatus(SidePassStopStatus&& from) noexcept
    : SidePassStopStatus() {
    *this = ::std::move(from);
  }

  inline SidePassStopStatus& operator=(const SidePassStopStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SidePassStopStatus& operator=(SidePassStopStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SidePassStopStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SidePassStopStatus* internal_default_instance() {
    return reinterpret_cast<const SidePassStopStatus*>(
               &_SidePassStopStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SidePassStopStatus& a, SidePassStopStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SidePassStopStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SidePassStopStatus* New() const final {
    return CreateMaybeMessage<SidePassStopStatus>(nullptr);
  }

  SidePassStopStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SidePassStopStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SidePassStopStatus& from);
  void MergeFrom(const SidePassStopStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SidePassStopStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.SidePassStopStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeLaneStopPathPointFieldNumber = 1,
    kCheckClearFlagFieldNumber = 2,
  };
  // optional .apollo.common.PathPoint change_lane_stop_path_point = 1;
  bool has_change_lane_stop_path_point() const;
  private:
  bool _internal_has_change_lane_stop_path_point() const;
  public:
  void clear_change_lane_stop_path_point();
  const ::apollo::common::PathPoint& change_lane_stop_path_point() const;
  ::apollo::common::PathPoint* release_change_lane_stop_path_point();
  ::apollo::common::PathPoint* mutable_change_lane_stop_path_point();
  void set_allocated_change_lane_stop_path_point(::apollo::common::PathPoint* change_lane_stop_path_point);
  private:
  const ::apollo::common::PathPoint& _internal_change_lane_stop_path_point() const;
  ::apollo::common::PathPoint* _internal_mutable_change_lane_stop_path_point();
  public:

  // optional bool check_clear_flag = 2;
  bool has_check_clear_flag() const;
  private:
  bool _internal_has_check_clear_flag() const;
  public:
  void clear_check_clear_flag();
  bool check_clear_flag() const;
  void set_check_clear_flag(bool value);
  private:
  bool _internal_check_clear_flag() const;
  void _internal_set_check_clear_flag(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.SidePassStopStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::common::PathPoint* change_lane_stop_path_point_;
  bool check_clear_flag_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class PlanningStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlanningStatus) */ {
 public:
  PlanningStatus();
  virtual ~PlanningStatus();

  PlanningStatus(const PlanningStatus& from);
  PlanningStatus(PlanningStatus&& from) noexcept
    : PlanningStatus() {
    *this = ::std::move(from);
  }

  inline PlanningStatus& operator=(const PlanningStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanningStatus& operator=(PlanningStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlanningStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanningStatus* internal_default_instance() {
    return reinterpret_cast<const PlanningStatus*>(
               &_PlanningStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PlanningStatus& a, PlanningStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanningStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlanningStatus* New() const final {
    return CreateMaybeMessage<PlanningStatus>(nullptr);
  }

  PlanningStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlanningStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlanningStatus& from);
  void MergeFrom(const PlanningStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanningStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PlanningStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBareIntersectionFieldNumber = 1,
    kChangeLaneFieldNumber = 2,
    kCrosswalkFieldNumber = 3,
    kDestinationFieldNumber = 4,
    kEngageAdviceFieldNumber = 5,
    kPedestrianFieldNumber = 6,
    kPullOverFieldNumber = 7,
    kReroutingFieldNumber = 8,
    kRightOfWayFieldNumber = 9,
    kScenarioFieldNumber = 10,
    kSidePassFieldNumber = 11,
    kStopSignFieldNumber = 12,
    kTrafficLightFieldNumber = 13,
    kSidePassStopFieldNumber = 14,
  };
  // optional .apollo.planning.BareIntersectionStatus bare_intersection = 1;
  bool has_bare_intersection() const;
  private:
  bool _internal_has_bare_intersection() const;
  public:
  void clear_bare_intersection();
  const ::apollo::planning::BareIntersectionStatus& bare_intersection() const;
  ::apollo::planning::BareIntersectionStatus* release_bare_intersection();
  ::apollo::planning::BareIntersectionStatus* mutable_bare_intersection();
  void set_allocated_bare_intersection(::apollo::planning::BareIntersectionStatus* bare_intersection);
  private:
  const ::apollo::planning::BareIntersectionStatus& _internal_bare_intersection() const;
  ::apollo::planning::BareIntersectionStatus* _internal_mutable_bare_intersection();
  public:

  // optional .apollo.planning.ChangeLaneStatus change_lane = 2;
  bool has_change_lane() const;
  private:
  bool _internal_has_change_lane() const;
  public:
  void clear_change_lane();
  const ::apollo::planning::ChangeLaneStatus& change_lane() const;
  ::apollo::planning::ChangeLaneStatus* release_change_lane();
  ::apollo::planning::ChangeLaneStatus* mutable_change_lane();
  void set_allocated_change_lane(::apollo::planning::ChangeLaneStatus* change_lane);
  private:
  const ::apollo::planning::ChangeLaneStatus& _internal_change_lane() const;
  ::apollo::planning::ChangeLaneStatus* _internal_mutable_change_lane();
  public:

  // optional .apollo.planning.CrosswalkStatus crosswalk = 3;
  bool has_crosswalk() const;
  private:
  bool _internal_has_crosswalk() const;
  public:
  void clear_crosswalk();
  const ::apollo::planning::CrosswalkStatus& crosswalk() const;
  ::apollo::planning::CrosswalkStatus* release_crosswalk();
  ::apollo::planning::CrosswalkStatus* mutable_crosswalk();
  void set_allocated_crosswalk(::apollo::planning::CrosswalkStatus* crosswalk);
  private:
  const ::apollo::planning::CrosswalkStatus& _internal_crosswalk() const;
  ::apollo::planning::CrosswalkStatus* _internal_mutable_crosswalk();
  public:

  // optional .apollo.planning.DestinationStatus destination = 4;
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  const ::apollo::planning::DestinationStatus& destination() const;
  ::apollo::planning::DestinationStatus* release_destination();
  ::apollo::planning::DestinationStatus* mutable_destination();
  void set_allocated_destination(::apollo::planning::DestinationStatus* destination);
  private:
  const ::apollo::planning::DestinationStatus& _internal_destination() const;
  ::apollo::planning::DestinationStatus* _internal_mutable_destination();
  public:

  // optional .apollo.common.EngageAdvice engage_advice = 5;
  bool has_engage_advice() const;
  private:
  bool _internal_has_engage_advice() const;
  public:
  void clear_engage_advice();
  const ::apollo::common::EngageAdvice& engage_advice() const;
  ::apollo::common::EngageAdvice* release_engage_advice();
  ::apollo::common::EngageAdvice* mutable_engage_advice();
  void set_allocated_engage_advice(::apollo::common::EngageAdvice* engage_advice);
  private:
  const ::apollo::common::EngageAdvice& _internal_engage_advice() const;
  ::apollo::common::EngageAdvice* _internal_mutable_engage_advice();
  public:

  // optional .apollo.planning.PedestrianStatus pedestrian = 6;
  bool has_pedestrian() const;
  private:
  bool _internal_has_pedestrian() const;
  public:
  void clear_pedestrian();
  const ::apollo::planning::PedestrianStatus& pedestrian() const;
  ::apollo::planning::PedestrianStatus* release_pedestrian();
  ::apollo::planning::PedestrianStatus* mutable_pedestrian();
  void set_allocated_pedestrian(::apollo::planning::PedestrianStatus* pedestrian);
  private:
  const ::apollo::planning::PedestrianStatus& _internal_pedestrian() const;
  ::apollo::planning::PedestrianStatus* _internal_mutable_pedestrian();
  public:

  // optional .apollo.planning.PullOverStatus pull_over = 7;
  bool has_pull_over() const;
  private:
  bool _internal_has_pull_over() const;
  public:
  void clear_pull_over();
  const ::apollo::planning::PullOverStatus& pull_over() const;
  ::apollo::planning::PullOverStatus* release_pull_over();
  ::apollo::planning::PullOverStatus* mutable_pull_over();
  void set_allocated_pull_over(::apollo::planning::PullOverStatus* pull_over);
  private:
  const ::apollo::planning::PullOverStatus& _internal_pull_over() const;
  ::apollo::planning::PullOverStatus* _internal_mutable_pull_over();
  public:

  // optional .apollo.planning.ReroutingStatus rerouting = 8;
  bool has_rerouting() const;
  private:
  bool _internal_has_rerouting() const;
  public:
  void clear_rerouting();
  const ::apollo::planning::ReroutingStatus& rerouting() const;
  ::apollo::planning::ReroutingStatus* release_rerouting();
  ::apollo::planning::ReroutingStatus* mutable_rerouting();
  void set_allocated_rerouting(::apollo::planning::ReroutingStatus* rerouting);
  private:
  const ::apollo::planning::ReroutingStatus& _internal_rerouting() const;
  ::apollo::planning::ReroutingStatus* _internal_mutable_rerouting();
  public:

  // optional .apollo.planning.RightOfWayStatus right_of_way = 9;
  bool has_right_of_way() const;
  private:
  bool _internal_has_right_of_way() const;
  public:
  void clear_right_of_way();
  const ::apollo::planning::RightOfWayStatus& right_of_way() const;
  ::apollo::planning::RightOfWayStatus* release_right_of_way();
  ::apollo::planning::RightOfWayStatus* mutable_right_of_way();
  void set_allocated_right_of_way(::apollo::planning::RightOfWayStatus* right_of_way);
  private:
  const ::apollo::planning::RightOfWayStatus& _internal_right_of_way() const;
  ::apollo::planning::RightOfWayStatus* _internal_mutable_right_of_way();
  public:

  // optional .apollo.planning.ScenarioStatus scenario = 10;
  bool has_scenario() const;
  private:
  bool _internal_has_scenario() const;
  public:
  void clear_scenario();
  const ::apollo::planning::ScenarioStatus& scenario() const;
  ::apollo::planning::ScenarioStatus* release_scenario();
  ::apollo::planning::ScenarioStatus* mutable_scenario();
  void set_allocated_scenario(::apollo::planning::ScenarioStatus* scenario);
  private:
  const ::apollo::planning::ScenarioStatus& _internal_scenario() const;
  ::apollo::planning::ScenarioStatus* _internal_mutable_scenario();
  public:

  // optional .apollo.planning.SidePassStatus side_pass = 11;
  bool has_side_pass() const;
  private:
  bool _internal_has_side_pass() const;
  public:
  void clear_side_pass();
  const ::apollo::planning::SidePassStatus& side_pass() const;
  ::apollo::planning::SidePassStatus* release_side_pass();
  ::apollo::planning::SidePassStatus* mutable_side_pass();
  void set_allocated_side_pass(::apollo::planning::SidePassStatus* side_pass);
  private:
  const ::apollo::planning::SidePassStatus& _internal_side_pass() const;
  ::apollo::planning::SidePassStatus* _internal_mutable_side_pass();
  public:

  // optional .apollo.planning.StopSignStatus stop_sign = 12;
  bool has_stop_sign() const;
  private:
  bool _internal_has_stop_sign() const;
  public:
  void clear_stop_sign();
  const ::apollo::planning::StopSignStatus& stop_sign() const;
  ::apollo::planning::StopSignStatus* release_stop_sign();
  ::apollo::planning::StopSignStatus* mutable_stop_sign();
  void set_allocated_stop_sign(::apollo::planning::StopSignStatus* stop_sign);
  private:
  const ::apollo::planning::StopSignStatus& _internal_stop_sign() const;
  ::apollo::planning::StopSignStatus* _internal_mutable_stop_sign();
  public:

  // optional .apollo.planning.TrafficLightStatus traffic_light = 13;
  bool has_traffic_light() const;
  private:
  bool _internal_has_traffic_light() const;
  public:
  void clear_traffic_light();
  const ::apollo::planning::TrafficLightStatus& traffic_light() const;
  ::apollo::planning::TrafficLightStatus* release_traffic_light();
  ::apollo::planning::TrafficLightStatus* mutable_traffic_light();
  void set_allocated_traffic_light(::apollo::planning::TrafficLightStatus* traffic_light);
  private:
  const ::apollo::planning::TrafficLightStatus& _internal_traffic_light() const;
  ::apollo::planning::TrafficLightStatus* _internal_mutable_traffic_light();
  public:

  // optional .apollo.planning.SidePassStopStatus side_pass_stop = 14;
  bool has_side_pass_stop() const;
  private:
  bool _internal_has_side_pass_stop() const;
  public:
  void clear_side_pass_stop();
  const ::apollo::planning::SidePassStopStatus& side_pass_stop() const;
  ::apollo::planning::SidePassStopStatus* release_side_pass_stop();
  ::apollo::planning::SidePassStopStatus* mutable_side_pass_stop();
  void set_allocated_side_pass_stop(::apollo::planning::SidePassStopStatus* side_pass_stop);
  private:
  const ::apollo::planning::SidePassStopStatus& _internal_side_pass_stop() const;
  ::apollo::planning::SidePassStopStatus* _internal_mutable_side_pass_stop();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.PlanningStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::planning::BareIntersectionStatus* bare_intersection_;
  ::apollo::planning::ChangeLaneStatus* change_lane_;
  ::apollo::planning::CrosswalkStatus* crosswalk_;
  ::apollo::planning::DestinationStatus* destination_;
  ::apollo::common::EngageAdvice* engage_advice_;
  ::apollo::planning::PedestrianStatus* pedestrian_;
  ::apollo::planning::PullOverStatus* pull_over_;
  ::apollo::planning::ReroutingStatus* rerouting_;
  ::apollo::planning::RightOfWayStatus* right_of_way_;
  ::apollo::planning::ScenarioStatus* scenario_;
  ::apollo::planning::SidePassStatus* side_pass_;
  ::apollo::planning::StopSignStatus* stop_sign_;
  ::apollo::planning::TrafficLightStatus* traffic_light_;
  ::apollo::planning::SidePassStopStatus* side_pass_stop_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BareIntersectionStatus

// optional string current_pnc_junction_overlap_id = 1;
inline bool BareIntersectionStatus::_internal_has_current_pnc_junction_overlap_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BareIntersectionStatus::has_current_pnc_junction_overlap_id() const {
  return _internal_has_current_pnc_junction_overlap_id();
}
inline void BareIntersectionStatus::clear_current_pnc_junction_overlap_id() {
  current_pnc_junction_overlap_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BareIntersectionStatus::current_pnc_junction_overlap_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
  return _internal_current_pnc_junction_overlap_id();
}
inline void BareIntersectionStatus::set_current_pnc_junction_overlap_id(const std::string& value) {
  _internal_set_current_pnc_junction_overlap_id(value);
  // @@protoc_insertion_point(field_set:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
inline std::string* BareIntersectionStatus::mutable_current_pnc_junction_overlap_id() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
  return _internal_mutable_current_pnc_junction_overlap_id();
}
inline const std::string& BareIntersectionStatus::_internal_current_pnc_junction_overlap_id() const {
  return current_pnc_junction_overlap_id_.GetNoArena();
}
inline void BareIntersectionStatus::_internal_set_current_pnc_junction_overlap_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  current_pnc_junction_overlap_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BareIntersectionStatus::set_current_pnc_junction_overlap_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  current_pnc_junction_overlap_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
inline void BareIntersectionStatus::set_current_pnc_junction_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  current_pnc_junction_overlap_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
inline void BareIntersectionStatus::set_current_pnc_junction_overlap_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  current_pnc_junction_overlap_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
inline std::string* BareIntersectionStatus::_internal_mutable_current_pnc_junction_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
  return current_pnc_junction_overlap_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BareIntersectionStatus::release_current_pnc_junction_overlap_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
  if (!_internal_has_current_pnc_junction_overlap_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return current_pnc_junction_overlap_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BareIntersectionStatus::set_allocated_current_pnc_junction_overlap_id(std::string* current_pnc_junction_overlap_id) {
  if (current_pnc_junction_overlap_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  current_pnc_junction_overlap_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_pnc_junction_overlap_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}

// optional string done_pnc_junction_overlap_id = 2;
inline bool BareIntersectionStatus::_internal_has_done_pnc_junction_overlap_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BareIntersectionStatus::has_done_pnc_junction_overlap_id() const {
  return _internal_has_done_pnc_junction_overlap_id();
}
inline void BareIntersectionStatus::clear_done_pnc_junction_overlap_id() {
  done_pnc_junction_overlap_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BareIntersectionStatus::done_pnc_junction_overlap_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
  return _internal_done_pnc_junction_overlap_id();
}
inline void BareIntersectionStatus::set_done_pnc_junction_overlap_id(const std::string& value) {
  _internal_set_done_pnc_junction_overlap_id(value);
  // @@protoc_insertion_point(field_set:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
inline std::string* BareIntersectionStatus::mutable_done_pnc_junction_overlap_id() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
  return _internal_mutable_done_pnc_junction_overlap_id();
}
inline const std::string& BareIntersectionStatus::_internal_done_pnc_junction_overlap_id() const {
  return done_pnc_junction_overlap_id_.GetNoArena();
}
inline void BareIntersectionStatus::_internal_set_done_pnc_junction_overlap_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  done_pnc_junction_overlap_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BareIntersectionStatus::set_done_pnc_junction_overlap_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  done_pnc_junction_overlap_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
inline void BareIntersectionStatus::set_done_pnc_junction_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  done_pnc_junction_overlap_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
inline void BareIntersectionStatus::set_done_pnc_junction_overlap_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  done_pnc_junction_overlap_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
inline std::string* BareIntersectionStatus::_internal_mutable_done_pnc_junction_overlap_id() {
  _has_bits_[0] |= 0x00000002u;
  return done_pnc_junction_overlap_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BareIntersectionStatus::release_done_pnc_junction_overlap_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
  if (!_internal_has_done_pnc_junction_overlap_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return done_pnc_junction_overlap_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BareIntersectionStatus::set_allocated_done_pnc_junction_overlap_id(std::string* done_pnc_junction_overlap_id) {
  if (done_pnc_junction_overlap_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  done_pnc_junction_overlap_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), done_pnc_junction_overlap_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}

// -------------------------------------------------------------------

// ChangeLaneStatus

// optional .apollo.planning.ChangeLaneStatus.Status status = 1;
inline bool ChangeLaneStatus::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_status() const {
  return _internal_has_status();
}
inline void ChangeLaneStatus::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::planning::ChangeLaneStatus_Status ChangeLaneStatus::_internal_status() const {
  return static_cast< ::apollo::planning::ChangeLaneStatus_Status >(status_);
}
inline ::apollo::planning::ChangeLaneStatus_Status ChangeLaneStatus::status() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.status)
  return _internal_status();
}
inline void ChangeLaneStatus::_internal_set_status(::apollo::planning::ChangeLaneStatus_Status value) {
  assert(::apollo::planning::ChangeLaneStatus_Status_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void ChangeLaneStatus::set_status(::apollo::planning::ChangeLaneStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.status)
}

// optional string path_id = 2;
inline bool ChangeLaneStatus::_internal_has_path_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_path_id() const {
  return _internal_has_path_id();
}
inline void ChangeLaneStatus::clear_path_id() {
  path_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeLaneStatus::path_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.path_id)
  return _internal_path_id();
}
inline void ChangeLaneStatus::set_path_id(const std::string& value) {
  _internal_set_path_id(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.path_id)
}
inline std::string* ChangeLaneStatus::mutable_path_id() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ChangeLaneStatus.path_id)
  return _internal_mutable_path_id();
}
inline const std::string& ChangeLaneStatus::_internal_path_id() const {
  return path_id_.GetNoArena();
}
inline void ChangeLaneStatus::_internal_set_path_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  path_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ChangeLaneStatus::set_path_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  path_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.ChangeLaneStatus.path_id)
}
inline void ChangeLaneStatus::set_path_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  path_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.ChangeLaneStatus.path_id)
}
inline void ChangeLaneStatus::set_path_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  path_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.ChangeLaneStatus.path_id)
}
inline std::string* ChangeLaneStatus::_internal_mutable_path_id() {
  _has_bits_[0] |= 0x00000001u;
  return path_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChangeLaneStatus::release_path_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.ChangeLaneStatus.path_id)
  if (!_internal_has_path_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return path_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeLaneStatus::set_allocated_path_id(std::string* path_id) {
  if (path_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  path_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ChangeLaneStatus.path_id)
}

// optional double timestamp = 3;
inline bool ChangeLaneStatus::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void ChangeLaneStatus::clear_timestamp() {
  timestamp_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ChangeLaneStatus::_internal_timestamp() const {
  return timestamp_;
}
inline double ChangeLaneStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.timestamp)
  return _internal_timestamp();
}
inline void ChangeLaneStatus::_internal_set_timestamp(double value) {
  _has_bits_[0] |= 0x00000002u;
  timestamp_ = value;
}
inline void ChangeLaneStatus::set_timestamp(double value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.timestamp)
}

// -------------------------------------------------------------------

// StopTime

// optional string obstacle_id = 1;
inline bool StopTime::_internal_has_obstacle_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopTime::has_obstacle_id() const {
  return _internal_has_obstacle_id();
}
inline void StopTime::clear_obstacle_id() {
  obstacle_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StopTime::obstacle_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopTime.obstacle_id)
  return _internal_obstacle_id();
}
inline void StopTime::set_obstacle_id(const std::string& value) {
  _internal_set_obstacle_id(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopTime.obstacle_id)
}
inline std::string* StopTime::mutable_obstacle_id() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopTime.obstacle_id)
  return _internal_mutable_obstacle_id();
}
inline const std::string& StopTime::_internal_obstacle_id() const {
  return obstacle_id_.GetNoArena();
}
inline void StopTime::_internal_set_obstacle_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  obstacle_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StopTime::set_obstacle_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  obstacle_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.StopTime.obstacle_id)
}
inline void StopTime::set_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  obstacle_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.StopTime.obstacle_id)
}
inline void StopTime::set_obstacle_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  obstacle_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.StopTime.obstacle_id)
}
inline std::string* StopTime::_internal_mutable_obstacle_id() {
  _has_bits_[0] |= 0x00000001u;
  return obstacle_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StopTime::release_obstacle_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopTime.obstacle_id)
  if (!_internal_has_obstacle_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return obstacle_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StopTime::set_allocated_obstacle_id(std::string* obstacle_id) {
  if (obstacle_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  obstacle_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), obstacle_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopTime.obstacle_id)
}

// optional double obstacle_stop_timestamp = 2;
inline bool StopTime::_internal_has_obstacle_stop_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StopTime::has_obstacle_stop_timestamp() const {
  return _internal_has_obstacle_stop_timestamp();
}
inline void StopTime::clear_obstacle_stop_timestamp() {
  obstacle_stop_timestamp_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double StopTime::_internal_obstacle_stop_timestamp() const {
  return obstacle_stop_timestamp_;
}
inline double StopTime::obstacle_stop_timestamp() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopTime.obstacle_stop_timestamp)
  return _internal_obstacle_stop_timestamp();
}
inline void StopTime::_internal_set_obstacle_stop_timestamp(double value) {
  _has_bits_[0] |= 0x00000002u;
  obstacle_stop_timestamp_ = value;
}
inline void StopTime::set_obstacle_stop_timestamp(double value) {
  _internal_set_obstacle_stop_timestamp(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopTime.obstacle_stop_timestamp)
}

// -------------------------------------------------------------------

// CrosswalkStatus

// optional string crosswalk_id = 1;
inline bool CrosswalkStatus::_internal_has_crosswalk_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrosswalkStatus::has_crosswalk_id() const {
  return _internal_has_crosswalk_id();
}
inline void CrosswalkStatus::clear_crosswalk_id() {
  crosswalk_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrosswalkStatus::crosswalk_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkStatus.crosswalk_id)
  return _internal_crosswalk_id();
}
inline void CrosswalkStatus::set_crosswalk_id(const std::string& value) {
  _internal_set_crosswalk_id(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkStatus.crosswalk_id)
}
inline std::string* CrosswalkStatus::mutable_crosswalk_id() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.CrosswalkStatus.crosswalk_id)
  return _internal_mutable_crosswalk_id();
}
inline const std::string& CrosswalkStatus::_internal_crosswalk_id() const {
  return crosswalk_id_.GetNoArena();
}
inline void CrosswalkStatus::_internal_set_crosswalk_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  crosswalk_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CrosswalkStatus::set_crosswalk_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  crosswalk_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.CrosswalkStatus.crosswalk_id)
}
inline void CrosswalkStatus::set_crosswalk_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  crosswalk_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.CrosswalkStatus.crosswalk_id)
}
inline void CrosswalkStatus::set_crosswalk_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  crosswalk_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.CrosswalkStatus.crosswalk_id)
}
inline std::string* CrosswalkStatus::_internal_mutable_crosswalk_id() {
  _has_bits_[0] |= 0x00000001u;
  return crosswalk_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CrosswalkStatus::release_crosswalk_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.CrosswalkStatus.crosswalk_id)
  if (!_internal_has_crosswalk_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return crosswalk_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CrosswalkStatus::set_allocated_crosswalk_id(std::string* crosswalk_id) {
  if (crosswalk_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  crosswalk_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), crosswalk_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.CrosswalkStatus.crosswalk_id)
}

// repeated .apollo.planning.StopTime stop_time = 2;
inline int CrosswalkStatus::_internal_stop_time_size() const {
  return stop_time_.size();
}
inline int CrosswalkStatus::stop_time_size() const {
  return _internal_stop_time_size();
}
inline void CrosswalkStatus::clear_stop_time() {
  stop_time_.Clear();
}
inline ::apollo::planning::StopTime* CrosswalkStatus::mutable_stop_time(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.CrosswalkStatus.stop_time)
  return stop_time_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >*
CrosswalkStatus::mutable_stop_time() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.CrosswalkStatus.stop_time)
  return &stop_time_;
}
inline const ::apollo::planning::StopTime& CrosswalkStatus::_internal_stop_time(int index) const {
  return stop_time_.Get(index);
}
inline const ::apollo::planning::StopTime& CrosswalkStatus::stop_time(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkStatus.stop_time)
  return _internal_stop_time(index);
}
inline ::apollo::planning::StopTime* CrosswalkStatus::_internal_add_stop_time() {
  return stop_time_.Add();
}
inline ::apollo::planning::StopTime* CrosswalkStatus::add_stop_time() {
  // @@protoc_insertion_point(field_add:apollo.planning.CrosswalkStatus.stop_time)
  return _internal_add_stop_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >&
CrosswalkStatus::stop_time() const {
  // @@protoc_insertion_point(field_list:apollo.planning.CrosswalkStatus.stop_time)
  return stop_time_;
}

// repeated string finished_crosswalk = 3;
inline int CrosswalkStatus::_internal_finished_crosswalk_size() const {
  return finished_crosswalk_.size();
}
inline int CrosswalkStatus::finished_crosswalk_size() const {
  return _internal_finished_crosswalk_size();
}
inline void CrosswalkStatus::clear_finished_crosswalk() {
  finished_crosswalk_.Clear();
}
inline std::string* CrosswalkStatus::add_finished_crosswalk() {
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.CrosswalkStatus.finished_crosswalk)
  return _internal_add_finished_crosswalk();
}
inline const std::string& CrosswalkStatus::_internal_finished_crosswalk(int index) const {
  return finished_crosswalk_.Get(index);
}
inline const std::string& CrosswalkStatus::finished_crosswalk(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkStatus.finished_crosswalk)
  return _internal_finished_crosswalk(index);
}
inline std::string* CrosswalkStatus::mutable_finished_crosswalk(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.CrosswalkStatus.finished_crosswalk)
  return finished_crosswalk_.Mutable(index);
}
inline void CrosswalkStatus::set_finished_crosswalk(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkStatus.finished_crosswalk)
  finished_crosswalk_.Mutable(index)->assign(value);
}
inline void CrosswalkStatus::set_finished_crosswalk(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkStatus.finished_crosswalk)
  finished_crosswalk_.Mutable(index)->assign(std::move(value));
}
inline void CrosswalkStatus::set_finished_crosswalk(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  finished_crosswalk_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline void CrosswalkStatus::set_finished_crosswalk(int index, const char* value, size_t size) {
  finished_crosswalk_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline std::string* CrosswalkStatus::_internal_add_finished_crosswalk() {
  return finished_crosswalk_.Add();
}
inline void CrosswalkStatus::add_finished_crosswalk(const std::string& value) {
  finished_crosswalk_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline void CrosswalkStatus::add_finished_crosswalk(std::string&& value) {
  finished_crosswalk_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline void CrosswalkStatus::add_finished_crosswalk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  finished_crosswalk_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline void CrosswalkStatus::add_finished_crosswalk(const char* value, size_t size) {
  finished_crosswalk_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CrosswalkStatus::finished_crosswalk() const {
  // @@protoc_insertion_point(field_list:apollo.planning.CrosswalkStatus.finished_crosswalk)
  return finished_crosswalk_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CrosswalkStatus::mutable_finished_crosswalk() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.CrosswalkStatus.finished_crosswalk)
  return &finished_crosswalk_;
}

// -------------------------------------------------------------------

// DestinationStatus

// optional bool has_passed_destination = 1 [default = false];
inline bool DestinationStatus::_internal_has_has_passed_destination() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DestinationStatus::has_has_passed_destination() const {
  return _internal_has_has_passed_destination();
}
inline void DestinationStatus::clear_has_passed_destination() {
  has_passed_destination_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool DestinationStatus::_internal_has_passed_destination() const {
  return has_passed_destination_;
}
inline bool DestinationStatus::has_passed_destination() const {
  // @@protoc_insertion_point(field_get:apollo.planning.DestinationStatus.has_passed_destination)
  return _internal_has_passed_destination();
}
inline void DestinationStatus::_internal_set_has_passed_destination(bool value) {
  _has_bits_[0] |= 0x00000001u;
  has_passed_destination_ = value;
}
inline void DestinationStatus::set_has_passed_destination(bool value) {
  _internal_set_has_passed_destination(value);
  // @@protoc_insertion_point(field_set:apollo.planning.DestinationStatus.has_passed_destination)
}

// -------------------------------------------------------------------

// PedestrianStatus

// repeated .apollo.planning.StopTime stop_time = 1;
inline int PedestrianStatus::_internal_stop_time_size() const {
  return stop_time_.size();
}
inline int PedestrianStatus::stop_time_size() const {
  return _internal_stop_time_size();
}
inline void PedestrianStatus::clear_stop_time() {
  stop_time_.Clear();
}
inline ::apollo::planning::StopTime* PedestrianStatus::mutable_stop_time(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PedestrianStatus.stop_time)
  return stop_time_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >*
PedestrianStatus::mutable_stop_time() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PedestrianStatus.stop_time)
  return &stop_time_;
}
inline const ::apollo::planning::StopTime& PedestrianStatus::_internal_stop_time(int index) const {
  return stop_time_.Get(index);
}
inline const ::apollo::planning::StopTime& PedestrianStatus::stop_time(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PedestrianStatus.stop_time)
  return _internal_stop_time(index);
}
inline ::apollo::planning::StopTime* PedestrianStatus::_internal_add_stop_time() {
  return stop_time_.Add();
}
inline ::apollo::planning::StopTime* PedestrianStatus::add_stop_time() {
  // @@protoc_insertion_point(field_add:apollo.planning.PedestrianStatus.stop_time)
  return _internal_add_stop_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >&
PedestrianStatus::stop_time() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PedestrianStatus.stop_time)
  return stop_time_;
}

// -------------------------------------------------------------------

// PullOverStatus

// optional bool is_feasible = 1 [default = false];
inline bool PullOverStatus::_internal_has_is_feasible() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PullOverStatus::has_is_feasible() const {
  return _internal_has_is_feasible();
}
inline void PullOverStatus::clear_is_feasible() {
  is_feasible_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool PullOverStatus::_internal_is_feasible() const {
  return is_feasible_;
}
inline bool PullOverStatus::is_feasible() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.is_feasible)
  return _internal_is_feasible();
}
inline void PullOverStatus::_internal_set_is_feasible(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_feasible_ = value;
}
inline void PullOverStatus::set_is_feasible(bool value) {
  _internal_set_is_feasible(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.is_feasible)
}

// optional .apollo.common.PointENU position = 2;
inline bool PullOverStatus::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool PullOverStatus::has_position() const {
  return _internal_has_position();
}
inline const ::apollo::common::PointENU& PullOverStatus::_internal_position() const {
  const ::apollo::common::PointENU* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::common::PointENU*>(
      &::apollo::common::_PointENU_default_instance_);
}
inline const ::apollo::common::PointENU& PullOverStatus::position() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.position)
  return _internal_position();
}
inline ::apollo::common::PointENU* PullOverStatus::release_position() {
  // @@protoc_insertion_point(field_release:apollo.planning.PullOverStatus.position)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::common::PointENU* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::apollo::common::PointENU* PullOverStatus::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::PointENU>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::apollo::common::PointENU* PullOverStatus::mutable_position() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PullOverStatus.position)
  return _internal_mutable_position();
}
inline void PullOverStatus::set_allocated_position(::apollo::common::PointENU* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PullOverStatus.position)
}

// optional double theta = 3;
inline bool PullOverStatus::_internal_has_theta() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PullOverStatus::has_theta() const {
  return _internal_has_theta();
}
inline void PullOverStatus::clear_theta() {
  theta_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double PullOverStatus::_internal_theta() const {
  return theta_;
}
inline double PullOverStatus::theta() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.theta)
  return _internal_theta();
}
inline void PullOverStatus::_internal_set_theta(double value) {
  _has_bits_[0] |= 0x00000002u;
  theta_ = value;
}
inline void PullOverStatus::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.theta)
}

// optional double length_front = 4;
inline bool PullOverStatus::_internal_has_length_front() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PullOverStatus::has_length_front() const {
  return _internal_has_length_front();
}
inline void PullOverStatus::clear_length_front() {
  length_front_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double PullOverStatus::_internal_length_front() const {
  return length_front_;
}
inline double PullOverStatus::length_front() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.length_front)
  return _internal_length_front();
}
inline void PullOverStatus::_internal_set_length_front(double value) {
  _has_bits_[0] |= 0x00000004u;
  length_front_ = value;
}
inline void PullOverStatus::set_length_front(double value) {
  _internal_set_length_front(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.length_front)
}

// optional double length_back = 5;
inline bool PullOverStatus::_internal_has_length_back() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PullOverStatus::has_length_back() const {
  return _internal_has_length_back();
}
inline void PullOverStatus::clear_length_back() {
  length_back_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double PullOverStatus::_internal_length_back() const {
  return length_back_;
}
inline double PullOverStatus::length_back() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.length_back)
  return _internal_length_back();
}
inline void PullOverStatus::_internal_set_length_back(double value) {
  _has_bits_[0] |= 0x00000008u;
  length_back_ = value;
}
inline void PullOverStatus::set_length_back(double value) {
  _internal_set_length_back(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.length_back)
}

// optional double width_left = 6;
inline bool PullOverStatus::_internal_has_width_left() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PullOverStatus::has_width_left() const {
  return _internal_has_width_left();
}
inline void PullOverStatus::clear_width_left() {
  width_left_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double PullOverStatus::_internal_width_left() const {
  return width_left_;
}
inline double PullOverStatus::width_left() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.width_left)
  return _internal_width_left();
}
inline void PullOverStatus::_internal_set_width_left(double value) {
  _has_bits_[0] |= 0x00000010u;
  width_left_ = value;
}
inline void PullOverStatus::set_width_left(double value) {
  _internal_set_width_left(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.width_left)
}

// optional double width_right = 7;
inline bool PullOverStatus::_internal_has_width_right() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PullOverStatus::has_width_right() const {
  return _internal_has_width_right();
}
inline void PullOverStatus::clear_width_right() {
  width_right_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double PullOverStatus::_internal_width_right() const {
  return width_right_;
}
inline double PullOverStatus::width_right() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.width_right)
  return _internal_width_right();
}
inline void PullOverStatus::_internal_set_width_right(double value) {
  _has_bits_[0] |= 0x00000100u;
  width_right_ = value;
}
inline void PullOverStatus::set_width_right(double value) {
  _internal_set_width_right(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.width_right)
}

// optional int32 idx = 8;
inline bool PullOverStatus::_internal_has_idx() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PullOverStatus::has_idx() const {
  return _internal_has_idx();
}
inline void PullOverStatus::clear_idx() {
  idx_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PullOverStatus::_internal_idx() const {
  return idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PullOverStatus::idx() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.idx)
  return _internal_idx();
}
inline void PullOverStatus::_internal_set_idx(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  idx_ = value;
}
inline void PullOverStatus::set_idx(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.idx)
}

// optional bool is_in_pull_over_scenario = 9 [default = false];
inline bool PullOverStatus::_internal_has_is_in_pull_over_scenario() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PullOverStatus::has_is_in_pull_over_scenario() const {
  return _internal_has_is_in_pull_over_scenario();
}
inline void PullOverStatus::clear_is_in_pull_over_scenario() {
  is_in_pull_over_scenario_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool PullOverStatus::_internal_is_in_pull_over_scenario() const {
  return is_in_pull_over_scenario_;
}
inline bool PullOverStatus::is_in_pull_over_scenario() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.is_in_pull_over_scenario)
  return _internal_is_in_pull_over_scenario();
}
inline void PullOverStatus::_internal_set_is_in_pull_over_scenario(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_in_pull_over_scenario_ = value;
}
inline void PullOverStatus::set_is_in_pull_over_scenario(bool value) {
  _internal_set_is_in_pull_over_scenario(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.is_in_pull_over_scenario)
}

// -------------------------------------------------------------------

// ReroutingStatus

// optional double last_rerouting_time = 1;
inline bool ReroutingStatus::_internal_has_last_rerouting_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReroutingStatus::has_last_rerouting_time() const {
  return _internal_has_last_rerouting_time();
}
inline void ReroutingStatus::clear_last_rerouting_time() {
  last_rerouting_time_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ReroutingStatus::_internal_last_rerouting_time() const {
  return last_rerouting_time_;
}
inline double ReroutingStatus::last_rerouting_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingStatus.last_rerouting_time)
  return _internal_last_rerouting_time();
}
inline void ReroutingStatus::_internal_set_last_rerouting_time(double value) {
  _has_bits_[0] |= 0x00000002u;
  last_rerouting_time_ = value;
}
inline void ReroutingStatus::set_last_rerouting_time(double value) {
  _internal_set_last_rerouting_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingStatus.last_rerouting_time)
}

// optional bool need_rerouting = 2 [default = false];
inline bool ReroutingStatus::_internal_has_need_rerouting() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReroutingStatus::has_need_rerouting() const {
  return _internal_has_need_rerouting();
}
inline void ReroutingStatus::clear_need_rerouting() {
  need_rerouting_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ReroutingStatus::_internal_need_rerouting() const {
  return need_rerouting_;
}
inline bool ReroutingStatus::need_rerouting() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingStatus.need_rerouting)
  return _internal_need_rerouting();
}
inline void ReroutingStatus::_internal_set_need_rerouting(bool value) {
  _has_bits_[0] |= 0x00000004u;
  need_rerouting_ = value;
}
inline void ReroutingStatus::set_need_rerouting(bool value) {
  _internal_set_need_rerouting(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingStatus.need_rerouting)
}

// optional .apollo.routing.RoutingRequest routing_request = 3;
inline bool ReroutingStatus::_internal_has_routing_request() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || routing_request_ != nullptr);
  return value;
}
inline bool ReroutingStatus::has_routing_request() const {
  return _internal_has_routing_request();
}
inline const ::apollo::routing::RoutingRequest& ReroutingStatus::_internal_routing_request() const {
  const ::apollo::routing::RoutingRequest* p = routing_request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::routing::RoutingRequest*>(
      &::apollo::routing::_RoutingRequest_default_instance_);
}
inline const ::apollo::routing::RoutingRequest& ReroutingStatus::routing_request() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingStatus.routing_request)
  return _internal_routing_request();
}
inline ::apollo::routing::RoutingRequest* ReroutingStatus::release_routing_request() {
  // @@protoc_insertion_point(field_release:apollo.planning.ReroutingStatus.routing_request)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::routing::RoutingRequest* temp = routing_request_;
  routing_request_ = nullptr;
  return temp;
}
inline ::apollo::routing::RoutingRequest* ReroutingStatus::_internal_mutable_routing_request() {
  _has_bits_[0] |= 0x00000001u;
  if (routing_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::routing::RoutingRequest>(GetArenaNoVirtual());
    routing_request_ = p;
  }
  return routing_request_;
}
inline ::apollo::routing::RoutingRequest* ReroutingStatus::mutable_routing_request() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ReroutingStatus.routing_request)
  return _internal_mutable_routing_request();
}
inline void ReroutingStatus::set_allocated_routing_request(::apollo::routing::RoutingRequest* routing_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(routing_request_);
  }
  if (routing_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      routing_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routing_request, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  routing_request_ = routing_request;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ReroutingStatus.routing_request)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RightOfWayStatus

// map<string, bool> junction = 1;
inline int RightOfWayStatus::_internal_junction_size() const {
  return junction_.size();
}
inline int RightOfWayStatus::junction_size() const {
  return _internal_junction_size();
}
inline void RightOfWayStatus::clear_junction() {
  junction_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
RightOfWayStatus::_internal_junction() const {
  return junction_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
RightOfWayStatus::junction() const {
  // @@protoc_insertion_point(field_map:apollo.planning.RightOfWayStatus.junction)
  return _internal_junction();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
RightOfWayStatus::_internal_mutable_junction() {
  return junction_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
RightOfWayStatus::mutable_junction() {
  // @@protoc_insertion_point(field_mutable_map:apollo.planning.RightOfWayStatus.junction)
  return _internal_mutable_junction();
}

// -------------------------------------------------------------------

// ScenarioStatus

// optional .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
inline bool ScenarioStatus::_internal_has_scenario_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScenarioStatus::has_scenario_type() const {
  return _internal_has_scenario_type();
}
inline void ScenarioStatus::clear_scenario_type() {
  scenario_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::planning::ScenarioConfig_ScenarioType ScenarioStatus::_internal_scenario_type() const {
  return static_cast< ::apollo::planning::ScenarioConfig_ScenarioType >(scenario_type_);
}
inline ::apollo::planning::ScenarioConfig_ScenarioType ScenarioStatus::scenario_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStatus.scenario_type)
  return _internal_scenario_type();
}
inline void ScenarioStatus::_internal_set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value) {
  assert(::apollo::planning::ScenarioConfig_ScenarioType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  scenario_type_ = value;
}
inline void ScenarioStatus::set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value) {
  _internal_set_scenario_type(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStatus.scenario_type)
}

// optional .apollo.planning.ScenarioConfig.StageType stage_type = 2;
inline bool ScenarioStatus::_internal_has_stage_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScenarioStatus::has_stage_type() const {
  return _internal_has_stage_type();
}
inline void ScenarioStatus::clear_stage_type() {
  stage_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::planning::ScenarioConfig_StageType ScenarioStatus::_internal_stage_type() const {
  return static_cast< ::apollo::planning::ScenarioConfig_StageType >(stage_type_);
}
inline ::apollo::planning::ScenarioConfig_StageType ScenarioStatus::stage_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStatus.stage_type)
  return _internal_stage_type();
}
inline void ScenarioStatus::_internal_set_stage_type(::apollo::planning::ScenarioConfig_StageType value) {
  assert(::apollo::planning::ScenarioConfig_StageType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  stage_type_ = value;
}
inline void ScenarioStatus::set_stage_type(::apollo::planning::ScenarioConfig_StageType value) {
  _internal_set_stage_type(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStatus.stage_type)
}

// -------------------------------------------------------------------

// SidePassStatus

// optional string front_blocking_obstacle_id = 1;
inline bool SidePassStatus::_internal_has_front_blocking_obstacle_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SidePassStatus::has_front_blocking_obstacle_id() const {
  return _internal_has_front_blocking_obstacle_id();
}
inline void SidePassStatus::clear_front_blocking_obstacle_id() {
  front_blocking_obstacle_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SidePassStatus::front_blocking_obstacle_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SidePassStatus.front_blocking_obstacle_id)
  return _internal_front_blocking_obstacle_id();
}
inline void SidePassStatus::set_front_blocking_obstacle_id(const std::string& value) {
  _internal_set_front_blocking_obstacle_id(value);
  // @@protoc_insertion_point(field_set:apollo.planning.SidePassStatus.front_blocking_obstacle_id)
}
inline std::string* SidePassStatus::mutable_front_blocking_obstacle_id() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.SidePassStatus.front_blocking_obstacle_id)
  return _internal_mutable_front_blocking_obstacle_id();
}
inline const std::string& SidePassStatus::_internal_front_blocking_obstacle_id() const {
  return front_blocking_obstacle_id_.GetNoArena();
}
inline void SidePassStatus::_internal_set_front_blocking_obstacle_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  front_blocking_obstacle_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SidePassStatus::set_front_blocking_obstacle_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  front_blocking_obstacle_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.SidePassStatus.front_blocking_obstacle_id)
}
inline void SidePassStatus::set_front_blocking_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  front_blocking_obstacle_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.SidePassStatus.front_blocking_obstacle_id)
}
inline void SidePassStatus::set_front_blocking_obstacle_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  front_blocking_obstacle_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.SidePassStatus.front_blocking_obstacle_id)
}
inline std::string* SidePassStatus::_internal_mutable_front_blocking_obstacle_id() {
  _has_bits_[0] |= 0x00000001u;
  return front_blocking_obstacle_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SidePassStatus::release_front_blocking_obstacle_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.SidePassStatus.front_blocking_obstacle_id)
  if (!_internal_has_front_blocking_obstacle_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return front_blocking_obstacle_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SidePassStatus::set_allocated_front_blocking_obstacle_id(std::string* front_blocking_obstacle_id) {
  if (front_blocking_obstacle_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  front_blocking_obstacle_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), front_blocking_obstacle_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.SidePassStatus.front_blocking_obstacle_id)
}

// -------------------------------------------------------------------

// StopSignStatus

// optional string current_stop_sign_overlap_id = 1;
inline bool StopSignStatus::_internal_has_current_stop_sign_overlap_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopSignStatus::has_current_stop_sign_overlap_id() const {
  return _internal_has_current_stop_sign_overlap_id();
}
inline void StopSignStatus::clear_current_stop_sign_overlap_id() {
  current_stop_sign_overlap_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StopSignStatus::current_stop_sign_overlap_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
  return _internal_current_stop_sign_overlap_id();
}
inline void StopSignStatus::set_current_stop_sign_overlap_id(const std::string& value) {
  _internal_set_current_stop_sign_overlap_id(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
}
inline std::string* StopSignStatus::mutable_current_stop_sign_overlap_id() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
  return _internal_mutable_current_stop_sign_overlap_id();
}
inline const std::string& StopSignStatus::_internal_current_stop_sign_overlap_id() const {
  return current_stop_sign_overlap_id_.GetNoArena();
}
inline void StopSignStatus::_internal_set_current_stop_sign_overlap_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  current_stop_sign_overlap_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StopSignStatus::set_current_stop_sign_overlap_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  current_stop_sign_overlap_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
}
inline void StopSignStatus::set_current_stop_sign_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  current_stop_sign_overlap_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
}
inline void StopSignStatus::set_current_stop_sign_overlap_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  current_stop_sign_overlap_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
}
inline std::string* StopSignStatus::_internal_mutable_current_stop_sign_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
  return current_stop_sign_overlap_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StopSignStatus::release_current_stop_sign_overlap_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
  if (!_internal_has_current_stop_sign_overlap_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return current_stop_sign_overlap_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StopSignStatus::set_allocated_current_stop_sign_overlap_id(std::string* current_stop_sign_overlap_id) {
  if (current_stop_sign_overlap_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  current_stop_sign_overlap_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_stop_sign_overlap_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
}

// optional string done_stop_sign_overlap_id = 2;
inline bool StopSignStatus::_internal_has_done_stop_sign_overlap_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StopSignStatus::has_done_stop_sign_overlap_id() const {
  return _internal_has_done_stop_sign_overlap_id();
}
inline void StopSignStatus::clear_done_stop_sign_overlap_id() {
  done_stop_sign_overlap_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StopSignStatus::done_stop_sign_overlap_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
  return _internal_done_stop_sign_overlap_id();
}
inline void StopSignStatus::set_done_stop_sign_overlap_id(const std::string& value) {
  _internal_set_done_stop_sign_overlap_id(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
}
inline std::string* StopSignStatus::mutable_done_stop_sign_overlap_id() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
  return _internal_mutable_done_stop_sign_overlap_id();
}
inline const std::string& StopSignStatus::_internal_done_stop_sign_overlap_id() const {
  return done_stop_sign_overlap_id_.GetNoArena();
}
inline void StopSignStatus::_internal_set_done_stop_sign_overlap_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  done_stop_sign_overlap_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StopSignStatus::set_done_stop_sign_overlap_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  done_stop_sign_overlap_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
}
inline void StopSignStatus::set_done_stop_sign_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  done_stop_sign_overlap_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
}
inline void StopSignStatus::set_done_stop_sign_overlap_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  done_stop_sign_overlap_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
}
inline std::string* StopSignStatus::_internal_mutable_done_stop_sign_overlap_id() {
  _has_bits_[0] |= 0x00000002u;
  return done_stop_sign_overlap_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StopSignStatus::release_done_stop_sign_overlap_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
  if (!_internal_has_done_stop_sign_overlap_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return done_stop_sign_overlap_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StopSignStatus::set_allocated_done_stop_sign_overlap_id(std::string* done_stop_sign_overlap_id) {
  if (done_stop_sign_overlap_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  done_stop_sign_overlap_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), done_stop_sign_overlap_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
}

// repeated string wait_for_obstacle_id = 3;
inline int StopSignStatus::_internal_wait_for_obstacle_id_size() const {
  return wait_for_obstacle_id_.size();
}
inline int StopSignStatus::wait_for_obstacle_id_size() const {
  return _internal_wait_for_obstacle_id_size();
}
inline void StopSignStatus::clear_wait_for_obstacle_id() {
  wait_for_obstacle_id_.Clear();
}
inline std::string* StopSignStatus::add_wait_for_obstacle_id() {
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.StopSignStatus.wait_for_obstacle_id)
  return _internal_add_wait_for_obstacle_id();
}
inline const std::string& StopSignStatus::_internal_wait_for_obstacle_id(int index) const {
  return wait_for_obstacle_id_.Get(index);
}
inline const std::string& StopSignStatus::wait_for_obstacle_id(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.wait_for_obstacle_id)
  return _internal_wait_for_obstacle_id(index);
}
inline std::string* StopSignStatus::mutable_wait_for_obstacle_id(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Mutable(index);
}
inline void StopSignStatus::set_wait_for_obstacle_id(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.wait_for_obstacle_id)
  wait_for_obstacle_id_.Mutable(index)->assign(value);
}
inline void StopSignStatus::set_wait_for_obstacle_id(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.wait_for_obstacle_id)
  wait_for_obstacle_id_.Mutable(index)->assign(std::move(value));
}
inline void StopSignStatus::set_wait_for_obstacle_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wait_for_obstacle_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline void StopSignStatus::set_wait_for_obstacle_id(int index, const char* value, size_t size) {
  wait_for_obstacle_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline std::string* StopSignStatus::_internal_add_wait_for_obstacle_id() {
  return wait_for_obstacle_id_.Add();
}
inline void StopSignStatus::add_wait_for_obstacle_id(const std::string& value) {
  wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline void StopSignStatus::add_wait_for_obstacle_id(std::string&& value) {
  wait_for_obstacle_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline void StopSignStatus::add_wait_for_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline void StopSignStatus::add_wait_for_obstacle_id(const char* value, size_t size) {
  wait_for_obstacle_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StopSignStatus::wait_for_obstacle_id() const {
  // @@protoc_insertion_point(field_list:apollo.planning.StopSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StopSignStatus::mutable_wait_for_obstacle_id() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.StopSignStatus.wait_for_obstacle_id)
  return &wait_for_obstacle_id_;
}

// -------------------------------------------------------------------

// TrafficLightStatus

// repeated string current_traffic_light_overlap_id = 1;
inline int TrafficLightStatus::_internal_current_traffic_light_overlap_id_size() const {
  return current_traffic_light_overlap_id_.size();
}
inline int TrafficLightStatus::current_traffic_light_overlap_id_size() const {
  return _internal_current_traffic_light_overlap_id_size();
}
inline void TrafficLightStatus::clear_current_traffic_light_overlap_id() {
  current_traffic_light_overlap_id_.Clear();
}
inline std::string* TrafficLightStatus::add_current_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return _internal_add_current_traffic_light_overlap_id();
}
inline const std::string& TrafficLightStatus::_internal_current_traffic_light_overlap_id(int index) const {
  return current_traffic_light_overlap_id_.Get(index);
}
inline const std::string& TrafficLightStatus::current_traffic_light_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return _internal_current_traffic_light_overlap_id(index);
}
inline std::string* TrafficLightStatus::mutable_current_traffic_light_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return current_traffic_light_overlap_id_.Mutable(index);
}
inline void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  current_traffic_light_overlap_id_.Mutable(index)->assign(value);
}
inline void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  current_traffic_light_overlap_id_.Mutable(index)->assign(std::move(value));
}
inline void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  current_traffic_light_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, const char* value, size_t size) {
  current_traffic_light_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline std::string* TrafficLightStatus::_internal_add_current_traffic_light_overlap_id() {
  return current_traffic_light_overlap_id_.Add();
}
inline void TrafficLightStatus::add_current_traffic_light_overlap_id(const std::string& value) {
  current_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_current_traffic_light_overlap_id(std::string&& value) {
  current_traffic_light_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_current_traffic_light_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  current_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_current_traffic_light_overlap_id(const char* value, size_t size) {
  current_traffic_light_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TrafficLightStatus::current_traffic_light_overlap_id() const {
  // @@protoc_insertion_point(field_list:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return current_traffic_light_overlap_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TrafficLightStatus::mutable_current_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return &current_traffic_light_overlap_id_;
}

// repeated string done_traffic_light_overlap_id = 2;
inline int TrafficLightStatus::_internal_done_traffic_light_overlap_id_size() const {
  return done_traffic_light_overlap_id_.size();
}
inline int TrafficLightStatus::done_traffic_light_overlap_id_size() const {
  return _internal_done_traffic_light_overlap_id_size();
}
inline void TrafficLightStatus::clear_done_traffic_light_overlap_id() {
  done_traffic_light_overlap_id_.Clear();
}
inline std::string* TrafficLightStatus::add_done_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return _internal_add_done_traffic_light_overlap_id();
}
inline const std::string& TrafficLightStatus::_internal_done_traffic_light_overlap_id(int index) const {
  return done_traffic_light_overlap_id_.Get(index);
}
inline const std::string& TrafficLightStatus::done_traffic_light_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return _internal_done_traffic_light_overlap_id(index);
}
inline std::string* TrafficLightStatus::mutable_done_traffic_light_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return done_traffic_light_overlap_id_.Mutable(index);
}
inline void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  done_traffic_light_overlap_id_.Mutable(index)->assign(value);
}
inline void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  done_traffic_light_overlap_id_.Mutable(index)->assign(std::move(value));
}
inline void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  done_traffic_light_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, const char* value, size_t size) {
  done_traffic_light_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline std::string* TrafficLightStatus::_internal_add_done_traffic_light_overlap_id() {
  return done_traffic_light_overlap_id_.Add();
}
inline void TrafficLightStatus::add_done_traffic_light_overlap_id(const std::string& value) {
  done_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_done_traffic_light_overlap_id(std::string&& value) {
  done_traffic_light_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_done_traffic_light_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  done_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_done_traffic_light_overlap_id(const char* value, size_t size) {
  done_traffic_light_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TrafficLightStatus::done_traffic_light_overlap_id() const {
  // @@protoc_insertion_point(field_list:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return done_traffic_light_overlap_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TrafficLightStatus::mutable_done_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return &done_traffic_light_overlap_id_;
}

// -------------------------------------------------------------------

// SidePassStopStatus

// optional .apollo.common.PathPoint change_lane_stop_path_point = 1;
inline bool SidePassStopStatus::_internal_has_change_lane_stop_path_point() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || change_lane_stop_path_point_ != nullptr);
  return value;
}
inline bool SidePassStopStatus::has_change_lane_stop_path_point() const {
  return _internal_has_change_lane_stop_path_point();
}
inline const ::apollo::common::PathPoint& SidePassStopStatus::_internal_change_lane_stop_path_point() const {
  const ::apollo::common::PathPoint* p = change_lane_stop_path_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::common::PathPoint*>(
      &::apollo::common::_PathPoint_default_instance_);
}
inline const ::apollo::common::PathPoint& SidePassStopStatus::change_lane_stop_path_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SidePassStopStatus.change_lane_stop_path_point)
  return _internal_change_lane_stop_path_point();
}
inline ::apollo::common::PathPoint* SidePassStopStatus::release_change_lane_stop_path_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.SidePassStopStatus.change_lane_stop_path_point)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::common::PathPoint* temp = change_lane_stop_path_point_;
  change_lane_stop_path_point_ = nullptr;
  return temp;
}
inline ::apollo::common::PathPoint* SidePassStopStatus::_internal_mutable_change_lane_stop_path_point() {
  _has_bits_[0] |= 0x00000001u;
  if (change_lane_stop_path_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::PathPoint>(GetArenaNoVirtual());
    change_lane_stop_path_point_ = p;
  }
  return change_lane_stop_path_point_;
}
inline ::apollo::common::PathPoint* SidePassStopStatus::mutable_change_lane_stop_path_point() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.SidePassStopStatus.change_lane_stop_path_point)
  return _internal_mutable_change_lane_stop_path_point();
}
inline void SidePassStopStatus::set_allocated_change_lane_stop_path_point(::apollo::common::PathPoint* change_lane_stop_path_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(change_lane_stop_path_point_);
  }
  if (change_lane_stop_path_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      change_lane_stop_path_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_lane_stop_path_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  change_lane_stop_path_point_ = change_lane_stop_path_point;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.SidePassStopStatus.change_lane_stop_path_point)
}

// optional bool check_clear_flag = 2;
inline bool SidePassStopStatus::_internal_has_check_clear_flag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SidePassStopStatus::has_check_clear_flag() const {
  return _internal_has_check_clear_flag();
}
inline void SidePassStopStatus::clear_check_clear_flag() {
  check_clear_flag_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SidePassStopStatus::_internal_check_clear_flag() const {
  return check_clear_flag_;
}
inline bool SidePassStopStatus::check_clear_flag() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SidePassStopStatus.check_clear_flag)
  return _internal_check_clear_flag();
}
inline void SidePassStopStatus::_internal_set_check_clear_flag(bool value) {
  _has_bits_[0] |= 0x00000002u;
  check_clear_flag_ = value;
}
inline void SidePassStopStatus::set_check_clear_flag(bool value) {
  _internal_set_check_clear_flag(value);
  // @@protoc_insertion_point(field_set:apollo.planning.SidePassStopStatus.check_clear_flag)
}

// -------------------------------------------------------------------

// PlanningStatus

// optional .apollo.planning.BareIntersectionStatus bare_intersection = 1;
inline bool PlanningStatus::_internal_has_bare_intersection() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || bare_intersection_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_bare_intersection() const {
  return _internal_has_bare_intersection();
}
inline void PlanningStatus::clear_bare_intersection() {
  if (bare_intersection_ != nullptr) bare_intersection_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::BareIntersectionStatus& PlanningStatus::_internal_bare_intersection() const {
  const ::apollo::planning::BareIntersectionStatus* p = bare_intersection_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::BareIntersectionStatus*>(
      &::apollo::planning::_BareIntersectionStatus_default_instance_);
}
inline const ::apollo::planning::BareIntersectionStatus& PlanningStatus::bare_intersection() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.bare_intersection)
  return _internal_bare_intersection();
}
inline ::apollo::planning::BareIntersectionStatus* PlanningStatus::release_bare_intersection() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.bare_intersection)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::BareIntersectionStatus* temp = bare_intersection_;
  bare_intersection_ = nullptr;
  return temp;
}
inline ::apollo::planning::BareIntersectionStatus* PlanningStatus::_internal_mutable_bare_intersection() {
  _has_bits_[0] |= 0x00000001u;
  if (bare_intersection_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::BareIntersectionStatus>(GetArenaNoVirtual());
    bare_intersection_ = p;
  }
  return bare_intersection_;
}
inline ::apollo::planning::BareIntersectionStatus* PlanningStatus::mutable_bare_intersection() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.bare_intersection)
  return _internal_mutable_bare_intersection();
}
inline void PlanningStatus::set_allocated_bare_intersection(::apollo::planning::BareIntersectionStatus* bare_intersection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bare_intersection_;
  }
  if (bare_intersection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bare_intersection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bare_intersection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bare_intersection_ = bare_intersection;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.bare_intersection)
}

// optional .apollo.planning.ChangeLaneStatus change_lane = 2;
inline bool PlanningStatus::_internal_has_change_lane() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || change_lane_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_change_lane() const {
  return _internal_has_change_lane();
}
inline void PlanningStatus::clear_change_lane() {
  if (change_lane_ != nullptr) change_lane_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::planning::ChangeLaneStatus& PlanningStatus::_internal_change_lane() const {
  const ::apollo::planning::ChangeLaneStatus* p = change_lane_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::ChangeLaneStatus*>(
      &::apollo::planning::_ChangeLaneStatus_default_instance_);
}
inline const ::apollo::planning::ChangeLaneStatus& PlanningStatus::change_lane() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.change_lane)
  return _internal_change_lane();
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::release_change_lane() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.change_lane)
  _has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::ChangeLaneStatus* temp = change_lane_;
  change_lane_ = nullptr;
  return temp;
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::_internal_mutable_change_lane() {
  _has_bits_[0] |= 0x00000002u;
  if (change_lane_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::ChangeLaneStatus>(GetArenaNoVirtual());
    change_lane_ = p;
  }
  return change_lane_;
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::mutable_change_lane() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.change_lane)
  return _internal_mutable_change_lane();
}
inline void PlanningStatus::set_allocated_change_lane(::apollo::planning::ChangeLaneStatus* change_lane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete change_lane_;
  }
  if (change_lane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      change_lane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_lane, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  change_lane_ = change_lane;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.change_lane)
}

// optional .apollo.planning.CrosswalkStatus crosswalk = 3;
inline bool PlanningStatus::_internal_has_crosswalk() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || crosswalk_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_crosswalk() const {
  return _internal_has_crosswalk();
}
inline void PlanningStatus::clear_crosswalk() {
  if (crosswalk_ != nullptr) crosswalk_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::planning::CrosswalkStatus& PlanningStatus::_internal_crosswalk() const {
  const ::apollo::planning::CrosswalkStatus* p = crosswalk_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::CrosswalkStatus*>(
      &::apollo::planning::_CrosswalkStatus_default_instance_);
}
inline const ::apollo::planning::CrosswalkStatus& PlanningStatus::crosswalk() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.crosswalk)
  return _internal_crosswalk();
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::release_crosswalk() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.crosswalk)
  _has_bits_[0] &= ~0x00000004u;
  ::apollo::planning::CrosswalkStatus* temp = crosswalk_;
  crosswalk_ = nullptr;
  return temp;
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::_internal_mutable_crosswalk() {
  _has_bits_[0] |= 0x00000004u;
  if (crosswalk_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::CrosswalkStatus>(GetArenaNoVirtual());
    crosswalk_ = p;
  }
  return crosswalk_;
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::mutable_crosswalk() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.crosswalk)
  return _internal_mutable_crosswalk();
}
inline void PlanningStatus::set_allocated_crosswalk(::apollo::planning::CrosswalkStatus* crosswalk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete crosswalk_;
  }
  if (crosswalk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      crosswalk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crosswalk, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  crosswalk_ = crosswalk;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.crosswalk)
}

// optional .apollo.planning.DestinationStatus destination = 4;
inline bool PlanningStatus::_internal_has_destination() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || destination_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_destination() const {
  return _internal_has_destination();
}
inline void PlanningStatus::clear_destination() {
  if (destination_ != nullptr) destination_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::planning::DestinationStatus& PlanningStatus::_internal_destination() const {
  const ::apollo::planning::DestinationStatus* p = destination_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::DestinationStatus*>(
      &::apollo::planning::_DestinationStatus_default_instance_);
}
inline const ::apollo::planning::DestinationStatus& PlanningStatus::destination() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.destination)
  return _internal_destination();
}
inline ::apollo::planning::DestinationStatus* PlanningStatus::release_destination() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.destination)
  _has_bits_[0] &= ~0x00000008u;
  ::apollo::planning::DestinationStatus* temp = destination_;
  destination_ = nullptr;
  return temp;
}
inline ::apollo::planning::DestinationStatus* PlanningStatus::_internal_mutable_destination() {
  _has_bits_[0] |= 0x00000008u;
  if (destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::DestinationStatus>(GetArenaNoVirtual());
    destination_ = p;
  }
  return destination_;
}
inline ::apollo::planning::DestinationStatus* PlanningStatus::mutable_destination() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.destination)
  return _internal_mutable_destination();
}
inline void PlanningStatus::set_allocated_destination(::apollo::planning::DestinationStatus* destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete destination_;
  }
  if (destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.destination)
}

// optional .apollo.common.EngageAdvice engage_advice = 5;
inline bool PlanningStatus::_internal_has_engage_advice() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || engage_advice_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_engage_advice() const {
  return _internal_has_engage_advice();
}
inline const ::apollo::common::EngageAdvice& PlanningStatus::_internal_engage_advice() const {
  const ::apollo::common::EngageAdvice* p = engage_advice_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::common::EngageAdvice*>(
      &::apollo::common::_EngageAdvice_default_instance_);
}
inline const ::apollo::common::EngageAdvice& PlanningStatus::engage_advice() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.engage_advice)
  return _internal_engage_advice();
}
inline ::apollo::common::EngageAdvice* PlanningStatus::release_engage_advice() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.engage_advice)
  _has_bits_[0] &= ~0x00000010u;
  ::apollo::common::EngageAdvice* temp = engage_advice_;
  engage_advice_ = nullptr;
  return temp;
}
inline ::apollo::common::EngageAdvice* PlanningStatus::_internal_mutable_engage_advice() {
  _has_bits_[0] |= 0x00000010u;
  if (engage_advice_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::EngageAdvice>(GetArenaNoVirtual());
    engage_advice_ = p;
  }
  return engage_advice_;
}
inline ::apollo::common::EngageAdvice* PlanningStatus::mutable_engage_advice() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.engage_advice)
  return _internal_mutable_engage_advice();
}
inline void PlanningStatus::set_allocated_engage_advice(::apollo::common::EngageAdvice* engage_advice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(engage_advice_);
  }
  if (engage_advice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      engage_advice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, engage_advice, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  engage_advice_ = engage_advice;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.engage_advice)
}

// optional .apollo.planning.PedestrianStatus pedestrian = 6;
inline bool PlanningStatus::_internal_has_pedestrian() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || pedestrian_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_pedestrian() const {
  return _internal_has_pedestrian();
}
inline void PlanningStatus::clear_pedestrian() {
  if (pedestrian_ != nullptr) pedestrian_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::apollo::planning::PedestrianStatus& PlanningStatus::_internal_pedestrian() const {
  const ::apollo::planning::PedestrianStatus* p = pedestrian_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::PedestrianStatus*>(
      &::apollo::planning::_PedestrianStatus_default_instance_);
}
inline const ::apollo::planning::PedestrianStatus& PlanningStatus::pedestrian() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.pedestrian)
  return _internal_pedestrian();
}
inline ::apollo::planning::PedestrianStatus* PlanningStatus::release_pedestrian() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.pedestrian)
  _has_bits_[0] &= ~0x00000020u;
  ::apollo::planning::PedestrianStatus* temp = pedestrian_;
  pedestrian_ = nullptr;
  return temp;
}
inline ::apollo::planning::PedestrianStatus* PlanningStatus::_internal_mutable_pedestrian() {
  _has_bits_[0] |= 0x00000020u;
  if (pedestrian_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::PedestrianStatus>(GetArenaNoVirtual());
    pedestrian_ = p;
  }
  return pedestrian_;
}
inline ::apollo::planning::PedestrianStatus* PlanningStatus::mutable_pedestrian() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.pedestrian)
  return _internal_mutable_pedestrian();
}
inline void PlanningStatus::set_allocated_pedestrian(::apollo::planning::PedestrianStatus* pedestrian) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pedestrian_;
  }
  if (pedestrian) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pedestrian = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pedestrian, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  pedestrian_ = pedestrian;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.pedestrian)
}

// optional .apollo.planning.PullOverStatus pull_over = 7;
inline bool PlanningStatus::_internal_has_pull_over() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || pull_over_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_pull_over() const {
  return _internal_has_pull_over();
}
inline void PlanningStatus::clear_pull_over() {
  if (pull_over_ != nullptr) pull_over_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::apollo::planning::PullOverStatus& PlanningStatus::_internal_pull_over() const {
  const ::apollo::planning::PullOverStatus* p = pull_over_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::PullOverStatus*>(
      &::apollo::planning::_PullOverStatus_default_instance_);
}
inline const ::apollo::planning::PullOverStatus& PlanningStatus::pull_over() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.pull_over)
  return _internal_pull_over();
}
inline ::apollo::planning::PullOverStatus* PlanningStatus::release_pull_over() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.pull_over)
  _has_bits_[0] &= ~0x00000040u;
  ::apollo::planning::PullOverStatus* temp = pull_over_;
  pull_over_ = nullptr;
  return temp;
}
inline ::apollo::planning::PullOverStatus* PlanningStatus::_internal_mutable_pull_over() {
  _has_bits_[0] |= 0x00000040u;
  if (pull_over_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::PullOverStatus>(GetArenaNoVirtual());
    pull_over_ = p;
  }
  return pull_over_;
}
inline ::apollo::planning::PullOverStatus* PlanningStatus::mutable_pull_over() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.pull_over)
  return _internal_mutable_pull_over();
}
inline void PlanningStatus::set_allocated_pull_over(::apollo::planning::PullOverStatus* pull_over) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pull_over_;
  }
  if (pull_over) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pull_over = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pull_over, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  pull_over_ = pull_over;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.pull_over)
}

// optional .apollo.planning.ReroutingStatus rerouting = 8;
inline bool PlanningStatus::_internal_has_rerouting() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || rerouting_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_rerouting() const {
  return _internal_has_rerouting();
}
inline void PlanningStatus::clear_rerouting() {
  if (rerouting_ != nullptr) rerouting_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::apollo::planning::ReroutingStatus& PlanningStatus::_internal_rerouting() const {
  const ::apollo::planning::ReroutingStatus* p = rerouting_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::ReroutingStatus*>(
      &::apollo::planning::_ReroutingStatus_default_instance_);
}
inline const ::apollo::planning::ReroutingStatus& PlanningStatus::rerouting() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.rerouting)
  return _internal_rerouting();
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::release_rerouting() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.rerouting)
  _has_bits_[0] &= ~0x00000080u;
  ::apollo::planning::ReroutingStatus* temp = rerouting_;
  rerouting_ = nullptr;
  return temp;
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::_internal_mutable_rerouting() {
  _has_bits_[0] |= 0x00000080u;
  if (rerouting_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::ReroutingStatus>(GetArenaNoVirtual());
    rerouting_ = p;
  }
  return rerouting_;
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::mutable_rerouting() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.rerouting)
  return _internal_mutable_rerouting();
}
inline void PlanningStatus::set_allocated_rerouting(::apollo::planning::ReroutingStatus* rerouting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rerouting_;
  }
  if (rerouting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rerouting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rerouting, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  rerouting_ = rerouting;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.rerouting)
}

// optional .apollo.planning.RightOfWayStatus right_of_way = 9;
inline bool PlanningStatus::_internal_has_right_of_way() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || right_of_way_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_right_of_way() const {
  return _internal_has_right_of_way();
}
inline void PlanningStatus::clear_right_of_way() {
  if (right_of_way_ != nullptr) right_of_way_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::apollo::planning::RightOfWayStatus& PlanningStatus::_internal_right_of_way() const {
  const ::apollo::planning::RightOfWayStatus* p = right_of_way_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::RightOfWayStatus*>(
      &::apollo::planning::_RightOfWayStatus_default_instance_);
}
inline const ::apollo::planning::RightOfWayStatus& PlanningStatus::right_of_way() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.right_of_way)
  return _internal_right_of_way();
}
inline ::apollo::planning::RightOfWayStatus* PlanningStatus::release_right_of_way() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.right_of_way)
  _has_bits_[0] &= ~0x00000100u;
  ::apollo::planning::RightOfWayStatus* temp = right_of_way_;
  right_of_way_ = nullptr;
  return temp;
}
inline ::apollo::planning::RightOfWayStatus* PlanningStatus::_internal_mutable_right_of_way() {
  _has_bits_[0] |= 0x00000100u;
  if (right_of_way_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::RightOfWayStatus>(GetArenaNoVirtual());
    right_of_way_ = p;
  }
  return right_of_way_;
}
inline ::apollo::planning::RightOfWayStatus* PlanningStatus::mutable_right_of_way() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.right_of_way)
  return _internal_mutable_right_of_way();
}
inline void PlanningStatus::set_allocated_right_of_way(::apollo::planning::RightOfWayStatus* right_of_way) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete right_of_way_;
  }
  if (right_of_way) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      right_of_way = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_of_way, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  right_of_way_ = right_of_way;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.right_of_way)
}

// optional .apollo.planning.ScenarioStatus scenario = 10;
inline bool PlanningStatus::_internal_has_scenario() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || scenario_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_scenario() const {
  return _internal_has_scenario();
}
inline void PlanningStatus::clear_scenario() {
  if (scenario_ != nullptr) scenario_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::apollo::planning::ScenarioStatus& PlanningStatus::_internal_scenario() const {
  const ::apollo::planning::ScenarioStatus* p = scenario_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::ScenarioStatus*>(
      &::apollo::planning::_ScenarioStatus_default_instance_);
}
inline const ::apollo::planning::ScenarioStatus& PlanningStatus::scenario() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.scenario)
  return _internal_scenario();
}
inline ::apollo::planning::ScenarioStatus* PlanningStatus::release_scenario() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.scenario)
  _has_bits_[0] &= ~0x00000200u;
  ::apollo::planning::ScenarioStatus* temp = scenario_;
  scenario_ = nullptr;
  return temp;
}
inline ::apollo::planning::ScenarioStatus* PlanningStatus::_internal_mutable_scenario() {
  _has_bits_[0] |= 0x00000200u;
  if (scenario_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::ScenarioStatus>(GetArenaNoVirtual());
    scenario_ = p;
  }
  return scenario_;
}
inline ::apollo::planning::ScenarioStatus* PlanningStatus::mutable_scenario() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.scenario)
  return _internal_mutable_scenario();
}
inline void PlanningStatus::set_allocated_scenario(::apollo::planning::ScenarioStatus* scenario) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete scenario_;
  }
  if (scenario) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      scenario = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scenario, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  scenario_ = scenario;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.scenario)
}

// optional .apollo.planning.SidePassStatus side_pass = 11;
inline bool PlanningStatus::_internal_has_side_pass() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || side_pass_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_side_pass() const {
  return _internal_has_side_pass();
}
inline void PlanningStatus::clear_side_pass() {
  if (side_pass_ != nullptr) side_pass_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::apollo::planning::SidePassStatus& PlanningStatus::_internal_side_pass() const {
  const ::apollo::planning::SidePassStatus* p = side_pass_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::SidePassStatus*>(
      &::apollo::planning::_SidePassStatus_default_instance_);
}
inline const ::apollo::planning::SidePassStatus& PlanningStatus::side_pass() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.side_pass)
  return _internal_side_pass();
}
inline ::apollo::planning::SidePassStatus* PlanningStatus::release_side_pass() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.side_pass)
  _has_bits_[0] &= ~0x00000400u;
  ::apollo::planning::SidePassStatus* temp = side_pass_;
  side_pass_ = nullptr;
  return temp;
}
inline ::apollo::planning::SidePassStatus* PlanningStatus::_internal_mutable_side_pass() {
  _has_bits_[0] |= 0x00000400u;
  if (side_pass_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::SidePassStatus>(GetArenaNoVirtual());
    side_pass_ = p;
  }
  return side_pass_;
}
inline ::apollo::planning::SidePassStatus* PlanningStatus::mutable_side_pass() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.side_pass)
  return _internal_mutable_side_pass();
}
inline void PlanningStatus::set_allocated_side_pass(::apollo::planning::SidePassStatus* side_pass) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete side_pass_;
  }
  if (side_pass) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      side_pass = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, side_pass, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  side_pass_ = side_pass;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.side_pass)
}

// optional .apollo.planning.StopSignStatus stop_sign = 12;
inline bool PlanningStatus::_internal_has_stop_sign() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || stop_sign_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_stop_sign() const {
  return _internal_has_stop_sign();
}
inline void PlanningStatus::clear_stop_sign() {
  if (stop_sign_ != nullptr) stop_sign_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::apollo::planning::StopSignStatus& PlanningStatus::_internal_stop_sign() const {
  const ::apollo::planning::StopSignStatus* p = stop_sign_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::StopSignStatus*>(
      &::apollo::planning::_StopSignStatus_default_instance_);
}
inline const ::apollo::planning::StopSignStatus& PlanningStatus::stop_sign() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.stop_sign)
  return _internal_stop_sign();
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::release_stop_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.stop_sign)
  _has_bits_[0] &= ~0x00000800u;
  ::apollo::planning::StopSignStatus* temp = stop_sign_;
  stop_sign_ = nullptr;
  return temp;
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::_internal_mutable_stop_sign() {
  _has_bits_[0] |= 0x00000800u;
  if (stop_sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::StopSignStatus>(GetArenaNoVirtual());
    stop_sign_ = p;
  }
  return stop_sign_;
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::mutable_stop_sign() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.stop_sign)
  return _internal_mutable_stop_sign();
}
inline void PlanningStatus::set_allocated_stop_sign(::apollo::planning::StopSignStatus* stop_sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stop_sign_;
  }
  if (stop_sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stop_sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_sign, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  stop_sign_ = stop_sign;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.stop_sign)
}

// optional .apollo.planning.TrafficLightStatus traffic_light = 13;
inline bool PlanningStatus::_internal_has_traffic_light() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || traffic_light_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_traffic_light() const {
  return _internal_has_traffic_light();
}
inline void PlanningStatus::clear_traffic_light() {
  if (traffic_light_ != nullptr) traffic_light_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::apollo::planning::TrafficLightStatus& PlanningStatus::_internal_traffic_light() const {
  const ::apollo::planning::TrafficLightStatus* p = traffic_light_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::TrafficLightStatus*>(
      &::apollo::planning::_TrafficLightStatus_default_instance_);
}
inline const ::apollo::planning::TrafficLightStatus& PlanningStatus::traffic_light() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.traffic_light)
  return _internal_traffic_light();
}
inline ::apollo::planning::TrafficLightStatus* PlanningStatus::release_traffic_light() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.traffic_light)
  _has_bits_[0] &= ~0x00001000u;
  ::apollo::planning::TrafficLightStatus* temp = traffic_light_;
  traffic_light_ = nullptr;
  return temp;
}
inline ::apollo::planning::TrafficLightStatus* PlanningStatus::_internal_mutable_traffic_light() {
  _has_bits_[0] |= 0x00001000u;
  if (traffic_light_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::TrafficLightStatus>(GetArenaNoVirtual());
    traffic_light_ = p;
  }
  return traffic_light_;
}
inline ::apollo::planning::TrafficLightStatus* PlanningStatus::mutable_traffic_light() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.traffic_light)
  return _internal_mutable_traffic_light();
}
inline void PlanningStatus::set_allocated_traffic_light(::apollo::planning::TrafficLightStatus* traffic_light) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete traffic_light_;
  }
  if (traffic_light) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      traffic_light = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, traffic_light, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  traffic_light_ = traffic_light;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.traffic_light)
}

// optional .apollo.planning.SidePassStopStatus side_pass_stop = 14;
inline bool PlanningStatus::_internal_has_side_pass_stop() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || side_pass_stop_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_side_pass_stop() const {
  return _internal_has_side_pass_stop();
}
inline void PlanningStatus::clear_side_pass_stop() {
  if (side_pass_stop_ != nullptr) side_pass_stop_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::apollo::planning::SidePassStopStatus& PlanningStatus::_internal_side_pass_stop() const {
  const ::apollo::planning::SidePassStopStatus* p = side_pass_stop_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::SidePassStopStatus*>(
      &::apollo::planning::_SidePassStopStatus_default_instance_);
}
inline const ::apollo::planning::SidePassStopStatus& PlanningStatus::side_pass_stop() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.side_pass_stop)
  return _internal_side_pass_stop();
}
inline ::apollo::planning::SidePassStopStatus* PlanningStatus::release_side_pass_stop() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.side_pass_stop)
  _has_bits_[0] &= ~0x00002000u;
  ::apollo::planning::SidePassStopStatus* temp = side_pass_stop_;
  side_pass_stop_ = nullptr;
  return temp;
}
inline ::apollo::planning::SidePassStopStatus* PlanningStatus::_internal_mutable_side_pass_stop() {
  _has_bits_[0] |= 0x00002000u;
  if (side_pass_stop_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::SidePassStopStatus>(GetArenaNoVirtual());
    side_pass_stop_ = p;
  }
  return side_pass_stop_;
}
inline ::apollo::planning::SidePassStopStatus* PlanningStatus::mutable_side_pass_stop() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.side_pass_stop)
  return _internal_mutable_side_pass_stop();
}
inline void PlanningStatus::set_allocated_side_pass_stop(::apollo::planning::SidePassStopStatus* side_pass_stop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete side_pass_stop_;
  }
  if (side_pass_stop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      side_pass_stop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, side_pass_stop, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  side_pass_stop_ = side_pass_stop;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.side_pass_stop)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::planning::ChangeLaneStatus_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::ChangeLaneStatus_Status>() {
  return ::apollo::planning::ChangeLaneStatus_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto
