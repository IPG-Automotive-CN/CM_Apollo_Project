// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/traffic_rule_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
namespace apollo {
namespace planning {
class BacksideVehicleConfig;
class BacksideVehicleConfigDefaultTypeInternal;
extern BacksideVehicleConfigDefaultTypeInternal _BacksideVehicleConfig_default_instance_;
class ChangeLaneConfig;
class ChangeLaneConfigDefaultTypeInternal;
extern ChangeLaneConfigDefaultTypeInternal _ChangeLaneConfig_default_instance_;
class CreepConfig;
class CreepConfigDefaultTypeInternal;
extern CreepConfigDefaultTypeInternal _CreepConfig_default_instance_;
class CrosswalkConfig;
class CrosswalkConfigDefaultTypeInternal;
extern CrosswalkConfigDefaultTypeInternal _CrosswalkConfig_default_instance_;
class DestinationConfig;
class DestinationConfigDefaultTypeInternal;
extern DestinationConfigDefaultTypeInternal _DestinationConfig_default_instance_;
class KeepClearConfig;
class KeepClearConfigDefaultTypeInternal;
extern KeepClearConfigDefaultTypeInternal _KeepClearConfig_default_instance_;
class ReferenceLineEndConfig;
class ReferenceLineEndConfigDefaultTypeInternal;
extern ReferenceLineEndConfigDefaultTypeInternal _ReferenceLineEndConfig_default_instance_;
class ReroutingConfig;
class ReroutingConfigDefaultTypeInternal;
extern ReroutingConfigDefaultTypeInternal _ReroutingConfig_default_instance_;
class StopSignConfig;
class StopSignConfigDefaultTypeInternal;
extern StopSignConfigDefaultTypeInternal _StopSignConfig_default_instance_;
class TrafficLightConfig;
class TrafficLightConfigDefaultTypeInternal;
extern TrafficLightConfigDefaultTypeInternal _TrafficLightConfig_default_instance_;
class TrafficRuleConfig;
class TrafficRuleConfigDefaultTypeInternal;
extern TrafficRuleConfigDefaultTypeInternal _TrafficRuleConfig_default_instance_;
class TrafficRuleConfigs;
class TrafficRuleConfigsDefaultTypeInternal;
extern TrafficRuleConfigsDefaultTypeInternal _TrafficRuleConfigs_default_instance_;
}  // namespace planning
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::planning::BacksideVehicleConfig* Arena::CreateMaybeMessage<::apollo::planning::BacksideVehicleConfig>(Arena*);
template<> ::apollo::planning::ChangeLaneConfig* Arena::CreateMaybeMessage<::apollo::planning::ChangeLaneConfig>(Arena*);
template<> ::apollo::planning::CreepConfig* Arena::CreateMaybeMessage<::apollo::planning::CreepConfig>(Arena*);
template<> ::apollo::planning::CrosswalkConfig* Arena::CreateMaybeMessage<::apollo::planning::CrosswalkConfig>(Arena*);
template<> ::apollo::planning::DestinationConfig* Arena::CreateMaybeMessage<::apollo::planning::DestinationConfig>(Arena*);
template<> ::apollo::planning::KeepClearConfig* Arena::CreateMaybeMessage<::apollo::planning::KeepClearConfig>(Arena*);
template<> ::apollo::planning::ReferenceLineEndConfig* Arena::CreateMaybeMessage<::apollo::planning::ReferenceLineEndConfig>(Arena*);
template<> ::apollo::planning::ReroutingConfig* Arena::CreateMaybeMessage<::apollo::planning::ReroutingConfig>(Arena*);
template<> ::apollo::planning::StopSignConfig* Arena::CreateMaybeMessage<::apollo::planning::StopSignConfig>(Arena*);
template<> ::apollo::planning::TrafficLightConfig* Arena::CreateMaybeMessage<::apollo::planning::TrafficLightConfig>(Arena*);
template<> ::apollo::planning::TrafficRuleConfig* Arena::CreateMaybeMessage<::apollo::planning::TrafficRuleConfig>(Arena*);
template<> ::apollo::planning::TrafficRuleConfigs* Arena::CreateMaybeMessage<::apollo::planning::TrafficRuleConfigs>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace planning {

enum TrafficRuleConfig_RuleId : int {
  TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE = 1,
  TrafficRuleConfig_RuleId_CHANGE_LANE = 2,
  TrafficRuleConfig_RuleId_CROSSWALK = 3,
  TrafficRuleConfig_RuleId_DESTINATION = 4,
  TrafficRuleConfig_RuleId_KEEP_CLEAR = 5,
  TrafficRuleConfig_RuleId_REFERENCE_LINE_END = 6,
  TrafficRuleConfig_RuleId_REROUTING = 7,
  TrafficRuleConfig_RuleId_STOP_SIGN = 8,
  TrafficRuleConfig_RuleId_TRAFFIC_LIGHT = 9
};
bool TrafficRuleConfig_RuleId_IsValid(int value);
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig_RuleId_RuleId_MIN = TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig_RuleId_RuleId_MAX = TrafficRuleConfig_RuleId_TRAFFIC_LIGHT;
constexpr int TrafficRuleConfig_RuleId_RuleId_ARRAYSIZE = TrafficRuleConfig_RuleId_RuleId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficRuleConfig_RuleId_descriptor();
template<typename T>
inline const std::string& TrafficRuleConfig_RuleId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficRuleConfig_RuleId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficRuleConfig_RuleId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficRuleConfig_RuleId_descriptor(), enum_t_value);
}
inline bool TrafficRuleConfig_RuleId_Parse(
    const std::string& name, TrafficRuleConfig_RuleId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficRuleConfig_RuleId>(
    TrafficRuleConfig_RuleId_descriptor(), name, value);
}
// ===================================================================

class BacksideVehicleConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.BacksideVehicleConfig) */ {
 public:
  BacksideVehicleConfig();
  virtual ~BacksideVehicleConfig();

  BacksideVehicleConfig(const BacksideVehicleConfig& from);
  BacksideVehicleConfig(BacksideVehicleConfig&& from) noexcept
    : BacksideVehicleConfig() {
    *this = ::std::move(from);
  }

  inline BacksideVehicleConfig& operator=(const BacksideVehicleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BacksideVehicleConfig& operator=(BacksideVehicleConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BacksideVehicleConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BacksideVehicleConfig* internal_default_instance() {
    return reinterpret_cast<const BacksideVehicleConfig*>(
               &_BacksideVehicleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BacksideVehicleConfig& a, BacksideVehicleConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BacksideVehicleConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BacksideVehicleConfig* New() const final {
    return CreateMaybeMessage<BacksideVehicleConfig>(nullptr);
  }

  BacksideVehicleConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BacksideVehicleConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BacksideVehicleConfig& from);
  void MergeFrom(const BacksideVehicleConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BacksideVehicleConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.BacksideVehicleConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBacksideLaneWidthFieldNumber = 1,
  };
  // optional double backside_lane_width = 1 [default = 4];
  bool has_backside_lane_width() const;
  private:
  bool _internal_has_backside_lane_width() const;
  public:
  void clear_backside_lane_width();
  double backside_lane_width() const;
  void set_backside_lane_width(double value);
  private:
  double _internal_backside_lane_width() const;
  void _internal_set_backside_lane_width(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.BacksideVehicleConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double backside_lane_width_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ChangeLaneConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ChangeLaneConfig) */ {
 public:
  ChangeLaneConfig();
  virtual ~ChangeLaneConfig();

  ChangeLaneConfig(const ChangeLaneConfig& from);
  ChangeLaneConfig(ChangeLaneConfig&& from) noexcept
    : ChangeLaneConfig() {
    *this = ::std::move(from);
  }

  inline ChangeLaneConfig& operator=(const ChangeLaneConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeLaneConfig& operator=(ChangeLaneConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChangeLaneConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeLaneConfig* internal_default_instance() {
    return reinterpret_cast<const ChangeLaneConfig*>(
               &_ChangeLaneConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChangeLaneConfig& a, ChangeLaneConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeLaneConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeLaneConfig* New() const final {
    return CreateMaybeMessage<ChangeLaneConfig>(nullptr);
  }

  ChangeLaneConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeLaneConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChangeLaneConfig& from);
  void MergeFrom(const ChangeLaneConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeLaneConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ChangeLaneConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableGuardObstacleFieldNumber = 3,
    kMinOvertakeDistanceFieldNumber = 1,
    kMinOvertakeTimeFieldNumber = 2,
    kGuardDistanceFieldNumber = 4,
    kMinGuardSpeedFieldNumber = 5,
  };
  // optional bool enable_guard_obstacle = 3 [default = false];
  bool has_enable_guard_obstacle() const;
  private:
  bool _internal_has_enable_guard_obstacle() const;
  public:
  void clear_enable_guard_obstacle();
  bool enable_guard_obstacle() const;
  void set_enable_guard_obstacle(bool value);
  private:
  bool _internal_enable_guard_obstacle() const;
  void _internal_set_enable_guard_obstacle(bool value);
  public:

  // optional double min_overtake_distance = 1 [default = 10];
  bool has_min_overtake_distance() const;
  private:
  bool _internal_has_min_overtake_distance() const;
  public:
  void clear_min_overtake_distance();
  double min_overtake_distance() const;
  void set_min_overtake_distance(double value);
  private:
  double _internal_min_overtake_distance() const;
  void _internal_set_min_overtake_distance(double value);
  public:

  // optional double min_overtake_time = 2 [default = 2];
  bool has_min_overtake_time() const;
  private:
  bool _internal_has_min_overtake_time() const;
  public:
  void clear_min_overtake_time();
  double min_overtake_time() const;
  void set_min_overtake_time(double value);
  private:
  double _internal_min_overtake_time() const;
  void _internal_set_min_overtake_time(double value);
  public:

  // optional double guard_distance = 4 [default = 100];
  bool has_guard_distance() const;
  private:
  bool _internal_has_guard_distance() const;
  public:
  void clear_guard_distance();
  double guard_distance() const;
  void set_guard_distance(double value);
  private:
  double _internal_guard_distance() const;
  void _internal_set_guard_distance(double value);
  public:

  // optional double min_guard_speed = 5 [default = 1];
  bool has_min_guard_speed() const;
  private:
  bool _internal_has_min_guard_speed() const;
  public:
  void clear_min_guard_speed();
  double min_guard_speed() const;
  void set_min_guard_speed(double value);
  private:
  double _internal_min_guard_speed() const;
  void _internal_set_min_guard_speed(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ChangeLaneConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enable_guard_obstacle_;
  double min_overtake_distance_;
  double min_overtake_time_;
  double guard_distance_;
  double min_guard_speed_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CreepConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CreepConfig) */ {
 public:
  CreepConfig();
  virtual ~CreepConfig();

  CreepConfig(const CreepConfig& from);
  CreepConfig(CreepConfig&& from) noexcept
    : CreepConfig() {
    *this = ::std::move(from);
  }

  inline CreepConfig& operator=(const CreepConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreepConfig& operator=(CreepConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreepConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreepConfig* internal_default_instance() {
    return reinterpret_cast<const CreepConfig*>(
               &_CreepConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreepConfig& a, CreepConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CreepConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreepConfig* New() const final {
    return CreateMaybeMessage<CreepConfig>(nullptr);
  }

  CreepConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreepConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreepConfig& from);
  void MergeFrom(const CreepConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreepConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.CreepConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kCreepDistanceToStopLineFieldNumber = 2,
    kStopDistanceFieldNumber = 3,
    kSpeedLimitFieldNumber = 4,
    kMaxValidStopDistanceFieldNumber = 5,
    kMinBoundaryTFieldNumber = 6,
    kMinBoundarySFieldNumber = 7,
  };
  // optional bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional double creep_distance_to_stop_line = 2 [default = 1];
  bool has_creep_distance_to_stop_line() const;
  private:
  bool _internal_has_creep_distance_to_stop_line() const;
  public:
  void clear_creep_distance_to_stop_line();
  double creep_distance_to_stop_line() const;
  void set_creep_distance_to_stop_line(double value);
  private:
  double _internal_creep_distance_to_stop_line() const;
  void _internal_set_creep_distance_to_stop_line(double value);
  public:

  // optional double stop_distance = 3 [default = 0.5];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double speed_limit = 4 [default = 1];
  bool has_speed_limit() const;
  private:
  bool _internal_has_speed_limit() const;
  public:
  void clear_speed_limit();
  double speed_limit() const;
  void set_speed_limit(double value);
  private:
  double _internal_speed_limit() const;
  void _internal_set_speed_limit(double value);
  public:

  // optional double max_valid_stop_distance = 5 [default = 0.3];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double min_boundary_t = 6 [default = 6];
  bool has_min_boundary_t() const;
  private:
  bool _internal_has_min_boundary_t() const;
  public:
  void clear_min_boundary_t();
  double min_boundary_t() const;
  void set_min_boundary_t(double value);
  private:
  double _internal_min_boundary_t() const;
  void _internal_set_min_boundary_t(double value);
  public:

  // optional double min_boundary_s = 7 [default = 3];
  bool has_min_boundary_s() const;
  private:
  bool _internal_has_min_boundary_s() const;
  public:
  void clear_min_boundary_s();
  double min_boundary_s() const;
  void set_min_boundary_s(double value);
  private:
  double _internal_min_boundary_s() const;
  void _internal_set_min_boundary_s(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.CreepConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enabled_;
  double creep_distance_to_stop_line_;
  double stop_distance_;
  double speed_limit_;
  double max_valid_stop_distance_;
  double min_boundary_t_;
  double min_boundary_s_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CrosswalkConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CrosswalkConfig) */ {
 public:
  CrosswalkConfig();
  virtual ~CrosswalkConfig();

  CrosswalkConfig(const CrosswalkConfig& from);
  CrosswalkConfig(CrosswalkConfig&& from) noexcept
    : CrosswalkConfig() {
    *this = ::std::move(from);
  }

  inline CrosswalkConfig& operator=(const CrosswalkConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrosswalkConfig& operator=(CrosswalkConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CrosswalkConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrosswalkConfig* internal_default_instance() {
    return reinterpret_cast<const CrosswalkConfig*>(
               &_CrosswalkConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CrosswalkConfig& a, CrosswalkConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CrosswalkConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CrosswalkConfig* New() const final {
    return CreateMaybeMessage<CrosswalkConfig>(nullptr);
  }

  CrosswalkConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CrosswalkConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CrosswalkConfig& from);
  void MergeFrom(const CrosswalkConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrosswalkConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.CrosswalkConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopDistanceFieldNumber = 1,
    kMaxStopDecelerationFieldNumber = 2,
    kMinPassSDistanceFieldNumber = 3,
    kMaxStopSpeedFieldNumber = 4,
    kMaxValidStopDistanceFieldNumber = 5,
    kExpandSDistanceFieldNumber = 6,
    kStopStrictLDistanceFieldNumber = 7,
    kStopLooseLDistanceFieldNumber = 8,
    kStopTimeoutFieldNumber = 9,
  };
  // optional double stop_distance = 1 [default = 1];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double max_stop_deceleration = 2 [default = 4];
  bool has_max_stop_deceleration() const;
  private:
  bool _internal_has_max_stop_deceleration() const;
  public:
  void clear_max_stop_deceleration();
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);
  private:
  double _internal_max_stop_deceleration() const;
  void _internal_set_max_stop_deceleration(double value);
  public:

  // optional double min_pass_s_distance = 3 [default = 1];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // optional double max_stop_speed = 4 [default = 0.3];
  bool has_max_stop_speed() const;
  private:
  bool _internal_has_max_stop_speed() const;
  public:
  void clear_max_stop_speed();
  double max_stop_speed() const;
  void set_max_stop_speed(double value);
  private:
  double _internal_max_stop_speed() const;
  void _internal_set_max_stop_speed(double value);
  public:

  // optional double max_valid_stop_distance = 5 [default = 3];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double expand_s_distance = 6 [default = 2];
  bool has_expand_s_distance() const;
  private:
  bool _internal_has_expand_s_distance() const;
  public:
  void clear_expand_s_distance();
  double expand_s_distance() const;
  void set_expand_s_distance(double value);
  private:
  double _internal_expand_s_distance() const;
  void _internal_set_expand_s_distance(double value);
  public:

  // optional double stop_strict_l_distance = 7 [default = 4];
  bool has_stop_strict_l_distance() const;
  private:
  bool _internal_has_stop_strict_l_distance() const;
  public:
  void clear_stop_strict_l_distance();
  double stop_strict_l_distance() const;
  void set_stop_strict_l_distance(double value);
  private:
  double _internal_stop_strict_l_distance() const;
  void _internal_set_stop_strict_l_distance(double value);
  public:

  // optional double stop_loose_l_distance = 8 [default = 5];
  bool has_stop_loose_l_distance() const;
  private:
  bool _internal_has_stop_loose_l_distance() const;
  public:
  void clear_stop_loose_l_distance();
  double stop_loose_l_distance() const;
  void set_stop_loose_l_distance(double value);
  private:
  double _internal_stop_loose_l_distance() const;
  void _internal_set_stop_loose_l_distance(double value);
  public:

  // optional double stop_timeout = 9 [default = 10];
  bool has_stop_timeout() const;
  private:
  bool _internal_has_stop_timeout() const;
  public:
  void clear_stop_timeout();
  double stop_timeout() const;
  void set_stop_timeout(double value);
  private:
  double _internal_stop_timeout() const;
  void _internal_set_stop_timeout(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.CrosswalkConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double stop_distance_;
  double max_stop_deceleration_;
  double min_pass_s_distance_;
  double max_stop_speed_;
  double max_valid_stop_distance_;
  double expand_s_distance_;
  double stop_strict_l_distance_;
  double stop_loose_l_distance_;
  double stop_timeout_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class DestinationConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.DestinationConfig) */ {
 public:
  DestinationConfig();
  virtual ~DestinationConfig();

  DestinationConfig(const DestinationConfig& from);
  DestinationConfig(DestinationConfig&& from) noexcept
    : DestinationConfig() {
    *this = ::std::move(from);
  }

  inline DestinationConfig& operator=(const DestinationConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestinationConfig& operator=(DestinationConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DestinationConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DestinationConfig* internal_default_instance() {
    return reinterpret_cast<const DestinationConfig*>(
               &_DestinationConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DestinationConfig& a, DestinationConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DestinationConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DestinationConfig* New() const final {
    return CreateMaybeMessage<DestinationConfig>(nullptr);
  }

  DestinationConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DestinationConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DestinationConfig& from);
  void MergeFrom(const DestinationConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestinationConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.DestinationConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopDistanceFieldNumber = 1,
  };
  // optional double stop_distance = 1 [default = 0.5];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.DestinationConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double stop_distance_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class KeepClearConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.KeepClearConfig) */ {
 public:
  KeepClearConfig();
  virtual ~KeepClearConfig();

  KeepClearConfig(const KeepClearConfig& from);
  KeepClearConfig(KeepClearConfig&& from) noexcept
    : KeepClearConfig() {
    *this = ::std::move(from);
  }

  inline KeepClearConfig& operator=(const KeepClearConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeepClearConfig& operator=(KeepClearConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeepClearConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeepClearConfig* internal_default_instance() {
    return reinterpret_cast<const KeepClearConfig*>(
               &_KeepClearConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(KeepClearConfig& a, KeepClearConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(KeepClearConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeepClearConfig* New() const final {
    return CreateMaybeMessage<KeepClearConfig>(nullptr);
  }

  KeepClearConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeepClearConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeepClearConfig& from);
  void MergeFrom(const KeepClearConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeepClearConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.KeepClearConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableKeepClearZoneFieldNumber = 1,
    kEnableJunctionFieldNumber = 2,
    kMinPassSDistanceFieldNumber = 3,
    kAlignWithTrafficSignToleranceFieldNumber = 4,
  };
  // optional bool enable_keep_clear_zone = 1 [default = true];
  bool has_enable_keep_clear_zone() const;
  private:
  bool _internal_has_enable_keep_clear_zone() const;
  public:
  void clear_enable_keep_clear_zone();
  bool enable_keep_clear_zone() const;
  void set_enable_keep_clear_zone(bool value);
  private:
  bool _internal_enable_keep_clear_zone() const;
  void _internal_set_enable_keep_clear_zone(bool value);
  public:

  // optional bool enable_junction = 2 [default = true];
  bool has_enable_junction() const;
  private:
  bool _internal_has_enable_junction() const;
  public:
  void clear_enable_junction();
  bool enable_junction() const;
  void set_enable_junction(bool value);
  private:
  bool _internal_enable_junction() const;
  void _internal_set_enable_junction(bool value);
  public:

  // optional double min_pass_s_distance = 3 [default = 2];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // optional double align_with_traffic_sign_tolerance = 4 [default = 4.5];
  bool has_align_with_traffic_sign_tolerance() const;
  private:
  bool _internal_has_align_with_traffic_sign_tolerance() const;
  public:
  void clear_align_with_traffic_sign_tolerance();
  double align_with_traffic_sign_tolerance() const;
  void set_align_with_traffic_sign_tolerance(double value);
  private:
  double _internal_align_with_traffic_sign_tolerance() const;
  void _internal_set_align_with_traffic_sign_tolerance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.KeepClearConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enable_keep_clear_zone_;
  bool enable_junction_;
  double min_pass_s_distance_;
  double align_with_traffic_sign_tolerance_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ReferenceLineEndConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ReferenceLineEndConfig) */ {
 public:
  ReferenceLineEndConfig();
  virtual ~ReferenceLineEndConfig();

  ReferenceLineEndConfig(const ReferenceLineEndConfig& from);
  ReferenceLineEndConfig(ReferenceLineEndConfig&& from) noexcept
    : ReferenceLineEndConfig() {
    *this = ::std::move(from);
  }

  inline ReferenceLineEndConfig& operator=(const ReferenceLineEndConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceLineEndConfig& operator=(ReferenceLineEndConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReferenceLineEndConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReferenceLineEndConfig* internal_default_instance() {
    return reinterpret_cast<const ReferenceLineEndConfig*>(
               &_ReferenceLineEndConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReferenceLineEndConfig& a, ReferenceLineEndConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceLineEndConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReferenceLineEndConfig* New() const final {
    return CreateMaybeMessage<ReferenceLineEndConfig>(nullptr);
  }

  ReferenceLineEndConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceLineEndConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReferenceLineEndConfig& from);
  void MergeFrom(const ReferenceLineEndConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceLineEndConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ReferenceLineEndConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopDistanceFieldNumber = 1,
    kMinReferenceLineRemainLengthFieldNumber = 2,
  };
  // optional double stop_distance = 1 [default = 0.5];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double min_reference_line_remain_length = 2 [default = 50];
  bool has_min_reference_line_remain_length() const;
  private:
  bool _internal_has_min_reference_line_remain_length() const;
  public:
  void clear_min_reference_line_remain_length();
  double min_reference_line_remain_length() const;
  void set_min_reference_line_remain_length(double value);
  private:
  double _internal_min_reference_line_remain_length() const;
  void _internal_set_min_reference_line_remain_length(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ReferenceLineEndConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double stop_distance_;
  double min_reference_line_remain_length_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ReroutingConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ReroutingConfig) */ {
 public:
  ReroutingConfig();
  virtual ~ReroutingConfig();

  ReroutingConfig(const ReroutingConfig& from);
  ReroutingConfig(ReroutingConfig&& from) noexcept
    : ReroutingConfig() {
    *this = ::std::move(from);
  }

  inline ReroutingConfig& operator=(const ReroutingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReroutingConfig& operator=(ReroutingConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReroutingConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReroutingConfig* internal_default_instance() {
    return reinterpret_cast<const ReroutingConfig*>(
               &_ReroutingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReroutingConfig& a, ReroutingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ReroutingConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReroutingConfig* New() const final {
    return CreateMaybeMessage<ReroutingConfig>(nullptr);
  }

  ReroutingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReroutingConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReroutingConfig& from);
  void MergeFrom(const ReroutingConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReroutingConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ReroutingConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCooldownTimeFieldNumber = 1,
    kPrepareReroutingTimeFieldNumber = 2,
  };
  // optional double cooldown_time = 1 [default = 3];
  bool has_cooldown_time() const;
  private:
  bool _internal_has_cooldown_time() const;
  public:
  void clear_cooldown_time();
  double cooldown_time() const;
  void set_cooldown_time(double value);
  private:
  double _internal_cooldown_time() const;
  void _internal_set_cooldown_time(double value);
  public:

  // optional double prepare_rerouting_time = 2 [default = 2];
  bool has_prepare_rerouting_time() const;
  private:
  bool _internal_has_prepare_rerouting_time() const;
  public:
  void clear_prepare_rerouting_time();
  double prepare_rerouting_time() const;
  void set_prepare_rerouting_time(double value);
  private:
  double _internal_prepare_rerouting_time() const;
  void _internal_set_prepare_rerouting_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ReroutingConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double cooldown_time_;
  double prepare_rerouting_time_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class StopSignConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopSignConfig) */ {
 public:
  StopSignConfig();
  virtual ~StopSignConfig();

  StopSignConfig(const StopSignConfig& from);
  StopSignConfig(StopSignConfig&& from) noexcept
    : StopSignConfig() {
    *this = ::std::move(from);
  }

  inline StopSignConfig& operator=(const StopSignConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSignConfig& operator=(StopSignConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopSignConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopSignConfig* internal_default_instance() {
    return reinterpret_cast<const StopSignConfig*>(
               &_StopSignConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StopSignConfig& a, StopSignConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSignConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopSignConfig* New() const final {
    return CreateMaybeMessage<StopSignConfig>(nullptr);
  }

  StopSignConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopSignConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopSignConfig& from);
  void MergeFrom(const StopSignConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSignConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.StopSignConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kStopDistanceFieldNumber = 2,
  };
  // optional bool enabled = 1 [default = true];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional double stop_distance = 2 [default = 1];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.StopSignConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enabled_;
  double stop_distance_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TrafficLightConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficLightConfig) */ {
 public:
  TrafficLightConfig();
  virtual ~TrafficLightConfig();

  TrafficLightConfig(const TrafficLightConfig& from);
  TrafficLightConfig(TrafficLightConfig&& from) noexcept
    : TrafficLightConfig() {
    *this = ::std::move(from);
  }

  inline TrafficLightConfig& operator=(const TrafficLightConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficLightConfig& operator=(TrafficLightConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficLightConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightConfig* internal_default_instance() {
    return reinterpret_cast<const TrafficLightConfig*>(
               &_TrafficLightConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TrafficLightConfig& a, TrafficLightConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficLightConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightConfig* New() const final {
    return CreateMaybeMessage<TrafficLightConfig>(nullptr);
  }

  TrafficLightConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficLightConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficLightConfig& from);
  void MergeFrom(const TrafficLightConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLightConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrafficLightConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kStopDistanceFieldNumber = 2,
    kMaxStopDecelerationFieldNumber = 3,
  };
  // optional bool enabled = 1 [default = true];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional double stop_distance = 2 [default = 1];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double max_stop_deceleration = 3 [default = 4];
  bool has_max_stop_deceleration() const;
  private:
  bool _internal_has_max_stop_deceleration() const;
  public:
  void clear_max_stop_deceleration();
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);
  private:
  double _internal_max_stop_deceleration() const;
  void _internal_set_max_stop_deceleration(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficLightConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enabled_;
  double stop_distance_;
  double max_stop_deceleration_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TrafficRuleConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficRuleConfig) */ {
 public:
  TrafficRuleConfig();
  virtual ~TrafficRuleConfig();

  TrafficRuleConfig(const TrafficRuleConfig& from);
  TrafficRuleConfig(TrafficRuleConfig&& from) noexcept
    : TrafficRuleConfig() {
    *this = ::std::move(from);
  }

  inline TrafficRuleConfig& operator=(const TrafficRuleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficRuleConfig& operator=(TrafficRuleConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficRuleConfig& default_instance();

  enum ConfigCase {
    kBacksideVehicle = 3,
    kChangeLane = 4,
    kCrosswalk = 5,
    kDestination = 6,
    kKeepClear = 7,
    kReferenceLineEnd = 8,
    kRerouting = 9,
    kStopSign = 10,
    kTrafficLight = 11,
    CONFIG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficRuleConfig* internal_default_instance() {
    return reinterpret_cast<const TrafficRuleConfig*>(
               &_TrafficRuleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TrafficRuleConfig& a, TrafficRuleConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficRuleConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficRuleConfig* New() const final {
    return CreateMaybeMessage<TrafficRuleConfig>(nullptr);
  }

  TrafficRuleConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficRuleConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficRuleConfig& from);
  void MergeFrom(const TrafficRuleConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficRuleConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrafficRuleConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficRuleConfig_RuleId RuleId;
  static constexpr RuleId BACKSIDE_VEHICLE =
    TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE;
  static constexpr RuleId CHANGE_LANE =
    TrafficRuleConfig_RuleId_CHANGE_LANE;
  static constexpr RuleId CROSSWALK =
    TrafficRuleConfig_RuleId_CROSSWALK;
  static constexpr RuleId DESTINATION =
    TrafficRuleConfig_RuleId_DESTINATION;
  static constexpr RuleId KEEP_CLEAR =
    TrafficRuleConfig_RuleId_KEEP_CLEAR;
  static constexpr RuleId REFERENCE_LINE_END =
    TrafficRuleConfig_RuleId_REFERENCE_LINE_END;
  static constexpr RuleId REROUTING =
    TrafficRuleConfig_RuleId_REROUTING;
  static constexpr RuleId STOP_SIGN =
    TrafficRuleConfig_RuleId_STOP_SIGN;
  static constexpr RuleId TRAFFIC_LIGHT =
    TrafficRuleConfig_RuleId_TRAFFIC_LIGHT;
  static inline bool RuleId_IsValid(int value) {
    return TrafficRuleConfig_RuleId_IsValid(value);
  }
  static constexpr RuleId RuleId_MIN =
    TrafficRuleConfig_RuleId_RuleId_MIN;
  static constexpr RuleId RuleId_MAX =
    TrafficRuleConfig_RuleId_RuleId_MAX;
  static constexpr int RuleId_ARRAYSIZE =
    TrafficRuleConfig_RuleId_RuleId_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RuleId_descriptor() {
    return TrafficRuleConfig_RuleId_descriptor();
  }
  template<typename T>
  static inline const std::string& RuleId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RuleId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RuleId_Name.");
    return TrafficRuleConfig_RuleId_Name(enum_t_value);
  }
  static inline bool RuleId_Parse(const std::string& name,
      RuleId* value) {
    return TrafficRuleConfig_RuleId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 2,
    kRuleIdFieldNumber = 1,
    kBacksideVehicleFieldNumber = 3,
    kChangeLaneFieldNumber = 4,
    kCrosswalkFieldNumber = 5,
    kDestinationFieldNumber = 6,
    kKeepClearFieldNumber = 7,
    kReferenceLineEndFieldNumber = 8,
    kReroutingFieldNumber = 9,
    kStopSignFieldNumber = 10,
    kTrafficLightFieldNumber = 11,
  };
  // optional bool enabled = 2;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional .apollo.planning.TrafficRuleConfig.RuleId rule_id = 1;
  bool has_rule_id() const;
  private:
  bool _internal_has_rule_id() const;
  public:
  void clear_rule_id();
  ::apollo::planning::TrafficRuleConfig_RuleId rule_id() const;
  void set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value);
  private:
  ::apollo::planning::TrafficRuleConfig_RuleId _internal_rule_id() const;
  void _internal_set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value);
  public:

  // optional .apollo.planning.BacksideVehicleConfig backside_vehicle = 3;
  bool has_backside_vehicle() const;
  private:
  bool _internal_has_backside_vehicle() const;
  public:
  void clear_backside_vehicle();
  const ::apollo::planning::BacksideVehicleConfig& backside_vehicle() const;
  ::apollo::planning::BacksideVehicleConfig* release_backside_vehicle();
  ::apollo::planning::BacksideVehicleConfig* mutable_backside_vehicle();
  void set_allocated_backside_vehicle(::apollo::planning::BacksideVehicleConfig* backside_vehicle);
  private:
  const ::apollo::planning::BacksideVehicleConfig& _internal_backside_vehicle() const;
  ::apollo::planning::BacksideVehicleConfig* _internal_mutable_backside_vehicle();
  public:

  // optional .apollo.planning.ChangeLaneConfig change_lane = 4;
  bool has_change_lane() const;
  private:
  bool _internal_has_change_lane() const;
  public:
  void clear_change_lane();
  const ::apollo::planning::ChangeLaneConfig& change_lane() const;
  ::apollo::planning::ChangeLaneConfig* release_change_lane();
  ::apollo::planning::ChangeLaneConfig* mutable_change_lane();
  void set_allocated_change_lane(::apollo::planning::ChangeLaneConfig* change_lane);
  private:
  const ::apollo::planning::ChangeLaneConfig& _internal_change_lane() const;
  ::apollo::planning::ChangeLaneConfig* _internal_mutable_change_lane();
  public:

  // optional .apollo.planning.CrosswalkConfig crosswalk = 5;
  bool has_crosswalk() const;
  private:
  bool _internal_has_crosswalk() const;
  public:
  void clear_crosswalk();
  const ::apollo::planning::CrosswalkConfig& crosswalk() const;
  ::apollo::planning::CrosswalkConfig* release_crosswalk();
  ::apollo::planning::CrosswalkConfig* mutable_crosswalk();
  void set_allocated_crosswalk(::apollo::planning::CrosswalkConfig* crosswalk);
  private:
  const ::apollo::planning::CrosswalkConfig& _internal_crosswalk() const;
  ::apollo::planning::CrosswalkConfig* _internal_mutable_crosswalk();
  public:

  // optional .apollo.planning.DestinationConfig destination = 6;
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  const ::apollo::planning::DestinationConfig& destination() const;
  ::apollo::planning::DestinationConfig* release_destination();
  ::apollo::planning::DestinationConfig* mutable_destination();
  void set_allocated_destination(::apollo::planning::DestinationConfig* destination);
  private:
  const ::apollo::planning::DestinationConfig& _internal_destination() const;
  ::apollo::planning::DestinationConfig* _internal_mutable_destination();
  public:

  // optional .apollo.planning.KeepClearConfig keep_clear = 7;
  bool has_keep_clear() const;
  private:
  bool _internal_has_keep_clear() const;
  public:
  void clear_keep_clear();
  const ::apollo::planning::KeepClearConfig& keep_clear() const;
  ::apollo::planning::KeepClearConfig* release_keep_clear();
  ::apollo::planning::KeepClearConfig* mutable_keep_clear();
  void set_allocated_keep_clear(::apollo::planning::KeepClearConfig* keep_clear);
  private:
  const ::apollo::planning::KeepClearConfig& _internal_keep_clear() const;
  ::apollo::planning::KeepClearConfig* _internal_mutable_keep_clear();
  public:

  // optional .apollo.planning.ReferenceLineEndConfig reference_line_end = 8;
  bool has_reference_line_end() const;
  private:
  bool _internal_has_reference_line_end() const;
  public:
  void clear_reference_line_end();
  const ::apollo::planning::ReferenceLineEndConfig& reference_line_end() const;
  ::apollo::planning::ReferenceLineEndConfig* release_reference_line_end();
  ::apollo::planning::ReferenceLineEndConfig* mutable_reference_line_end();
  void set_allocated_reference_line_end(::apollo::planning::ReferenceLineEndConfig* reference_line_end);
  private:
  const ::apollo::planning::ReferenceLineEndConfig& _internal_reference_line_end() const;
  ::apollo::planning::ReferenceLineEndConfig* _internal_mutable_reference_line_end();
  public:

  // optional .apollo.planning.ReroutingConfig rerouting = 9;
  bool has_rerouting() const;
  private:
  bool _internal_has_rerouting() const;
  public:
  void clear_rerouting();
  const ::apollo::planning::ReroutingConfig& rerouting() const;
  ::apollo::planning::ReroutingConfig* release_rerouting();
  ::apollo::planning::ReroutingConfig* mutable_rerouting();
  void set_allocated_rerouting(::apollo::planning::ReroutingConfig* rerouting);
  private:
  const ::apollo::planning::ReroutingConfig& _internal_rerouting() const;
  ::apollo::planning::ReroutingConfig* _internal_mutable_rerouting();
  public:

  // optional .apollo.planning.StopSignConfig stop_sign = 10;
  bool has_stop_sign() const;
  private:
  bool _internal_has_stop_sign() const;
  public:
  void clear_stop_sign();
  const ::apollo::planning::StopSignConfig& stop_sign() const;
  ::apollo::planning::StopSignConfig* release_stop_sign();
  ::apollo::planning::StopSignConfig* mutable_stop_sign();
  void set_allocated_stop_sign(::apollo::planning::StopSignConfig* stop_sign);
  private:
  const ::apollo::planning::StopSignConfig& _internal_stop_sign() const;
  ::apollo::planning::StopSignConfig* _internal_mutable_stop_sign();
  public:

  // optional .apollo.planning.TrafficLightConfig traffic_light = 11;
  bool has_traffic_light() const;
  private:
  bool _internal_has_traffic_light() const;
  public:
  void clear_traffic_light();
  const ::apollo::planning::TrafficLightConfig& traffic_light() const;
  ::apollo::planning::TrafficLightConfig* release_traffic_light();
  ::apollo::planning::TrafficLightConfig* mutable_traffic_light();
  void set_allocated_traffic_light(::apollo::planning::TrafficLightConfig* traffic_light);
  private:
  const ::apollo::planning::TrafficLightConfig& _internal_traffic_light() const;
  ::apollo::planning::TrafficLightConfig* _internal_mutable_traffic_light();
  public:

  void clear_config();
  ConfigCase config_case() const;
  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficRuleConfig)
 private:
  class _Internal;
  void set_has_backside_vehicle();
  void set_has_change_lane();
  void set_has_crosswalk();
  void set_has_destination();
  void set_has_keep_clear();
  void set_has_reference_line_end();
  void set_has_rerouting();
  void set_has_stop_sign();
  void set_has_traffic_light();

  inline bool has_config() const;
  inline void clear_has_config();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enabled_;
  int rule_id_;
  union ConfigUnion {
    ConfigUnion() {}
    ::apollo::planning::BacksideVehicleConfig* backside_vehicle_;
    ::apollo::planning::ChangeLaneConfig* change_lane_;
    ::apollo::planning::CrosswalkConfig* crosswalk_;
    ::apollo::planning::DestinationConfig* destination_;
    ::apollo::planning::KeepClearConfig* keep_clear_;
    ::apollo::planning::ReferenceLineEndConfig* reference_line_end_;
    ::apollo::planning::ReroutingConfig* rerouting_;
    ::apollo::planning::StopSignConfig* stop_sign_;
    ::apollo::planning::TrafficLightConfig* traffic_light_;
  } config_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TrafficRuleConfigs :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficRuleConfigs) */ {
 public:
  TrafficRuleConfigs();
  virtual ~TrafficRuleConfigs();

  TrafficRuleConfigs(const TrafficRuleConfigs& from);
  TrafficRuleConfigs(TrafficRuleConfigs&& from) noexcept
    : TrafficRuleConfigs() {
    *this = ::std::move(from);
  }

  inline TrafficRuleConfigs& operator=(const TrafficRuleConfigs& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficRuleConfigs& operator=(TrafficRuleConfigs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficRuleConfigs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficRuleConfigs* internal_default_instance() {
    return reinterpret_cast<const TrafficRuleConfigs*>(
               &_TrafficRuleConfigs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TrafficRuleConfigs& a, TrafficRuleConfigs& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficRuleConfigs* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficRuleConfigs* New() const final {
    return CreateMaybeMessage<TrafficRuleConfigs>(nullptr);
  }

  TrafficRuleConfigs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficRuleConfigs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficRuleConfigs& from);
  void MergeFrom(const TrafficRuleConfigs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficRuleConfigs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrafficRuleConfigs";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // repeated .apollo.planning.TrafficRuleConfig config = 1;
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  ::apollo::planning::TrafficRuleConfig* mutable_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >*
      mutable_config();
  private:
  const ::apollo::planning::TrafficRuleConfig& _internal_config(int index) const;
  ::apollo::planning::TrafficRuleConfig* _internal_add_config();
  public:
  const ::apollo::planning::TrafficRuleConfig& config(int index) const;
  ::apollo::planning::TrafficRuleConfig* add_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >&
      config() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficRuleConfigs)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig > config_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BacksideVehicleConfig

// optional double backside_lane_width = 1 [default = 4];
inline bool BacksideVehicleConfig::_internal_has_backside_lane_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BacksideVehicleConfig::has_backside_lane_width() const {
  return _internal_has_backside_lane_width();
}
inline void BacksideVehicleConfig::clear_backside_lane_width() {
  backside_lane_width_ = 4;
  _has_bits_[0] &= ~0x00000001u;
}
inline double BacksideVehicleConfig::_internal_backside_lane_width() const {
  return backside_lane_width_;
}
inline double BacksideVehicleConfig::backside_lane_width() const {
  // @@protoc_insertion_point(field_get:apollo.planning.BacksideVehicleConfig.backside_lane_width)
  return _internal_backside_lane_width();
}
inline void BacksideVehicleConfig::_internal_set_backside_lane_width(double value) {
  _has_bits_[0] |= 0x00000001u;
  backside_lane_width_ = value;
}
inline void BacksideVehicleConfig::set_backside_lane_width(double value) {
  _internal_set_backside_lane_width(value);
  // @@protoc_insertion_point(field_set:apollo.planning.BacksideVehicleConfig.backside_lane_width)
}

// -------------------------------------------------------------------

// ChangeLaneConfig

// optional double min_overtake_distance = 1 [default = 10];
inline bool ChangeLaneConfig::_internal_has_min_overtake_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeLaneConfig::has_min_overtake_distance() const {
  return _internal_has_min_overtake_distance();
}
inline void ChangeLaneConfig::clear_min_overtake_distance() {
  min_overtake_distance_ = 10;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ChangeLaneConfig::_internal_min_overtake_distance() const {
  return min_overtake_distance_;
}
inline double ChangeLaneConfig::min_overtake_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.min_overtake_distance)
  return _internal_min_overtake_distance();
}
inline void ChangeLaneConfig::_internal_set_min_overtake_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  min_overtake_distance_ = value;
}
inline void ChangeLaneConfig::set_min_overtake_distance(double value) {
  _internal_set_min_overtake_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.min_overtake_distance)
}

// optional double min_overtake_time = 2 [default = 2];
inline bool ChangeLaneConfig::_internal_has_min_overtake_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeLaneConfig::has_min_overtake_time() const {
  return _internal_has_min_overtake_time();
}
inline void ChangeLaneConfig::clear_min_overtake_time() {
  min_overtake_time_ = 2;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ChangeLaneConfig::_internal_min_overtake_time() const {
  return min_overtake_time_;
}
inline double ChangeLaneConfig::min_overtake_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.min_overtake_time)
  return _internal_min_overtake_time();
}
inline void ChangeLaneConfig::_internal_set_min_overtake_time(double value) {
  _has_bits_[0] |= 0x00000004u;
  min_overtake_time_ = value;
}
inline void ChangeLaneConfig::set_min_overtake_time(double value) {
  _internal_set_min_overtake_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.min_overtake_time)
}

// optional bool enable_guard_obstacle = 3 [default = false];
inline bool ChangeLaneConfig::_internal_has_enable_guard_obstacle() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeLaneConfig::has_enable_guard_obstacle() const {
  return _internal_has_enable_guard_obstacle();
}
inline void ChangeLaneConfig::clear_enable_guard_obstacle() {
  enable_guard_obstacle_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ChangeLaneConfig::_internal_enable_guard_obstacle() const {
  return enable_guard_obstacle_;
}
inline bool ChangeLaneConfig::enable_guard_obstacle() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.enable_guard_obstacle)
  return _internal_enable_guard_obstacle();
}
inline void ChangeLaneConfig::_internal_set_enable_guard_obstacle(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enable_guard_obstacle_ = value;
}
inline void ChangeLaneConfig::set_enable_guard_obstacle(bool value) {
  _internal_set_enable_guard_obstacle(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.enable_guard_obstacle)
}

// optional double guard_distance = 4 [default = 100];
inline bool ChangeLaneConfig::_internal_has_guard_distance() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChangeLaneConfig::has_guard_distance() const {
  return _internal_has_guard_distance();
}
inline void ChangeLaneConfig::clear_guard_distance() {
  guard_distance_ = 100;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ChangeLaneConfig::_internal_guard_distance() const {
  return guard_distance_;
}
inline double ChangeLaneConfig::guard_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.guard_distance)
  return _internal_guard_distance();
}
inline void ChangeLaneConfig::_internal_set_guard_distance(double value) {
  _has_bits_[0] |= 0x00000008u;
  guard_distance_ = value;
}
inline void ChangeLaneConfig::set_guard_distance(double value) {
  _internal_set_guard_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.guard_distance)
}

// optional double min_guard_speed = 5 [default = 1];
inline bool ChangeLaneConfig::_internal_has_min_guard_speed() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChangeLaneConfig::has_min_guard_speed() const {
  return _internal_has_min_guard_speed();
}
inline void ChangeLaneConfig::clear_min_guard_speed() {
  min_guard_speed_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ChangeLaneConfig::_internal_min_guard_speed() const {
  return min_guard_speed_;
}
inline double ChangeLaneConfig::min_guard_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.min_guard_speed)
  return _internal_min_guard_speed();
}
inline void ChangeLaneConfig::_internal_set_min_guard_speed(double value) {
  _has_bits_[0] |= 0x00000010u;
  min_guard_speed_ = value;
}
inline void ChangeLaneConfig::set_min_guard_speed(double value) {
  _internal_set_min_guard_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.min_guard_speed)
}

// -------------------------------------------------------------------

// CreepConfig

// optional bool enabled = 1;
inline bool CreepConfig::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreepConfig::has_enabled() const {
  return _internal_has_enabled();
}
inline void CreepConfig::clear_enabled() {
  enabled_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CreepConfig::_internal_enabled() const {
  return enabled_;
}
inline bool CreepConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.enabled)
  return _internal_enabled();
}
inline void CreepConfig::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_ = value;
}
inline void CreepConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.enabled)
}

// optional double creep_distance_to_stop_line = 2 [default = 1];
inline bool CreepConfig::_internal_has_creep_distance_to_stop_line() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreepConfig::has_creep_distance_to_stop_line() const {
  return _internal_has_creep_distance_to_stop_line();
}
inline void CreepConfig::clear_creep_distance_to_stop_line() {
  creep_distance_to_stop_line_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline double CreepConfig::_internal_creep_distance_to_stop_line() const {
  return creep_distance_to_stop_line_;
}
inline double CreepConfig::creep_distance_to_stop_line() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.creep_distance_to_stop_line)
  return _internal_creep_distance_to_stop_line();
}
inline void CreepConfig::_internal_set_creep_distance_to_stop_line(double value) {
  _has_bits_[0] |= 0x00000002u;
  creep_distance_to_stop_line_ = value;
}
inline void CreepConfig::set_creep_distance_to_stop_line(double value) {
  _internal_set_creep_distance_to_stop_line(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.creep_distance_to_stop_line)
}

// optional double stop_distance = 3 [default = 0.5];
inline bool CreepConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CreepConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void CreepConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  _has_bits_[0] &= ~0x00000004u;
}
inline double CreepConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double CreepConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.stop_distance)
  return _internal_stop_distance();
}
inline void CreepConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  stop_distance_ = value;
}
inline void CreepConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.stop_distance)
}

// optional double speed_limit = 4 [default = 1];
inline bool CreepConfig::_internal_has_speed_limit() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CreepConfig::has_speed_limit() const {
  return _internal_has_speed_limit();
}
inline void CreepConfig::clear_speed_limit() {
  speed_limit_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline double CreepConfig::_internal_speed_limit() const {
  return speed_limit_;
}
inline double CreepConfig::speed_limit() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.speed_limit)
  return _internal_speed_limit();
}
inline void CreepConfig::_internal_set_speed_limit(double value) {
  _has_bits_[0] |= 0x00000008u;
  speed_limit_ = value;
}
inline void CreepConfig::set_speed_limit(double value) {
  _internal_set_speed_limit(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.speed_limit)
}

// optional double max_valid_stop_distance = 5 [default = 0.3];
inline bool CreepConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CreepConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void CreepConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 0.3;
  _has_bits_[0] &= ~0x00000010u;
}
inline double CreepConfig::_internal_max_valid_stop_distance() const {
  return max_valid_stop_distance_;
}
inline double CreepConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void CreepConfig::_internal_set_max_valid_stop_distance(double value) {
  _has_bits_[0] |= 0x00000010u;
  max_valid_stop_distance_ = value;
}
inline void CreepConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.max_valid_stop_distance)
}

// optional double min_boundary_t = 6 [default = 6];
inline bool CreepConfig::_internal_has_min_boundary_t() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CreepConfig::has_min_boundary_t() const {
  return _internal_has_min_boundary_t();
}
inline void CreepConfig::clear_min_boundary_t() {
  min_boundary_t_ = 6;
  _has_bits_[0] &= ~0x00000020u;
}
inline double CreepConfig::_internal_min_boundary_t() const {
  return min_boundary_t_;
}
inline double CreepConfig::min_boundary_t() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.min_boundary_t)
  return _internal_min_boundary_t();
}
inline void CreepConfig::_internal_set_min_boundary_t(double value) {
  _has_bits_[0] |= 0x00000020u;
  min_boundary_t_ = value;
}
inline void CreepConfig::set_min_boundary_t(double value) {
  _internal_set_min_boundary_t(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.min_boundary_t)
}

// optional double min_boundary_s = 7 [default = 3];
inline bool CreepConfig::_internal_has_min_boundary_s() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CreepConfig::has_min_boundary_s() const {
  return _internal_has_min_boundary_s();
}
inline void CreepConfig::clear_min_boundary_s() {
  min_boundary_s_ = 3;
  _has_bits_[0] &= ~0x00000040u;
}
inline double CreepConfig::_internal_min_boundary_s() const {
  return min_boundary_s_;
}
inline double CreepConfig::min_boundary_s() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.min_boundary_s)
  return _internal_min_boundary_s();
}
inline void CreepConfig::_internal_set_min_boundary_s(double value) {
  _has_bits_[0] |= 0x00000040u;
  min_boundary_s_ = value;
}
inline void CreepConfig::set_min_boundary_s(double value) {
  _internal_set_min_boundary_s(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.min_boundary_s)
}

// -------------------------------------------------------------------

// CrosswalkConfig

// optional double stop_distance = 1 [default = 1];
inline bool CrosswalkConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void CrosswalkConfig::clear_stop_distance() {
  stop_distance_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline double CrosswalkConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double CrosswalkConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_distance)
  return _internal_stop_distance();
}
inline void CrosswalkConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000001u;
  stop_distance_ = value;
}
inline void CrosswalkConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_distance)
}

// optional double max_stop_deceleration = 2 [default = 4];
inline bool CrosswalkConfig::_internal_has_max_stop_deceleration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_max_stop_deceleration() const {
  return _internal_has_max_stop_deceleration();
}
inline void CrosswalkConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 4;
  _has_bits_[0] &= ~0x00000002u;
}
inline double CrosswalkConfig::_internal_max_stop_deceleration() const {
  return max_stop_deceleration_;
}
inline double CrosswalkConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.max_stop_deceleration)
  return _internal_max_stop_deceleration();
}
inline void CrosswalkConfig::_internal_set_max_stop_deceleration(double value) {
  _has_bits_[0] |= 0x00000002u;
  max_stop_deceleration_ = value;
}
inline void CrosswalkConfig::set_max_stop_deceleration(double value) {
  _internal_set_max_stop_deceleration(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.max_stop_deceleration)
}

// optional double min_pass_s_distance = 3 [default = 1];
inline bool CrosswalkConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void CrosswalkConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline double CrosswalkConfig::_internal_min_pass_s_distance() const {
  return min_pass_s_distance_;
}
inline double CrosswalkConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void CrosswalkConfig::_internal_set_min_pass_s_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  min_pass_s_distance_ = value;
}
inline void CrosswalkConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.min_pass_s_distance)
}

// optional double max_stop_speed = 4 [default = 0.3];
inline bool CrosswalkConfig::_internal_has_max_stop_speed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_max_stop_speed() const {
  return _internal_has_max_stop_speed();
}
inline void CrosswalkConfig::clear_max_stop_speed() {
  max_stop_speed_ = 0.3;
  _has_bits_[0] &= ~0x00000008u;
}
inline double CrosswalkConfig::_internal_max_stop_speed() const {
  return max_stop_speed_;
}
inline double CrosswalkConfig::max_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.max_stop_speed)
  return _internal_max_stop_speed();
}
inline void CrosswalkConfig::_internal_set_max_stop_speed(double value) {
  _has_bits_[0] |= 0x00000008u;
  max_stop_speed_ = value;
}
inline void CrosswalkConfig::set_max_stop_speed(double value) {
  _internal_set_max_stop_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.max_stop_speed)
}

// optional double max_valid_stop_distance = 5 [default = 3];
inline bool CrosswalkConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void CrosswalkConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3;
  _has_bits_[0] &= ~0x00000010u;
}
inline double CrosswalkConfig::_internal_max_valid_stop_distance() const {
  return max_valid_stop_distance_;
}
inline double CrosswalkConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void CrosswalkConfig::_internal_set_max_valid_stop_distance(double value) {
  _has_bits_[0] |= 0x00000010u;
  max_valid_stop_distance_ = value;
}
inline void CrosswalkConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.max_valid_stop_distance)
}

// optional double expand_s_distance = 6 [default = 2];
inline bool CrosswalkConfig::_internal_has_expand_s_distance() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_expand_s_distance() const {
  return _internal_has_expand_s_distance();
}
inline void CrosswalkConfig::clear_expand_s_distance() {
  expand_s_distance_ = 2;
  _has_bits_[0] &= ~0x00000020u;
}
inline double CrosswalkConfig::_internal_expand_s_distance() const {
  return expand_s_distance_;
}
inline double CrosswalkConfig::expand_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.expand_s_distance)
  return _internal_expand_s_distance();
}
inline void CrosswalkConfig::_internal_set_expand_s_distance(double value) {
  _has_bits_[0] |= 0x00000020u;
  expand_s_distance_ = value;
}
inline void CrosswalkConfig::set_expand_s_distance(double value) {
  _internal_set_expand_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.expand_s_distance)
}

// optional double stop_strict_l_distance = 7 [default = 4];
inline bool CrosswalkConfig::_internal_has_stop_strict_l_distance() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_stop_strict_l_distance() const {
  return _internal_has_stop_strict_l_distance();
}
inline void CrosswalkConfig::clear_stop_strict_l_distance() {
  stop_strict_l_distance_ = 4;
  _has_bits_[0] &= ~0x00000040u;
}
inline double CrosswalkConfig::_internal_stop_strict_l_distance() const {
  return stop_strict_l_distance_;
}
inline double CrosswalkConfig::stop_strict_l_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_strict_l_distance)
  return _internal_stop_strict_l_distance();
}
inline void CrosswalkConfig::_internal_set_stop_strict_l_distance(double value) {
  _has_bits_[0] |= 0x00000040u;
  stop_strict_l_distance_ = value;
}
inline void CrosswalkConfig::set_stop_strict_l_distance(double value) {
  _internal_set_stop_strict_l_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_strict_l_distance)
}

// optional double stop_loose_l_distance = 8 [default = 5];
inline bool CrosswalkConfig::_internal_has_stop_loose_l_distance() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_stop_loose_l_distance() const {
  return _internal_has_stop_loose_l_distance();
}
inline void CrosswalkConfig::clear_stop_loose_l_distance() {
  stop_loose_l_distance_ = 5;
  _has_bits_[0] &= ~0x00000080u;
}
inline double CrosswalkConfig::_internal_stop_loose_l_distance() const {
  return stop_loose_l_distance_;
}
inline double CrosswalkConfig::stop_loose_l_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_loose_l_distance)
  return _internal_stop_loose_l_distance();
}
inline void CrosswalkConfig::_internal_set_stop_loose_l_distance(double value) {
  _has_bits_[0] |= 0x00000080u;
  stop_loose_l_distance_ = value;
}
inline void CrosswalkConfig::set_stop_loose_l_distance(double value) {
  _internal_set_stop_loose_l_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_loose_l_distance)
}

// optional double stop_timeout = 9 [default = 10];
inline bool CrosswalkConfig::_internal_has_stop_timeout() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_stop_timeout() const {
  return _internal_has_stop_timeout();
}
inline void CrosswalkConfig::clear_stop_timeout() {
  stop_timeout_ = 10;
  _has_bits_[0] &= ~0x00000100u;
}
inline double CrosswalkConfig::_internal_stop_timeout() const {
  return stop_timeout_;
}
inline double CrosswalkConfig::stop_timeout() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_timeout)
  return _internal_stop_timeout();
}
inline void CrosswalkConfig::_internal_set_stop_timeout(double value) {
  _has_bits_[0] |= 0x00000100u;
  stop_timeout_ = value;
}
inline void CrosswalkConfig::set_stop_timeout(double value) {
  _internal_set_stop_timeout(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_timeout)
}

// -------------------------------------------------------------------

// DestinationConfig

// optional double stop_distance = 1 [default = 0.5];
inline bool DestinationConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DestinationConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void DestinationConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  _has_bits_[0] &= ~0x00000001u;
}
inline double DestinationConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double DestinationConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.DestinationConfig.stop_distance)
  return _internal_stop_distance();
}
inline void DestinationConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000001u;
  stop_distance_ = value;
}
inline void DestinationConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.DestinationConfig.stop_distance)
}

// -------------------------------------------------------------------

// KeepClearConfig

// optional bool enable_keep_clear_zone = 1 [default = true];
inline bool KeepClearConfig::_internal_has_enable_keep_clear_zone() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeepClearConfig::has_enable_keep_clear_zone() const {
  return _internal_has_enable_keep_clear_zone();
}
inline void KeepClearConfig::clear_enable_keep_clear_zone() {
  enable_keep_clear_zone_ = true;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool KeepClearConfig::_internal_enable_keep_clear_zone() const {
  return enable_keep_clear_zone_;
}
inline bool KeepClearConfig::enable_keep_clear_zone() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.enable_keep_clear_zone)
  return _internal_enable_keep_clear_zone();
}
inline void KeepClearConfig::_internal_set_enable_keep_clear_zone(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enable_keep_clear_zone_ = value;
}
inline void KeepClearConfig::set_enable_keep_clear_zone(bool value) {
  _internal_set_enable_keep_clear_zone(value);
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.enable_keep_clear_zone)
}

// optional bool enable_junction = 2 [default = true];
inline bool KeepClearConfig::_internal_has_enable_junction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeepClearConfig::has_enable_junction() const {
  return _internal_has_enable_junction();
}
inline void KeepClearConfig::clear_enable_junction() {
  enable_junction_ = true;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool KeepClearConfig::_internal_enable_junction() const {
  return enable_junction_;
}
inline bool KeepClearConfig::enable_junction() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.enable_junction)
  return _internal_enable_junction();
}
inline void KeepClearConfig::_internal_set_enable_junction(bool value) {
  _has_bits_[0] |= 0x00000002u;
  enable_junction_ = value;
}
inline void KeepClearConfig::set_enable_junction(bool value) {
  _internal_set_enable_junction(value);
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.enable_junction)
}

// optional double min_pass_s_distance = 3 [default = 2];
inline bool KeepClearConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KeepClearConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void KeepClearConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 2;
  _has_bits_[0] &= ~0x00000004u;
}
inline double KeepClearConfig::_internal_min_pass_s_distance() const {
  return min_pass_s_distance_;
}
inline double KeepClearConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void KeepClearConfig::_internal_set_min_pass_s_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  min_pass_s_distance_ = value;
}
inline void KeepClearConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.min_pass_s_distance)
}

// optional double align_with_traffic_sign_tolerance = 4 [default = 4.5];
inline bool KeepClearConfig::_internal_has_align_with_traffic_sign_tolerance() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KeepClearConfig::has_align_with_traffic_sign_tolerance() const {
  return _internal_has_align_with_traffic_sign_tolerance();
}
inline void KeepClearConfig::clear_align_with_traffic_sign_tolerance() {
  align_with_traffic_sign_tolerance_ = 4.5;
  _has_bits_[0] &= ~0x00000008u;
}
inline double KeepClearConfig::_internal_align_with_traffic_sign_tolerance() const {
  return align_with_traffic_sign_tolerance_;
}
inline double KeepClearConfig::align_with_traffic_sign_tolerance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.align_with_traffic_sign_tolerance)
  return _internal_align_with_traffic_sign_tolerance();
}
inline void KeepClearConfig::_internal_set_align_with_traffic_sign_tolerance(double value) {
  _has_bits_[0] |= 0x00000008u;
  align_with_traffic_sign_tolerance_ = value;
}
inline void KeepClearConfig::set_align_with_traffic_sign_tolerance(double value) {
  _internal_set_align_with_traffic_sign_tolerance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.align_with_traffic_sign_tolerance)
}

// -------------------------------------------------------------------

// ReferenceLineEndConfig

// optional double stop_distance = 1 [default = 0.5];
inline bool ReferenceLineEndConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReferenceLineEndConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void ReferenceLineEndConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ReferenceLineEndConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double ReferenceLineEndConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReferenceLineEndConfig.stop_distance)
  return _internal_stop_distance();
}
inline void ReferenceLineEndConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000001u;
  stop_distance_ = value;
}
inline void ReferenceLineEndConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReferenceLineEndConfig.stop_distance)
}

// optional double min_reference_line_remain_length = 2 [default = 50];
inline bool ReferenceLineEndConfig::_internal_has_min_reference_line_remain_length() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReferenceLineEndConfig::has_min_reference_line_remain_length() const {
  return _internal_has_min_reference_line_remain_length();
}
inline void ReferenceLineEndConfig::clear_min_reference_line_remain_length() {
  min_reference_line_remain_length_ = 50;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ReferenceLineEndConfig::_internal_min_reference_line_remain_length() const {
  return min_reference_line_remain_length_;
}
inline double ReferenceLineEndConfig::min_reference_line_remain_length() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReferenceLineEndConfig.min_reference_line_remain_length)
  return _internal_min_reference_line_remain_length();
}
inline void ReferenceLineEndConfig::_internal_set_min_reference_line_remain_length(double value) {
  _has_bits_[0] |= 0x00000002u;
  min_reference_line_remain_length_ = value;
}
inline void ReferenceLineEndConfig::set_min_reference_line_remain_length(double value) {
  _internal_set_min_reference_line_remain_length(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReferenceLineEndConfig.min_reference_line_remain_length)
}

// -------------------------------------------------------------------

// ReroutingConfig

// optional double cooldown_time = 1 [default = 3];
inline bool ReroutingConfig::_internal_has_cooldown_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReroutingConfig::has_cooldown_time() const {
  return _internal_has_cooldown_time();
}
inline void ReroutingConfig::clear_cooldown_time() {
  cooldown_time_ = 3;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ReroutingConfig::_internal_cooldown_time() const {
  return cooldown_time_;
}
inline double ReroutingConfig::cooldown_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingConfig.cooldown_time)
  return _internal_cooldown_time();
}
inline void ReroutingConfig::_internal_set_cooldown_time(double value) {
  _has_bits_[0] |= 0x00000001u;
  cooldown_time_ = value;
}
inline void ReroutingConfig::set_cooldown_time(double value) {
  _internal_set_cooldown_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingConfig.cooldown_time)
}

// optional double prepare_rerouting_time = 2 [default = 2];
inline bool ReroutingConfig::_internal_has_prepare_rerouting_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReroutingConfig::has_prepare_rerouting_time() const {
  return _internal_has_prepare_rerouting_time();
}
inline void ReroutingConfig::clear_prepare_rerouting_time() {
  prepare_rerouting_time_ = 2;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ReroutingConfig::_internal_prepare_rerouting_time() const {
  return prepare_rerouting_time_;
}
inline double ReroutingConfig::prepare_rerouting_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingConfig.prepare_rerouting_time)
  return _internal_prepare_rerouting_time();
}
inline void ReroutingConfig::_internal_set_prepare_rerouting_time(double value) {
  _has_bits_[0] |= 0x00000002u;
  prepare_rerouting_time_ = value;
}
inline void ReroutingConfig::set_prepare_rerouting_time(double value) {
  _internal_set_prepare_rerouting_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingConfig.prepare_rerouting_time)
}

// -------------------------------------------------------------------

// StopSignConfig

// optional bool enabled = 1 [default = true];
inline bool StopSignConfig::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopSignConfig::has_enabled() const {
  return _internal_has_enabled();
}
inline void StopSignConfig::clear_enabled() {
  enabled_ = true;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool StopSignConfig::_internal_enabled() const {
  return enabled_;
}
inline bool StopSignConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.enabled)
  return _internal_enabled();
}
inline void StopSignConfig::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_ = value;
}
inline void StopSignConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.enabled)
}

// optional double stop_distance = 2 [default = 1];
inline bool StopSignConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StopSignConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void StopSignConfig::clear_stop_distance() {
  stop_distance_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline double StopSignConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double StopSignConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.stop_distance)
  return _internal_stop_distance();
}
inline void StopSignConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  stop_distance_ = value;
}
inline void StopSignConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.stop_distance)
}

// -------------------------------------------------------------------

// TrafficLightConfig

// optional bool enabled = 1 [default = true];
inline bool TrafficLightConfig::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficLightConfig::has_enabled() const {
  return _internal_has_enabled();
}
inline void TrafficLightConfig::clear_enabled() {
  enabled_ = true;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool TrafficLightConfig::_internal_enabled() const {
  return enabled_;
}
inline bool TrafficLightConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightConfig.enabled)
  return _internal_enabled();
}
inline void TrafficLightConfig::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_ = value;
}
inline void TrafficLightConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightConfig.enabled)
}

// optional double stop_distance = 2 [default = 1];
inline bool TrafficLightConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrafficLightConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void TrafficLightConfig::clear_stop_distance() {
  stop_distance_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline double TrafficLightConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double TrafficLightConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightConfig.stop_distance)
  return _internal_stop_distance();
}
inline void TrafficLightConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  stop_distance_ = value;
}
inline void TrafficLightConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightConfig.stop_distance)
}

// optional double max_stop_deceleration = 3 [default = 4];
inline bool TrafficLightConfig::_internal_has_max_stop_deceleration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrafficLightConfig::has_max_stop_deceleration() const {
  return _internal_has_max_stop_deceleration();
}
inline void TrafficLightConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 4;
  _has_bits_[0] &= ~0x00000004u;
}
inline double TrafficLightConfig::_internal_max_stop_deceleration() const {
  return max_stop_deceleration_;
}
inline double TrafficLightConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightConfig.max_stop_deceleration)
  return _internal_max_stop_deceleration();
}
inline void TrafficLightConfig::_internal_set_max_stop_deceleration(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_stop_deceleration_ = value;
}
inline void TrafficLightConfig::set_max_stop_deceleration(double value) {
  _internal_set_max_stop_deceleration(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightConfig.max_stop_deceleration)
}

// -------------------------------------------------------------------

// TrafficRuleConfig

// optional .apollo.planning.TrafficRuleConfig.RuleId rule_id = 1;
inline bool TrafficRuleConfig::_internal_has_rule_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrafficRuleConfig::has_rule_id() const {
  return _internal_has_rule_id();
}
inline void TrafficRuleConfig::clear_rule_id() {
  rule_id_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::planning::TrafficRuleConfig_RuleId TrafficRuleConfig::_internal_rule_id() const {
  return static_cast< ::apollo::planning::TrafficRuleConfig_RuleId >(rule_id_);
}
inline ::apollo::planning::TrafficRuleConfig_RuleId TrafficRuleConfig::rule_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.rule_id)
  return _internal_rule_id();
}
inline void TrafficRuleConfig::_internal_set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value) {
  assert(::apollo::planning::TrafficRuleConfig_RuleId_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  rule_id_ = value;
}
inline void TrafficRuleConfig::set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value) {
  _internal_set_rule_id(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficRuleConfig.rule_id)
}

// optional bool enabled = 2;
inline bool TrafficRuleConfig::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficRuleConfig::has_enabled() const {
  return _internal_has_enabled();
}
inline void TrafficRuleConfig::clear_enabled() {
  enabled_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool TrafficRuleConfig::_internal_enabled() const {
  return enabled_;
}
inline bool TrafficRuleConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.enabled)
  return _internal_enabled();
}
inline void TrafficRuleConfig::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_ = value;
}
inline void TrafficRuleConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficRuleConfig.enabled)
}

// optional .apollo.planning.BacksideVehicleConfig backside_vehicle = 3;
inline bool TrafficRuleConfig::_internal_has_backside_vehicle() const {
  return config_case() == kBacksideVehicle;
}
inline bool TrafficRuleConfig::has_backside_vehicle() const {
  return _internal_has_backside_vehicle();
}
inline void TrafficRuleConfig::set_has_backside_vehicle() {
  _oneof_case_[0] = kBacksideVehicle;
}
inline void TrafficRuleConfig::clear_backside_vehicle() {
  if (_internal_has_backside_vehicle()) {
    delete config_.backside_vehicle_;
    clear_has_config();
  }
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::release_backside_vehicle() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.backside_vehicle)
  if (_internal_has_backside_vehicle()) {
    clear_has_config();
      ::apollo::planning::BacksideVehicleConfig* temp = config_.backside_vehicle_;
    config_.backside_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::BacksideVehicleConfig& TrafficRuleConfig::_internal_backside_vehicle() const {
  return _internal_has_backside_vehicle()
      ? *config_.backside_vehicle_
      : *reinterpret_cast< ::apollo::planning::BacksideVehicleConfig*>(&::apollo::planning::_BacksideVehicleConfig_default_instance_);
}
inline const ::apollo::planning::BacksideVehicleConfig& TrafficRuleConfig::backside_vehicle() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.backside_vehicle)
  return _internal_backside_vehicle();
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::_internal_mutable_backside_vehicle() {
  if (!_internal_has_backside_vehicle()) {
    clear_config();
    set_has_backside_vehicle();
    config_.backside_vehicle_ = CreateMaybeMessage< ::apollo::planning::BacksideVehicleConfig >(
        GetArenaNoVirtual());
  }
  return config_.backside_vehicle_;
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::mutable_backside_vehicle() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.backside_vehicle)
  return _internal_mutable_backside_vehicle();
}

// optional .apollo.planning.ChangeLaneConfig change_lane = 4;
inline bool TrafficRuleConfig::_internal_has_change_lane() const {
  return config_case() == kChangeLane;
}
inline bool TrafficRuleConfig::has_change_lane() const {
  return _internal_has_change_lane();
}
inline void TrafficRuleConfig::set_has_change_lane() {
  _oneof_case_[0] = kChangeLane;
}
inline void TrafficRuleConfig::clear_change_lane() {
  if (_internal_has_change_lane()) {
    delete config_.change_lane_;
    clear_has_config();
  }
}
inline ::apollo::planning::ChangeLaneConfig* TrafficRuleConfig::release_change_lane() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.change_lane)
  if (_internal_has_change_lane()) {
    clear_has_config();
      ::apollo::planning::ChangeLaneConfig* temp = config_.change_lane_;
    config_.change_lane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ChangeLaneConfig& TrafficRuleConfig::_internal_change_lane() const {
  return _internal_has_change_lane()
      ? *config_.change_lane_
      : *reinterpret_cast< ::apollo::planning::ChangeLaneConfig*>(&::apollo::planning::_ChangeLaneConfig_default_instance_);
}
inline const ::apollo::planning::ChangeLaneConfig& TrafficRuleConfig::change_lane() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.change_lane)
  return _internal_change_lane();
}
inline ::apollo::planning::ChangeLaneConfig* TrafficRuleConfig::_internal_mutable_change_lane() {
  if (!_internal_has_change_lane()) {
    clear_config();
    set_has_change_lane();
    config_.change_lane_ = CreateMaybeMessage< ::apollo::planning::ChangeLaneConfig >(
        GetArenaNoVirtual());
  }
  return config_.change_lane_;
}
inline ::apollo::planning::ChangeLaneConfig* TrafficRuleConfig::mutable_change_lane() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.change_lane)
  return _internal_mutable_change_lane();
}

// optional .apollo.planning.CrosswalkConfig crosswalk = 5;
inline bool TrafficRuleConfig::_internal_has_crosswalk() const {
  return config_case() == kCrosswalk;
}
inline bool TrafficRuleConfig::has_crosswalk() const {
  return _internal_has_crosswalk();
}
inline void TrafficRuleConfig::set_has_crosswalk() {
  _oneof_case_[0] = kCrosswalk;
}
inline void TrafficRuleConfig::clear_crosswalk() {
  if (_internal_has_crosswalk()) {
    delete config_.crosswalk_;
    clear_has_config();
  }
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::release_crosswalk() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.crosswalk)
  if (_internal_has_crosswalk()) {
    clear_has_config();
      ::apollo::planning::CrosswalkConfig* temp = config_.crosswalk_;
    config_.crosswalk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::CrosswalkConfig& TrafficRuleConfig::_internal_crosswalk() const {
  return _internal_has_crosswalk()
      ? *config_.crosswalk_
      : *reinterpret_cast< ::apollo::planning::CrosswalkConfig*>(&::apollo::planning::_CrosswalkConfig_default_instance_);
}
inline const ::apollo::planning::CrosswalkConfig& TrafficRuleConfig::crosswalk() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.crosswalk)
  return _internal_crosswalk();
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::_internal_mutable_crosswalk() {
  if (!_internal_has_crosswalk()) {
    clear_config();
    set_has_crosswalk();
    config_.crosswalk_ = CreateMaybeMessage< ::apollo::planning::CrosswalkConfig >(
        GetArenaNoVirtual());
  }
  return config_.crosswalk_;
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::mutable_crosswalk() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.crosswalk)
  return _internal_mutable_crosswalk();
}

// optional .apollo.planning.DestinationConfig destination = 6;
inline bool TrafficRuleConfig::_internal_has_destination() const {
  return config_case() == kDestination;
}
inline bool TrafficRuleConfig::has_destination() const {
  return _internal_has_destination();
}
inline void TrafficRuleConfig::set_has_destination() {
  _oneof_case_[0] = kDestination;
}
inline void TrafficRuleConfig::clear_destination() {
  if (_internal_has_destination()) {
    delete config_.destination_;
    clear_has_config();
  }
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::release_destination() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.destination)
  if (_internal_has_destination()) {
    clear_has_config();
      ::apollo::planning::DestinationConfig* temp = config_.destination_;
    config_.destination_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::DestinationConfig& TrafficRuleConfig::_internal_destination() const {
  return _internal_has_destination()
      ? *config_.destination_
      : *reinterpret_cast< ::apollo::planning::DestinationConfig*>(&::apollo::planning::_DestinationConfig_default_instance_);
}
inline const ::apollo::planning::DestinationConfig& TrafficRuleConfig::destination() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.destination)
  return _internal_destination();
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::_internal_mutable_destination() {
  if (!_internal_has_destination()) {
    clear_config();
    set_has_destination();
    config_.destination_ = CreateMaybeMessage< ::apollo::planning::DestinationConfig >(
        GetArenaNoVirtual());
  }
  return config_.destination_;
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::mutable_destination() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.destination)
  return _internal_mutable_destination();
}

// optional .apollo.planning.KeepClearConfig keep_clear = 7;
inline bool TrafficRuleConfig::_internal_has_keep_clear() const {
  return config_case() == kKeepClear;
}
inline bool TrafficRuleConfig::has_keep_clear() const {
  return _internal_has_keep_clear();
}
inline void TrafficRuleConfig::set_has_keep_clear() {
  _oneof_case_[0] = kKeepClear;
}
inline void TrafficRuleConfig::clear_keep_clear() {
  if (_internal_has_keep_clear()) {
    delete config_.keep_clear_;
    clear_has_config();
  }
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::release_keep_clear() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.keep_clear)
  if (_internal_has_keep_clear()) {
    clear_has_config();
      ::apollo::planning::KeepClearConfig* temp = config_.keep_clear_;
    config_.keep_clear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::KeepClearConfig& TrafficRuleConfig::_internal_keep_clear() const {
  return _internal_has_keep_clear()
      ? *config_.keep_clear_
      : *reinterpret_cast< ::apollo::planning::KeepClearConfig*>(&::apollo::planning::_KeepClearConfig_default_instance_);
}
inline const ::apollo::planning::KeepClearConfig& TrafficRuleConfig::keep_clear() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.keep_clear)
  return _internal_keep_clear();
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::_internal_mutable_keep_clear() {
  if (!_internal_has_keep_clear()) {
    clear_config();
    set_has_keep_clear();
    config_.keep_clear_ = CreateMaybeMessage< ::apollo::planning::KeepClearConfig >(
        GetArenaNoVirtual());
  }
  return config_.keep_clear_;
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::mutable_keep_clear() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.keep_clear)
  return _internal_mutable_keep_clear();
}

// optional .apollo.planning.ReferenceLineEndConfig reference_line_end = 8;
inline bool TrafficRuleConfig::_internal_has_reference_line_end() const {
  return config_case() == kReferenceLineEnd;
}
inline bool TrafficRuleConfig::has_reference_line_end() const {
  return _internal_has_reference_line_end();
}
inline void TrafficRuleConfig::set_has_reference_line_end() {
  _oneof_case_[0] = kReferenceLineEnd;
}
inline void TrafficRuleConfig::clear_reference_line_end() {
  if (_internal_has_reference_line_end()) {
    delete config_.reference_line_end_;
    clear_has_config();
  }
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::release_reference_line_end() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.reference_line_end)
  if (_internal_has_reference_line_end()) {
    clear_has_config();
      ::apollo::planning::ReferenceLineEndConfig* temp = config_.reference_line_end_;
    config_.reference_line_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ReferenceLineEndConfig& TrafficRuleConfig::_internal_reference_line_end() const {
  return _internal_has_reference_line_end()
      ? *config_.reference_line_end_
      : *reinterpret_cast< ::apollo::planning::ReferenceLineEndConfig*>(&::apollo::planning::_ReferenceLineEndConfig_default_instance_);
}
inline const ::apollo::planning::ReferenceLineEndConfig& TrafficRuleConfig::reference_line_end() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.reference_line_end)
  return _internal_reference_line_end();
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::_internal_mutable_reference_line_end() {
  if (!_internal_has_reference_line_end()) {
    clear_config();
    set_has_reference_line_end();
    config_.reference_line_end_ = CreateMaybeMessage< ::apollo::planning::ReferenceLineEndConfig >(
        GetArenaNoVirtual());
  }
  return config_.reference_line_end_;
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::mutable_reference_line_end() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.reference_line_end)
  return _internal_mutable_reference_line_end();
}

// optional .apollo.planning.ReroutingConfig rerouting = 9;
inline bool TrafficRuleConfig::_internal_has_rerouting() const {
  return config_case() == kRerouting;
}
inline bool TrafficRuleConfig::has_rerouting() const {
  return _internal_has_rerouting();
}
inline void TrafficRuleConfig::set_has_rerouting() {
  _oneof_case_[0] = kRerouting;
}
inline void TrafficRuleConfig::clear_rerouting() {
  if (_internal_has_rerouting()) {
    delete config_.rerouting_;
    clear_has_config();
  }
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::release_rerouting() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.rerouting)
  if (_internal_has_rerouting()) {
    clear_has_config();
      ::apollo::planning::ReroutingConfig* temp = config_.rerouting_;
    config_.rerouting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ReroutingConfig& TrafficRuleConfig::_internal_rerouting() const {
  return _internal_has_rerouting()
      ? *config_.rerouting_
      : *reinterpret_cast< ::apollo::planning::ReroutingConfig*>(&::apollo::planning::_ReroutingConfig_default_instance_);
}
inline const ::apollo::planning::ReroutingConfig& TrafficRuleConfig::rerouting() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.rerouting)
  return _internal_rerouting();
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::_internal_mutable_rerouting() {
  if (!_internal_has_rerouting()) {
    clear_config();
    set_has_rerouting();
    config_.rerouting_ = CreateMaybeMessage< ::apollo::planning::ReroutingConfig >(
        GetArenaNoVirtual());
  }
  return config_.rerouting_;
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::mutable_rerouting() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.rerouting)
  return _internal_mutable_rerouting();
}

// optional .apollo.planning.StopSignConfig stop_sign = 10;
inline bool TrafficRuleConfig::_internal_has_stop_sign() const {
  return config_case() == kStopSign;
}
inline bool TrafficRuleConfig::has_stop_sign() const {
  return _internal_has_stop_sign();
}
inline void TrafficRuleConfig::set_has_stop_sign() {
  _oneof_case_[0] = kStopSign;
}
inline void TrafficRuleConfig::clear_stop_sign() {
  if (_internal_has_stop_sign()) {
    delete config_.stop_sign_;
    clear_has_config();
  }
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::release_stop_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.stop_sign)
  if (_internal_has_stop_sign()) {
    clear_has_config();
      ::apollo::planning::StopSignConfig* temp = config_.stop_sign_;
    config_.stop_sign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::StopSignConfig& TrafficRuleConfig::_internal_stop_sign() const {
  return _internal_has_stop_sign()
      ? *config_.stop_sign_
      : *reinterpret_cast< ::apollo::planning::StopSignConfig*>(&::apollo::planning::_StopSignConfig_default_instance_);
}
inline const ::apollo::planning::StopSignConfig& TrafficRuleConfig::stop_sign() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.stop_sign)
  return _internal_stop_sign();
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::_internal_mutable_stop_sign() {
  if (!_internal_has_stop_sign()) {
    clear_config();
    set_has_stop_sign();
    config_.stop_sign_ = CreateMaybeMessage< ::apollo::planning::StopSignConfig >(
        GetArenaNoVirtual());
  }
  return config_.stop_sign_;
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::mutable_stop_sign() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.stop_sign)
  return _internal_mutable_stop_sign();
}

// optional .apollo.planning.TrafficLightConfig traffic_light = 11;
inline bool TrafficRuleConfig::_internal_has_traffic_light() const {
  return config_case() == kTrafficLight;
}
inline bool TrafficRuleConfig::has_traffic_light() const {
  return _internal_has_traffic_light();
}
inline void TrafficRuleConfig::set_has_traffic_light() {
  _oneof_case_[0] = kTrafficLight;
}
inline void TrafficRuleConfig::clear_traffic_light() {
  if (_internal_has_traffic_light()) {
    delete config_.traffic_light_;
    clear_has_config();
  }
}
inline ::apollo::planning::TrafficLightConfig* TrafficRuleConfig::release_traffic_light() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.traffic_light)
  if (_internal_has_traffic_light()) {
    clear_has_config();
      ::apollo::planning::TrafficLightConfig* temp = config_.traffic_light_;
    config_.traffic_light_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::TrafficLightConfig& TrafficRuleConfig::_internal_traffic_light() const {
  return _internal_has_traffic_light()
      ? *config_.traffic_light_
      : *reinterpret_cast< ::apollo::planning::TrafficLightConfig*>(&::apollo::planning::_TrafficLightConfig_default_instance_);
}
inline const ::apollo::planning::TrafficLightConfig& TrafficRuleConfig::traffic_light() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.traffic_light)
  return _internal_traffic_light();
}
inline ::apollo::planning::TrafficLightConfig* TrafficRuleConfig::_internal_mutable_traffic_light() {
  if (!_internal_has_traffic_light()) {
    clear_config();
    set_has_traffic_light();
    config_.traffic_light_ = CreateMaybeMessage< ::apollo::planning::TrafficLightConfig >(
        GetArenaNoVirtual());
  }
  return config_.traffic_light_;
}
inline ::apollo::planning::TrafficLightConfig* TrafficRuleConfig::mutable_traffic_light() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.traffic_light)
  return _internal_mutable_traffic_light();
}

inline bool TrafficRuleConfig::has_config() const {
  return config_case() != CONFIG_NOT_SET;
}
inline void TrafficRuleConfig::clear_has_config() {
  _oneof_case_[0] = CONFIG_NOT_SET;
}
inline TrafficRuleConfig::ConfigCase TrafficRuleConfig::config_case() const {
  return TrafficRuleConfig::ConfigCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TrafficRuleConfigs

// repeated .apollo.planning.TrafficRuleConfig config = 1;
inline int TrafficRuleConfigs::_internal_config_size() const {
  return config_.size();
}
inline int TrafficRuleConfigs::config_size() const {
  return _internal_config_size();
}
inline void TrafficRuleConfigs::clear_config() {
  config_.Clear();
}
inline ::apollo::planning::TrafficRuleConfig* TrafficRuleConfigs::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfigs.config)
  return config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >*
TrafficRuleConfigs::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.TrafficRuleConfigs.config)
  return &config_;
}
inline const ::apollo::planning::TrafficRuleConfig& TrafficRuleConfigs::_internal_config(int index) const {
  return config_.Get(index);
}
inline const ::apollo::planning::TrafficRuleConfig& TrafficRuleConfigs::config(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfigs.config)
  return _internal_config(index);
}
inline ::apollo::planning::TrafficRuleConfig* TrafficRuleConfigs::_internal_add_config() {
  return config_.Add();
}
inline ::apollo::planning::TrafficRuleConfig* TrafficRuleConfigs::add_config() {
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficRuleConfigs.config)
  return _internal_add_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >&
TrafficRuleConfigs::config() const {
  // @@protoc_insertion_point(field_list:apollo.planning.TrafficRuleConfigs.config)
  return config_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::planning::TrafficRuleConfig_RuleId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::TrafficRuleConfig_RuleId>() {
  return ::apollo::planning::TrafficRuleConfig_RuleId_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto
