// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/planning_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/planning/proto/decider_config.pb.h"
#include "modules/planning/proto/dp_st_speed_config.pb.h"
#include "modules/planning/proto/lane_change_decider_config.pb.h"
#include "modules/planning/proto/open_space_fallback_decider_config.pb.h"
#include "modules/planning/proto/open_space_pre_stop_decider_config.pb.h"
#include "modules/planning/proto/open_space_roi_decider_config.pb.h"
#include "modules/planning/proto/open_space_trajectory_provider_config.pb.h"
#include "modules/planning/proto/open_space_trajectory_partition_config.pb.h"
#include "modules/planning/proto/path_assessment_decider_config.pb.h"
#include "modules/planning/proto/path_bounds_decider_config.pb.h"
#include "modules/planning/proto/path_lane_borrow_decider_config.pb.h"
#include "modules/planning/proto/piecewise_jerk_path_config.pb.h"
#include "modules/planning/proto/piecewise_jerk_speed_config.pb.h"
#include "modules/planning/proto/proceed_with_caution_speed_config.pb.h"
#include "modules/planning/proto/rule_based_stop_decider_config.pb.h"
#include "modules/planning/proto/speed_bounds_decider_config.pb.h"
#include "modules/planning/proto/navi_path_decider_config.pb.h"
#include "modules/planning/proto/navi_speed_decider_config.pb.h"
#include "modules/planning/proto/navi_obstacle_decider_config.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[19]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
namespace apollo {
namespace planning {
class NavigationPlanningConfig;
class NavigationPlanningConfigDefaultTypeInternal;
extern NavigationPlanningConfigDefaultTypeInternal _NavigationPlanningConfig_default_instance_;
class PathDeciderConfig;
class PathDeciderConfigDefaultTypeInternal;
extern PathDeciderConfigDefaultTypeInternal _PathDeciderConfig_default_instance_;
class PlannerNaviConfig;
class PlannerNaviConfigDefaultTypeInternal;
extern PlannerNaviConfigDefaultTypeInternal _PlannerNaviConfig_default_instance_;
class PlannerPublicRoadConfig;
class PlannerPublicRoadConfigDefaultTypeInternal;
extern PlannerPublicRoadConfigDefaultTypeInternal _PlannerPublicRoadConfig_default_instance_;
class PlanningConfig;
class PlanningConfigDefaultTypeInternal;
extern PlanningConfigDefaultTypeInternal _PlanningConfig_default_instance_;
class RtkPlanningConfig;
class RtkPlanningConfigDefaultTypeInternal;
extern RtkPlanningConfigDefaultTypeInternal _RtkPlanningConfig_default_instance_;
class ScenarioBareIntersectionUnprotectedConfig;
class ScenarioBareIntersectionUnprotectedConfigDefaultTypeInternal;
extern ScenarioBareIntersectionUnprotectedConfigDefaultTypeInternal _ScenarioBareIntersectionUnprotectedConfig_default_instance_;
class ScenarioConfig;
class ScenarioConfigDefaultTypeInternal;
extern ScenarioConfigDefaultTypeInternal _ScenarioConfig_default_instance_;
class ScenarioConfig_StageConfig;
class ScenarioConfig_StageConfigDefaultTypeInternal;
extern ScenarioConfig_StageConfigDefaultTypeInternal _ScenarioConfig_StageConfig_default_instance_;
class ScenarioLaneFollowConfig;
class ScenarioLaneFollowConfigDefaultTypeInternal;
extern ScenarioLaneFollowConfigDefaultTypeInternal _ScenarioLaneFollowConfig_default_instance_;
class ScenarioNarrowStreetUTurnConfig;
class ScenarioNarrowStreetUTurnConfigDefaultTypeInternal;
extern ScenarioNarrowStreetUTurnConfigDefaultTypeInternal _ScenarioNarrowStreetUTurnConfig_default_instance_;
class ScenarioPullOverConfig;
class ScenarioPullOverConfigDefaultTypeInternal;
extern ScenarioPullOverConfigDefaultTypeInternal _ScenarioPullOverConfig_default_instance_;
class ScenarioStopSignUnprotectedConfig;
class ScenarioStopSignUnprotectedConfigDefaultTypeInternal;
extern ScenarioStopSignUnprotectedConfigDefaultTypeInternal _ScenarioStopSignUnprotectedConfig_default_instance_;
class ScenarioTrafficLightProtectedConfig;
class ScenarioTrafficLightProtectedConfigDefaultTypeInternal;
extern ScenarioTrafficLightProtectedConfigDefaultTypeInternal _ScenarioTrafficLightProtectedConfig_default_instance_;
class ScenarioTrafficLightUnprotectedLeftTurnConfig;
class ScenarioTrafficLightUnprotectedLeftTurnConfigDefaultTypeInternal;
extern ScenarioTrafficLightUnprotectedLeftTurnConfigDefaultTypeInternal _ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_;
class ScenarioTrafficLightUnprotectedRightTurnConfig;
class ScenarioTrafficLightUnprotectedRightTurnConfigDefaultTypeInternal;
extern ScenarioTrafficLightUnprotectedRightTurnConfigDefaultTypeInternal _ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_;
class ScenarioValetParkingConfig;
class ScenarioValetParkingConfigDefaultTypeInternal;
extern ScenarioValetParkingConfigDefaultTypeInternal _ScenarioValetParkingConfig_default_instance_;
class StandardPlanningConfig;
class StandardPlanningConfigDefaultTypeInternal;
extern StandardPlanningConfigDefaultTypeInternal _StandardPlanningConfig_default_instance_;
class TaskConfig;
class TaskConfigDefaultTypeInternal;
extern TaskConfigDefaultTypeInternal _TaskConfig_default_instance_;
}  // namespace planning
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::planning::NavigationPlanningConfig* Arena::CreateMaybeMessage<::apollo::planning::NavigationPlanningConfig>(Arena*);
template<> ::apollo::planning::PathDeciderConfig* Arena::CreateMaybeMessage<::apollo::planning::PathDeciderConfig>(Arena*);
template<> ::apollo::planning::PlannerNaviConfig* Arena::CreateMaybeMessage<::apollo::planning::PlannerNaviConfig>(Arena*);
template<> ::apollo::planning::PlannerPublicRoadConfig* Arena::CreateMaybeMessage<::apollo::planning::PlannerPublicRoadConfig>(Arena*);
template<> ::apollo::planning::PlanningConfig* Arena::CreateMaybeMessage<::apollo::planning::PlanningConfig>(Arena*);
template<> ::apollo::planning::RtkPlanningConfig* Arena::CreateMaybeMessage<::apollo::planning::RtkPlanningConfig>(Arena*);
template<> ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioBareIntersectionUnprotectedConfig>(Arena*);
template<> ::apollo::planning::ScenarioConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioConfig>(Arena*);
template<> ::apollo::planning::ScenarioConfig_StageConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioConfig_StageConfig>(Arena*);
template<> ::apollo::planning::ScenarioLaneFollowConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioLaneFollowConfig>(Arena*);
template<> ::apollo::planning::ScenarioNarrowStreetUTurnConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioNarrowStreetUTurnConfig>(Arena*);
template<> ::apollo::planning::ScenarioPullOverConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioPullOverConfig>(Arena*);
template<> ::apollo::planning::ScenarioStopSignUnprotectedConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioStopSignUnprotectedConfig>(Arena*);
template<> ::apollo::planning::ScenarioTrafficLightProtectedConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioTrafficLightProtectedConfig>(Arena*);
template<> ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig>(Arena*);
template<> ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig>(Arena*);
template<> ::apollo::planning::ScenarioValetParkingConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioValetParkingConfig>(Arena*);
template<> ::apollo::planning::StandardPlanningConfig* Arena::CreateMaybeMessage<::apollo::planning::StandardPlanningConfig>(Arena*);
template<> ::apollo::planning::TaskConfig* Arena::CreateMaybeMessage<::apollo::planning::TaskConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace planning {

enum TaskConfig_TaskType : int {
  TaskConfig_TaskType_DP_ST_SPEED_OPTIMIZER = 1,
  TaskConfig_TaskType_PATH_DECIDER = 4,
  TaskConfig_TaskType_SPEED_DECIDER = 5,
  TaskConfig_TaskType_NAVI_PATH_DECIDER = 7,
  TaskConfig_TaskType_NAVI_SPEED_DECIDER = 8,
  TaskConfig_TaskType_NAVI_OBSTACLE_DECIDER = 9,
  TaskConfig_TaskType_CREEP_DECIDER = 11,
  TaskConfig_TaskType_OPEN_SPACE_PRE_STOP_DECIDER = 12,
  TaskConfig_TaskType_PROCEED_WITH_CAUTION_SPEED = 15,
  TaskConfig_TaskType_DECIDER_RSS = 16,
  TaskConfig_TaskType_SPEED_BOUNDS_PRIORI_DECIDER = 17,
  TaskConfig_TaskType_SPEED_BOUNDS_FINAL_DECIDER = 18,
  TaskConfig_TaskType_PIECEWISE_JERK_PATH_OPTIMIZER = 19,
  TaskConfig_TaskType_PATH_BOUNDS_DECIDER = 20,
  TaskConfig_TaskType_OPEN_SPACE_ROI_DECIDER = 21,
  TaskConfig_TaskType_OPEN_SPACE_TRAJECTORY_PROVIDER = 22,
  TaskConfig_TaskType_OPEN_SPACE_TRAJECTORY_PARTITION = 23,
  TaskConfig_TaskType_OPEN_SPACE_FALLBACK_DECIDER = 24,
  TaskConfig_TaskType_PATH_ASSESSMENT_DECIDER = 25,
  TaskConfig_TaskType_PATH_LANE_BORROW_DECIDER = 26,
  TaskConfig_TaskType_PIECEWISE_JERK_SPEED_OPTIMIZER = 27,
  TaskConfig_TaskType_LANE_CHANGE_DECIDER = 28,
  TaskConfig_TaskType_RULE_BASED_STOP_DECIDER = 29
};
bool TaskConfig_TaskType_IsValid(int value);
constexpr TaskConfig_TaskType TaskConfig_TaskType_TaskType_MIN = TaskConfig_TaskType_DP_ST_SPEED_OPTIMIZER;
constexpr TaskConfig_TaskType TaskConfig_TaskType_TaskType_MAX = TaskConfig_TaskType_RULE_BASED_STOP_DECIDER;
constexpr int TaskConfig_TaskType_TaskType_ARRAYSIZE = TaskConfig_TaskType_TaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskConfig_TaskType_descriptor();
template<typename T>
inline const std::string& TaskConfig_TaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskConfig_TaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskConfig_TaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskConfig_TaskType_descriptor(), enum_t_value);
}
inline bool TaskConfig_TaskType_Parse(
    const std::string& name, TaskConfig_TaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskConfig_TaskType>(
    TaskConfig_TaskType_descriptor(), name, value);
}
enum ScenarioConfig_ScenarioType : int {
  ScenarioConfig_ScenarioType_LANE_FOLLOW = 0,
  ScenarioConfig_ScenarioType_CHANGE_LANE = 1,
  ScenarioConfig_ScenarioType_BARE_INTERSECTION_UNPROTECTED = 3,
  ScenarioConfig_ScenarioType_STOP_SIGN_PROTECTED = 4,
  ScenarioConfig_ScenarioType_STOP_SIGN_UNPROTECTED = 5,
  ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_PROTECTED = 6,
  ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN = 7,
  ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN = 8,
  ScenarioConfig_ScenarioType_YIELD_SIGN_UNPROTECTED = 9,
  ScenarioConfig_ScenarioType_PULL_OVER = 10,
  ScenarioConfig_ScenarioType_VALET_PARKING = 11,
  ScenarioConfig_ScenarioType_NARROW_STREET_U_TURN = 12
};
bool ScenarioConfig_ScenarioType_IsValid(int value);
constexpr ScenarioConfig_ScenarioType ScenarioConfig_ScenarioType_ScenarioType_MIN = ScenarioConfig_ScenarioType_LANE_FOLLOW;
constexpr ScenarioConfig_ScenarioType ScenarioConfig_ScenarioType_ScenarioType_MAX = ScenarioConfig_ScenarioType_NARROW_STREET_U_TURN;
constexpr int ScenarioConfig_ScenarioType_ScenarioType_ARRAYSIZE = ScenarioConfig_ScenarioType_ScenarioType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScenarioConfig_ScenarioType_descriptor();
template<typename T>
inline const std::string& ScenarioConfig_ScenarioType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScenarioConfig_ScenarioType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScenarioConfig_ScenarioType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ScenarioConfig_ScenarioType_descriptor(), enum_t_value);
}
inline bool ScenarioConfig_ScenarioType_Parse(
    const std::string& name, ScenarioConfig_ScenarioType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScenarioConfig_ScenarioType>(
    ScenarioConfig_ScenarioType_descriptor(), name, value);
}
enum ScenarioConfig_StageType : int {
  ScenarioConfig_StageType_NO_STAGE = 0,
  ScenarioConfig_StageType_LANE_FOLLOW_DEFAULT_STAGE = 1,
  ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_APPROACH = 200,
  ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_CREEP = 201,
  ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_INTERSECTION_CRUISE = 202,
  ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_PRE_STOP = 300,
  ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_STOP = 301,
  ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_CREEP = 302,
  ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_INTERSECTION_CRUISE = 303,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_PROTECTED_APPROACH = 400,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_PROTECTED_INTERSECTION_CRUISE = 401,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_CREEP = 410,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_INTERSECTION_CRUISE = 411,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_STOP = 420,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_CREEP = 421,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_INTERSECTION_CRUISE = 422,
  ScenarioConfig_StageType_PULL_OVER_APPROACH = 500,
  ScenarioConfig_StageType_PULL_OVER_RETRY_APPROACH_PARKING = 501,
  ScenarioConfig_StageType_PULL_OVER_RETRY_PARKING = 502,
  ScenarioConfig_StageType_VALET_PARKING_APPROACHING_PARKING_SPOT = 510,
  ScenarioConfig_StageType_VALET_PARKING_PARKING = 511
};
bool ScenarioConfig_StageType_IsValid(int value);
constexpr ScenarioConfig_StageType ScenarioConfig_StageType_StageType_MIN = ScenarioConfig_StageType_NO_STAGE;
constexpr ScenarioConfig_StageType ScenarioConfig_StageType_StageType_MAX = ScenarioConfig_StageType_VALET_PARKING_PARKING;
constexpr int ScenarioConfig_StageType_StageType_ARRAYSIZE = ScenarioConfig_StageType_StageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScenarioConfig_StageType_descriptor();
template<typename T>
inline const std::string& ScenarioConfig_StageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScenarioConfig_StageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScenarioConfig_StageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ScenarioConfig_StageType_descriptor(), enum_t_value);
}
inline bool ScenarioConfig_StageType_Parse(
    const std::string& name, ScenarioConfig_StageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScenarioConfig_StageType>(
    ScenarioConfig_StageType_descriptor(), name, value);
}
enum PlannerType : int {
  RTK = 0,
  PUBLIC_ROAD = 1,
  NAVI = 2,
  LATTICE = 3
};
bool PlannerType_IsValid(int value);
constexpr PlannerType PlannerType_MIN = RTK;
constexpr PlannerType PlannerType_MAX = LATTICE;
constexpr int PlannerType_ARRAYSIZE = PlannerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlannerType_descriptor();
template<typename T>
inline const std::string& PlannerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlannerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlannerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlannerType_descriptor(), enum_t_value);
}
inline bool PlannerType_Parse(
    const std::string& name, PlannerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlannerType>(
    PlannerType_descriptor(), name, value);
}
// ===================================================================

class PathDeciderConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PathDeciderConfig) */ {
 public:
  PathDeciderConfig();
  virtual ~PathDeciderConfig();

  PathDeciderConfig(const PathDeciderConfig& from);
  PathDeciderConfig(PathDeciderConfig&& from) noexcept
    : PathDeciderConfig() {
    *this = ::std::move(from);
  }

  inline PathDeciderConfig& operator=(const PathDeciderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathDeciderConfig& operator=(PathDeciderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PathDeciderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathDeciderConfig* internal_default_instance() {
    return reinterpret_cast<const PathDeciderConfig*>(
               &_PathDeciderConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PathDeciderConfig& a, PathDeciderConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PathDeciderConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PathDeciderConfig* New() const final {
    return CreateMaybeMessage<PathDeciderConfig>(nullptr);
  }

  PathDeciderConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PathDeciderConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PathDeciderConfig& from);
  void MergeFrom(const PathDeciderConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathDeciderConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PathDeciderConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.planning.PathDeciderConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TaskConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TaskConfig) */ {
 public:
  TaskConfig();
  virtual ~TaskConfig();

  TaskConfig(const TaskConfig& from);
  TaskConfig(TaskConfig&& from) noexcept
    : TaskConfig() {
    *this = ::std::move(from);
  }

  inline TaskConfig& operator=(const TaskConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskConfig& operator=(TaskConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaskConfig& default_instance();

  enum TaskConfigCase {
    kDpStSpeedConfig = 3,
    kPathDeciderConfig = 7,
    kProceedWithCautionSpeedConfig = 8,
    kCreepDeciderConfig = 10,
    kOpenSpacePreStopDeciderConfig = 11,
    kSpeedBoundsDeciderConfig = 15,
    kPiecewiseJerkPathConfig = 16,
    kPathBoundsDeciderConfig = 17,
    kOpenSpaceFallbackDeciderConfig = 18,
    kOpenSpaceRoiDeciderConfig = 19,
    kOpenSpaceTrajectoryProviderConfig = 20,
    kOpenSpaceTrajectoryPartitionConfig = 21,
    kPathAssessmentDeciderConfig = 22,
    kPiecewiseJerkSpeedConfig = 23,
    kPathLaneBorrowDeciderConfig = 24,
    kLaneChangeDeciderConfig = 25,
    kRuleBasedStopDeciderConfig = 26,
    TASK_CONFIG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskConfig* internal_default_instance() {
    return reinterpret_cast<const TaskConfig*>(
               &_TaskConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TaskConfig& a, TaskConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskConfig* New() const final {
    return CreateMaybeMessage<TaskConfig>(nullptr);
  }

  TaskConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaskConfig& from);
  void MergeFrom(const TaskConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TaskConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TaskConfig_TaskType TaskType;
  static constexpr TaskType DP_ST_SPEED_OPTIMIZER =
    TaskConfig_TaskType_DP_ST_SPEED_OPTIMIZER;
  static constexpr TaskType PATH_DECIDER =
    TaskConfig_TaskType_PATH_DECIDER;
  static constexpr TaskType SPEED_DECIDER =
    TaskConfig_TaskType_SPEED_DECIDER;
  static constexpr TaskType NAVI_PATH_DECIDER =
    TaskConfig_TaskType_NAVI_PATH_DECIDER;
  static constexpr TaskType NAVI_SPEED_DECIDER =
    TaskConfig_TaskType_NAVI_SPEED_DECIDER;
  static constexpr TaskType NAVI_OBSTACLE_DECIDER =
    TaskConfig_TaskType_NAVI_OBSTACLE_DECIDER;
  static constexpr TaskType CREEP_DECIDER =
    TaskConfig_TaskType_CREEP_DECIDER;
  static constexpr TaskType OPEN_SPACE_PRE_STOP_DECIDER =
    TaskConfig_TaskType_OPEN_SPACE_PRE_STOP_DECIDER;
  static constexpr TaskType PROCEED_WITH_CAUTION_SPEED =
    TaskConfig_TaskType_PROCEED_WITH_CAUTION_SPEED;
  static constexpr TaskType DECIDER_RSS =
    TaskConfig_TaskType_DECIDER_RSS;
  static constexpr TaskType SPEED_BOUNDS_PRIORI_DECIDER =
    TaskConfig_TaskType_SPEED_BOUNDS_PRIORI_DECIDER;
  static constexpr TaskType SPEED_BOUNDS_FINAL_DECIDER =
    TaskConfig_TaskType_SPEED_BOUNDS_FINAL_DECIDER;
  static constexpr TaskType PIECEWISE_JERK_PATH_OPTIMIZER =
    TaskConfig_TaskType_PIECEWISE_JERK_PATH_OPTIMIZER;
  static constexpr TaskType PATH_BOUNDS_DECIDER =
    TaskConfig_TaskType_PATH_BOUNDS_DECIDER;
  static constexpr TaskType OPEN_SPACE_ROI_DECIDER =
    TaskConfig_TaskType_OPEN_SPACE_ROI_DECIDER;
  static constexpr TaskType OPEN_SPACE_TRAJECTORY_PROVIDER =
    TaskConfig_TaskType_OPEN_SPACE_TRAJECTORY_PROVIDER;
  static constexpr TaskType OPEN_SPACE_TRAJECTORY_PARTITION =
    TaskConfig_TaskType_OPEN_SPACE_TRAJECTORY_PARTITION;
  static constexpr TaskType OPEN_SPACE_FALLBACK_DECIDER =
    TaskConfig_TaskType_OPEN_SPACE_FALLBACK_DECIDER;
  static constexpr TaskType PATH_ASSESSMENT_DECIDER =
    TaskConfig_TaskType_PATH_ASSESSMENT_DECIDER;
  static constexpr TaskType PATH_LANE_BORROW_DECIDER =
    TaskConfig_TaskType_PATH_LANE_BORROW_DECIDER;
  static constexpr TaskType PIECEWISE_JERK_SPEED_OPTIMIZER =
    TaskConfig_TaskType_PIECEWISE_JERK_SPEED_OPTIMIZER;
  static constexpr TaskType LANE_CHANGE_DECIDER =
    TaskConfig_TaskType_LANE_CHANGE_DECIDER;
  static constexpr TaskType RULE_BASED_STOP_DECIDER =
    TaskConfig_TaskType_RULE_BASED_STOP_DECIDER;
  static inline bool TaskType_IsValid(int value) {
    return TaskConfig_TaskType_IsValid(value);
  }
  static constexpr TaskType TaskType_MIN =
    TaskConfig_TaskType_TaskType_MIN;
  static constexpr TaskType TaskType_MAX =
    TaskConfig_TaskType_TaskType_MAX;
  static constexpr int TaskType_ARRAYSIZE =
    TaskConfig_TaskType_TaskType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TaskType_descriptor() {
    return TaskConfig_TaskType_descriptor();
  }
  template<typename T>
  static inline const std::string& TaskType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TaskType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TaskType_Name.");
    return TaskConfig_TaskType_Name(enum_t_value);
  }
  static inline bool TaskType_Parse(const std::string& name,
      TaskType* value) {
    return TaskConfig_TaskType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTaskTypeFieldNumber = 1,
    kDpStSpeedConfigFieldNumber = 3,
    kPathDeciderConfigFieldNumber = 7,
    kProceedWithCautionSpeedConfigFieldNumber = 8,
    kCreepDeciderConfigFieldNumber = 10,
    kOpenSpacePreStopDeciderConfigFieldNumber = 11,
    kSpeedBoundsDeciderConfigFieldNumber = 15,
    kPiecewiseJerkPathConfigFieldNumber = 16,
    kPathBoundsDeciderConfigFieldNumber = 17,
    kOpenSpaceFallbackDeciderConfigFieldNumber = 18,
    kOpenSpaceRoiDeciderConfigFieldNumber = 19,
    kOpenSpaceTrajectoryProviderConfigFieldNumber = 20,
    kOpenSpaceTrajectoryPartitionConfigFieldNumber = 21,
    kPathAssessmentDeciderConfigFieldNumber = 22,
    kPiecewiseJerkSpeedConfigFieldNumber = 23,
    kPathLaneBorrowDeciderConfigFieldNumber = 24,
    kLaneChangeDeciderConfigFieldNumber = 25,
    kRuleBasedStopDeciderConfigFieldNumber = 26,
  };
  // optional .apollo.planning.TaskConfig.TaskType task_type = 1;
  bool has_task_type() const;
  private:
  bool _internal_has_task_type() const;
  public:
  void clear_task_type();
  ::apollo::planning::TaskConfig_TaskType task_type() const;
  void set_task_type(::apollo::planning::TaskConfig_TaskType value);
  private:
  ::apollo::planning::TaskConfig_TaskType _internal_task_type() const;
  void _internal_set_task_type(::apollo::planning::TaskConfig_TaskType value);
  public:

  // optional .apollo.planning.DpStSpeedConfig dp_st_speed_config = 3;
  bool has_dp_st_speed_config() const;
  private:
  bool _internal_has_dp_st_speed_config() const;
  public:
  void clear_dp_st_speed_config();
  const ::apollo::planning::DpStSpeedConfig& dp_st_speed_config() const;
  ::apollo::planning::DpStSpeedConfig* release_dp_st_speed_config();
  ::apollo::planning::DpStSpeedConfig* mutable_dp_st_speed_config();
  void set_allocated_dp_st_speed_config(::apollo::planning::DpStSpeedConfig* dp_st_speed_config);
  private:
  const ::apollo::planning::DpStSpeedConfig& _internal_dp_st_speed_config() const;
  ::apollo::planning::DpStSpeedConfig* _internal_mutable_dp_st_speed_config();
  public:

  // optional .apollo.planning.PathDeciderConfig path_decider_config = 7;
  bool has_path_decider_config() const;
  private:
  bool _internal_has_path_decider_config() const;
  public:
  void clear_path_decider_config();
  const ::apollo::planning::PathDeciderConfig& path_decider_config() const;
  ::apollo::planning::PathDeciderConfig* release_path_decider_config();
  ::apollo::planning::PathDeciderConfig* mutable_path_decider_config();
  void set_allocated_path_decider_config(::apollo::planning::PathDeciderConfig* path_decider_config);
  private:
  const ::apollo::planning::PathDeciderConfig& _internal_path_decider_config() const;
  ::apollo::planning::PathDeciderConfig* _internal_mutable_path_decider_config();
  public:

  // optional .apollo.planning.ProceedWithCautionSpeedConfig proceed_with_caution_speed_config = 8;
  bool has_proceed_with_caution_speed_config() const;
  private:
  bool _internal_has_proceed_with_caution_speed_config() const;
  public:
  void clear_proceed_with_caution_speed_config();
  const ::apollo::planning::ProceedWithCautionSpeedConfig& proceed_with_caution_speed_config() const;
  ::apollo::planning::ProceedWithCautionSpeedConfig* release_proceed_with_caution_speed_config();
  ::apollo::planning::ProceedWithCautionSpeedConfig* mutable_proceed_with_caution_speed_config();
  void set_allocated_proceed_with_caution_speed_config(::apollo::planning::ProceedWithCautionSpeedConfig* proceed_with_caution_speed_config);
  private:
  const ::apollo::planning::ProceedWithCautionSpeedConfig& _internal_proceed_with_caution_speed_config() const;
  ::apollo::planning::ProceedWithCautionSpeedConfig* _internal_mutable_proceed_with_caution_speed_config();
  public:

  // optional .apollo.planning.CreepDeciderConfig creep_decider_config = 10;
  bool has_creep_decider_config() const;
  private:
  bool _internal_has_creep_decider_config() const;
  public:
  void clear_creep_decider_config();
  const ::apollo::planning::CreepDeciderConfig& creep_decider_config() const;
  ::apollo::planning::CreepDeciderConfig* release_creep_decider_config();
  ::apollo::planning::CreepDeciderConfig* mutable_creep_decider_config();
  void set_allocated_creep_decider_config(::apollo::planning::CreepDeciderConfig* creep_decider_config);
  private:
  const ::apollo::planning::CreepDeciderConfig& _internal_creep_decider_config() const;
  ::apollo::planning::CreepDeciderConfig* _internal_mutable_creep_decider_config();
  public:

  // optional .apollo.planning.OpenSpacePreStopDeciderConfig open_space_pre_stop_decider_config = 11;
  bool has_open_space_pre_stop_decider_config() const;
  private:
  bool _internal_has_open_space_pre_stop_decider_config() const;
  public:
  void clear_open_space_pre_stop_decider_config();
  const ::apollo::planning::OpenSpacePreStopDeciderConfig& open_space_pre_stop_decider_config() const;
  ::apollo::planning::OpenSpacePreStopDeciderConfig* release_open_space_pre_stop_decider_config();
  ::apollo::planning::OpenSpacePreStopDeciderConfig* mutable_open_space_pre_stop_decider_config();
  void set_allocated_open_space_pre_stop_decider_config(::apollo::planning::OpenSpacePreStopDeciderConfig* open_space_pre_stop_decider_config);
  private:
  const ::apollo::planning::OpenSpacePreStopDeciderConfig& _internal_open_space_pre_stop_decider_config() const;
  ::apollo::planning::OpenSpacePreStopDeciderConfig* _internal_mutable_open_space_pre_stop_decider_config();
  public:

  // optional .apollo.planning.SpeedBoundsDeciderConfig speed_bounds_decider_config = 15;
  bool has_speed_bounds_decider_config() const;
  private:
  bool _internal_has_speed_bounds_decider_config() const;
  public:
  void clear_speed_bounds_decider_config();
  const ::apollo::planning::SpeedBoundsDeciderConfig& speed_bounds_decider_config() const;
  ::apollo::planning::SpeedBoundsDeciderConfig* release_speed_bounds_decider_config();
  ::apollo::planning::SpeedBoundsDeciderConfig* mutable_speed_bounds_decider_config();
  void set_allocated_speed_bounds_decider_config(::apollo::planning::SpeedBoundsDeciderConfig* speed_bounds_decider_config);
  private:
  const ::apollo::planning::SpeedBoundsDeciderConfig& _internal_speed_bounds_decider_config() const;
  ::apollo::planning::SpeedBoundsDeciderConfig* _internal_mutable_speed_bounds_decider_config();
  public:

  // optional .apollo.planning.PiecewiseJerkPathConfig piecewise_jerk_path_config = 16;
  bool has_piecewise_jerk_path_config() const;
  private:
  bool _internal_has_piecewise_jerk_path_config() const;
  public:
  void clear_piecewise_jerk_path_config();
  const ::apollo::planning::PiecewiseJerkPathConfig& piecewise_jerk_path_config() const;
  ::apollo::planning::PiecewiseJerkPathConfig* release_piecewise_jerk_path_config();
  ::apollo::planning::PiecewiseJerkPathConfig* mutable_piecewise_jerk_path_config();
  void set_allocated_piecewise_jerk_path_config(::apollo::planning::PiecewiseJerkPathConfig* piecewise_jerk_path_config);
  private:
  const ::apollo::planning::PiecewiseJerkPathConfig& _internal_piecewise_jerk_path_config() const;
  ::apollo::planning::PiecewiseJerkPathConfig* _internal_mutable_piecewise_jerk_path_config();
  public:

  // optional .apollo.planning.PathBoundsDeciderConfig path_bounds_decider_config = 17;
  bool has_path_bounds_decider_config() const;
  private:
  bool _internal_has_path_bounds_decider_config() const;
  public:
  void clear_path_bounds_decider_config();
  const ::apollo::planning::PathBoundsDeciderConfig& path_bounds_decider_config() const;
  ::apollo::planning::PathBoundsDeciderConfig* release_path_bounds_decider_config();
  ::apollo::planning::PathBoundsDeciderConfig* mutable_path_bounds_decider_config();
  void set_allocated_path_bounds_decider_config(::apollo::planning::PathBoundsDeciderConfig* path_bounds_decider_config);
  private:
  const ::apollo::planning::PathBoundsDeciderConfig& _internal_path_bounds_decider_config() const;
  ::apollo::planning::PathBoundsDeciderConfig* _internal_mutable_path_bounds_decider_config();
  public:

  // optional .apollo.planning.OpenSpaceFallBackDeciderConfig open_space_fallback_decider_config = 18;
  bool has_open_space_fallback_decider_config() const;
  private:
  bool _internal_has_open_space_fallback_decider_config() const;
  public:
  void clear_open_space_fallback_decider_config();
  const ::apollo::planning::OpenSpaceFallBackDeciderConfig& open_space_fallback_decider_config() const;
  ::apollo::planning::OpenSpaceFallBackDeciderConfig* release_open_space_fallback_decider_config();
  ::apollo::planning::OpenSpaceFallBackDeciderConfig* mutable_open_space_fallback_decider_config();
  void set_allocated_open_space_fallback_decider_config(::apollo::planning::OpenSpaceFallBackDeciderConfig* open_space_fallback_decider_config);
  private:
  const ::apollo::planning::OpenSpaceFallBackDeciderConfig& _internal_open_space_fallback_decider_config() const;
  ::apollo::planning::OpenSpaceFallBackDeciderConfig* _internal_mutable_open_space_fallback_decider_config();
  public:

  // optional .apollo.planning.OpenSpaceRoiDeciderConfig open_space_roi_decider_config = 19;
  bool has_open_space_roi_decider_config() const;
  private:
  bool _internal_has_open_space_roi_decider_config() const;
  public:
  void clear_open_space_roi_decider_config();
  const ::apollo::planning::OpenSpaceRoiDeciderConfig& open_space_roi_decider_config() const;
  ::apollo::planning::OpenSpaceRoiDeciderConfig* release_open_space_roi_decider_config();
  ::apollo::planning::OpenSpaceRoiDeciderConfig* mutable_open_space_roi_decider_config();
  void set_allocated_open_space_roi_decider_config(::apollo::planning::OpenSpaceRoiDeciderConfig* open_space_roi_decider_config);
  private:
  const ::apollo::planning::OpenSpaceRoiDeciderConfig& _internal_open_space_roi_decider_config() const;
  ::apollo::planning::OpenSpaceRoiDeciderConfig* _internal_mutable_open_space_roi_decider_config();
  public:

  // optional .apollo.planning.OpenSpaceTrajectoryProviderConfig open_space_trajectory_provider_config = 20;
  bool has_open_space_trajectory_provider_config() const;
  private:
  bool _internal_has_open_space_trajectory_provider_config() const;
  public:
  void clear_open_space_trajectory_provider_config();
  const ::apollo::planning::OpenSpaceTrajectoryProviderConfig& open_space_trajectory_provider_config() const;
  ::apollo::planning::OpenSpaceTrajectoryProviderConfig* release_open_space_trajectory_provider_config();
  ::apollo::planning::OpenSpaceTrajectoryProviderConfig* mutable_open_space_trajectory_provider_config();
  void set_allocated_open_space_trajectory_provider_config(::apollo::planning::OpenSpaceTrajectoryProviderConfig* open_space_trajectory_provider_config);
  private:
  const ::apollo::planning::OpenSpaceTrajectoryProviderConfig& _internal_open_space_trajectory_provider_config() const;
  ::apollo::planning::OpenSpaceTrajectoryProviderConfig* _internal_mutable_open_space_trajectory_provider_config();
  public:

  // optional .apollo.planning.OpenSpaceTrajectoryPartitionConfig open_space_trajectory_partition_config = 21;
  bool has_open_space_trajectory_partition_config() const;
  private:
  bool _internal_has_open_space_trajectory_partition_config() const;
  public:
  void clear_open_space_trajectory_partition_config();
  const ::apollo::planning::OpenSpaceTrajectoryPartitionConfig& open_space_trajectory_partition_config() const;
  ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* release_open_space_trajectory_partition_config();
  ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* mutable_open_space_trajectory_partition_config();
  void set_allocated_open_space_trajectory_partition_config(::apollo::planning::OpenSpaceTrajectoryPartitionConfig* open_space_trajectory_partition_config);
  private:
  const ::apollo::planning::OpenSpaceTrajectoryPartitionConfig& _internal_open_space_trajectory_partition_config() const;
  ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* _internal_mutable_open_space_trajectory_partition_config();
  public:

  // optional .apollo.planning.PathAssessmentDeciderConfig path_assessment_decider_config = 22;
  bool has_path_assessment_decider_config() const;
  private:
  bool _internal_has_path_assessment_decider_config() const;
  public:
  void clear_path_assessment_decider_config();
  const ::apollo::planning::PathAssessmentDeciderConfig& path_assessment_decider_config() const;
  ::apollo::planning::PathAssessmentDeciderConfig* release_path_assessment_decider_config();
  ::apollo::planning::PathAssessmentDeciderConfig* mutable_path_assessment_decider_config();
  void set_allocated_path_assessment_decider_config(::apollo::planning::PathAssessmentDeciderConfig* path_assessment_decider_config);
  private:
  const ::apollo::planning::PathAssessmentDeciderConfig& _internal_path_assessment_decider_config() const;
  ::apollo::planning::PathAssessmentDeciderConfig* _internal_mutable_path_assessment_decider_config();
  public:

  // optional .apollo.planning.PiecewiseJerkSpeedConfig piecewise_jerk_speed_config = 23;
  bool has_piecewise_jerk_speed_config() const;
  private:
  bool _internal_has_piecewise_jerk_speed_config() const;
  public:
  void clear_piecewise_jerk_speed_config();
  const ::apollo::planning::PiecewiseJerkSpeedConfig& piecewise_jerk_speed_config() const;
  ::apollo::planning::PiecewiseJerkSpeedConfig* release_piecewise_jerk_speed_config();
  ::apollo::planning::PiecewiseJerkSpeedConfig* mutable_piecewise_jerk_speed_config();
  void set_allocated_piecewise_jerk_speed_config(::apollo::planning::PiecewiseJerkSpeedConfig* piecewise_jerk_speed_config);
  private:
  const ::apollo::planning::PiecewiseJerkSpeedConfig& _internal_piecewise_jerk_speed_config() const;
  ::apollo::planning::PiecewiseJerkSpeedConfig* _internal_mutable_piecewise_jerk_speed_config();
  public:

  // optional .apollo.planning.PathLaneBorrowDeciderConfig path_lane_borrow_decider_config = 24;
  bool has_path_lane_borrow_decider_config() const;
  private:
  bool _internal_has_path_lane_borrow_decider_config() const;
  public:
  void clear_path_lane_borrow_decider_config();
  const ::apollo::planning::PathLaneBorrowDeciderConfig& path_lane_borrow_decider_config() const;
  ::apollo::planning::PathLaneBorrowDeciderConfig* release_path_lane_borrow_decider_config();
  ::apollo::planning::PathLaneBorrowDeciderConfig* mutable_path_lane_borrow_decider_config();
  void set_allocated_path_lane_borrow_decider_config(::apollo::planning::PathLaneBorrowDeciderConfig* path_lane_borrow_decider_config);
  private:
  const ::apollo::planning::PathLaneBorrowDeciderConfig& _internal_path_lane_borrow_decider_config() const;
  ::apollo::planning::PathLaneBorrowDeciderConfig* _internal_mutable_path_lane_borrow_decider_config();
  public:

  // optional .apollo.planning.LaneChangeDeciderConfig lane_change_decider_config = 25;
  bool has_lane_change_decider_config() const;
  private:
  bool _internal_has_lane_change_decider_config() const;
  public:
  void clear_lane_change_decider_config();
  const ::apollo::planning::LaneChangeDeciderConfig& lane_change_decider_config() const;
  ::apollo::planning::LaneChangeDeciderConfig* release_lane_change_decider_config();
  ::apollo::planning::LaneChangeDeciderConfig* mutable_lane_change_decider_config();
  void set_allocated_lane_change_decider_config(::apollo::planning::LaneChangeDeciderConfig* lane_change_decider_config);
  private:
  const ::apollo::planning::LaneChangeDeciderConfig& _internal_lane_change_decider_config() const;
  ::apollo::planning::LaneChangeDeciderConfig* _internal_mutable_lane_change_decider_config();
  public:

  // optional .apollo.planning.RuleBasedStopDeciderConfig rule_based_stop_decider_config = 26;
  bool has_rule_based_stop_decider_config() const;
  private:
  bool _internal_has_rule_based_stop_decider_config() const;
  public:
  void clear_rule_based_stop_decider_config();
  const ::apollo::planning::RuleBasedStopDeciderConfig& rule_based_stop_decider_config() const;
  ::apollo::planning::RuleBasedStopDeciderConfig* release_rule_based_stop_decider_config();
  ::apollo::planning::RuleBasedStopDeciderConfig* mutable_rule_based_stop_decider_config();
  void set_allocated_rule_based_stop_decider_config(::apollo::planning::RuleBasedStopDeciderConfig* rule_based_stop_decider_config);
  private:
  const ::apollo::planning::RuleBasedStopDeciderConfig& _internal_rule_based_stop_decider_config() const;
  ::apollo::planning::RuleBasedStopDeciderConfig* _internal_mutable_rule_based_stop_decider_config();
  public:

  void clear_task_config();
  TaskConfigCase task_config_case() const;
  // @@protoc_insertion_point(class_scope:apollo.planning.TaskConfig)
 private:
  class _Internal;
  void set_has_dp_st_speed_config();
  void set_has_path_decider_config();
  void set_has_proceed_with_caution_speed_config();
  void set_has_creep_decider_config();
  void set_has_open_space_pre_stop_decider_config();
  void set_has_speed_bounds_decider_config();
  void set_has_piecewise_jerk_path_config();
  void set_has_path_bounds_decider_config();
  void set_has_open_space_fallback_decider_config();
  void set_has_open_space_roi_decider_config();
  void set_has_open_space_trajectory_provider_config();
  void set_has_open_space_trajectory_partition_config();
  void set_has_path_assessment_decider_config();
  void set_has_piecewise_jerk_speed_config();
  void set_has_path_lane_borrow_decider_config();
  void set_has_lane_change_decider_config();
  void set_has_rule_based_stop_decider_config();

  inline bool has_task_config() const;
  inline void clear_has_task_config();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int task_type_;
  union TaskConfigUnion {
    TaskConfigUnion() {}
    ::apollo::planning::DpStSpeedConfig* dp_st_speed_config_;
    ::apollo::planning::PathDeciderConfig* path_decider_config_;
    ::apollo::planning::ProceedWithCautionSpeedConfig* proceed_with_caution_speed_config_;
    ::apollo::planning::CreepDeciderConfig* creep_decider_config_;
    ::apollo::planning::OpenSpacePreStopDeciderConfig* open_space_pre_stop_decider_config_;
    ::apollo::planning::SpeedBoundsDeciderConfig* speed_bounds_decider_config_;
    ::apollo::planning::PiecewiseJerkPathConfig* piecewise_jerk_path_config_;
    ::apollo::planning::PathBoundsDeciderConfig* path_bounds_decider_config_;
    ::apollo::planning::OpenSpaceFallBackDeciderConfig* open_space_fallback_decider_config_;
    ::apollo::planning::OpenSpaceRoiDeciderConfig* open_space_roi_decider_config_;
    ::apollo::planning::OpenSpaceTrajectoryProviderConfig* open_space_trajectory_provider_config_;
    ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* open_space_trajectory_partition_config_;
    ::apollo::planning::PathAssessmentDeciderConfig* path_assessment_decider_config_;
    ::apollo::planning::PiecewiseJerkSpeedConfig* piecewise_jerk_speed_config_;
    ::apollo::planning::PathLaneBorrowDeciderConfig* path_lane_borrow_decider_config_;
    ::apollo::planning::LaneChangeDeciderConfig* lane_change_decider_config_;
    ::apollo::planning::RuleBasedStopDeciderConfig* rule_based_stop_decider_config_;
  } task_config_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ScenarioLaneFollowConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioLaneFollowConfig) */ {
 public:
  ScenarioLaneFollowConfig();
  virtual ~ScenarioLaneFollowConfig();

  ScenarioLaneFollowConfig(const ScenarioLaneFollowConfig& from);
  ScenarioLaneFollowConfig(ScenarioLaneFollowConfig&& from) noexcept
    : ScenarioLaneFollowConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioLaneFollowConfig& operator=(const ScenarioLaneFollowConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioLaneFollowConfig& operator=(ScenarioLaneFollowConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioLaneFollowConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioLaneFollowConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioLaneFollowConfig*>(
               &_ScenarioLaneFollowConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ScenarioLaneFollowConfig& a, ScenarioLaneFollowConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioLaneFollowConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioLaneFollowConfig* New() const final {
    return CreateMaybeMessage<ScenarioLaneFollowConfig>(nullptr);
  }

  ScenarioLaneFollowConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioLaneFollowConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioLaneFollowConfig& from);
  void MergeFrom(const ScenarioLaneFollowConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioLaneFollowConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioLaneFollowConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioLaneFollowConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ScenarioBareIntersectionUnprotectedConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioBareIntersectionUnprotectedConfig) */ {
 public:
  ScenarioBareIntersectionUnprotectedConfig();
  virtual ~ScenarioBareIntersectionUnprotectedConfig();

  ScenarioBareIntersectionUnprotectedConfig(const ScenarioBareIntersectionUnprotectedConfig& from);
  ScenarioBareIntersectionUnprotectedConfig(ScenarioBareIntersectionUnprotectedConfig&& from) noexcept
    : ScenarioBareIntersectionUnprotectedConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioBareIntersectionUnprotectedConfig& operator=(const ScenarioBareIntersectionUnprotectedConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioBareIntersectionUnprotectedConfig& operator=(ScenarioBareIntersectionUnprotectedConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioBareIntersectionUnprotectedConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioBareIntersectionUnprotectedConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioBareIntersectionUnprotectedConfig*>(
               &_ScenarioBareIntersectionUnprotectedConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ScenarioBareIntersectionUnprotectedConfig& a, ScenarioBareIntersectionUnprotectedConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioBareIntersectionUnprotectedConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioBareIntersectionUnprotectedConfig* New() const final {
    return CreateMaybeMessage<ScenarioBareIntersectionUnprotectedConfig>(nullptr);
  }

  ScenarioBareIntersectionUnprotectedConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioBareIntersectionUnprotectedConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioBareIntersectionUnprotectedConfig& from);
  void MergeFrom(const ScenarioBareIntersectionUnprotectedConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioBareIntersectionUnprotectedConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioBareIntersectionUnprotectedConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableExplicitStopFieldNumber = 2,
    kStartBareIntersectionScenarioDistanceFieldNumber = 1,
    kMinPassSDistanceFieldNumber = 3,
    kApproachSpeedLimitFieldNumber = 4,
    kStopDistanceFieldNumber = 5,
    kStopTimeoutSecFieldNumber = 6,
    kCreepTimeoutSecFieldNumber = 7,
  };
  // optional bool enable_explicit_stop = 2 [default = false];
  bool has_enable_explicit_stop() const;
  private:
  bool _internal_has_enable_explicit_stop() const;
  public:
  void clear_enable_explicit_stop();
  bool enable_explicit_stop() const;
  void set_enable_explicit_stop(bool value);
  private:
  bool _internal_enable_explicit_stop() const;
  void _internal_set_enable_explicit_stop(bool value);
  public:

  // optional double start_bare_intersection_scenario_distance = 1 [default = 25];
  bool has_start_bare_intersection_scenario_distance() const;
  private:
  bool _internal_has_start_bare_intersection_scenario_distance() const;
  public:
  void clear_start_bare_intersection_scenario_distance();
  double start_bare_intersection_scenario_distance() const;
  void set_start_bare_intersection_scenario_distance(double value);
  private:
  double _internal_start_bare_intersection_scenario_distance() const;
  void _internal_set_start_bare_intersection_scenario_distance(double value);
  public:

  // optional double min_pass_s_distance = 3 [default = 3];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // optional double approach_speed_limit = 4 [default = 6.7056];
  bool has_approach_speed_limit() const;
  private:
  bool _internal_has_approach_speed_limit() const;
  public:
  void clear_approach_speed_limit();
  double approach_speed_limit() const;
  void set_approach_speed_limit(double value);
  private:
  double _internal_approach_speed_limit() const;
  void _internal_set_approach_speed_limit(double value);
  public:

  // optional double stop_distance = 5 [default = 0.5];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional float stop_timeout_sec = 6 [default = 8];
  bool has_stop_timeout_sec() const;
  private:
  bool _internal_has_stop_timeout_sec() const;
  public:
  void clear_stop_timeout_sec();
  float stop_timeout_sec() const;
  void set_stop_timeout_sec(float value);
  private:
  float _internal_stop_timeout_sec() const;
  void _internal_set_stop_timeout_sec(float value);
  public:

  // optional float creep_timeout_sec = 7 [default = 10];
  bool has_creep_timeout_sec() const;
  private:
  bool _internal_has_creep_timeout_sec() const;
  public:
  void clear_creep_timeout_sec();
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);
  private:
  float _internal_creep_timeout_sec() const;
  void _internal_set_creep_timeout_sec(float value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioBareIntersectionUnprotectedConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enable_explicit_stop_;
  double start_bare_intersection_scenario_distance_;
  double min_pass_s_distance_;
  double approach_speed_limit_;
  double stop_distance_;
  float stop_timeout_sec_;
  float creep_timeout_sec_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ScenarioStopSignUnprotectedConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioStopSignUnprotectedConfig) */ {
 public:
  ScenarioStopSignUnprotectedConfig();
  virtual ~ScenarioStopSignUnprotectedConfig();

  ScenarioStopSignUnprotectedConfig(const ScenarioStopSignUnprotectedConfig& from);
  ScenarioStopSignUnprotectedConfig(ScenarioStopSignUnprotectedConfig&& from) noexcept
    : ScenarioStopSignUnprotectedConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioStopSignUnprotectedConfig& operator=(const ScenarioStopSignUnprotectedConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioStopSignUnprotectedConfig& operator=(ScenarioStopSignUnprotectedConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioStopSignUnprotectedConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioStopSignUnprotectedConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioStopSignUnprotectedConfig*>(
               &_ScenarioStopSignUnprotectedConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ScenarioStopSignUnprotectedConfig& a, ScenarioStopSignUnprotectedConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioStopSignUnprotectedConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioStopSignUnprotectedConfig* New() const final {
    return CreateMaybeMessage<ScenarioStopSignUnprotectedConfig>(nullptr);
  }

  ScenarioStopSignUnprotectedConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioStopSignUnprotectedConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioStopSignUnprotectedConfig& from);
  void MergeFrom(const ScenarioStopSignUnprotectedConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioStopSignUnprotectedConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioStopSignUnprotectedConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreepTimeoutSecFieldNumber = 8,
    kStartStopSignScenarioDistanceFieldNumber = 1,
    kWatchVehicleMaxValidStopDistanceFieldNumber = 2,
    kMaxValidStopDistanceFieldNumber = 3,
    kMaxAdcStopSpeedFieldNumber = 4,
    kMinPassSDistanceFieldNumber = 6,
    kStopDurationSecFieldNumber = 5,
    kStopTimeoutSecFieldNumber = 7,
  };
  // optional float creep_timeout_sec = 8 [default = 10];
  bool has_creep_timeout_sec() const;
  private:
  bool _internal_has_creep_timeout_sec() const;
  public:
  void clear_creep_timeout_sec();
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);
  private:
  float _internal_creep_timeout_sec() const;
  void _internal_set_creep_timeout_sec(float value);
  public:

  // optional double start_stop_sign_scenario_distance = 1 [default = 5];
  bool has_start_stop_sign_scenario_distance() const;
  private:
  bool _internal_has_start_stop_sign_scenario_distance() const;
  public:
  void clear_start_stop_sign_scenario_distance();
  double start_stop_sign_scenario_distance() const;
  void set_start_stop_sign_scenario_distance(double value);
  private:
  double _internal_start_stop_sign_scenario_distance() const;
  void _internal_set_start_stop_sign_scenario_distance(double value);
  public:

  // optional double watch_vehicle_max_valid_stop_distance = 2 [default = 5];
  bool has_watch_vehicle_max_valid_stop_distance() const;
  private:
  bool _internal_has_watch_vehicle_max_valid_stop_distance() const;
  public:
  void clear_watch_vehicle_max_valid_stop_distance();
  double watch_vehicle_max_valid_stop_distance() const;
  void set_watch_vehicle_max_valid_stop_distance(double value);
  private:
  double _internal_watch_vehicle_max_valid_stop_distance() const;
  void _internal_set_watch_vehicle_max_valid_stop_distance(double value);
  public:

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double max_adc_stop_speed = 4 [default = 0.3];
  bool has_max_adc_stop_speed() const;
  private:
  bool _internal_has_max_adc_stop_speed() const;
  public:
  void clear_max_adc_stop_speed();
  double max_adc_stop_speed() const;
  void set_max_adc_stop_speed(double value);
  private:
  double _internal_max_adc_stop_speed() const;
  void _internal_set_max_adc_stop_speed(double value);
  public:

  // optional double min_pass_s_distance = 6 [default = 3];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // optional float stop_duration_sec = 5 [default = 1];
  bool has_stop_duration_sec() const;
  private:
  bool _internal_has_stop_duration_sec() const;
  public:
  void clear_stop_duration_sec();
  float stop_duration_sec() const;
  void set_stop_duration_sec(float value);
  private:
  float _internal_stop_duration_sec() const;
  void _internal_set_stop_duration_sec(float value);
  public:

  // optional float stop_timeout_sec = 7 [default = 8];
  bool has_stop_timeout_sec() const;
  private:
  bool _internal_has_stop_timeout_sec() const;
  public:
  void clear_stop_timeout_sec();
  float stop_timeout_sec() const;
  void set_stop_timeout_sec(float value);
  private:
  float _internal_stop_timeout_sec() const;
  void _internal_set_stop_timeout_sec(float value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioStopSignUnprotectedConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float creep_timeout_sec_;
  double start_stop_sign_scenario_distance_;
  double watch_vehicle_max_valid_stop_distance_;
  double max_valid_stop_distance_;
  double max_adc_stop_speed_;
  double min_pass_s_distance_;
  float stop_duration_sec_;
  float stop_timeout_sec_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ScenarioTrafficLightProtectedConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioTrafficLightProtectedConfig) */ {
 public:
  ScenarioTrafficLightProtectedConfig();
  virtual ~ScenarioTrafficLightProtectedConfig();

  ScenarioTrafficLightProtectedConfig(const ScenarioTrafficLightProtectedConfig& from);
  ScenarioTrafficLightProtectedConfig(ScenarioTrafficLightProtectedConfig&& from) noexcept
    : ScenarioTrafficLightProtectedConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioTrafficLightProtectedConfig& operator=(const ScenarioTrafficLightProtectedConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioTrafficLightProtectedConfig& operator=(ScenarioTrafficLightProtectedConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioTrafficLightProtectedConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioTrafficLightProtectedConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioTrafficLightProtectedConfig*>(
               &_ScenarioTrafficLightProtectedConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ScenarioTrafficLightProtectedConfig& a, ScenarioTrafficLightProtectedConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioTrafficLightProtectedConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioTrafficLightProtectedConfig* New() const final {
    return CreateMaybeMessage<ScenarioTrafficLightProtectedConfig>(nullptr);
  }

  ScenarioTrafficLightProtectedConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioTrafficLightProtectedConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioTrafficLightProtectedConfig& from);
  void MergeFrom(const ScenarioTrafficLightProtectedConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioTrafficLightProtectedConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioTrafficLightProtectedConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTrafficLightScenarioDistanceFieldNumber = 1,
    kMaxValidStopDistanceFieldNumber = 2,
    kMaxAdcStopSpeedFieldNumber = 3,
    kMinPassSDistanceFieldNumber = 4,
  };
  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  bool has_start_traffic_light_scenario_distance() const;
  private:
  bool _internal_has_start_traffic_light_scenario_distance() const;
  public:
  void clear_start_traffic_light_scenario_distance();
  double start_traffic_light_scenario_distance() const;
  void set_start_traffic_light_scenario_distance(double value);
  private:
  double _internal_start_traffic_light_scenario_distance() const;
  void _internal_set_start_traffic_light_scenario_distance(double value);
  public:

  // optional double max_valid_stop_distance = 2 [default = 2];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double max_adc_stop_speed = 3 [default = 0.3];
  bool has_max_adc_stop_speed() const;
  private:
  bool _internal_has_max_adc_stop_speed() const;
  public:
  void clear_max_adc_stop_speed();
  double max_adc_stop_speed() const;
  void set_max_adc_stop_speed(double value);
  private:
  double _internal_max_adc_stop_speed() const;
  void _internal_set_max_adc_stop_speed(double value);
  public:

  // optional double min_pass_s_distance = 4 [default = 3];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioTrafficLightProtectedConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double start_traffic_light_scenario_distance_;
  double max_valid_stop_distance_;
  double max_adc_stop_speed_;
  double min_pass_s_distance_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ScenarioTrafficLightUnprotectedLeftTurnConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig) */ {
 public:
  ScenarioTrafficLightUnprotectedLeftTurnConfig();
  virtual ~ScenarioTrafficLightUnprotectedLeftTurnConfig();

  ScenarioTrafficLightUnprotectedLeftTurnConfig(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from);
  ScenarioTrafficLightUnprotectedLeftTurnConfig(ScenarioTrafficLightUnprotectedLeftTurnConfig&& from) noexcept
    : ScenarioTrafficLightUnprotectedLeftTurnConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioTrafficLightUnprotectedLeftTurnConfig& operator=(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioTrafficLightUnprotectedLeftTurnConfig& operator=(ScenarioTrafficLightUnprotectedLeftTurnConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioTrafficLightUnprotectedLeftTurnConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioTrafficLightUnprotectedLeftTurnConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioTrafficLightUnprotectedLeftTurnConfig*>(
               &_ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ScenarioTrafficLightUnprotectedLeftTurnConfig& a, ScenarioTrafficLightUnprotectedLeftTurnConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioTrafficLightUnprotectedLeftTurnConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioTrafficLightUnprotectedLeftTurnConfig* New() const final {
    return CreateMaybeMessage<ScenarioTrafficLightUnprotectedLeftTurnConfig>(nullptr);
  }

  ScenarioTrafficLightUnprotectedLeftTurnConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioTrafficLightUnprotectedLeftTurnConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from);
  void MergeFrom(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioTrafficLightUnprotectedLeftTurnConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreepTimeoutSecFieldNumber = 5,
    kStartTrafficLightScenarioDistanceFieldNumber = 1,
    kMaxValidStopDistanceFieldNumber = 2,
    kMaxAdcStopSpeedFieldNumber = 3,
    kMinPassSDistanceFieldNumber = 4,
  };
  // optional float creep_timeout_sec = 5 [default = 10];
  bool has_creep_timeout_sec() const;
  private:
  bool _internal_has_creep_timeout_sec() const;
  public:
  void clear_creep_timeout_sec();
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);
  private:
  float _internal_creep_timeout_sec() const;
  void _internal_set_creep_timeout_sec(float value);
  public:

  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  bool has_start_traffic_light_scenario_distance() const;
  private:
  bool _internal_has_start_traffic_light_scenario_distance() const;
  public:
  void clear_start_traffic_light_scenario_distance();
  double start_traffic_light_scenario_distance() const;
  void set_start_traffic_light_scenario_distance(double value);
  private:
  double _internal_start_traffic_light_scenario_distance() const;
  void _internal_set_start_traffic_light_scenario_distance(double value);
  public:

  // optional double max_valid_stop_distance = 2 [default = 3.5];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double max_adc_stop_speed = 3 [default = 0.3];
  bool has_max_adc_stop_speed() const;
  private:
  bool _internal_has_max_adc_stop_speed() const;
  public:
  void clear_max_adc_stop_speed();
  double max_adc_stop_speed() const;
  void set_max_adc_stop_speed(double value);
  private:
  double _internal_max_adc_stop_speed() const;
  void _internal_set_max_adc_stop_speed(double value);
  public:

  // optional double min_pass_s_distance = 4 [default = 3];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float creep_timeout_sec_;
  double start_traffic_light_scenario_distance_;
  double max_valid_stop_distance_;
  double max_adc_stop_speed_;
  double min_pass_s_distance_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ScenarioTrafficLightUnprotectedRightTurnConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig) */ {
 public:
  ScenarioTrafficLightUnprotectedRightTurnConfig();
  virtual ~ScenarioTrafficLightUnprotectedRightTurnConfig();

  ScenarioTrafficLightUnprotectedRightTurnConfig(const ScenarioTrafficLightUnprotectedRightTurnConfig& from);
  ScenarioTrafficLightUnprotectedRightTurnConfig(ScenarioTrafficLightUnprotectedRightTurnConfig&& from) noexcept
    : ScenarioTrafficLightUnprotectedRightTurnConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioTrafficLightUnprotectedRightTurnConfig& operator=(const ScenarioTrafficLightUnprotectedRightTurnConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioTrafficLightUnprotectedRightTurnConfig& operator=(ScenarioTrafficLightUnprotectedRightTurnConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioTrafficLightUnprotectedRightTurnConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioTrafficLightUnprotectedRightTurnConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioTrafficLightUnprotectedRightTurnConfig*>(
               &_ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ScenarioTrafficLightUnprotectedRightTurnConfig& a, ScenarioTrafficLightUnprotectedRightTurnConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioTrafficLightUnprotectedRightTurnConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioTrafficLightUnprotectedRightTurnConfig* New() const final {
    return CreateMaybeMessage<ScenarioTrafficLightUnprotectedRightTurnConfig>(nullptr);
  }

  ScenarioTrafficLightUnprotectedRightTurnConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioTrafficLightUnprotectedRightTurnConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioTrafficLightUnprotectedRightTurnConfig& from);
  void MergeFrom(const ScenarioTrafficLightUnprotectedRightTurnConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioTrafficLightUnprotectedRightTurnConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableRightTurnOnRedFieldNumber = 2,
    kStartTrafficLightScenarioDistanceFieldNumber = 1,
    kMaxValidStopDistanceFieldNumber = 3,
    kMaxAdcStopSpeedFieldNumber = 4,
    kMinPassSDistanceFieldNumber = 5,
    kRedLightRightTurnStopDurationSecFieldNumber = 6,
    kCreepTimeoutSecFieldNumber = 7,
  };
  // optional bool enable_right_turn_on_red = 2 [default = false];
  bool has_enable_right_turn_on_red() const;
  private:
  bool _internal_has_enable_right_turn_on_red() const;
  public:
  void clear_enable_right_turn_on_red();
  bool enable_right_turn_on_red() const;
  void set_enable_right_turn_on_red(bool value);
  private:
  bool _internal_enable_right_turn_on_red() const;
  void _internal_set_enable_right_turn_on_red(bool value);
  public:

  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  bool has_start_traffic_light_scenario_distance() const;
  private:
  bool _internal_has_start_traffic_light_scenario_distance() const;
  public:
  void clear_start_traffic_light_scenario_distance();
  double start_traffic_light_scenario_distance() const;
  void set_start_traffic_light_scenario_distance(double value);
  private:
  double _internal_start_traffic_light_scenario_distance() const;
  void _internal_set_start_traffic_light_scenario_distance(double value);
  public:

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double max_adc_stop_speed = 4 [default = 0.3];
  bool has_max_adc_stop_speed() const;
  private:
  bool _internal_has_max_adc_stop_speed() const;
  public:
  void clear_max_adc_stop_speed();
  double max_adc_stop_speed() const;
  void set_max_adc_stop_speed(double value);
  private:
  double _internal_max_adc_stop_speed() const;
  void _internal_set_max_adc_stop_speed(double value);
  public:

  // optional double min_pass_s_distance = 5 [default = 3];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // optional float red_light_right_turn_stop_duration_sec = 6 [default = 3];
  bool has_red_light_right_turn_stop_duration_sec() const;
  private:
  bool _internal_has_red_light_right_turn_stop_duration_sec() const;
  public:
  void clear_red_light_right_turn_stop_duration_sec();
  float red_light_right_turn_stop_duration_sec() const;
  void set_red_light_right_turn_stop_duration_sec(float value);
  private:
  float _internal_red_light_right_turn_stop_duration_sec() const;
  void _internal_set_red_light_right_turn_stop_duration_sec(float value);
  public:

  // optional float creep_timeout_sec = 7 [default = 10];
  bool has_creep_timeout_sec() const;
  private:
  bool _internal_has_creep_timeout_sec() const;
  public:
  void clear_creep_timeout_sec();
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);
  private:
  float _internal_creep_timeout_sec() const;
  void _internal_set_creep_timeout_sec(float value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enable_right_turn_on_red_;
  double start_traffic_light_scenario_distance_;
  double max_valid_stop_distance_;
  double max_adc_stop_speed_;
  double min_pass_s_distance_;
  float red_light_right_turn_stop_duration_sec_;
  float creep_timeout_sec_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ScenarioPullOverConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioPullOverConfig) */ {
 public:
  ScenarioPullOverConfig();
  virtual ~ScenarioPullOverConfig();

  ScenarioPullOverConfig(const ScenarioPullOverConfig& from);
  ScenarioPullOverConfig(ScenarioPullOverConfig&& from) noexcept
    : ScenarioPullOverConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioPullOverConfig& operator=(const ScenarioPullOverConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioPullOverConfig& operator=(ScenarioPullOverConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioPullOverConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioPullOverConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioPullOverConfig*>(
               &_ScenarioPullOverConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ScenarioPullOverConfig& a, ScenarioPullOverConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioPullOverConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioPullOverConfig* New() const final {
    return CreateMaybeMessage<ScenarioPullOverConfig>(nullptr);
  }

  ScenarioPullOverConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioPullOverConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioPullOverConfig& from);
  void MergeFrom(const ScenarioPullOverConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioPullOverConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioPullOverConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartPullOverScenarioDistanceFieldNumber = 1,
    kPullOverMinDistanceBufferFieldNumber = 2,
    kMaxDistanceStopSearchFieldNumber = 3,
    kMaxAdcStopSpeedFieldNumber = 4,
    kMaxSErrorToEndPointFieldNumber = 5,
    kMaxLErrorToEndPointFieldNumber = 6,
    kMaxThetaErrorToEndPointFieldNumber = 7,
    kMaxDistanceErrorToEndPointFieldNumber = 8,
    kPassDestinationThresholdFieldNumber = 9,
    kMaxValidStopDistanceFieldNumber = 10,
    kSDistanceToStopForOpenSpaceParkingFieldNumber = 11,
  };
  // optional double start_pull_over_scenario_distance = 1 [default = 50];
  bool has_start_pull_over_scenario_distance() const;
  private:
  bool _internal_has_start_pull_over_scenario_distance() const;
  public:
  void clear_start_pull_over_scenario_distance();
  double start_pull_over_scenario_distance() const;
  void set_start_pull_over_scenario_distance(double value);
  private:
  double _internal_start_pull_over_scenario_distance() const;
  void _internal_set_start_pull_over_scenario_distance(double value);
  public:

  // optional double pull_over_min_distance_buffer = 2 [default = 10];
  bool has_pull_over_min_distance_buffer() const;
  private:
  bool _internal_has_pull_over_min_distance_buffer() const;
  public:
  void clear_pull_over_min_distance_buffer();
  double pull_over_min_distance_buffer() const;
  void set_pull_over_min_distance_buffer(double value);
  private:
  double _internal_pull_over_min_distance_buffer() const;
  void _internal_set_pull_over_min_distance_buffer(double value);
  public:

  // optional double max_distance_stop_search = 3 [default = 25];
  bool has_max_distance_stop_search() const;
  private:
  bool _internal_has_max_distance_stop_search() const;
  public:
  void clear_max_distance_stop_search();
  double max_distance_stop_search() const;
  void set_max_distance_stop_search(double value);
  private:
  double _internal_max_distance_stop_search() const;
  void _internal_set_max_distance_stop_search(double value);
  public:

  // optional double max_adc_stop_speed = 4 [default = 0.1];
  bool has_max_adc_stop_speed() const;
  private:
  bool _internal_has_max_adc_stop_speed() const;
  public:
  void clear_max_adc_stop_speed();
  double max_adc_stop_speed() const;
  void set_max_adc_stop_speed(double value);
  private:
  double _internal_max_adc_stop_speed() const;
  void _internal_set_max_adc_stop_speed(double value);
  public:

  // optional double max_s_error_to_end_point = 5 [default = 0.2];
  bool has_max_s_error_to_end_point() const;
  private:
  bool _internal_has_max_s_error_to_end_point() const;
  public:
  void clear_max_s_error_to_end_point();
  double max_s_error_to_end_point() const;
  void set_max_s_error_to_end_point(double value);
  private:
  double _internal_max_s_error_to_end_point() const;
  void _internal_set_max_s_error_to_end_point(double value);
  public:

  // optional double max_l_error_to_end_point = 6 [default = 0.5];
  bool has_max_l_error_to_end_point() const;
  private:
  bool _internal_has_max_l_error_to_end_point() const;
  public:
  void clear_max_l_error_to_end_point();
  double max_l_error_to_end_point() const;
  void set_max_l_error_to_end_point(double value);
  private:
  double _internal_max_l_error_to_end_point() const;
  void _internal_set_max_l_error_to_end_point(double value);
  public:

  // optional double max_theta_error_to_end_point = 7 [default = 0.2];
  bool has_max_theta_error_to_end_point() const;
  private:
  bool _internal_has_max_theta_error_to_end_point() const;
  public:
  void clear_max_theta_error_to_end_point();
  double max_theta_error_to_end_point() const;
  void set_max_theta_error_to_end_point(double value);
  private:
  double _internal_max_theta_error_to_end_point() const;
  void _internal_set_max_theta_error_to_end_point(double value);
  public:

  // optional double max_distance_error_to_end_point = 8 [default = 0.2];
  bool has_max_distance_error_to_end_point() const;
  private:
  bool _internal_has_max_distance_error_to_end_point() const;
  public:
  void clear_max_distance_error_to_end_point();
  double max_distance_error_to_end_point() const;
  void set_max_distance_error_to_end_point(double value);
  private:
  double _internal_max_distance_error_to_end_point() const;
  void _internal_set_max_distance_error_to_end_point(double value);
  public:

  // optional double pass_destination_threshold = 9 [default = 10];
  bool has_pass_destination_threshold() const;
  private:
  bool _internal_has_pass_destination_threshold() const;
  public:
  void clear_pass_destination_threshold();
  double pass_destination_threshold() const;
  void set_pass_destination_threshold(double value);
  private:
  double _internal_pass_destination_threshold() const;
  void _internal_set_pass_destination_threshold(double value);
  public:

  // optional double max_valid_stop_distance = 10 [default = 1];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double s_distance_to_stop_for_open_space_parking = 11 [default = 7];
  bool has_s_distance_to_stop_for_open_space_parking() const;
  private:
  bool _internal_has_s_distance_to_stop_for_open_space_parking() const;
  public:
  void clear_s_distance_to_stop_for_open_space_parking();
  double s_distance_to_stop_for_open_space_parking() const;
  void set_s_distance_to_stop_for_open_space_parking(double value);
  private:
  double _internal_s_distance_to_stop_for_open_space_parking() const;
  void _internal_set_s_distance_to_stop_for_open_space_parking(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioPullOverConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double start_pull_over_scenario_distance_;
  double pull_over_min_distance_buffer_;
  double max_distance_stop_search_;
  double max_adc_stop_speed_;
  double max_s_error_to_end_point_;
  double max_l_error_to_end_point_;
  double max_theta_error_to_end_point_;
  double max_distance_error_to_end_point_;
  double pass_destination_threshold_;
  double max_valid_stop_distance_;
  double s_distance_to_stop_for_open_space_parking_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ScenarioValetParkingConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioValetParkingConfig) */ {
 public:
  ScenarioValetParkingConfig();
  virtual ~ScenarioValetParkingConfig();

  ScenarioValetParkingConfig(const ScenarioValetParkingConfig& from);
  ScenarioValetParkingConfig(ScenarioValetParkingConfig&& from) noexcept
    : ScenarioValetParkingConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioValetParkingConfig& operator=(const ScenarioValetParkingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioValetParkingConfig& operator=(ScenarioValetParkingConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioValetParkingConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioValetParkingConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioValetParkingConfig*>(
               &_ScenarioValetParkingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ScenarioValetParkingConfig& a, ScenarioValetParkingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioValetParkingConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioValetParkingConfig* New() const final {
    return CreateMaybeMessage<ScenarioValetParkingConfig>(nullptr);
  }

  ScenarioValetParkingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioValetParkingConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioValetParkingConfig& from);
  void MergeFrom(const ScenarioValetParkingConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioValetParkingConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioValetParkingConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParkingSpotRangeToStartFieldNumber = 1,
    kMaxValidStopDistanceFieldNumber = 2,
    kMaxAdcStopSpeedFieldNumber = 3,
  };
  // optional double parking_spot_range_to_start = 1 [default = 20];
  bool has_parking_spot_range_to_start() const;
  private:
  bool _internal_has_parking_spot_range_to_start() const;
  public:
  void clear_parking_spot_range_to_start();
  double parking_spot_range_to_start() const;
  void set_parking_spot_range_to_start(double value);
  private:
  double _internal_parking_spot_range_to_start() const;
  void _internal_set_parking_spot_range_to_start(double value);
  public:

  // optional double max_valid_stop_distance = 2 [default = 1];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double max_adc_stop_speed = 3 [default = 0.1];
  bool has_max_adc_stop_speed() const;
  private:
  bool _internal_has_max_adc_stop_speed() const;
  public:
  void clear_max_adc_stop_speed();
  double max_adc_stop_speed() const;
  void set_max_adc_stop_speed(double value);
  private:
  double _internal_max_adc_stop_speed() const;
  void _internal_set_max_adc_stop_speed(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioValetParkingConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double parking_spot_range_to_start_;
  double max_valid_stop_distance_;
  double max_adc_stop_speed_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ScenarioNarrowStreetUTurnConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioNarrowStreetUTurnConfig) */ {
 public:
  ScenarioNarrowStreetUTurnConfig();
  virtual ~ScenarioNarrowStreetUTurnConfig();

  ScenarioNarrowStreetUTurnConfig(const ScenarioNarrowStreetUTurnConfig& from);
  ScenarioNarrowStreetUTurnConfig(ScenarioNarrowStreetUTurnConfig&& from) noexcept
    : ScenarioNarrowStreetUTurnConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioNarrowStreetUTurnConfig& operator=(const ScenarioNarrowStreetUTurnConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioNarrowStreetUTurnConfig& operator=(ScenarioNarrowStreetUTurnConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioNarrowStreetUTurnConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioNarrowStreetUTurnConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioNarrowStreetUTurnConfig*>(
               &_ScenarioNarrowStreetUTurnConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ScenarioNarrowStreetUTurnConfig& a, ScenarioNarrowStreetUTurnConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioNarrowStreetUTurnConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioNarrowStreetUTurnConfig* New() const final {
    return CreateMaybeMessage<ScenarioNarrowStreetUTurnConfig>(nullptr);
  }

  ScenarioNarrowStreetUTurnConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioNarrowStreetUTurnConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioNarrowStreetUTurnConfig& from);
  void MergeFrom(const ScenarioNarrowStreetUTurnConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioNarrowStreetUTurnConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioNarrowStreetUTurnConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioNarrowStreetUTurnConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ScenarioConfig_StageConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioConfig.StageConfig) */ {
 public:
  ScenarioConfig_StageConfig();
  virtual ~ScenarioConfig_StageConfig();

  ScenarioConfig_StageConfig(const ScenarioConfig_StageConfig& from);
  ScenarioConfig_StageConfig(ScenarioConfig_StageConfig&& from) noexcept
    : ScenarioConfig_StageConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioConfig_StageConfig& operator=(const ScenarioConfig_StageConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioConfig_StageConfig& operator=(ScenarioConfig_StageConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioConfig_StageConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioConfig_StageConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioConfig_StageConfig*>(
               &_ScenarioConfig_StageConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ScenarioConfig_StageConfig& a, ScenarioConfig_StageConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioConfig_StageConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioConfig_StageConfig* New() const final {
    return CreateMaybeMessage<ScenarioConfig_StageConfig>(nullptr);
  }

  ScenarioConfig_StageConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioConfig_StageConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioConfig_StageConfig& from);
  void MergeFrom(const ScenarioConfig_StageConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioConfig_StageConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioConfig.StageConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskTypeFieldNumber = 3,
    kTaskConfigFieldNumber = 4,
    kStageTypeFieldNumber = 1,
    kEnabledFieldNumber = 2,
  };
  // repeated .apollo.planning.TaskConfig.TaskType task_type = 3;
  int task_type_size() const;
  private:
  int _internal_task_type_size() const;
  public:
  void clear_task_type();
  private:
  ::apollo::planning::TaskConfig_TaskType _internal_task_type(int index) const;
  void _internal_add_task_type(::apollo::planning::TaskConfig_TaskType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_task_type();
  public:
  ::apollo::planning::TaskConfig_TaskType task_type(int index) const;
  void set_task_type(int index, ::apollo::planning::TaskConfig_TaskType value);
  void add_task_type(::apollo::planning::TaskConfig_TaskType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& task_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_task_type();

  // repeated .apollo.planning.TaskConfig task_config = 4;
  int task_config_size() const;
  private:
  int _internal_task_config_size() const;
  public:
  void clear_task_config();
  ::apollo::planning::TaskConfig* mutable_task_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TaskConfig >*
      mutable_task_config();
  private:
  const ::apollo::planning::TaskConfig& _internal_task_config(int index) const;
  ::apollo::planning::TaskConfig* _internal_add_task_config();
  public:
  const ::apollo::planning::TaskConfig& task_config(int index) const;
  ::apollo::planning::TaskConfig* add_task_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TaskConfig >&
      task_config() const;

  // optional .apollo.planning.ScenarioConfig.StageType stage_type = 1;
  bool has_stage_type() const;
  private:
  bool _internal_has_stage_type() const;
  public:
  void clear_stage_type();
  ::apollo::planning::ScenarioConfig_StageType stage_type() const;
  void set_stage_type(::apollo::planning::ScenarioConfig_StageType value);
  private:
  ::apollo::planning::ScenarioConfig_StageType _internal_stage_type() const;
  void _internal_set_stage_type(::apollo::planning::ScenarioConfig_StageType value);
  public:

  // optional bool enabled = 2 [default = true];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioConfig.StageConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> task_type_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TaskConfig > task_config_;
  int stage_type_;
  bool enabled_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ScenarioConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioConfig) */ {
 public:
  ScenarioConfig();
  virtual ~ScenarioConfig();

  ScenarioConfig(const ScenarioConfig& from);
  ScenarioConfig(ScenarioConfig&& from) noexcept
    : ScenarioConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioConfig& operator=(const ScenarioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioConfig& operator=(ScenarioConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioConfig& default_instance();

  enum ScenarioConfigCase {
    kLaneFollowConfig = 2,
    kBareIntersectionUnprotectedConfig = 4,
    kStopSignUnprotectedConfig = 5,
    kTrafficLightProtectedConfig = 6,
    kTrafficLightUnprotectedRightTurnConfig = 7,
    kTrafficLightUnprotectedLeftTurnConfig = 8,
    kPullOverConfig = 9,
    kValetParkingConfig = 10,
    kNarrowStreetUTurnConfig = 11,
    SCENARIO_CONFIG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioConfig*>(
               &_ScenarioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ScenarioConfig& a, ScenarioConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioConfig* New() const final {
    return CreateMaybeMessage<ScenarioConfig>(nullptr);
  }

  ScenarioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioConfig& from);
  void MergeFrom(const ScenarioConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ScenarioConfig_StageConfig StageConfig;

  typedef ScenarioConfig_ScenarioType ScenarioType;
  static constexpr ScenarioType LANE_FOLLOW =
    ScenarioConfig_ScenarioType_LANE_FOLLOW;
  static constexpr ScenarioType CHANGE_LANE =
    ScenarioConfig_ScenarioType_CHANGE_LANE;
  static constexpr ScenarioType BARE_INTERSECTION_UNPROTECTED =
    ScenarioConfig_ScenarioType_BARE_INTERSECTION_UNPROTECTED;
  static constexpr ScenarioType STOP_SIGN_PROTECTED =
    ScenarioConfig_ScenarioType_STOP_SIGN_PROTECTED;
  static constexpr ScenarioType STOP_SIGN_UNPROTECTED =
    ScenarioConfig_ScenarioType_STOP_SIGN_UNPROTECTED;
  static constexpr ScenarioType TRAFFIC_LIGHT_PROTECTED =
    ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_PROTECTED;
  static constexpr ScenarioType TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN =
    ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN;
  static constexpr ScenarioType TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN =
    ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN;
  static constexpr ScenarioType YIELD_SIGN_UNPROTECTED =
    ScenarioConfig_ScenarioType_YIELD_SIGN_UNPROTECTED;
  static constexpr ScenarioType PULL_OVER =
    ScenarioConfig_ScenarioType_PULL_OVER;
  static constexpr ScenarioType VALET_PARKING =
    ScenarioConfig_ScenarioType_VALET_PARKING;
  static constexpr ScenarioType NARROW_STREET_U_TURN =
    ScenarioConfig_ScenarioType_NARROW_STREET_U_TURN;
  static inline bool ScenarioType_IsValid(int value) {
    return ScenarioConfig_ScenarioType_IsValid(value);
  }
  static constexpr ScenarioType ScenarioType_MIN =
    ScenarioConfig_ScenarioType_ScenarioType_MIN;
  static constexpr ScenarioType ScenarioType_MAX =
    ScenarioConfig_ScenarioType_ScenarioType_MAX;
  static constexpr int ScenarioType_ARRAYSIZE =
    ScenarioConfig_ScenarioType_ScenarioType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScenarioType_descriptor() {
    return ScenarioConfig_ScenarioType_descriptor();
  }
  template<typename T>
  static inline const std::string& ScenarioType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScenarioType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScenarioType_Name.");
    return ScenarioConfig_ScenarioType_Name(enum_t_value);
  }
  static inline bool ScenarioType_Parse(const std::string& name,
      ScenarioType* value) {
    return ScenarioConfig_ScenarioType_Parse(name, value);
  }

  typedef ScenarioConfig_StageType StageType;
  static constexpr StageType NO_STAGE =
    ScenarioConfig_StageType_NO_STAGE;
  static constexpr StageType LANE_FOLLOW_DEFAULT_STAGE =
    ScenarioConfig_StageType_LANE_FOLLOW_DEFAULT_STAGE;
  static constexpr StageType BARE_INTERSECTION_UNPROTECTED_APPROACH =
    ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_APPROACH;
  static constexpr StageType BARE_INTERSECTION_UNPROTECTED_CREEP =
    ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_CREEP;
  static constexpr StageType BARE_INTERSECTION_UNPROTECTED_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_INTERSECTION_CRUISE;
  static constexpr StageType STOP_SIGN_UNPROTECTED_PRE_STOP =
    ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_PRE_STOP;
  static constexpr StageType STOP_SIGN_UNPROTECTED_STOP =
    ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_STOP;
  static constexpr StageType STOP_SIGN_UNPROTECTED_CREEP =
    ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_CREEP;
  static constexpr StageType STOP_SIGN_UNPROTECTED_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_INTERSECTION_CRUISE;
  static constexpr StageType TRAFFIC_LIGHT_PROTECTED_APPROACH =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_PROTECTED_APPROACH;
  static constexpr StageType TRAFFIC_LIGHT_PROTECTED_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_PROTECTED_INTERSECTION_CRUISE;
  static constexpr StageType TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_CREEP =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_CREEP;
  static constexpr StageType TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_INTERSECTION_CRUISE;
  static constexpr StageType TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_STOP =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_STOP;
  static constexpr StageType TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_CREEP =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_CREEP;
  static constexpr StageType TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_INTERSECTION_CRUISE;
  static constexpr StageType PULL_OVER_APPROACH =
    ScenarioConfig_StageType_PULL_OVER_APPROACH;
  static constexpr StageType PULL_OVER_RETRY_APPROACH_PARKING =
    ScenarioConfig_StageType_PULL_OVER_RETRY_APPROACH_PARKING;
  static constexpr StageType PULL_OVER_RETRY_PARKING =
    ScenarioConfig_StageType_PULL_OVER_RETRY_PARKING;
  static constexpr StageType VALET_PARKING_APPROACHING_PARKING_SPOT =
    ScenarioConfig_StageType_VALET_PARKING_APPROACHING_PARKING_SPOT;
  static constexpr StageType VALET_PARKING_PARKING =
    ScenarioConfig_StageType_VALET_PARKING_PARKING;
  static inline bool StageType_IsValid(int value) {
    return ScenarioConfig_StageType_IsValid(value);
  }
  static constexpr StageType StageType_MIN =
    ScenarioConfig_StageType_StageType_MIN;
  static constexpr StageType StageType_MAX =
    ScenarioConfig_StageType_StageType_MAX;
  static constexpr int StageType_ARRAYSIZE =
    ScenarioConfig_StageType_StageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StageType_descriptor() {
    return ScenarioConfig_StageType_descriptor();
  }
  template<typename T>
  static inline const std::string& StageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StageType_Name.");
    return ScenarioConfig_StageType_Name(enum_t_value);
  }
  static inline bool StageType_Parse(const std::string& name,
      StageType* value) {
    return ScenarioConfig_StageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStageTypeFieldNumber = 12,
    kStageConfigFieldNumber = 13,
    kScenarioTypeFieldNumber = 1,
    kLaneFollowConfigFieldNumber = 2,
    kBareIntersectionUnprotectedConfigFieldNumber = 4,
    kStopSignUnprotectedConfigFieldNumber = 5,
    kTrafficLightProtectedConfigFieldNumber = 6,
    kTrafficLightUnprotectedRightTurnConfigFieldNumber = 7,
    kTrafficLightUnprotectedLeftTurnConfigFieldNumber = 8,
    kPullOverConfigFieldNumber = 9,
    kValetParkingConfigFieldNumber = 10,
    kNarrowStreetUTurnConfigFieldNumber = 11,
  };
  // repeated .apollo.planning.ScenarioConfig.StageType stage_type = 12;
  int stage_type_size() const;
  private:
  int _internal_stage_type_size() const;
  public:
  void clear_stage_type();
  private:
  ::apollo::planning::ScenarioConfig_StageType _internal_stage_type(int index) const;
  void _internal_add_stage_type(::apollo::planning::ScenarioConfig_StageType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_stage_type();
  public:
  ::apollo::planning::ScenarioConfig_StageType stage_type(int index) const;
  void set_stage_type(int index, ::apollo::planning::ScenarioConfig_StageType value);
  void add_stage_type(::apollo::planning::ScenarioConfig_StageType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& stage_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_stage_type();

  // repeated .apollo.planning.ScenarioConfig.StageConfig stage_config = 13;
  int stage_config_size() const;
  private:
  int _internal_stage_config_size() const;
  public:
  void clear_stage_config();
  ::apollo::planning::ScenarioConfig_StageConfig* mutable_stage_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ScenarioConfig_StageConfig >*
      mutable_stage_config();
  private:
  const ::apollo::planning::ScenarioConfig_StageConfig& _internal_stage_config(int index) const;
  ::apollo::planning::ScenarioConfig_StageConfig* _internal_add_stage_config();
  public:
  const ::apollo::planning::ScenarioConfig_StageConfig& stage_config(int index) const;
  ::apollo::planning::ScenarioConfig_StageConfig* add_stage_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ScenarioConfig_StageConfig >&
      stage_config() const;

  // optional .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  bool has_scenario_type() const;
  private:
  bool _internal_has_scenario_type() const;
  public:
  void clear_scenario_type();
  ::apollo::planning::ScenarioConfig_ScenarioType scenario_type() const;
  void set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value);
  private:
  ::apollo::planning::ScenarioConfig_ScenarioType _internal_scenario_type() const;
  void _internal_set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value);
  public:

  // optional .apollo.planning.ScenarioLaneFollowConfig lane_follow_config = 2;
  bool has_lane_follow_config() const;
  private:
  bool _internal_has_lane_follow_config() const;
  public:
  void clear_lane_follow_config();
  const ::apollo::planning::ScenarioLaneFollowConfig& lane_follow_config() const;
  ::apollo::planning::ScenarioLaneFollowConfig* release_lane_follow_config();
  ::apollo::planning::ScenarioLaneFollowConfig* mutable_lane_follow_config();
  void set_allocated_lane_follow_config(::apollo::planning::ScenarioLaneFollowConfig* lane_follow_config);
  private:
  const ::apollo::planning::ScenarioLaneFollowConfig& _internal_lane_follow_config() const;
  ::apollo::planning::ScenarioLaneFollowConfig* _internal_mutable_lane_follow_config();
  public:

  // optional .apollo.planning.ScenarioBareIntersectionUnprotectedConfig bare_intersection_unprotected_config = 4;
  bool has_bare_intersection_unprotected_config() const;
  private:
  bool _internal_has_bare_intersection_unprotected_config() const;
  public:
  void clear_bare_intersection_unprotected_config();
  const ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig& bare_intersection_unprotected_config() const;
  ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* release_bare_intersection_unprotected_config();
  ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* mutable_bare_intersection_unprotected_config();
  void set_allocated_bare_intersection_unprotected_config(::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* bare_intersection_unprotected_config);
  private:
  const ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig& _internal_bare_intersection_unprotected_config() const;
  ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* _internal_mutable_bare_intersection_unprotected_config();
  public:

  // optional .apollo.planning.ScenarioStopSignUnprotectedConfig stop_sign_unprotected_config = 5;
  bool has_stop_sign_unprotected_config() const;
  private:
  bool _internal_has_stop_sign_unprotected_config() const;
  public:
  void clear_stop_sign_unprotected_config();
  const ::apollo::planning::ScenarioStopSignUnprotectedConfig& stop_sign_unprotected_config() const;
  ::apollo::planning::ScenarioStopSignUnprotectedConfig* release_stop_sign_unprotected_config();
  ::apollo::planning::ScenarioStopSignUnprotectedConfig* mutable_stop_sign_unprotected_config();
  void set_allocated_stop_sign_unprotected_config(::apollo::planning::ScenarioStopSignUnprotectedConfig* stop_sign_unprotected_config);
  private:
  const ::apollo::planning::ScenarioStopSignUnprotectedConfig& _internal_stop_sign_unprotected_config() const;
  ::apollo::planning::ScenarioStopSignUnprotectedConfig* _internal_mutable_stop_sign_unprotected_config();
  public:

  // optional .apollo.planning.ScenarioTrafficLightProtectedConfig traffic_light_protected_config = 6;
  bool has_traffic_light_protected_config() const;
  private:
  bool _internal_has_traffic_light_protected_config() const;
  public:
  void clear_traffic_light_protected_config();
  const ::apollo::planning::ScenarioTrafficLightProtectedConfig& traffic_light_protected_config() const;
  ::apollo::planning::ScenarioTrafficLightProtectedConfig* release_traffic_light_protected_config();
  ::apollo::planning::ScenarioTrafficLightProtectedConfig* mutable_traffic_light_protected_config();
  void set_allocated_traffic_light_protected_config(::apollo::planning::ScenarioTrafficLightProtectedConfig* traffic_light_protected_config);
  private:
  const ::apollo::planning::ScenarioTrafficLightProtectedConfig& _internal_traffic_light_protected_config() const;
  ::apollo::planning::ScenarioTrafficLightProtectedConfig* _internal_mutable_traffic_light_protected_config();
  public:

  // optional .apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig traffic_light_unprotected_right_turn_config = 7;
  bool has_traffic_light_unprotected_right_turn_config() const;
  private:
  bool _internal_has_traffic_light_unprotected_right_turn_config() const;
  public:
  void clear_traffic_light_unprotected_right_turn_config();
  const ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig& traffic_light_unprotected_right_turn_config() const;
  ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* release_traffic_light_unprotected_right_turn_config();
  ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* mutable_traffic_light_unprotected_right_turn_config();
  void set_allocated_traffic_light_unprotected_right_turn_config(::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* traffic_light_unprotected_right_turn_config);
  private:
  const ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig& _internal_traffic_light_unprotected_right_turn_config() const;
  ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* _internal_mutable_traffic_light_unprotected_right_turn_config();
  public:

  // optional .apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig traffic_light_unprotected_left_turn_config = 8;
  bool has_traffic_light_unprotected_left_turn_config() const;
  private:
  bool _internal_has_traffic_light_unprotected_left_turn_config() const;
  public:
  void clear_traffic_light_unprotected_left_turn_config();
  const ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig& traffic_light_unprotected_left_turn_config() const;
  ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* release_traffic_light_unprotected_left_turn_config();
  ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* mutable_traffic_light_unprotected_left_turn_config();
  void set_allocated_traffic_light_unprotected_left_turn_config(::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* traffic_light_unprotected_left_turn_config);
  private:
  const ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig& _internal_traffic_light_unprotected_left_turn_config() const;
  ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* _internal_mutable_traffic_light_unprotected_left_turn_config();
  public:

  // optional .apollo.planning.ScenarioPullOverConfig pull_over_config = 9;
  bool has_pull_over_config() const;
  private:
  bool _internal_has_pull_over_config() const;
  public:
  void clear_pull_over_config();
  const ::apollo::planning::ScenarioPullOverConfig& pull_over_config() const;
  ::apollo::planning::ScenarioPullOverConfig* release_pull_over_config();
  ::apollo::planning::ScenarioPullOverConfig* mutable_pull_over_config();
  void set_allocated_pull_over_config(::apollo::planning::ScenarioPullOverConfig* pull_over_config);
  private:
  const ::apollo::planning::ScenarioPullOverConfig& _internal_pull_over_config() const;
  ::apollo::planning::ScenarioPullOverConfig* _internal_mutable_pull_over_config();
  public:

  // optional .apollo.planning.ScenarioValetParkingConfig valet_parking_config = 10;
  bool has_valet_parking_config() const;
  private:
  bool _internal_has_valet_parking_config() const;
  public:
  void clear_valet_parking_config();
  const ::apollo::planning::ScenarioValetParkingConfig& valet_parking_config() const;
  ::apollo::planning::ScenarioValetParkingConfig* release_valet_parking_config();
  ::apollo::planning::ScenarioValetParkingConfig* mutable_valet_parking_config();
  void set_allocated_valet_parking_config(::apollo::planning::ScenarioValetParkingConfig* valet_parking_config);
  private:
  const ::apollo::planning::ScenarioValetParkingConfig& _internal_valet_parking_config() const;
  ::apollo::planning::ScenarioValetParkingConfig* _internal_mutable_valet_parking_config();
  public:

  // optional .apollo.planning.ScenarioNarrowStreetUTurnConfig narrow_street_u_turn_config = 11;
  bool has_narrow_street_u_turn_config() const;
  private:
  bool _internal_has_narrow_street_u_turn_config() const;
  public:
  void clear_narrow_street_u_turn_config();
  const ::apollo::planning::ScenarioNarrowStreetUTurnConfig& narrow_street_u_turn_config() const;
  ::apollo::planning::ScenarioNarrowStreetUTurnConfig* release_narrow_street_u_turn_config();
  ::apollo::planning::ScenarioNarrowStreetUTurnConfig* mutable_narrow_street_u_turn_config();
  void set_allocated_narrow_street_u_turn_config(::apollo::planning::ScenarioNarrowStreetUTurnConfig* narrow_street_u_turn_config);
  private:
  const ::apollo::planning::ScenarioNarrowStreetUTurnConfig& _internal_narrow_street_u_turn_config() const;
  ::apollo::planning::ScenarioNarrowStreetUTurnConfig* _internal_mutable_narrow_street_u_turn_config();
  public:

  void clear_scenario_config();
  ScenarioConfigCase scenario_config_case() const;
  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioConfig)
 private:
  class _Internal;
  void set_has_lane_follow_config();
  void set_has_bare_intersection_unprotected_config();
  void set_has_stop_sign_unprotected_config();
  void set_has_traffic_light_protected_config();
  void set_has_traffic_light_unprotected_right_turn_config();
  void set_has_traffic_light_unprotected_left_turn_config();
  void set_has_pull_over_config();
  void set_has_valet_parking_config();
  void set_has_narrow_street_u_turn_config();

  inline bool has_scenario_config() const;
  inline void clear_has_scenario_config();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> stage_type_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ScenarioConfig_StageConfig > stage_config_;
  int scenario_type_;
  union ScenarioConfigUnion {
    ScenarioConfigUnion() {}
    ::apollo::planning::ScenarioLaneFollowConfig* lane_follow_config_;
    ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* bare_intersection_unprotected_config_;
    ::apollo::planning::ScenarioStopSignUnprotectedConfig* stop_sign_unprotected_config_;
    ::apollo::planning::ScenarioTrafficLightProtectedConfig* traffic_light_protected_config_;
    ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* traffic_light_unprotected_right_turn_config_;
    ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* traffic_light_unprotected_left_turn_config_;
    ::apollo::planning::ScenarioPullOverConfig* pull_over_config_;
    ::apollo::planning::ScenarioValetParkingConfig* valet_parking_config_;
    ::apollo::planning::ScenarioNarrowStreetUTurnConfig* narrow_street_u_turn_config_;
  } scenario_config_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class PlannerPublicRoadConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlannerPublicRoadConfig) */ {
 public:
  PlannerPublicRoadConfig();
  virtual ~PlannerPublicRoadConfig();

  PlannerPublicRoadConfig(const PlannerPublicRoadConfig& from);
  PlannerPublicRoadConfig(PlannerPublicRoadConfig&& from) noexcept
    : PlannerPublicRoadConfig() {
    *this = ::std::move(from);
  }

  inline PlannerPublicRoadConfig& operator=(const PlannerPublicRoadConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlannerPublicRoadConfig& operator=(PlannerPublicRoadConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlannerPublicRoadConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlannerPublicRoadConfig* internal_default_instance() {
    return reinterpret_cast<const PlannerPublicRoadConfig*>(
               &_PlannerPublicRoadConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PlannerPublicRoadConfig& a, PlannerPublicRoadConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PlannerPublicRoadConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlannerPublicRoadConfig* New() const final {
    return CreateMaybeMessage<PlannerPublicRoadConfig>(nullptr);
  }

  PlannerPublicRoadConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlannerPublicRoadConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlannerPublicRoadConfig& from);
  void MergeFrom(const PlannerPublicRoadConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlannerPublicRoadConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PlannerPublicRoadConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScenarioTypeFieldNumber = 1,
  };
  // repeated .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  int scenario_type_size() const;
  private:
  int _internal_scenario_type_size() const;
  public:
  void clear_scenario_type();
  private:
  ::apollo::planning::ScenarioConfig_ScenarioType _internal_scenario_type(int index) const;
  void _internal_add_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_scenario_type();
  public:
  ::apollo::planning::ScenarioConfig_ScenarioType scenario_type(int index) const;
  void set_scenario_type(int index, ::apollo::planning::ScenarioConfig_ScenarioType value);
  void add_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& scenario_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_scenario_type();

  // @@protoc_insertion_point(class_scope:apollo.planning.PlannerPublicRoadConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> scenario_type_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class PlannerNaviConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlannerNaviConfig) */ {
 public:
  PlannerNaviConfig();
  virtual ~PlannerNaviConfig();

  PlannerNaviConfig(const PlannerNaviConfig& from);
  PlannerNaviConfig(PlannerNaviConfig&& from) noexcept
    : PlannerNaviConfig() {
    *this = ::std::move(from);
  }

  inline PlannerNaviConfig& operator=(const PlannerNaviConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlannerNaviConfig& operator=(PlannerNaviConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlannerNaviConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlannerNaviConfig* internal_default_instance() {
    return reinterpret_cast<const PlannerNaviConfig*>(
               &_PlannerNaviConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PlannerNaviConfig& a, PlannerNaviConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PlannerNaviConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlannerNaviConfig* New() const final {
    return CreateMaybeMessage<PlannerNaviConfig>(nullptr);
  }

  PlannerNaviConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlannerNaviConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlannerNaviConfig& from);
  void MergeFrom(const PlannerNaviConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlannerNaviConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PlannerNaviConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 1,
    kNaviPathDeciderConfigFieldNumber = 2,
    kNaviSpeedDeciderConfigFieldNumber = 3,
    kNaviObstacleDeciderConfigFieldNumber = 4,
  };
  // repeated .apollo.planning.TaskConfig.TaskType task = 1;
  int task_size() const;
  private:
  int _internal_task_size() const;
  public:
  void clear_task();
  private:
  ::apollo::planning::TaskConfig_TaskType _internal_task(int index) const;
  void _internal_add_task(::apollo::planning::TaskConfig_TaskType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_task();
  public:
  ::apollo::planning::TaskConfig_TaskType task(int index) const;
  void set_task(int index, ::apollo::planning::TaskConfig_TaskType value);
  void add_task(::apollo::planning::TaskConfig_TaskType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& task() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_task();

  // optional .apollo.planning.NaviPathDeciderConfig navi_path_decider_config = 2;
  bool has_navi_path_decider_config() const;
  private:
  bool _internal_has_navi_path_decider_config() const;
  public:
  void clear_navi_path_decider_config();
  const ::apollo::planning::NaviPathDeciderConfig& navi_path_decider_config() const;
  ::apollo::planning::NaviPathDeciderConfig* release_navi_path_decider_config();
  ::apollo::planning::NaviPathDeciderConfig* mutable_navi_path_decider_config();
  void set_allocated_navi_path_decider_config(::apollo::planning::NaviPathDeciderConfig* navi_path_decider_config);
  private:
  const ::apollo::planning::NaviPathDeciderConfig& _internal_navi_path_decider_config() const;
  ::apollo::planning::NaviPathDeciderConfig* _internal_mutable_navi_path_decider_config();
  public:

  // optional .apollo.planning.NaviSpeedDeciderConfig navi_speed_decider_config = 3;
  bool has_navi_speed_decider_config() const;
  private:
  bool _internal_has_navi_speed_decider_config() const;
  public:
  void clear_navi_speed_decider_config();
  const ::apollo::planning::NaviSpeedDeciderConfig& navi_speed_decider_config() const;
  ::apollo::planning::NaviSpeedDeciderConfig* release_navi_speed_decider_config();
  ::apollo::planning::NaviSpeedDeciderConfig* mutable_navi_speed_decider_config();
  void set_allocated_navi_speed_decider_config(::apollo::planning::NaviSpeedDeciderConfig* navi_speed_decider_config);
  private:
  const ::apollo::planning::NaviSpeedDeciderConfig& _internal_navi_speed_decider_config() const;
  ::apollo::planning::NaviSpeedDeciderConfig* _internal_mutable_navi_speed_decider_config();
  public:

  // optional .apollo.planning.NaviObstacleDeciderConfig navi_obstacle_decider_config = 4;
  bool has_navi_obstacle_decider_config() const;
  private:
  bool _internal_has_navi_obstacle_decider_config() const;
  public:
  void clear_navi_obstacle_decider_config();
  const ::apollo::planning::NaviObstacleDeciderConfig& navi_obstacle_decider_config() const;
  ::apollo::planning::NaviObstacleDeciderConfig* release_navi_obstacle_decider_config();
  ::apollo::planning::NaviObstacleDeciderConfig* mutable_navi_obstacle_decider_config();
  void set_allocated_navi_obstacle_decider_config(::apollo::planning::NaviObstacleDeciderConfig* navi_obstacle_decider_config);
  private:
  const ::apollo::planning::NaviObstacleDeciderConfig& _internal_navi_obstacle_decider_config() const;
  ::apollo::planning::NaviObstacleDeciderConfig* _internal_mutable_navi_obstacle_decider_config();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.PlannerNaviConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> task_;
  ::apollo::planning::NaviPathDeciderConfig* navi_path_decider_config_;
  ::apollo::planning::NaviSpeedDeciderConfig* navi_speed_decider_config_;
  ::apollo::planning::NaviObstacleDeciderConfig* navi_obstacle_decider_config_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class RtkPlanningConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.RtkPlanningConfig) */ {
 public:
  RtkPlanningConfig();
  virtual ~RtkPlanningConfig();

  RtkPlanningConfig(const RtkPlanningConfig& from);
  RtkPlanningConfig(RtkPlanningConfig&& from) noexcept
    : RtkPlanningConfig() {
    *this = ::std::move(from);
  }

  inline RtkPlanningConfig& operator=(const RtkPlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtkPlanningConfig& operator=(RtkPlanningConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RtkPlanningConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RtkPlanningConfig* internal_default_instance() {
    return reinterpret_cast<const RtkPlanningConfig*>(
               &_RtkPlanningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RtkPlanningConfig& a, RtkPlanningConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RtkPlanningConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RtkPlanningConfig* New() const final {
    return CreateMaybeMessage<RtkPlanningConfig>(nullptr);
  }

  RtkPlanningConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RtkPlanningConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RtkPlanningConfig& from);
  void MergeFrom(const RtkPlanningConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtkPlanningConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.RtkPlanningConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlannerTypeFieldNumber = 1,
  };
  // optional .apollo.planning.PlannerType planner_type = 1;
  bool has_planner_type() const;
  private:
  bool _internal_has_planner_type() const;
  public:
  void clear_planner_type();
  ::apollo::planning::PlannerType planner_type() const;
  void set_planner_type(::apollo::planning::PlannerType value);
  private:
  ::apollo::planning::PlannerType _internal_planner_type() const;
  void _internal_set_planner_type(::apollo::planning::PlannerType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.RtkPlanningConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int planner_type_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class StandardPlanningConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StandardPlanningConfig) */ {
 public:
  StandardPlanningConfig();
  virtual ~StandardPlanningConfig();

  StandardPlanningConfig(const StandardPlanningConfig& from);
  StandardPlanningConfig(StandardPlanningConfig&& from) noexcept
    : StandardPlanningConfig() {
    *this = ::std::move(from);
  }

  inline StandardPlanningConfig& operator=(const StandardPlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StandardPlanningConfig& operator=(StandardPlanningConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StandardPlanningConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StandardPlanningConfig* internal_default_instance() {
    return reinterpret_cast<const StandardPlanningConfig*>(
               &_StandardPlanningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StandardPlanningConfig& a, StandardPlanningConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StandardPlanningConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StandardPlanningConfig* New() const final {
    return CreateMaybeMessage<StandardPlanningConfig>(nullptr);
  }

  StandardPlanningConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StandardPlanningConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StandardPlanningConfig& from);
  void MergeFrom(const StandardPlanningConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StandardPlanningConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.StandardPlanningConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlannerTypeFieldNumber = 1,
    kPlannerPublicRoadConfigFieldNumber = 2,
  };
  // repeated .apollo.planning.PlannerType planner_type = 1;
  int planner_type_size() const;
  private:
  int _internal_planner_type_size() const;
  public:
  void clear_planner_type();
  private:
  ::apollo::planning::PlannerType _internal_planner_type(int index) const;
  void _internal_add_planner_type(::apollo::planning::PlannerType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_planner_type();
  public:
  ::apollo::planning::PlannerType planner_type(int index) const;
  void set_planner_type(int index, ::apollo::planning::PlannerType value);
  void add_planner_type(::apollo::planning::PlannerType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& planner_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_planner_type();

  // optional .apollo.planning.PlannerPublicRoadConfig planner_public_road_config = 2;
  bool has_planner_public_road_config() const;
  private:
  bool _internal_has_planner_public_road_config() const;
  public:
  void clear_planner_public_road_config();
  const ::apollo::planning::PlannerPublicRoadConfig& planner_public_road_config() const;
  ::apollo::planning::PlannerPublicRoadConfig* release_planner_public_road_config();
  ::apollo::planning::PlannerPublicRoadConfig* mutable_planner_public_road_config();
  void set_allocated_planner_public_road_config(::apollo::planning::PlannerPublicRoadConfig* planner_public_road_config);
  private:
  const ::apollo::planning::PlannerPublicRoadConfig& _internal_planner_public_road_config() const;
  ::apollo::planning::PlannerPublicRoadConfig* _internal_mutable_planner_public_road_config();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.StandardPlanningConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> planner_type_;
  ::apollo::planning::PlannerPublicRoadConfig* planner_public_road_config_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class NavigationPlanningConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.NavigationPlanningConfig) */ {
 public:
  NavigationPlanningConfig();
  virtual ~NavigationPlanningConfig();

  NavigationPlanningConfig(const NavigationPlanningConfig& from);
  NavigationPlanningConfig(NavigationPlanningConfig&& from) noexcept
    : NavigationPlanningConfig() {
    *this = ::std::move(from);
  }

  inline NavigationPlanningConfig& operator=(const NavigationPlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationPlanningConfig& operator=(NavigationPlanningConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavigationPlanningConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavigationPlanningConfig* internal_default_instance() {
    return reinterpret_cast<const NavigationPlanningConfig*>(
               &_NavigationPlanningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(NavigationPlanningConfig& a, NavigationPlanningConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationPlanningConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NavigationPlanningConfig* New() const final {
    return CreateMaybeMessage<NavigationPlanningConfig>(nullptr);
  }

  NavigationPlanningConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavigationPlanningConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavigationPlanningConfig& from);
  void MergeFrom(const NavigationPlanningConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationPlanningConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.NavigationPlanningConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlannerTypeFieldNumber = 1,
    kPlannerNaviConfigFieldNumber = 4,
  };
  // repeated .apollo.planning.PlannerType planner_type = 1;
  int planner_type_size() const;
  private:
  int _internal_planner_type_size() const;
  public:
  void clear_planner_type();
  private:
  ::apollo::planning::PlannerType _internal_planner_type(int index) const;
  void _internal_add_planner_type(::apollo::planning::PlannerType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_planner_type();
  public:
  ::apollo::planning::PlannerType planner_type(int index) const;
  void set_planner_type(int index, ::apollo::planning::PlannerType value);
  void add_planner_type(::apollo::planning::PlannerType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& planner_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_planner_type();

  // optional .apollo.planning.PlannerNaviConfig planner_navi_config = 4;
  bool has_planner_navi_config() const;
  private:
  bool _internal_has_planner_navi_config() const;
  public:
  void clear_planner_navi_config();
  const ::apollo::planning::PlannerNaviConfig& planner_navi_config() const;
  ::apollo::planning::PlannerNaviConfig* release_planner_navi_config();
  ::apollo::planning::PlannerNaviConfig* mutable_planner_navi_config();
  void set_allocated_planner_navi_config(::apollo::planning::PlannerNaviConfig* planner_navi_config);
  private:
  const ::apollo::planning::PlannerNaviConfig& _internal_planner_navi_config() const;
  ::apollo::planning::PlannerNaviConfig* _internal_mutable_planner_navi_config();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.NavigationPlanningConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> planner_type_;
  ::apollo::planning::PlannerNaviConfig* planner_navi_config_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class PlanningConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlanningConfig) */ {
 public:
  PlanningConfig();
  virtual ~PlanningConfig();

  PlanningConfig(const PlanningConfig& from);
  PlanningConfig(PlanningConfig&& from) noexcept
    : PlanningConfig() {
    *this = ::std::move(from);
  }

  inline PlanningConfig& operator=(const PlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanningConfig& operator=(PlanningConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlanningConfig& default_instance();

  enum PlanningConfigCase {
    kRtkPlanningConfig = 1,
    kStandardPlanningConfig = 2,
    kNavigationPlanningConfig = 3,
    PLANNING_CONFIG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanningConfig* internal_default_instance() {
    return reinterpret_cast<const PlanningConfig*>(
               &_PlanningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PlanningConfig& a, PlanningConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanningConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlanningConfig* New() const final {
    return CreateMaybeMessage<PlanningConfig>(nullptr);
  }

  PlanningConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlanningConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlanningConfig& from);
  void MergeFrom(const PlanningConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanningConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PlanningConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultTaskConfigFieldNumber = 5,
    kRtkPlanningConfigFieldNumber = 1,
    kStandardPlanningConfigFieldNumber = 2,
    kNavigationPlanningConfigFieldNumber = 3,
  };
  // repeated .apollo.planning.TaskConfig default_task_config = 5;
  int default_task_config_size() const;
  private:
  int _internal_default_task_config_size() const;
  public:
  void clear_default_task_config();
  ::apollo::planning::TaskConfig* mutable_default_task_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TaskConfig >*
      mutable_default_task_config();
  private:
  const ::apollo::planning::TaskConfig& _internal_default_task_config(int index) const;
  ::apollo::planning::TaskConfig* _internal_add_default_task_config();
  public:
  const ::apollo::planning::TaskConfig& default_task_config(int index) const;
  ::apollo::planning::TaskConfig* add_default_task_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TaskConfig >&
      default_task_config() const;

  // optional .apollo.planning.RtkPlanningConfig rtk_planning_config = 1;
  bool has_rtk_planning_config() const;
  private:
  bool _internal_has_rtk_planning_config() const;
  public:
  void clear_rtk_planning_config();
  const ::apollo::planning::RtkPlanningConfig& rtk_planning_config() const;
  ::apollo::planning::RtkPlanningConfig* release_rtk_planning_config();
  ::apollo::planning::RtkPlanningConfig* mutable_rtk_planning_config();
  void set_allocated_rtk_planning_config(::apollo::planning::RtkPlanningConfig* rtk_planning_config);
  private:
  const ::apollo::planning::RtkPlanningConfig& _internal_rtk_planning_config() const;
  ::apollo::planning::RtkPlanningConfig* _internal_mutable_rtk_planning_config();
  public:

  // optional .apollo.planning.StandardPlanningConfig standard_planning_config = 2;
  bool has_standard_planning_config() const;
  private:
  bool _internal_has_standard_planning_config() const;
  public:
  void clear_standard_planning_config();
  const ::apollo::planning::StandardPlanningConfig& standard_planning_config() const;
  ::apollo::planning::StandardPlanningConfig* release_standard_planning_config();
  ::apollo::planning::StandardPlanningConfig* mutable_standard_planning_config();
  void set_allocated_standard_planning_config(::apollo::planning::StandardPlanningConfig* standard_planning_config);
  private:
  const ::apollo::planning::StandardPlanningConfig& _internal_standard_planning_config() const;
  ::apollo::planning::StandardPlanningConfig* _internal_mutable_standard_planning_config();
  public:

  // optional .apollo.planning.NavigationPlanningConfig navigation_planning_config = 3;
  bool has_navigation_planning_config() const;
  private:
  bool _internal_has_navigation_planning_config() const;
  public:
  void clear_navigation_planning_config();
  const ::apollo::planning::NavigationPlanningConfig& navigation_planning_config() const;
  ::apollo::planning::NavigationPlanningConfig* release_navigation_planning_config();
  ::apollo::planning::NavigationPlanningConfig* mutable_navigation_planning_config();
  void set_allocated_navigation_planning_config(::apollo::planning::NavigationPlanningConfig* navigation_planning_config);
  private:
  const ::apollo::planning::NavigationPlanningConfig& _internal_navigation_planning_config() const;
  ::apollo::planning::NavigationPlanningConfig* _internal_mutable_navigation_planning_config();
  public:

  void clear_planning_config();
  PlanningConfigCase planning_config_case() const;
  // @@protoc_insertion_point(class_scope:apollo.planning.PlanningConfig)
 private:
  class _Internal;
  void set_has_rtk_planning_config();
  void set_has_standard_planning_config();
  void set_has_navigation_planning_config();

  inline bool has_planning_config() const;
  inline void clear_has_planning_config();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TaskConfig > default_task_config_;
  union PlanningConfigUnion {
    PlanningConfigUnion() {}
    ::apollo::planning::RtkPlanningConfig* rtk_planning_config_;
    ::apollo::planning::StandardPlanningConfig* standard_planning_config_;
    ::apollo::planning::NavigationPlanningConfig* navigation_planning_config_;
  } planning_config_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PathDeciderConfig

// -------------------------------------------------------------------

// TaskConfig

// optional .apollo.planning.TaskConfig.TaskType task_type = 1;
inline bool TaskConfig::_internal_has_task_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TaskConfig::has_task_type() const {
  return _internal_has_task_type();
}
inline void TaskConfig::clear_task_type() {
  task_type_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::planning::TaskConfig_TaskType TaskConfig::_internal_task_type() const {
  return static_cast< ::apollo::planning::TaskConfig_TaskType >(task_type_);
}
inline ::apollo::planning::TaskConfig_TaskType TaskConfig::task_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.task_type)
  return _internal_task_type();
}
inline void TaskConfig::_internal_set_task_type(::apollo::planning::TaskConfig_TaskType value) {
  assert(::apollo::planning::TaskConfig_TaskType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  task_type_ = value;
}
inline void TaskConfig::set_task_type(::apollo::planning::TaskConfig_TaskType value) {
  _internal_set_task_type(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TaskConfig.task_type)
}

// optional .apollo.planning.DpStSpeedConfig dp_st_speed_config = 3;
inline bool TaskConfig::_internal_has_dp_st_speed_config() const {
  return task_config_case() == kDpStSpeedConfig;
}
inline bool TaskConfig::has_dp_st_speed_config() const {
  return _internal_has_dp_st_speed_config();
}
inline void TaskConfig::set_has_dp_st_speed_config() {
  _oneof_case_[0] = kDpStSpeedConfig;
}
inline ::apollo::planning::DpStSpeedConfig* TaskConfig::release_dp_st_speed_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.dp_st_speed_config)
  if (_internal_has_dp_st_speed_config()) {
    clear_has_task_config();
      ::apollo::planning::DpStSpeedConfig* temp = task_config_.dp_st_speed_config_;
    task_config_.dp_st_speed_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::DpStSpeedConfig& TaskConfig::_internal_dp_st_speed_config() const {
  return _internal_has_dp_st_speed_config()
      ? *task_config_.dp_st_speed_config_
      : *reinterpret_cast< ::apollo::planning::DpStSpeedConfig*>(&::apollo::planning::_DpStSpeedConfig_default_instance_);
}
inline const ::apollo::planning::DpStSpeedConfig& TaskConfig::dp_st_speed_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.dp_st_speed_config)
  return _internal_dp_st_speed_config();
}
inline ::apollo::planning::DpStSpeedConfig* TaskConfig::_internal_mutable_dp_st_speed_config() {
  if (!_internal_has_dp_st_speed_config()) {
    clear_task_config();
    set_has_dp_st_speed_config();
    task_config_.dp_st_speed_config_ = CreateMaybeMessage< ::apollo::planning::DpStSpeedConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.dp_st_speed_config_;
}
inline ::apollo::planning::DpStSpeedConfig* TaskConfig::mutable_dp_st_speed_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.dp_st_speed_config)
  return _internal_mutable_dp_st_speed_config();
}

// optional .apollo.planning.PathDeciderConfig path_decider_config = 7;
inline bool TaskConfig::_internal_has_path_decider_config() const {
  return task_config_case() == kPathDeciderConfig;
}
inline bool TaskConfig::has_path_decider_config() const {
  return _internal_has_path_decider_config();
}
inline void TaskConfig::set_has_path_decider_config() {
  _oneof_case_[0] = kPathDeciderConfig;
}
inline void TaskConfig::clear_path_decider_config() {
  if (_internal_has_path_decider_config()) {
    delete task_config_.path_decider_config_;
    clear_has_task_config();
  }
}
inline ::apollo::planning::PathDeciderConfig* TaskConfig::release_path_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.path_decider_config)
  if (_internal_has_path_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::PathDeciderConfig* temp = task_config_.path_decider_config_;
    task_config_.path_decider_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::PathDeciderConfig& TaskConfig::_internal_path_decider_config() const {
  return _internal_has_path_decider_config()
      ? *task_config_.path_decider_config_
      : *reinterpret_cast< ::apollo::planning::PathDeciderConfig*>(&::apollo::planning::_PathDeciderConfig_default_instance_);
}
inline const ::apollo::planning::PathDeciderConfig& TaskConfig::path_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.path_decider_config)
  return _internal_path_decider_config();
}
inline ::apollo::planning::PathDeciderConfig* TaskConfig::_internal_mutable_path_decider_config() {
  if (!_internal_has_path_decider_config()) {
    clear_task_config();
    set_has_path_decider_config();
    task_config_.path_decider_config_ = CreateMaybeMessage< ::apollo::planning::PathDeciderConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.path_decider_config_;
}
inline ::apollo::planning::PathDeciderConfig* TaskConfig::mutable_path_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.path_decider_config)
  return _internal_mutable_path_decider_config();
}

// optional .apollo.planning.ProceedWithCautionSpeedConfig proceed_with_caution_speed_config = 8;
inline bool TaskConfig::_internal_has_proceed_with_caution_speed_config() const {
  return task_config_case() == kProceedWithCautionSpeedConfig;
}
inline bool TaskConfig::has_proceed_with_caution_speed_config() const {
  return _internal_has_proceed_with_caution_speed_config();
}
inline void TaskConfig::set_has_proceed_with_caution_speed_config() {
  _oneof_case_[0] = kProceedWithCautionSpeedConfig;
}
inline ::apollo::planning::ProceedWithCautionSpeedConfig* TaskConfig::release_proceed_with_caution_speed_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.proceed_with_caution_speed_config)
  if (_internal_has_proceed_with_caution_speed_config()) {
    clear_has_task_config();
      ::apollo::planning::ProceedWithCautionSpeedConfig* temp = task_config_.proceed_with_caution_speed_config_;
    task_config_.proceed_with_caution_speed_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ProceedWithCautionSpeedConfig& TaskConfig::_internal_proceed_with_caution_speed_config() const {
  return _internal_has_proceed_with_caution_speed_config()
      ? *task_config_.proceed_with_caution_speed_config_
      : *reinterpret_cast< ::apollo::planning::ProceedWithCautionSpeedConfig*>(&::apollo::planning::_ProceedWithCautionSpeedConfig_default_instance_);
}
inline const ::apollo::planning::ProceedWithCautionSpeedConfig& TaskConfig::proceed_with_caution_speed_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.proceed_with_caution_speed_config)
  return _internal_proceed_with_caution_speed_config();
}
inline ::apollo::planning::ProceedWithCautionSpeedConfig* TaskConfig::_internal_mutable_proceed_with_caution_speed_config() {
  if (!_internal_has_proceed_with_caution_speed_config()) {
    clear_task_config();
    set_has_proceed_with_caution_speed_config();
    task_config_.proceed_with_caution_speed_config_ = CreateMaybeMessage< ::apollo::planning::ProceedWithCautionSpeedConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.proceed_with_caution_speed_config_;
}
inline ::apollo::planning::ProceedWithCautionSpeedConfig* TaskConfig::mutable_proceed_with_caution_speed_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.proceed_with_caution_speed_config)
  return _internal_mutable_proceed_with_caution_speed_config();
}

// optional .apollo.planning.CreepDeciderConfig creep_decider_config = 10;
inline bool TaskConfig::_internal_has_creep_decider_config() const {
  return task_config_case() == kCreepDeciderConfig;
}
inline bool TaskConfig::has_creep_decider_config() const {
  return _internal_has_creep_decider_config();
}
inline void TaskConfig::set_has_creep_decider_config() {
  _oneof_case_[0] = kCreepDeciderConfig;
}
inline ::apollo::planning::CreepDeciderConfig* TaskConfig::release_creep_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.creep_decider_config)
  if (_internal_has_creep_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::CreepDeciderConfig* temp = task_config_.creep_decider_config_;
    task_config_.creep_decider_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::CreepDeciderConfig& TaskConfig::_internal_creep_decider_config() const {
  return _internal_has_creep_decider_config()
      ? *task_config_.creep_decider_config_
      : *reinterpret_cast< ::apollo::planning::CreepDeciderConfig*>(&::apollo::planning::_CreepDeciderConfig_default_instance_);
}
inline const ::apollo::planning::CreepDeciderConfig& TaskConfig::creep_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.creep_decider_config)
  return _internal_creep_decider_config();
}
inline ::apollo::planning::CreepDeciderConfig* TaskConfig::_internal_mutable_creep_decider_config() {
  if (!_internal_has_creep_decider_config()) {
    clear_task_config();
    set_has_creep_decider_config();
    task_config_.creep_decider_config_ = CreateMaybeMessage< ::apollo::planning::CreepDeciderConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.creep_decider_config_;
}
inline ::apollo::planning::CreepDeciderConfig* TaskConfig::mutable_creep_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.creep_decider_config)
  return _internal_mutable_creep_decider_config();
}

// optional .apollo.planning.OpenSpacePreStopDeciderConfig open_space_pre_stop_decider_config = 11;
inline bool TaskConfig::_internal_has_open_space_pre_stop_decider_config() const {
  return task_config_case() == kOpenSpacePreStopDeciderConfig;
}
inline bool TaskConfig::has_open_space_pre_stop_decider_config() const {
  return _internal_has_open_space_pre_stop_decider_config();
}
inline void TaskConfig::set_has_open_space_pre_stop_decider_config() {
  _oneof_case_[0] = kOpenSpacePreStopDeciderConfig;
}
inline ::apollo::planning::OpenSpacePreStopDeciderConfig* TaskConfig::release_open_space_pre_stop_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.open_space_pre_stop_decider_config)
  if (_internal_has_open_space_pre_stop_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::OpenSpacePreStopDeciderConfig* temp = task_config_.open_space_pre_stop_decider_config_;
    task_config_.open_space_pre_stop_decider_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::OpenSpacePreStopDeciderConfig& TaskConfig::_internal_open_space_pre_stop_decider_config() const {
  return _internal_has_open_space_pre_stop_decider_config()
      ? *task_config_.open_space_pre_stop_decider_config_
      : *reinterpret_cast< ::apollo::planning::OpenSpacePreStopDeciderConfig*>(&::apollo::planning::_OpenSpacePreStopDeciderConfig_default_instance_);
}
inline const ::apollo::planning::OpenSpacePreStopDeciderConfig& TaskConfig::open_space_pre_stop_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.open_space_pre_stop_decider_config)
  return _internal_open_space_pre_stop_decider_config();
}
inline ::apollo::planning::OpenSpacePreStopDeciderConfig* TaskConfig::_internal_mutable_open_space_pre_stop_decider_config() {
  if (!_internal_has_open_space_pre_stop_decider_config()) {
    clear_task_config();
    set_has_open_space_pre_stop_decider_config();
    task_config_.open_space_pre_stop_decider_config_ = CreateMaybeMessage< ::apollo::planning::OpenSpacePreStopDeciderConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.open_space_pre_stop_decider_config_;
}
inline ::apollo::planning::OpenSpacePreStopDeciderConfig* TaskConfig::mutable_open_space_pre_stop_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.open_space_pre_stop_decider_config)
  return _internal_mutable_open_space_pre_stop_decider_config();
}

// optional .apollo.planning.SpeedBoundsDeciderConfig speed_bounds_decider_config = 15;
inline bool TaskConfig::_internal_has_speed_bounds_decider_config() const {
  return task_config_case() == kSpeedBoundsDeciderConfig;
}
inline bool TaskConfig::has_speed_bounds_decider_config() const {
  return _internal_has_speed_bounds_decider_config();
}
inline void TaskConfig::set_has_speed_bounds_decider_config() {
  _oneof_case_[0] = kSpeedBoundsDeciderConfig;
}
inline ::apollo::planning::SpeedBoundsDeciderConfig* TaskConfig::release_speed_bounds_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.speed_bounds_decider_config)
  if (_internal_has_speed_bounds_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::SpeedBoundsDeciderConfig* temp = task_config_.speed_bounds_decider_config_;
    task_config_.speed_bounds_decider_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::SpeedBoundsDeciderConfig& TaskConfig::_internal_speed_bounds_decider_config() const {
  return _internal_has_speed_bounds_decider_config()
      ? *task_config_.speed_bounds_decider_config_
      : *reinterpret_cast< ::apollo::planning::SpeedBoundsDeciderConfig*>(&::apollo::planning::_SpeedBoundsDeciderConfig_default_instance_);
}
inline const ::apollo::planning::SpeedBoundsDeciderConfig& TaskConfig::speed_bounds_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.speed_bounds_decider_config)
  return _internal_speed_bounds_decider_config();
}
inline ::apollo::planning::SpeedBoundsDeciderConfig* TaskConfig::_internal_mutable_speed_bounds_decider_config() {
  if (!_internal_has_speed_bounds_decider_config()) {
    clear_task_config();
    set_has_speed_bounds_decider_config();
    task_config_.speed_bounds_decider_config_ = CreateMaybeMessage< ::apollo::planning::SpeedBoundsDeciderConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.speed_bounds_decider_config_;
}
inline ::apollo::planning::SpeedBoundsDeciderConfig* TaskConfig::mutable_speed_bounds_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.speed_bounds_decider_config)
  return _internal_mutable_speed_bounds_decider_config();
}

// optional .apollo.planning.PiecewiseJerkPathConfig piecewise_jerk_path_config = 16;
inline bool TaskConfig::_internal_has_piecewise_jerk_path_config() const {
  return task_config_case() == kPiecewiseJerkPathConfig;
}
inline bool TaskConfig::has_piecewise_jerk_path_config() const {
  return _internal_has_piecewise_jerk_path_config();
}
inline void TaskConfig::set_has_piecewise_jerk_path_config() {
  _oneof_case_[0] = kPiecewiseJerkPathConfig;
}
inline ::apollo::planning::PiecewiseJerkPathConfig* TaskConfig::release_piecewise_jerk_path_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.piecewise_jerk_path_config)
  if (_internal_has_piecewise_jerk_path_config()) {
    clear_has_task_config();
      ::apollo::planning::PiecewiseJerkPathConfig* temp = task_config_.piecewise_jerk_path_config_;
    task_config_.piecewise_jerk_path_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::PiecewiseJerkPathConfig& TaskConfig::_internal_piecewise_jerk_path_config() const {
  return _internal_has_piecewise_jerk_path_config()
      ? *task_config_.piecewise_jerk_path_config_
      : *reinterpret_cast< ::apollo::planning::PiecewiseJerkPathConfig*>(&::apollo::planning::_PiecewiseJerkPathConfig_default_instance_);
}
inline const ::apollo::planning::PiecewiseJerkPathConfig& TaskConfig::piecewise_jerk_path_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.piecewise_jerk_path_config)
  return _internal_piecewise_jerk_path_config();
}
inline ::apollo::planning::PiecewiseJerkPathConfig* TaskConfig::_internal_mutable_piecewise_jerk_path_config() {
  if (!_internal_has_piecewise_jerk_path_config()) {
    clear_task_config();
    set_has_piecewise_jerk_path_config();
    task_config_.piecewise_jerk_path_config_ = CreateMaybeMessage< ::apollo::planning::PiecewiseJerkPathConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.piecewise_jerk_path_config_;
}
inline ::apollo::planning::PiecewiseJerkPathConfig* TaskConfig::mutable_piecewise_jerk_path_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.piecewise_jerk_path_config)
  return _internal_mutable_piecewise_jerk_path_config();
}

// optional .apollo.planning.PathBoundsDeciderConfig path_bounds_decider_config = 17;
inline bool TaskConfig::_internal_has_path_bounds_decider_config() const {
  return task_config_case() == kPathBoundsDeciderConfig;
}
inline bool TaskConfig::has_path_bounds_decider_config() const {
  return _internal_has_path_bounds_decider_config();
}
inline void TaskConfig::set_has_path_bounds_decider_config() {
  _oneof_case_[0] = kPathBoundsDeciderConfig;
}
inline ::apollo::planning::PathBoundsDeciderConfig* TaskConfig::release_path_bounds_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.path_bounds_decider_config)
  if (_internal_has_path_bounds_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::PathBoundsDeciderConfig* temp = task_config_.path_bounds_decider_config_;
    task_config_.path_bounds_decider_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::PathBoundsDeciderConfig& TaskConfig::_internal_path_bounds_decider_config() const {
  return _internal_has_path_bounds_decider_config()
      ? *task_config_.path_bounds_decider_config_
      : *reinterpret_cast< ::apollo::planning::PathBoundsDeciderConfig*>(&::apollo::planning::_PathBoundsDeciderConfig_default_instance_);
}
inline const ::apollo::planning::PathBoundsDeciderConfig& TaskConfig::path_bounds_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.path_bounds_decider_config)
  return _internal_path_bounds_decider_config();
}
inline ::apollo::planning::PathBoundsDeciderConfig* TaskConfig::_internal_mutable_path_bounds_decider_config() {
  if (!_internal_has_path_bounds_decider_config()) {
    clear_task_config();
    set_has_path_bounds_decider_config();
    task_config_.path_bounds_decider_config_ = CreateMaybeMessage< ::apollo::planning::PathBoundsDeciderConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.path_bounds_decider_config_;
}
inline ::apollo::planning::PathBoundsDeciderConfig* TaskConfig::mutable_path_bounds_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.path_bounds_decider_config)
  return _internal_mutable_path_bounds_decider_config();
}

// optional .apollo.planning.OpenSpaceFallBackDeciderConfig open_space_fallback_decider_config = 18;
inline bool TaskConfig::_internal_has_open_space_fallback_decider_config() const {
  return task_config_case() == kOpenSpaceFallbackDeciderConfig;
}
inline bool TaskConfig::has_open_space_fallback_decider_config() const {
  return _internal_has_open_space_fallback_decider_config();
}
inline void TaskConfig::set_has_open_space_fallback_decider_config() {
  _oneof_case_[0] = kOpenSpaceFallbackDeciderConfig;
}
inline ::apollo::planning::OpenSpaceFallBackDeciderConfig* TaskConfig::release_open_space_fallback_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.open_space_fallback_decider_config)
  if (_internal_has_open_space_fallback_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::OpenSpaceFallBackDeciderConfig* temp = task_config_.open_space_fallback_decider_config_;
    task_config_.open_space_fallback_decider_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::OpenSpaceFallBackDeciderConfig& TaskConfig::_internal_open_space_fallback_decider_config() const {
  return _internal_has_open_space_fallback_decider_config()
      ? *task_config_.open_space_fallback_decider_config_
      : *reinterpret_cast< ::apollo::planning::OpenSpaceFallBackDeciderConfig*>(&::apollo::planning::_OpenSpaceFallBackDeciderConfig_default_instance_);
}
inline const ::apollo::planning::OpenSpaceFallBackDeciderConfig& TaskConfig::open_space_fallback_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.open_space_fallback_decider_config)
  return _internal_open_space_fallback_decider_config();
}
inline ::apollo::planning::OpenSpaceFallBackDeciderConfig* TaskConfig::_internal_mutable_open_space_fallback_decider_config() {
  if (!_internal_has_open_space_fallback_decider_config()) {
    clear_task_config();
    set_has_open_space_fallback_decider_config();
    task_config_.open_space_fallback_decider_config_ = CreateMaybeMessage< ::apollo::planning::OpenSpaceFallBackDeciderConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.open_space_fallback_decider_config_;
}
inline ::apollo::planning::OpenSpaceFallBackDeciderConfig* TaskConfig::mutable_open_space_fallback_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.open_space_fallback_decider_config)
  return _internal_mutable_open_space_fallback_decider_config();
}

// optional .apollo.planning.OpenSpaceRoiDeciderConfig open_space_roi_decider_config = 19;
inline bool TaskConfig::_internal_has_open_space_roi_decider_config() const {
  return task_config_case() == kOpenSpaceRoiDeciderConfig;
}
inline bool TaskConfig::has_open_space_roi_decider_config() const {
  return _internal_has_open_space_roi_decider_config();
}
inline void TaskConfig::set_has_open_space_roi_decider_config() {
  _oneof_case_[0] = kOpenSpaceRoiDeciderConfig;
}
inline ::apollo::planning::OpenSpaceRoiDeciderConfig* TaskConfig::release_open_space_roi_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.open_space_roi_decider_config)
  if (_internal_has_open_space_roi_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::OpenSpaceRoiDeciderConfig* temp = task_config_.open_space_roi_decider_config_;
    task_config_.open_space_roi_decider_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::OpenSpaceRoiDeciderConfig& TaskConfig::_internal_open_space_roi_decider_config() const {
  return _internal_has_open_space_roi_decider_config()
      ? *task_config_.open_space_roi_decider_config_
      : *reinterpret_cast< ::apollo::planning::OpenSpaceRoiDeciderConfig*>(&::apollo::planning::_OpenSpaceRoiDeciderConfig_default_instance_);
}
inline const ::apollo::planning::OpenSpaceRoiDeciderConfig& TaskConfig::open_space_roi_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.open_space_roi_decider_config)
  return _internal_open_space_roi_decider_config();
}
inline ::apollo::planning::OpenSpaceRoiDeciderConfig* TaskConfig::_internal_mutable_open_space_roi_decider_config() {
  if (!_internal_has_open_space_roi_decider_config()) {
    clear_task_config();
    set_has_open_space_roi_decider_config();
    task_config_.open_space_roi_decider_config_ = CreateMaybeMessage< ::apollo::planning::OpenSpaceRoiDeciderConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.open_space_roi_decider_config_;
}
inline ::apollo::planning::OpenSpaceRoiDeciderConfig* TaskConfig::mutable_open_space_roi_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.open_space_roi_decider_config)
  return _internal_mutable_open_space_roi_decider_config();
}

// optional .apollo.planning.OpenSpaceTrajectoryProviderConfig open_space_trajectory_provider_config = 20;
inline bool TaskConfig::_internal_has_open_space_trajectory_provider_config() const {
  return task_config_case() == kOpenSpaceTrajectoryProviderConfig;
}
inline bool TaskConfig::has_open_space_trajectory_provider_config() const {
  return _internal_has_open_space_trajectory_provider_config();
}
inline void TaskConfig::set_has_open_space_trajectory_provider_config() {
  _oneof_case_[0] = kOpenSpaceTrajectoryProviderConfig;
}
inline ::apollo::planning::OpenSpaceTrajectoryProviderConfig* TaskConfig::release_open_space_trajectory_provider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.open_space_trajectory_provider_config)
  if (_internal_has_open_space_trajectory_provider_config()) {
    clear_has_task_config();
      ::apollo::planning::OpenSpaceTrajectoryProviderConfig* temp = task_config_.open_space_trajectory_provider_config_;
    task_config_.open_space_trajectory_provider_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::OpenSpaceTrajectoryProviderConfig& TaskConfig::_internal_open_space_trajectory_provider_config() const {
  return _internal_has_open_space_trajectory_provider_config()
      ? *task_config_.open_space_trajectory_provider_config_
      : *reinterpret_cast< ::apollo::planning::OpenSpaceTrajectoryProviderConfig*>(&::apollo::planning::_OpenSpaceTrajectoryProviderConfig_default_instance_);
}
inline const ::apollo::planning::OpenSpaceTrajectoryProviderConfig& TaskConfig::open_space_trajectory_provider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.open_space_trajectory_provider_config)
  return _internal_open_space_trajectory_provider_config();
}
inline ::apollo::planning::OpenSpaceTrajectoryProviderConfig* TaskConfig::_internal_mutable_open_space_trajectory_provider_config() {
  if (!_internal_has_open_space_trajectory_provider_config()) {
    clear_task_config();
    set_has_open_space_trajectory_provider_config();
    task_config_.open_space_trajectory_provider_config_ = CreateMaybeMessage< ::apollo::planning::OpenSpaceTrajectoryProviderConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.open_space_trajectory_provider_config_;
}
inline ::apollo::planning::OpenSpaceTrajectoryProviderConfig* TaskConfig::mutable_open_space_trajectory_provider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.open_space_trajectory_provider_config)
  return _internal_mutable_open_space_trajectory_provider_config();
}

// optional .apollo.planning.OpenSpaceTrajectoryPartitionConfig open_space_trajectory_partition_config = 21;
inline bool TaskConfig::_internal_has_open_space_trajectory_partition_config() const {
  return task_config_case() == kOpenSpaceTrajectoryPartitionConfig;
}
inline bool TaskConfig::has_open_space_trajectory_partition_config() const {
  return _internal_has_open_space_trajectory_partition_config();
}
inline void TaskConfig::set_has_open_space_trajectory_partition_config() {
  _oneof_case_[0] = kOpenSpaceTrajectoryPartitionConfig;
}
inline ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* TaskConfig::release_open_space_trajectory_partition_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.open_space_trajectory_partition_config)
  if (_internal_has_open_space_trajectory_partition_config()) {
    clear_has_task_config();
      ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* temp = task_config_.open_space_trajectory_partition_config_;
    task_config_.open_space_trajectory_partition_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::OpenSpaceTrajectoryPartitionConfig& TaskConfig::_internal_open_space_trajectory_partition_config() const {
  return _internal_has_open_space_trajectory_partition_config()
      ? *task_config_.open_space_trajectory_partition_config_
      : *reinterpret_cast< ::apollo::planning::OpenSpaceTrajectoryPartitionConfig*>(&::apollo::planning::_OpenSpaceTrajectoryPartitionConfig_default_instance_);
}
inline const ::apollo::planning::OpenSpaceTrajectoryPartitionConfig& TaskConfig::open_space_trajectory_partition_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.open_space_trajectory_partition_config)
  return _internal_open_space_trajectory_partition_config();
}
inline ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* TaskConfig::_internal_mutable_open_space_trajectory_partition_config() {
  if (!_internal_has_open_space_trajectory_partition_config()) {
    clear_task_config();
    set_has_open_space_trajectory_partition_config();
    task_config_.open_space_trajectory_partition_config_ = CreateMaybeMessage< ::apollo::planning::OpenSpaceTrajectoryPartitionConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.open_space_trajectory_partition_config_;
}
inline ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* TaskConfig::mutable_open_space_trajectory_partition_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.open_space_trajectory_partition_config)
  return _internal_mutable_open_space_trajectory_partition_config();
}

// optional .apollo.planning.PathAssessmentDeciderConfig path_assessment_decider_config = 22;
inline bool TaskConfig::_internal_has_path_assessment_decider_config() const {
  return task_config_case() == kPathAssessmentDeciderConfig;
}
inline bool TaskConfig::has_path_assessment_decider_config() const {
  return _internal_has_path_assessment_decider_config();
}
inline void TaskConfig::set_has_path_assessment_decider_config() {
  _oneof_case_[0] = kPathAssessmentDeciderConfig;
}
inline ::apollo::planning::PathAssessmentDeciderConfig* TaskConfig::release_path_assessment_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.path_assessment_decider_config)
  if (_internal_has_path_assessment_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::PathAssessmentDeciderConfig* temp = task_config_.path_assessment_decider_config_;
    task_config_.path_assessment_decider_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::PathAssessmentDeciderConfig& TaskConfig::_internal_path_assessment_decider_config() const {
  return _internal_has_path_assessment_decider_config()
      ? *task_config_.path_assessment_decider_config_
      : *reinterpret_cast< ::apollo::planning::PathAssessmentDeciderConfig*>(&::apollo::planning::_PathAssessmentDeciderConfig_default_instance_);
}
inline const ::apollo::planning::PathAssessmentDeciderConfig& TaskConfig::path_assessment_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.path_assessment_decider_config)
  return _internal_path_assessment_decider_config();
}
inline ::apollo::planning::PathAssessmentDeciderConfig* TaskConfig::_internal_mutable_path_assessment_decider_config() {
  if (!_internal_has_path_assessment_decider_config()) {
    clear_task_config();
    set_has_path_assessment_decider_config();
    task_config_.path_assessment_decider_config_ = CreateMaybeMessage< ::apollo::planning::PathAssessmentDeciderConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.path_assessment_decider_config_;
}
inline ::apollo::planning::PathAssessmentDeciderConfig* TaskConfig::mutable_path_assessment_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.path_assessment_decider_config)
  return _internal_mutable_path_assessment_decider_config();
}

// optional .apollo.planning.PiecewiseJerkSpeedConfig piecewise_jerk_speed_config = 23;
inline bool TaskConfig::_internal_has_piecewise_jerk_speed_config() const {
  return task_config_case() == kPiecewiseJerkSpeedConfig;
}
inline bool TaskConfig::has_piecewise_jerk_speed_config() const {
  return _internal_has_piecewise_jerk_speed_config();
}
inline void TaskConfig::set_has_piecewise_jerk_speed_config() {
  _oneof_case_[0] = kPiecewiseJerkSpeedConfig;
}
inline ::apollo::planning::PiecewiseJerkSpeedConfig* TaskConfig::release_piecewise_jerk_speed_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.piecewise_jerk_speed_config)
  if (_internal_has_piecewise_jerk_speed_config()) {
    clear_has_task_config();
      ::apollo::planning::PiecewiseJerkSpeedConfig* temp = task_config_.piecewise_jerk_speed_config_;
    task_config_.piecewise_jerk_speed_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::PiecewiseJerkSpeedConfig& TaskConfig::_internal_piecewise_jerk_speed_config() const {
  return _internal_has_piecewise_jerk_speed_config()
      ? *task_config_.piecewise_jerk_speed_config_
      : *reinterpret_cast< ::apollo::planning::PiecewiseJerkSpeedConfig*>(&::apollo::planning::_PiecewiseJerkSpeedConfig_default_instance_);
}
inline const ::apollo::planning::PiecewiseJerkSpeedConfig& TaskConfig::piecewise_jerk_speed_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.piecewise_jerk_speed_config)
  return _internal_piecewise_jerk_speed_config();
}
inline ::apollo::planning::PiecewiseJerkSpeedConfig* TaskConfig::_internal_mutable_piecewise_jerk_speed_config() {
  if (!_internal_has_piecewise_jerk_speed_config()) {
    clear_task_config();
    set_has_piecewise_jerk_speed_config();
    task_config_.piecewise_jerk_speed_config_ = CreateMaybeMessage< ::apollo::planning::PiecewiseJerkSpeedConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.piecewise_jerk_speed_config_;
}
inline ::apollo::planning::PiecewiseJerkSpeedConfig* TaskConfig::mutable_piecewise_jerk_speed_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.piecewise_jerk_speed_config)
  return _internal_mutable_piecewise_jerk_speed_config();
}

// optional .apollo.planning.PathLaneBorrowDeciderConfig path_lane_borrow_decider_config = 24;
inline bool TaskConfig::_internal_has_path_lane_borrow_decider_config() const {
  return task_config_case() == kPathLaneBorrowDeciderConfig;
}
inline bool TaskConfig::has_path_lane_borrow_decider_config() const {
  return _internal_has_path_lane_borrow_decider_config();
}
inline void TaskConfig::set_has_path_lane_borrow_decider_config() {
  _oneof_case_[0] = kPathLaneBorrowDeciderConfig;
}
inline ::apollo::planning::PathLaneBorrowDeciderConfig* TaskConfig::release_path_lane_borrow_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.path_lane_borrow_decider_config)
  if (_internal_has_path_lane_borrow_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::PathLaneBorrowDeciderConfig* temp = task_config_.path_lane_borrow_decider_config_;
    task_config_.path_lane_borrow_decider_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::PathLaneBorrowDeciderConfig& TaskConfig::_internal_path_lane_borrow_decider_config() const {
  return _internal_has_path_lane_borrow_decider_config()
      ? *task_config_.path_lane_borrow_decider_config_
      : *reinterpret_cast< ::apollo::planning::PathLaneBorrowDeciderConfig*>(&::apollo::planning::_PathLaneBorrowDeciderConfig_default_instance_);
}
inline const ::apollo::planning::PathLaneBorrowDeciderConfig& TaskConfig::path_lane_borrow_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.path_lane_borrow_decider_config)
  return _internal_path_lane_borrow_decider_config();
}
inline ::apollo::planning::PathLaneBorrowDeciderConfig* TaskConfig::_internal_mutable_path_lane_borrow_decider_config() {
  if (!_internal_has_path_lane_borrow_decider_config()) {
    clear_task_config();
    set_has_path_lane_borrow_decider_config();
    task_config_.path_lane_borrow_decider_config_ = CreateMaybeMessage< ::apollo::planning::PathLaneBorrowDeciderConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.path_lane_borrow_decider_config_;
}
inline ::apollo::planning::PathLaneBorrowDeciderConfig* TaskConfig::mutable_path_lane_borrow_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.path_lane_borrow_decider_config)
  return _internal_mutable_path_lane_borrow_decider_config();
}

// optional .apollo.planning.LaneChangeDeciderConfig lane_change_decider_config = 25;
inline bool TaskConfig::_internal_has_lane_change_decider_config() const {
  return task_config_case() == kLaneChangeDeciderConfig;
}
inline bool TaskConfig::has_lane_change_decider_config() const {
  return _internal_has_lane_change_decider_config();
}
inline void TaskConfig::set_has_lane_change_decider_config() {
  _oneof_case_[0] = kLaneChangeDeciderConfig;
}
inline ::apollo::planning::LaneChangeDeciderConfig* TaskConfig::release_lane_change_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.lane_change_decider_config)
  if (_internal_has_lane_change_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::LaneChangeDeciderConfig* temp = task_config_.lane_change_decider_config_;
    task_config_.lane_change_decider_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::LaneChangeDeciderConfig& TaskConfig::_internal_lane_change_decider_config() const {
  return _internal_has_lane_change_decider_config()
      ? *task_config_.lane_change_decider_config_
      : *reinterpret_cast< ::apollo::planning::LaneChangeDeciderConfig*>(&::apollo::planning::_LaneChangeDeciderConfig_default_instance_);
}
inline const ::apollo::planning::LaneChangeDeciderConfig& TaskConfig::lane_change_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.lane_change_decider_config)
  return _internal_lane_change_decider_config();
}
inline ::apollo::planning::LaneChangeDeciderConfig* TaskConfig::_internal_mutable_lane_change_decider_config() {
  if (!_internal_has_lane_change_decider_config()) {
    clear_task_config();
    set_has_lane_change_decider_config();
    task_config_.lane_change_decider_config_ = CreateMaybeMessage< ::apollo::planning::LaneChangeDeciderConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.lane_change_decider_config_;
}
inline ::apollo::planning::LaneChangeDeciderConfig* TaskConfig::mutable_lane_change_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.lane_change_decider_config)
  return _internal_mutable_lane_change_decider_config();
}

// optional .apollo.planning.RuleBasedStopDeciderConfig rule_based_stop_decider_config = 26;
inline bool TaskConfig::_internal_has_rule_based_stop_decider_config() const {
  return task_config_case() == kRuleBasedStopDeciderConfig;
}
inline bool TaskConfig::has_rule_based_stop_decider_config() const {
  return _internal_has_rule_based_stop_decider_config();
}
inline void TaskConfig::set_has_rule_based_stop_decider_config() {
  _oneof_case_[0] = kRuleBasedStopDeciderConfig;
}
inline ::apollo::planning::RuleBasedStopDeciderConfig* TaskConfig::release_rule_based_stop_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.rule_based_stop_decider_config)
  if (_internal_has_rule_based_stop_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::RuleBasedStopDeciderConfig* temp = task_config_.rule_based_stop_decider_config_;
    task_config_.rule_based_stop_decider_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::RuleBasedStopDeciderConfig& TaskConfig::_internal_rule_based_stop_decider_config() const {
  return _internal_has_rule_based_stop_decider_config()
      ? *task_config_.rule_based_stop_decider_config_
      : *reinterpret_cast< ::apollo::planning::RuleBasedStopDeciderConfig*>(&::apollo::planning::_RuleBasedStopDeciderConfig_default_instance_);
}
inline const ::apollo::planning::RuleBasedStopDeciderConfig& TaskConfig::rule_based_stop_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.rule_based_stop_decider_config)
  return _internal_rule_based_stop_decider_config();
}
inline ::apollo::planning::RuleBasedStopDeciderConfig* TaskConfig::_internal_mutable_rule_based_stop_decider_config() {
  if (!_internal_has_rule_based_stop_decider_config()) {
    clear_task_config();
    set_has_rule_based_stop_decider_config();
    task_config_.rule_based_stop_decider_config_ = CreateMaybeMessage< ::apollo::planning::RuleBasedStopDeciderConfig >(
        GetArenaNoVirtual());
  }
  return task_config_.rule_based_stop_decider_config_;
}
inline ::apollo::planning::RuleBasedStopDeciderConfig* TaskConfig::mutable_rule_based_stop_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.rule_based_stop_decider_config)
  return _internal_mutable_rule_based_stop_decider_config();
}

inline bool TaskConfig::has_task_config() const {
  return task_config_case() != TASK_CONFIG_NOT_SET;
}
inline void TaskConfig::clear_has_task_config() {
  _oneof_case_[0] = TASK_CONFIG_NOT_SET;
}
inline TaskConfig::TaskConfigCase TaskConfig::task_config_case() const {
  return TaskConfig::TaskConfigCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ScenarioLaneFollowConfig

// -------------------------------------------------------------------

// ScenarioBareIntersectionUnprotectedConfig

// optional double start_bare_intersection_scenario_distance = 1 [default = 25];
inline bool ScenarioBareIntersectionUnprotectedConfig::_internal_has_start_bare_intersection_scenario_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScenarioBareIntersectionUnprotectedConfig::has_start_bare_intersection_scenario_distance() const {
  return _internal_has_start_bare_intersection_scenario_distance();
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_start_bare_intersection_scenario_distance() {
  start_bare_intersection_scenario_distance_ = 25;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ScenarioBareIntersectionUnprotectedConfig::_internal_start_bare_intersection_scenario_distance() const {
  return start_bare_intersection_scenario_distance_;
}
inline double ScenarioBareIntersectionUnprotectedConfig::start_bare_intersection_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.start_bare_intersection_scenario_distance)
  return _internal_start_bare_intersection_scenario_distance();
}
inline void ScenarioBareIntersectionUnprotectedConfig::_internal_set_start_bare_intersection_scenario_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  start_bare_intersection_scenario_distance_ = value;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_start_bare_intersection_scenario_distance(double value) {
  _internal_set_start_bare_intersection_scenario_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.start_bare_intersection_scenario_distance)
}

// optional bool enable_explicit_stop = 2 [default = false];
inline bool ScenarioBareIntersectionUnprotectedConfig::_internal_has_enable_explicit_stop() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScenarioBareIntersectionUnprotectedConfig::has_enable_explicit_stop() const {
  return _internal_has_enable_explicit_stop();
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_enable_explicit_stop() {
  enable_explicit_stop_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ScenarioBareIntersectionUnprotectedConfig::_internal_enable_explicit_stop() const {
  return enable_explicit_stop_;
}
inline bool ScenarioBareIntersectionUnprotectedConfig::enable_explicit_stop() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.enable_explicit_stop)
  return _internal_enable_explicit_stop();
}
inline void ScenarioBareIntersectionUnprotectedConfig::_internal_set_enable_explicit_stop(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enable_explicit_stop_ = value;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_enable_explicit_stop(bool value) {
  _internal_set_enable_explicit_stop(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.enable_explicit_stop)
}

// optional double min_pass_s_distance = 3 [default = 3];
inline bool ScenarioBareIntersectionUnprotectedConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScenarioBareIntersectionUnprotectedConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ScenarioBareIntersectionUnprotectedConfig::_internal_min_pass_s_distance() const {
  return min_pass_s_distance_;
}
inline double ScenarioBareIntersectionUnprotectedConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void ScenarioBareIntersectionUnprotectedConfig::_internal_set_min_pass_s_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  min_pass_s_distance_ = value;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.min_pass_s_distance)
}

// optional double approach_speed_limit = 4 [default = 6.7056];
inline bool ScenarioBareIntersectionUnprotectedConfig::_internal_has_approach_speed_limit() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ScenarioBareIntersectionUnprotectedConfig::has_approach_speed_limit() const {
  return _internal_has_approach_speed_limit();
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_approach_speed_limit() {
  approach_speed_limit_ = 6.7056;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ScenarioBareIntersectionUnprotectedConfig::_internal_approach_speed_limit() const {
  return approach_speed_limit_;
}
inline double ScenarioBareIntersectionUnprotectedConfig::approach_speed_limit() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.approach_speed_limit)
  return _internal_approach_speed_limit();
}
inline void ScenarioBareIntersectionUnprotectedConfig::_internal_set_approach_speed_limit(double value) {
  _has_bits_[0] |= 0x00000008u;
  approach_speed_limit_ = value;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_approach_speed_limit(double value) {
  _internal_set_approach_speed_limit(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.approach_speed_limit)
}

// optional double stop_distance = 5 [default = 0.5];
inline bool ScenarioBareIntersectionUnprotectedConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ScenarioBareIntersectionUnprotectedConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ScenarioBareIntersectionUnprotectedConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double ScenarioBareIntersectionUnprotectedConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.stop_distance)
  return _internal_stop_distance();
}
inline void ScenarioBareIntersectionUnprotectedConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000010u;
  stop_distance_ = value;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.stop_distance)
}

// optional float stop_timeout_sec = 6 [default = 8];
inline bool ScenarioBareIntersectionUnprotectedConfig::_internal_has_stop_timeout_sec() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ScenarioBareIntersectionUnprotectedConfig::has_stop_timeout_sec() const {
  return _internal_has_stop_timeout_sec();
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_stop_timeout_sec() {
  stop_timeout_sec_ = 8;
  _has_bits_[0] &= ~0x00000020u;
}
inline float ScenarioBareIntersectionUnprotectedConfig::_internal_stop_timeout_sec() const {
  return stop_timeout_sec_;
}
inline float ScenarioBareIntersectionUnprotectedConfig::stop_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.stop_timeout_sec)
  return _internal_stop_timeout_sec();
}
inline void ScenarioBareIntersectionUnprotectedConfig::_internal_set_stop_timeout_sec(float value) {
  _has_bits_[0] |= 0x00000020u;
  stop_timeout_sec_ = value;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_stop_timeout_sec(float value) {
  _internal_set_stop_timeout_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.stop_timeout_sec)
}

// optional float creep_timeout_sec = 7 [default = 10];
inline bool ScenarioBareIntersectionUnprotectedConfig::_internal_has_creep_timeout_sec() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ScenarioBareIntersectionUnprotectedConfig::has_creep_timeout_sec() const {
  return _internal_has_creep_timeout_sec();
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  _has_bits_[0] &= ~0x00000040u;
}
inline float ScenarioBareIntersectionUnprotectedConfig::_internal_creep_timeout_sec() const {
  return creep_timeout_sec_;
}
inline float ScenarioBareIntersectionUnprotectedConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.creep_timeout_sec)
  return _internal_creep_timeout_sec();
}
inline void ScenarioBareIntersectionUnprotectedConfig::_internal_set_creep_timeout_sec(float value) {
  _has_bits_[0] |= 0x00000040u;
  creep_timeout_sec_ = value;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_creep_timeout_sec(float value) {
  _internal_set_creep_timeout_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.creep_timeout_sec)
}

// -------------------------------------------------------------------

// ScenarioStopSignUnprotectedConfig

// optional double start_stop_sign_scenario_distance = 1 [default = 5];
inline bool ScenarioStopSignUnprotectedConfig::_internal_has_start_stop_sign_scenario_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScenarioStopSignUnprotectedConfig::has_start_stop_sign_scenario_distance() const {
  return _internal_has_start_stop_sign_scenario_distance();
}
inline void ScenarioStopSignUnprotectedConfig::clear_start_stop_sign_scenario_distance() {
  start_stop_sign_scenario_distance_ = 5;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ScenarioStopSignUnprotectedConfig::_internal_start_stop_sign_scenario_distance() const {
  return start_stop_sign_scenario_distance_;
}
inline double ScenarioStopSignUnprotectedConfig::start_stop_sign_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.start_stop_sign_scenario_distance)
  return _internal_start_stop_sign_scenario_distance();
}
inline void ScenarioStopSignUnprotectedConfig::_internal_set_start_stop_sign_scenario_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  start_stop_sign_scenario_distance_ = value;
}
inline void ScenarioStopSignUnprotectedConfig::set_start_stop_sign_scenario_distance(double value) {
  _internal_set_start_stop_sign_scenario_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.start_stop_sign_scenario_distance)
}

// optional double watch_vehicle_max_valid_stop_distance = 2 [default = 5];
inline bool ScenarioStopSignUnprotectedConfig::_internal_has_watch_vehicle_max_valid_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScenarioStopSignUnprotectedConfig::has_watch_vehicle_max_valid_stop_distance() const {
  return _internal_has_watch_vehicle_max_valid_stop_distance();
}
inline void ScenarioStopSignUnprotectedConfig::clear_watch_vehicle_max_valid_stop_distance() {
  watch_vehicle_max_valid_stop_distance_ = 5;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ScenarioStopSignUnprotectedConfig::_internal_watch_vehicle_max_valid_stop_distance() const {
  return watch_vehicle_max_valid_stop_distance_;
}
inline double ScenarioStopSignUnprotectedConfig::watch_vehicle_max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.watch_vehicle_max_valid_stop_distance)
  return _internal_watch_vehicle_max_valid_stop_distance();
}
inline void ScenarioStopSignUnprotectedConfig::_internal_set_watch_vehicle_max_valid_stop_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  watch_vehicle_max_valid_stop_distance_ = value;
}
inline void ScenarioStopSignUnprotectedConfig::set_watch_vehicle_max_valid_stop_distance(double value) {
  _internal_set_watch_vehicle_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.watch_vehicle_max_valid_stop_distance)
}

// optional double max_valid_stop_distance = 3 [default = 3.5];
inline bool ScenarioStopSignUnprotectedConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ScenarioStopSignUnprotectedConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void ScenarioStopSignUnprotectedConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3.5;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ScenarioStopSignUnprotectedConfig::_internal_max_valid_stop_distance() const {
  return max_valid_stop_distance_;
}
inline double ScenarioStopSignUnprotectedConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void ScenarioStopSignUnprotectedConfig::_internal_set_max_valid_stop_distance(double value) {
  _has_bits_[0] |= 0x00000008u;
  max_valid_stop_distance_ = value;
}
inline void ScenarioStopSignUnprotectedConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.max_valid_stop_distance)
}

// optional double max_adc_stop_speed = 4 [default = 0.3];
inline bool ScenarioStopSignUnprotectedConfig::_internal_has_max_adc_stop_speed() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ScenarioStopSignUnprotectedConfig::has_max_adc_stop_speed() const {
  return _internal_has_max_adc_stop_speed();
}
inline void ScenarioStopSignUnprotectedConfig::clear_max_adc_stop_speed() {
  max_adc_stop_speed_ = 0.3;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ScenarioStopSignUnprotectedConfig::_internal_max_adc_stop_speed() const {
  return max_adc_stop_speed_;
}
inline double ScenarioStopSignUnprotectedConfig::max_adc_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.max_adc_stop_speed)
  return _internal_max_adc_stop_speed();
}
inline void ScenarioStopSignUnprotectedConfig::_internal_set_max_adc_stop_speed(double value) {
  _has_bits_[0] |= 0x00000010u;
  max_adc_stop_speed_ = value;
}
inline void ScenarioStopSignUnprotectedConfig::set_max_adc_stop_speed(double value) {
  _internal_set_max_adc_stop_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.max_adc_stop_speed)
}

// optional float stop_duration_sec = 5 [default = 1];
inline bool ScenarioStopSignUnprotectedConfig::_internal_has_stop_duration_sec() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ScenarioStopSignUnprotectedConfig::has_stop_duration_sec() const {
  return _internal_has_stop_duration_sec();
}
inline void ScenarioStopSignUnprotectedConfig::clear_stop_duration_sec() {
  stop_duration_sec_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline float ScenarioStopSignUnprotectedConfig::_internal_stop_duration_sec() const {
  return stop_duration_sec_;
}
inline float ScenarioStopSignUnprotectedConfig::stop_duration_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.stop_duration_sec)
  return _internal_stop_duration_sec();
}
inline void ScenarioStopSignUnprotectedConfig::_internal_set_stop_duration_sec(float value) {
  _has_bits_[0] |= 0x00000040u;
  stop_duration_sec_ = value;
}
inline void ScenarioStopSignUnprotectedConfig::set_stop_duration_sec(float value) {
  _internal_set_stop_duration_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.stop_duration_sec)
}

// optional double min_pass_s_distance = 6 [default = 3];
inline bool ScenarioStopSignUnprotectedConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ScenarioStopSignUnprotectedConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void ScenarioStopSignUnprotectedConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ScenarioStopSignUnprotectedConfig::_internal_min_pass_s_distance() const {
  return min_pass_s_distance_;
}
inline double ScenarioStopSignUnprotectedConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void ScenarioStopSignUnprotectedConfig::_internal_set_min_pass_s_distance(double value) {
  _has_bits_[0] |= 0x00000020u;
  min_pass_s_distance_ = value;
}
inline void ScenarioStopSignUnprotectedConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.min_pass_s_distance)
}

// optional float stop_timeout_sec = 7 [default = 8];
inline bool ScenarioStopSignUnprotectedConfig::_internal_has_stop_timeout_sec() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ScenarioStopSignUnprotectedConfig::has_stop_timeout_sec() const {
  return _internal_has_stop_timeout_sec();
}
inline void ScenarioStopSignUnprotectedConfig::clear_stop_timeout_sec() {
  stop_timeout_sec_ = 8;
  _has_bits_[0] &= ~0x00000080u;
}
inline float ScenarioStopSignUnprotectedConfig::_internal_stop_timeout_sec() const {
  return stop_timeout_sec_;
}
inline float ScenarioStopSignUnprotectedConfig::stop_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.stop_timeout_sec)
  return _internal_stop_timeout_sec();
}
inline void ScenarioStopSignUnprotectedConfig::_internal_set_stop_timeout_sec(float value) {
  _has_bits_[0] |= 0x00000080u;
  stop_timeout_sec_ = value;
}
inline void ScenarioStopSignUnprotectedConfig::set_stop_timeout_sec(float value) {
  _internal_set_stop_timeout_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.stop_timeout_sec)
}

// optional float creep_timeout_sec = 8 [default = 10];
inline bool ScenarioStopSignUnprotectedConfig::_internal_has_creep_timeout_sec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScenarioStopSignUnprotectedConfig::has_creep_timeout_sec() const {
  return _internal_has_creep_timeout_sec();
}
inline void ScenarioStopSignUnprotectedConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ScenarioStopSignUnprotectedConfig::_internal_creep_timeout_sec() const {
  return creep_timeout_sec_;
}
inline float ScenarioStopSignUnprotectedConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.creep_timeout_sec)
  return _internal_creep_timeout_sec();
}
inline void ScenarioStopSignUnprotectedConfig::_internal_set_creep_timeout_sec(float value) {
  _has_bits_[0] |= 0x00000001u;
  creep_timeout_sec_ = value;
}
inline void ScenarioStopSignUnprotectedConfig::set_creep_timeout_sec(float value) {
  _internal_set_creep_timeout_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.creep_timeout_sec)
}

// -------------------------------------------------------------------

// ScenarioTrafficLightProtectedConfig

// optional double start_traffic_light_scenario_distance = 1 [default = 5];
inline bool ScenarioTrafficLightProtectedConfig::_internal_has_start_traffic_light_scenario_distance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScenarioTrafficLightProtectedConfig::has_start_traffic_light_scenario_distance() const {
  return _internal_has_start_traffic_light_scenario_distance();
}
inline void ScenarioTrafficLightProtectedConfig::clear_start_traffic_light_scenario_distance() {
  start_traffic_light_scenario_distance_ = 5;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ScenarioTrafficLightProtectedConfig::_internal_start_traffic_light_scenario_distance() const {
  return start_traffic_light_scenario_distance_;
}
inline double ScenarioTrafficLightProtectedConfig::start_traffic_light_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightProtectedConfig.start_traffic_light_scenario_distance)
  return _internal_start_traffic_light_scenario_distance();
}
inline void ScenarioTrafficLightProtectedConfig::_internal_set_start_traffic_light_scenario_distance(double value) {
  _has_bits_[0] |= 0x00000001u;
  start_traffic_light_scenario_distance_ = value;
}
inline void ScenarioTrafficLightProtectedConfig::set_start_traffic_light_scenario_distance(double value) {
  _internal_set_start_traffic_light_scenario_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightProtectedConfig.start_traffic_light_scenario_distance)
}

// optional double max_valid_stop_distance = 2 [default = 2];
inline bool ScenarioTrafficLightProtectedConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScenarioTrafficLightProtectedConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void ScenarioTrafficLightProtectedConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 2;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ScenarioTrafficLightProtectedConfig::_internal_max_valid_stop_distance() const {
  return max_valid_stop_distance_;
}
inline double ScenarioTrafficLightProtectedConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightProtectedConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void ScenarioTrafficLightProtectedConfig::_internal_set_max_valid_stop_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  max_valid_stop_distance_ = value;
}
inline void ScenarioTrafficLightProtectedConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightProtectedConfig.max_valid_stop_distance)
}

// optional double max_adc_stop_speed = 3 [default = 0.3];
inline bool ScenarioTrafficLightProtectedConfig::_internal_has_max_adc_stop_speed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScenarioTrafficLightProtectedConfig::has_max_adc_stop_speed() const {
  return _internal_has_max_adc_stop_speed();
}
inline void ScenarioTrafficLightProtectedConfig::clear_max_adc_stop_speed() {
  max_adc_stop_speed_ = 0.3;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ScenarioTrafficLightProtectedConfig::_internal_max_adc_stop_speed() const {
  return max_adc_stop_speed_;
}
inline double ScenarioTrafficLightProtectedConfig::max_adc_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightProtectedConfig.max_adc_stop_speed)
  return _internal_max_adc_stop_speed();
}
inline void ScenarioTrafficLightProtectedConfig::_internal_set_max_adc_stop_speed(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_adc_stop_speed_ = value;
}
inline void ScenarioTrafficLightProtectedConfig::set_max_adc_stop_speed(double value) {
  _internal_set_max_adc_stop_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightProtectedConfig.max_adc_stop_speed)
}

// optional double min_pass_s_distance = 4 [default = 3];
inline bool ScenarioTrafficLightProtectedConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ScenarioTrafficLightProtectedConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void ScenarioTrafficLightProtectedConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ScenarioTrafficLightProtectedConfig::_internal_min_pass_s_distance() const {
  return min_pass_s_distance_;
}
inline double ScenarioTrafficLightProtectedConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightProtectedConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void ScenarioTrafficLightProtectedConfig::_internal_set_min_pass_s_distance(double value) {
  _has_bits_[0] |= 0x00000008u;
  min_pass_s_distance_ = value;
}
inline void ScenarioTrafficLightProtectedConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightProtectedConfig.min_pass_s_distance)
}

// -------------------------------------------------------------------

// ScenarioTrafficLightUnprotectedLeftTurnConfig

// optional double start_traffic_light_scenario_distance = 1 [default = 5];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_has_start_traffic_light_scenario_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_start_traffic_light_scenario_distance() const {
  return _internal_has_start_traffic_light_scenario_distance();
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_start_traffic_light_scenario_distance() {
  start_traffic_light_scenario_distance_ = 5;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_start_traffic_light_scenario_distance() const {
  return start_traffic_light_scenario_distance_;
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::start_traffic_light_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.start_traffic_light_scenario_distance)
  return _internal_start_traffic_light_scenario_distance();
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_set_start_traffic_light_scenario_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  start_traffic_light_scenario_distance_ = value;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_start_traffic_light_scenario_distance(double value) {
  _internal_set_start_traffic_light_scenario_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.start_traffic_light_scenario_distance)
}

// optional double max_valid_stop_distance = 2 [default = 3.5];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3.5;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_max_valid_stop_distance() const {
  return max_valid_stop_distance_;
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_set_max_valid_stop_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_valid_stop_distance_ = value;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_valid_stop_distance)
}

// optional double max_adc_stop_speed = 3 [default = 0.3];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_has_max_adc_stop_speed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_max_adc_stop_speed() const {
  return _internal_has_max_adc_stop_speed();
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_max_adc_stop_speed() {
  max_adc_stop_speed_ = 0.3;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_max_adc_stop_speed() const {
  return max_adc_stop_speed_;
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::max_adc_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_adc_stop_speed)
  return _internal_max_adc_stop_speed();
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_set_max_adc_stop_speed(double value) {
  _has_bits_[0] |= 0x00000008u;
  max_adc_stop_speed_ = value;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_max_adc_stop_speed(double value) {
  _internal_set_max_adc_stop_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_adc_stop_speed)
}

// optional double min_pass_s_distance = 4 [default = 3];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_min_pass_s_distance() const {
  return min_pass_s_distance_;
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_set_min_pass_s_distance(double value) {
  _has_bits_[0] |= 0x00000010u;
  min_pass_s_distance_ = value;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.min_pass_s_distance)
}

// optional float creep_timeout_sec = 5 [default = 10];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_has_creep_timeout_sec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_creep_timeout_sec() const {
  return _internal_has_creep_timeout_sec();
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_creep_timeout_sec() const {
  return creep_timeout_sec_;
}
inline float ScenarioTrafficLightUnprotectedLeftTurnConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.creep_timeout_sec)
  return _internal_creep_timeout_sec();
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::_internal_set_creep_timeout_sec(float value) {
  _has_bits_[0] |= 0x00000001u;
  creep_timeout_sec_ = value;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_creep_timeout_sec(float value) {
  _internal_set_creep_timeout_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.creep_timeout_sec)
}

// -------------------------------------------------------------------

// ScenarioTrafficLightUnprotectedRightTurnConfig

// optional double start_traffic_light_scenario_distance = 1 [default = 5];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_has_start_traffic_light_scenario_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_start_traffic_light_scenario_distance() const {
  return _internal_has_start_traffic_light_scenario_distance();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_start_traffic_light_scenario_distance() {
  start_traffic_light_scenario_distance_ = 5;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_start_traffic_light_scenario_distance() const {
  return start_traffic_light_scenario_distance_;
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::start_traffic_light_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.start_traffic_light_scenario_distance)
  return _internal_start_traffic_light_scenario_distance();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_set_start_traffic_light_scenario_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  start_traffic_light_scenario_distance_ = value;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_start_traffic_light_scenario_distance(double value) {
  _internal_set_start_traffic_light_scenario_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.start_traffic_light_scenario_distance)
}

// optional bool enable_right_turn_on_red = 2 [default = false];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_has_enable_right_turn_on_red() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_enable_right_turn_on_red() const {
  return _internal_has_enable_right_turn_on_red();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_enable_right_turn_on_red() {
  enable_right_turn_on_red_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_enable_right_turn_on_red() const {
  return enable_right_turn_on_red_;
}
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::enable_right_turn_on_red() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.enable_right_turn_on_red)
  return _internal_enable_right_turn_on_red();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_set_enable_right_turn_on_red(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enable_right_turn_on_red_ = value;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_enable_right_turn_on_red(bool value) {
  _internal_set_enable_right_turn_on_red(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.enable_right_turn_on_red)
}

// optional double max_valid_stop_distance = 3 [default = 3.5];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3.5;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_max_valid_stop_distance() const {
  return max_valid_stop_distance_;
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_set_max_valid_stop_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_valid_stop_distance_ = value;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_valid_stop_distance)
}

// optional double max_adc_stop_speed = 4 [default = 0.3];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_has_max_adc_stop_speed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_max_adc_stop_speed() const {
  return _internal_has_max_adc_stop_speed();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_max_adc_stop_speed() {
  max_adc_stop_speed_ = 0.3;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_max_adc_stop_speed() const {
  return max_adc_stop_speed_;
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::max_adc_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_adc_stop_speed)
  return _internal_max_adc_stop_speed();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_set_max_adc_stop_speed(double value) {
  _has_bits_[0] |= 0x00000008u;
  max_adc_stop_speed_ = value;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_max_adc_stop_speed(double value) {
  _internal_set_max_adc_stop_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_adc_stop_speed)
}

// optional double min_pass_s_distance = 5 [default = 3];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_min_pass_s_distance() const {
  return min_pass_s_distance_;
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_set_min_pass_s_distance(double value) {
  _has_bits_[0] |= 0x00000010u;
  min_pass_s_distance_ = value;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.min_pass_s_distance)
}

// optional float red_light_right_turn_stop_duration_sec = 6 [default = 3];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_has_red_light_right_turn_stop_duration_sec() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_red_light_right_turn_stop_duration_sec() const {
  return _internal_has_red_light_right_turn_stop_duration_sec();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_red_light_right_turn_stop_duration_sec() {
  red_light_right_turn_stop_duration_sec_ = 3;
  _has_bits_[0] &= ~0x00000020u;
}
inline float ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_red_light_right_turn_stop_duration_sec() const {
  return red_light_right_turn_stop_duration_sec_;
}
inline float ScenarioTrafficLightUnprotectedRightTurnConfig::red_light_right_turn_stop_duration_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.red_light_right_turn_stop_duration_sec)
  return _internal_red_light_right_turn_stop_duration_sec();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_set_red_light_right_turn_stop_duration_sec(float value) {
  _has_bits_[0] |= 0x00000020u;
  red_light_right_turn_stop_duration_sec_ = value;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_red_light_right_turn_stop_duration_sec(float value) {
  _internal_set_red_light_right_turn_stop_duration_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.red_light_right_turn_stop_duration_sec)
}

// optional float creep_timeout_sec = 7 [default = 10];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_has_creep_timeout_sec() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_creep_timeout_sec() const {
  return _internal_has_creep_timeout_sec();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  _has_bits_[0] &= ~0x00000040u;
}
inline float ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_creep_timeout_sec() const {
  return creep_timeout_sec_;
}
inline float ScenarioTrafficLightUnprotectedRightTurnConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.creep_timeout_sec)
  return _internal_creep_timeout_sec();
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::_internal_set_creep_timeout_sec(float value) {
  _has_bits_[0] |= 0x00000040u;
  creep_timeout_sec_ = value;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_creep_timeout_sec(float value) {
  _internal_set_creep_timeout_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.creep_timeout_sec)
}

// -------------------------------------------------------------------

// ScenarioPullOverConfig

// optional double start_pull_over_scenario_distance = 1 [default = 50];
inline bool ScenarioPullOverConfig::_internal_has_start_pull_over_scenario_distance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScenarioPullOverConfig::has_start_pull_over_scenario_distance() const {
  return _internal_has_start_pull_over_scenario_distance();
}
inline void ScenarioPullOverConfig::clear_start_pull_over_scenario_distance() {
  start_pull_over_scenario_distance_ = 50;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ScenarioPullOverConfig::_internal_start_pull_over_scenario_distance() const {
  return start_pull_over_scenario_distance_;
}
inline double ScenarioPullOverConfig::start_pull_over_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.start_pull_over_scenario_distance)
  return _internal_start_pull_over_scenario_distance();
}
inline void ScenarioPullOverConfig::_internal_set_start_pull_over_scenario_distance(double value) {
  _has_bits_[0] |= 0x00000001u;
  start_pull_over_scenario_distance_ = value;
}
inline void ScenarioPullOverConfig::set_start_pull_over_scenario_distance(double value) {
  _internal_set_start_pull_over_scenario_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.start_pull_over_scenario_distance)
}

// optional double pull_over_min_distance_buffer = 2 [default = 10];
inline bool ScenarioPullOverConfig::_internal_has_pull_over_min_distance_buffer() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScenarioPullOverConfig::has_pull_over_min_distance_buffer() const {
  return _internal_has_pull_over_min_distance_buffer();
}
inline void ScenarioPullOverConfig::clear_pull_over_min_distance_buffer() {
  pull_over_min_distance_buffer_ = 10;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ScenarioPullOverConfig::_internal_pull_over_min_distance_buffer() const {
  return pull_over_min_distance_buffer_;
}
inline double ScenarioPullOverConfig::pull_over_min_distance_buffer() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.pull_over_min_distance_buffer)
  return _internal_pull_over_min_distance_buffer();
}
inline void ScenarioPullOverConfig::_internal_set_pull_over_min_distance_buffer(double value) {
  _has_bits_[0] |= 0x00000002u;
  pull_over_min_distance_buffer_ = value;
}
inline void ScenarioPullOverConfig::set_pull_over_min_distance_buffer(double value) {
  _internal_set_pull_over_min_distance_buffer(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.pull_over_min_distance_buffer)
}

// optional double max_distance_stop_search = 3 [default = 25];
inline bool ScenarioPullOverConfig::_internal_has_max_distance_stop_search() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScenarioPullOverConfig::has_max_distance_stop_search() const {
  return _internal_has_max_distance_stop_search();
}
inline void ScenarioPullOverConfig::clear_max_distance_stop_search() {
  max_distance_stop_search_ = 25;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ScenarioPullOverConfig::_internal_max_distance_stop_search() const {
  return max_distance_stop_search_;
}
inline double ScenarioPullOverConfig::max_distance_stop_search() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_distance_stop_search)
  return _internal_max_distance_stop_search();
}
inline void ScenarioPullOverConfig::_internal_set_max_distance_stop_search(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_distance_stop_search_ = value;
}
inline void ScenarioPullOverConfig::set_max_distance_stop_search(double value) {
  _internal_set_max_distance_stop_search(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_distance_stop_search)
}

// optional double max_adc_stop_speed = 4 [default = 0.1];
inline bool ScenarioPullOverConfig::_internal_has_max_adc_stop_speed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ScenarioPullOverConfig::has_max_adc_stop_speed() const {
  return _internal_has_max_adc_stop_speed();
}
inline void ScenarioPullOverConfig::clear_max_adc_stop_speed() {
  max_adc_stop_speed_ = 0.1;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ScenarioPullOverConfig::_internal_max_adc_stop_speed() const {
  return max_adc_stop_speed_;
}
inline double ScenarioPullOverConfig::max_adc_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_adc_stop_speed)
  return _internal_max_adc_stop_speed();
}
inline void ScenarioPullOverConfig::_internal_set_max_adc_stop_speed(double value) {
  _has_bits_[0] |= 0x00000008u;
  max_adc_stop_speed_ = value;
}
inline void ScenarioPullOverConfig::set_max_adc_stop_speed(double value) {
  _internal_set_max_adc_stop_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_adc_stop_speed)
}

// optional double max_s_error_to_end_point = 5 [default = 0.2];
inline bool ScenarioPullOverConfig::_internal_has_max_s_error_to_end_point() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ScenarioPullOverConfig::has_max_s_error_to_end_point() const {
  return _internal_has_max_s_error_to_end_point();
}
inline void ScenarioPullOverConfig::clear_max_s_error_to_end_point() {
  max_s_error_to_end_point_ = 0.2;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ScenarioPullOverConfig::_internal_max_s_error_to_end_point() const {
  return max_s_error_to_end_point_;
}
inline double ScenarioPullOverConfig::max_s_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_s_error_to_end_point)
  return _internal_max_s_error_to_end_point();
}
inline void ScenarioPullOverConfig::_internal_set_max_s_error_to_end_point(double value) {
  _has_bits_[0] |= 0x00000010u;
  max_s_error_to_end_point_ = value;
}
inline void ScenarioPullOverConfig::set_max_s_error_to_end_point(double value) {
  _internal_set_max_s_error_to_end_point(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_s_error_to_end_point)
}

// optional double max_l_error_to_end_point = 6 [default = 0.5];
inline bool ScenarioPullOverConfig::_internal_has_max_l_error_to_end_point() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ScenarioPullOverConfig::has_max_l_error_to_end_point() const {
  return _internal_has_max_l_error_to_end_point();
}
inline void ScenarioPullOverConfig::clear_max_l_error_to_end_point() {
  max_l_error_to_end_point_ = 0.5;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ScenarioPullOverConfig::_internal_max_l_error_to_end_point() const {
  return max_l_error_to_end_point_;
}
inline double ScenarioPullOverConfig::max_l_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_l_error_to_end_point)
  return _internal_max_l_error_to_end_point();
}
inline void ScenarioPullOverConfig::_internal_set_max_l_error_to_end_point(double value) {
  _has_bits_[0] |= 0x00000020u;
  max_l_error_to_end_point_ = value;
}
inline void ScenarioPullOverConfig::set_max_l_error_to_end_point(double value) {
  _internal_set_max_l_error_to_end_point(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_l_error_to_end_point)
}

// optional double max_theta_error_to_end_point = 7 [default = 0.2];
inline bool ScenarioPullOverConfig::_internal_has_max_theta_error_to_end_point() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ScenarioPullOverConfig::has_max_theta_error_to_end_point() const {
  return _internal_has_max_theta_error_to_end_point();
}
inline void ScenarioPullOverConfig::clear_max_theta_error_to_end_point() {
  max_theta_error_to_end_point_ = 0.2;
  _has_bits_[0] &= ~0x00000040u;
}
inline double ScenarioPullOverConfig::_internal_max_theta_error_to_end_point() const {
  return max_theta_error_to_end_point_;
}
inline double ScenarioPullOverConfig::max_theta_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_theta_error_to_end_point)
  return _internal_max_theta_error_to_end_point();
}
inline void ScenarioPullOverConfig::_internal_set_max_theta_error_to_end_point(double value) {
  _has_bits_[0] |= 0x00000040u;
  max_theta_error_to_end_point_ = value;
}
inline void ScenarioPullOverConfig::set_max_theta_error_to_end_point(double value) {
  _internal_set_max_theta_error_to_end_point(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_theta_error_to_end_point)
}

// optional double max_distance_error_to_end_point = 8 [default = 0.2];
inline bool ScenarioPullOverConfig::_internal_has_max_distance_error_to_end_point() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ScenarioPullOverConfig::has_max_distance_error_to_end_point() const {
  return _internal_has_max_distance_error_to_end_point();
}
inline void ScenarioPullOverConfig::clear_max_distance_error_to_end_point() {
  max_distance_error_to_end_point_ = 0.2;
  _has_bits_[0] &= ~0x00000080u;
}
inline double ScenarioPullOverConfig::_internal_max_distance_error_to_end_point() const {
  return max_distance_error_to_end_point_;
}
inline double ScenarioPullOverConfig::max_distance_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_distance_error_to_end_point)
  return _internal_max_distance_error_to_end_point();
}
inline void ScenarioPullOverConfig::_internal_set_max_distance_error_to_end_point(double value) {
  _has_bits_[0] |= 0x00000080u;
  max_distance_error_to_end_point_ = value;
}
inline void ScenarioPullOverConfig::set_max_distance_error_to_end_point(double value) {
  _internal_set_max_distance_error_to_end_point(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_distance_error_to_end_point)
}

// optional double pass_destination_threshold = 9 [default = 10];
inline bool ScenarioPullOverConfig::_internal_has_pass_destination_threshold() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ScenarioPullOverConfig::has_pass_destination_threshold() const {
  return _internal_has_pass_destination_threshold();
}
inline void ScenarioPullOverConfig::clear_pass_destination_threshold() {
  pass_destination_threshold_ = 10;
  _has_bits_[0] &= ~0x00000100u;
}
inline double ScenarioPullOverConfig::_internal_pass_destination_threshold() const {
  return pass_destination_threshold_;
}
inline double ScenarioPullOverConfig::pass_destination_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.pass_destination_threshold)
  return _internal_pass_destination_threshold();
}
inline void ScenarioPullOverConfig::_internal_set_pass_destination_threshold(double value) {
  _has_bits_[0] |= 0x00000100u;
  pass_destination_threshold_ = value;
}
inline void ScenarioPullOverConfig::set_pass_destination_threshold(double value) {
  _internal_set_pass_destination_threshold(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.pass_destination_threshold)
}

// optional double max_valid_stop_distance = 10 [default = 1];
inline bool ScenarioPullOverConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ScenarioPullOverConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void ScenarioPullOverConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline double ScenarioPullOverConfig::_internal_max_valid_stop_distance() const {
  return max_valid_stop_distance_;
}
inline double ScenarioPullOverConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void ScenarioPullOverConfig::_internal_set_max_valid_stop_distance(double value) {
  _has_bits_[0] |= 0x00000200u;
  max_valid_stop_distance_ = value;
}
inline void ScenarioPullOverConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_valid_stop_distance)
}

// optional double s_distance_to_stop_for_open_space_parking = 11 [default = 7];
inline bool ScenarioPullOverConfig::_internal_has_s_distance_to_stop_for_open_space_parking() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ScenarioPullOverConfig::has_s_distance_to_stop_for_open_space_parking() const {
  return _internal_has_s_distance_to_stop_for_open_space_parking();
}
inline void ScenarioPullOverConfig::clear_s_distance_to_stop_for_open_space_parking() {
  s_distance_to_stop_for_open_space_parking_ = 7;
  _has_bits_[0] &= ~0x00000400u;
}
inline double ScenarioPullOverConfig::_internal_s_distance_to_stop_for_open_space_parking() const {
  return s_distance_to_stop_for_open_space_parking_;
}
inline double ScenarioPullOverConfig::s_distance_to_stop_for_open_space_parking() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.s_distance_to_stop_for_open_space_parking)
  return _internal_s_distance_to_stop_for_open_space_parking();
}
inline void ScenarioPullOverConfig::_internal_set_s_distance_to_stop_for_open_space_parking(double value) {
  _has_bits_[0] |= 0x00000400u;
  s_distance_to_stop_for_open_space_parking_ = value;
}
inline void ScenarioPullOverConfig::set_s_distance_to_stop_for_open_space_parking(double value) {
  _internal_set_s_distance_to_stop_for_open_space_parking(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.s_distance_to_stop_for_open_space_parking)
}

// -------------------------------------------------------------------

// ScenarioValetParkingConfig

// optional double parking_spot_range_to_start = 1 [default = 20];
inline bool ScenarioValetParkingConfig::_internal_has_parking_spot_range_to_start() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScenarioValetParkingConfig::has_parking_spot_range_to_start() const {
  return _internal_has_parking_spot_range_to_start();
}
inline void ScenarioValetParkingConfig::clear_parking_spot_range_to_start() {
  parking_spot_range_to_start_ = 20;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ScenarioValetParkingConfig::_internal_parking_spot_range_to_start() const {
  return parking_spot_range_to_start_;
}
inline double ScenarioValetParkingConfig::parking_spot_range_to_start() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioValetParkingConfig.parking_spot_range_to_start)
  return _internal_parking_spot_range_to_start();
}
inline void ScenarioValetParkingConfig::_internal_set_parking_spot_range_to_start(double value) {
  _has_bits_[0] |= 0x00000001u;
  parking_spot_range_to_start_ = value;
}
inline void ScenarioValetParkingConfig::set_parking_spot_range_to_start(double value) {
  _internal_set_parking_spot_range_to_start(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioValetParkingConfig.parking_spot_range_to_start)
}

// optional double max_valid_stop_distance = 2 [default = 1];
inline bool ScenarioValetParkingConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScenarioValetParkingConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void ScenarioValetParkingConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ScenarioValetParkingConfig::_internal_max_valid_stop_distance() const {
  return max_valid_stop_distance_;
}
inline double ScenarioValetParkingConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioValetParkingConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void ScenarioValetParkingConfig::_internal_set_max_valid_stop_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  max_valid_stop_distance_ = value;
}
inline void ScenarioValetParkingConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioValetParkingConfig.max_valid_stop_distance)
}

// optional double max_adc_stop_speed = 3 [default = 0.1];
inline bool ScenarioValetParkingConfig::_internal_has_max_adc_stop_speed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScenarioValetParkingConfig::has_max_adc_stop_speed() const {
  return _internal_has_max_adc_stop_speed();
}
inline void ScenarioValetParkingConfig::clear_max_adc_stop_speed() {
  max_adc_stop_speed_ = 0.1;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ScenarioValetParkingConfig::_internal_max_adc_stop_speed() const {
  return max_adc_stop_speed_;
}
inline double ScenarioValetParkingConfig::max_adc_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioValetParkingConfig.max_adc_stop_speed)
  return _internal_max_adc_stop_speed();
}
inline void ScenarioValetParkingConfig::_internal_set_max_adc_stop_speed(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_adc_stop_speed_ = value;
}
inline void ScenarioValetParkingConfig::set_max_adc_stop_speed(double value) {
  _internal_set_max_adc_stop_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioValetParkingConfig.max_adc_stop_speed)
}

// -------------------------------------------------------------------

// ScenarioNarrowStreetUTurnConfig

// -------------------------------------------------------------------

// ScenarioConfig_StageConfig

// optional .apollo.planning.ScenarioConfig.StageType stage_type = 1;
inline bool ScenarioConfig_StageConfig::_internal_has_stage_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScenarioConfig_StageConfig::has_stage_type() const {
  return _internal_has_stage_type();
}
inline void ScenarioConfig_StageConfig::clear_stage_type() {
  stage_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::planning::ScenarioConfig_StageType ScenarioConfig_StageConfig::_internal_stage_type() const {
  return static_cast< ::apollo::planning::ScenarioConfig_StageType >(stage_type_);
}
inline ::apollo::planning::ScenarioConfig_StageType ScenarioConfig_StageConfig::stage_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.StageConfig.stage_type)
  return _internal_stage_type();
}
inline void ScenarioConfig_StageConfig::_internal_set_stage_type(::apollo::planning::ScenarioConfig_StageType value) {
  assert(::apollo::planning::ScenarioConfig_StageType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  stage_type_ = value;
}
inline void ScenarioConfig_StageConfig::set_stage_type(::apollo::planning::ScenarioConfig_StageType value) {
  _internal_set_stage_type(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioConfig.StageConfig.stage_type)
}

// optional bool enabled = 2 [default = true];
inline bool ScenarioConfig_StageConfig::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScenarioConfig_StageConfig::has_enabled() const {
  return _internal_has_enabled();
}
inline void ScenarioConfig_StageConfig::clear_enabled() {
  enabled_ = true;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ScenarioConfig_StageConfig::_internal_enabled() const {
  return enabled_;
}
inline bool ScenarioConfig_StageConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.StageConfig.enabled)
  return _internal_enabled();
}
inline void ScenarioConfig_StageConfig::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000002u;
  enabled_ = value;
}
inline void ScenarioConfig_StageConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioConfig.StageConfig.enabled)
}

// repeated .apollo.planning.TaskConfig.TaskType task_type = 3;
inline int ScenarioConfig_StageConfig::_internal_task_type_size() const {
  return task_type_.size();
}
inline int ScenarioConfig_StageConfig::task_type_size() const {
  return _internal_task_type_size();
}
inline void ScenarioConfig_StageConfig::clear_task_type() {
  task_type_.Clear();
}
inline ::apollo::planning::TaskConfig_TaskType ScenarioConfig_StageConfig::_internal_task_type(int index) const {
  return static_cast< ::apollo::planning::TaskConfig_TaskType >(task_type_.Get(index));
}
inline ::apollo::planning::TaskConfig_TaskType ScenarioConfig_StageConfig::task_type(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.StageConfig.task_type)
  return _internal_task_type(index);
}
inline void ScenarioConfig_StageConfig::set_task_type(int index, ::apollo::planning::TaskConfig_TaskType value) {
  assert(::apollo::planning::TaskConfig_TaskType_IsValid(value));
  task_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioConfig.StageConfig.task_type)
}
inline void ScenarioConfig_StageConfig::_internal_add_task_type(::apollo::planning::TaskConfig_TaskType value) {
  assert(::apollo::planning::TaskConfig_TaskType_IsValid(value));
  task_type_.Add(value);
}
inline void ScenarioConfig_StageConfig::add_task_type(::apollo::planning::TaskConfig_TaskType value) {
  // @@protoc_insertion_point(field_add:apollo.planning.ScenarioConfig.StageConfig.task_type)
  _internal_add_task_type(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ScenarioConfig_StageConfig::task_type() const {
  // @@protoc_insertion_point(field_list:apollo.planning.ScenarioConfig.StageConfig.task_type)
  return task_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ScenarioConfig_StageConfig::_internal_mutable_task_type() {
  return &task_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ScenarioConfig_StageConfig::mutable_task_type() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.ScenarioConfig.StageConfig.task_type)
  return _internal_mutable_task_type();
}

// repeated .apollo.planning.TaskConfig task_config = 4;
inline int ScenarioConfig_StageConfig::_internal_task_config_size() const {
  return task_config_.size();
}
inline int ScenarioConfig_StageConfig::task_config_size() const {
  return _internal_task_config_size();
}
inline void ScenarioConfig_StageConfig::clear_task_config() {
  task_config_.Clear();
}
inline ::apollo::planning::TaskConfig* ScenarioConfig_StageConfig::mutable_task_config(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TaskConfig >*
ScenarioConfig_StageConfig::mutable_task_config() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.ScenarioConfig.StageConfig.task_config)
  return &task_config_;
}
inline const ::apollo::planning::TaskConfig& ScenarioConfig_StageConfig::_internal_task_config(int index) const {
  return task_config_.Get(index);
}
inline const ::apollo::planning::TaskConfig& ScenarioConfig_StageConfig::task_config(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.StageConfig.task_config)
  return _internal_task_config(index);
}
inline ::apollo::planning::TaskConfig* ScenarioConfig_StageConfig::_internal_add_task_config() {
  return task_config_.Add();
}
inline ::apollo::planning::TaskConfig* ScenarioConfig_StageConfig::add_task_config() {
  // @@protoc_insertion_point(field_add:apollo.planning.ScenarioConfig.StageConfig.task_config)
  return _internal_add_task_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TaskConfig >&
ScenarioConfig_StageConfig::task_config() const {
  // @@protoc_insertion_point(field_list:apollo.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_;
}

// -------------------------------------------------------------------

// ScenarioConfig

// optional .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
inline bool ScenarioConfig::_internal_has_scenario_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScenarioConfig::has_scenario_type() const {
  return _internal_has_scenario_type();
}
inline void ScenarioConfig::clear_scenario_type() {
  scenario_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::planning::ScenarioConfig_ScenarioType ScenarioConfig::_internal_scenario_type() const {
  return static_cast< ::apollo::planning::ScenarioConfig_ScenarioType >(scenario_type_);
}
inline ::apollo::planning::ScenarioConfig_ScenarioType ScenarioConfig::scenario_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.scenario_type)
  return _internal_scenario_type();
}
inline void ScenarioConfig::_internal_set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value) {
  assert(::apollo::planning::ScenarioConfig_ScenarioType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  scenario_type_ = value;
}
inline void ScenarioConfig::set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value) {
  _internal_set_scenario_type(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioConfig.scenario_type)
}

// optional .apollo.planning.ScenarioLaneFollowConfig lane_follow_config = 2;
inline bool ScenarioConfig::_internal_has_lane_follow_config() const {
  return scenario_config_case() == kLaneFollowConfig;
}
inline bool ScenarioConfig::has_lane_follow_config() const {
  return _internal_has_lane_follow_config();
}
inline void ScenarioConfig::set_has_lane_follow_config() {
  _oneof_case_[0] = kLaneFollowConfig;
}
inline void ScenarioConfig::clear_lane_follow_config() {
  if (_internal_has_lane_follow_config()) {
    delete scenario_config_.lane_follow_config_;
    clear_has_scenario_config();
  }
}
inline ::apollo::planning::ScenarioLaneFollowConfig* ScenarioConfig::release_lane_follow_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.lane_follow_config)
  if (_internal_has_lane_follow_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioLaneFollowConfig* temp = scenario_config_.lane_follow_config_;
    scenario_config_.lane_follow_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ScenarioLaneFollowConfig& ScenarioConfig::_internal_lane_follow_config() const {
  return _internal_has_lane_follow_config()
      ? *scenario_config_.lane_follow_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioLaneFollowConfig*>(&::apollo::planning::_ScenarioLaneFollowConfig_default_instance_);
}
inline const ::apollo::planning::ScenarioLaneFollowConfig& ScenarioConfig::lane_follow_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.lane_follow_config)
  return _internal_lane_follow_config();
}
inline ::apollo::planning::ScenarioLaneFollowConfig* ScenarioConfig::_internal_mutable_lane_follow_config() {
  if (!_internal_has_lane_follow_config()) {
    clear_scenario_config();
    set_has_lane_follow_config();
    scenario_config_.lane_follow_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioLaneFollowConfig >(
        GetArenaNoVirtual());
  }
  return scenario_config_.lane_follow_config_;
}
inline ::apollo::planning::ScenarioLaneFollowConfig* ScenarioConfig::mutable_lane_follow_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.lane_follow_config)
  return _internal_mutable_lane_follow_config();
}

// optional .apollo.planning.ScenarioBareIntersectionUnprotectedConfig bare_intersection_unprotected_config = 4;
inline bool ScenarioConfig::_internal_has_bare_intersection_unprotected_config() const {
  return scenario_config_case() == kBareIntersectionUnprotectedConfig;
}
inline bool ScenarioConfig::has_bare_intersection_unprotected_config() const {
  return _internal_has_bare_intersection_unprotected_config();
}
inline void ScenarioConfig::set_has_bare_intersection_unprotected_config() {
  _oneof_case_[0] = kBareIntersectionUnprotectedConfig;
}
inline void ScenarioConfig::clear_bare_intersection_unprotected_config() {
  if (_internal_has_bare_intersection_unprotected_config()) {
    delete scenario_config_.bare_intersection_unprotected_config_;
    clear_has_scenario_config();
  }
}
inline ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* ScenarioConfig::release_bare_intersection_unprotected_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.bare_intersection_unprotected_config)
  if (_internal_has_bare_intersection_unprotected_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* temp = scenario_config_.bare_intersection_unprotected_config_;
    scenario_config_.bare_intersection_unprotected_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig& ScenarioConfig::_internal_bare_intersection_unprotected_config() const {
  return _internal_has_bare_intersection_unprotected_config()
      ? *scenario_config_.bare_intersection_unprotected_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig*>(&::apollo::planning::_ScenarioBareIntersectionUnprotectedConfig_default_instance_);
}
inline const ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig& ScenarioConfig::bare_intersection_unprotected_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.bare_intersection_unprotected_config)
  return _internal_bare_intersection_unprotected_config();
}
inline ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* ScenarioConfig::_internal_mutable_bare_intersection_unprotected_config() {
  if (!_internal_has_bare_intersection_unprotected_config()) {
    clear_scenario_config();
    set_has_bare_intersection_unprotected_config();
    scenario_config_.bare_intersection_unprotected_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig >(
        GetArenaNoVirtual());
  }
  return scenario_config_.bare_intersection_unprotected_config_;
}
inline ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* ScenarioConfig::mutable_bare_intersection_unprotected_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.bare_intersection_unprotected_config)
  return _internal_mutable_bare_intersection_unprotected_config();
}

// optional .apollo.planning.ScenarioStopSignUnprotectedConfig stop_sign_unprotected_config = 5;
inline bool ScenarioConfig::_internal_has_stop_sign_unprotected_config() const {
  return scenario_config_case() == kStopSignUnprotectedConfig;
}
inline bool ScenarioConfig::has_stop_sign_unprotected_config() const {
  return _internal_has_stop_sign_unprotected_config();
}
inline void ScenarioConfig::set_has_stop_sign_unprotected_config() {
  _oneof_case_[0] = kStopSignUnprotectedConfig;
}
inline void ScenarioConfig::clear_stop_sign_unprotected_config() {
  if (_internal_has_stop_sign_unprotected_config()) {
    delete scenario_config_.stop_sign_unprotected_config_;
    clear_has_scenario_config();
  }
}
inline ::apollo::planning::ScenarioStopSignUnprotectedConfig* ScenarioConfig::release_stop_sign_unprotected_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.stop_sign_unprotected_config)
  if (_internal_has_stop_sign_unprotected_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioStopSignUnprotectedConfig* temp = scenario_config_.stop_sign_unprotected_config_;
    scenario_config_.stop_sign_unprotected_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ScenarioStopSignUnprotectedConfig& ScenarioConfig::_internal_stop_sign_unprotected_config() const {
  return _internal_has_stop_sign_unprotected_config()
      ? *scenario_config_.stop_sign_unprotected_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioStopSignUnprotectedConfig*>(&::apollo::planning::_ScenarioStopSignUnprotectedConfig_default_instance_);
}
inline const ::apollo::planning::ScenarioStopSignUnprotectedConfig& ScenarioConfig::stop_sign_unprotected_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.stop_sign_unprotected_config)
  return _internal_stop_sign_unprotected_config();
}
inline ::apollo::planning::ScenarioStopSignUnprotectedConfig* ScenarioConfig::_internal_mutable_stop_sign_unprotected_config() {
  if (!_internal_has_stop_sign_unprotected_config()) {
    clear_scenario_config();
    set_has_stop_sign_unprotected_config();
    scenario_config_.stop_sign_unprotected_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioStopSignUnprotectedConfig >(
        GetArenaNoVirtual());
  }
  return scenario_config_.stop_sign_unprotected_config_;
}
inline ::apollo::planning::ScenarioStopSignUnprotectedConfig* ScenarioConfig::mutable_stop_sign_unprotected_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.stop_sign_unprotected_config)
  return _internal_mutable_stop_sign_unprotected_config();
}

// optional .apollo.planning.ScenarioTrafficLightProtectedConfig traffic_light_protected_config = 6;
inline bool ScenarioConfig::_internal_has_traffic_light_protected_config() const {
  return scenario_config_case() == kTrafficLightProtectedConfig;
}
inline bool ScenarioConfig::has_traffic_light_protected_config() const {
  return _internal_has_traffic_light_protected_config();
}
inline void ScenarioConfig::set_has_traffic_light_protected_config() {
  _oneof_case_[0] = kTrafficLightProtectedConfig;
}
inline void ScenarioConfig::clear_traffic_light_protected_config() {
  if (_internal_has_traffic_light_protected_config()) {
    delete scenario_config_.traffic_light_protected_config_;
    clear_has_scenario_config();
  }
}
inline ::apollo::planning::ScenarioTrafficLightProtectedConfig* ScenarioConfig::release_traffic_light_protected_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.traffic_light_protected_config)
  if (_internal_has_traffic_light_protected_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioTrafficLightProtectedConfig* temp = scenario_config_.traffic_light_protected_config_;
    scenario_config_.traffic_light_protected_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ScenarioTrafficLightProtectedConfig& ScenarioConfig::_internal_traffic_light_protected_config() const {
  return _internal_has_traffic_light_protected_config()
      ? *scenario_config_.traffic_light_protected_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioTrafficLightProtectedConfig*>(&::apollo::planning::_ScenarioTrafficLightProtectedConfig_default_instance_);
}
inline const ::apollo::planning::ScenarioTrafficLightProtectedConfig& ScenarioConfig::traffic_light_protected_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.traffic_light_protected_config)
  return _internal_traffic_light_protected_config();
}
inline ::apollo::planning::ScenarioTrafficLightProtectedConfig* ScenarioConfig::_internal_mutable_traffic_light_protected_config() {
  if (!_internal_has_traffic_light_protected_config()) {
    clear_scenario_config();
    set_has_traffic_light_protected_config();
    scenario_config_.traffic_light_protected_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioTrafficLightProtectedConfig >(
        GetArenaNoVirtual());
  }
  return scenario_config_.traffic_light_protected_config_;
}
inline ::apollo::planning::ScenarioTrafficLightProtectedConfig* ScenarioConfig::mutable_traffic_light_protected_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.traffic_light_protected_config)
  return _internal_mutable_traffic_light_protected_config();
}

// optional .apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig traffic_light_unprotected_right_turn_config = 7;
inline bool ScenarioConfig::_internal_has_traffic_light_unprotected_right_turn_config() const {
  return scenario_config_case() == kTrafficLightUnprotectedRightTurnConfig;
}
inline bool ScenarioConfig::has_traffic_light_unprotected_right_turn_config() const {
  return _internal_has_traffic_light_unprotected_right_turn_config();
}
inline void ScenarioConfig::set_has_traffic_light_unprotected_right_turn_config() {
  _oneof_case_[0] = kTrafficLightUnprotectedRightTurnConfig;
}
inline void ScenarioConfig::clear_traffic_light_unprotected_right_turn_config() {
  if (_internal_has_traffic_light_unprotected_right_turn_config()) {
    delete scenario_config_.traffic_light_unprotected_right_turn_config_;
    clear_has_scenario_config();
  }
}
inline ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* ScenarioConfig::release_traffic_light_unprotected_right_turn_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
  if (_internal_has_traffic_light_unprotected_right_turn_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* temp = scenario_config_.traffic_light_unprotected_right_turn_config_;
    scenario_config_.traffic_light_unprotected_right_turn_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig& ScenarioConfig::_internal_traffic_light_unprotected_right_turn_config() const {
  return _internal_has_traffic_light_unprotected_right_turn_config()
      ? *scenario_config_.traffic_light_unprotected_right_turn_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig*>(&::apollo::planning::_ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_);
}
inline const ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig& ScenarioConfig::traffic_light_unprotected_right_turn_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
  return _internal_traffic_light_unprotected_right_turn_config();
}
inline ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* ScenarioConfig::_internal_mutable_traffic_light_unprotected_right_turn_config() {
  if (!_internal_has_traffic_light_unprotected_right_turn_config()) {
    clear_scenario_config();
    set_has_traffic_light_unprotected_right_turn_config();
    scenario_config_.traffic_light_unprotected_right_turn_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig >(
        GetArenaNoVirtual());
  }
  return scenario_config_.traffic_light_unprotected_right_turn_config_;
}
inline ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* ScenarioConfig::mutable_traffic_light_unprotected_right_turn_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
  return _internal_mutable_traffic_light_unprotected_right_turn_config();
}

// optional .apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig traffic_light_unprotected_left_turn_config = 8;
inline bool ScenarioConfig::_internal_has_traffic_light_unprotected_left_turn_config() const {
  return scenario_config_case() == kTrafficLightUnprotectedLeftTurnConfig;
}
inline bool ScenarioConfig::has_traffic_light_unprotected_left_turn_config() const {
  return _internal_has_traffic_light_unprotected_left_turn_config();
}
inline void ScenarioConfig::set_has_traffic_light_unprotected_left_turn_config() {
  _oneof_case_[0] = kTrafficLightUnprotectedLeftTurnConfig;
}
inline void ScenarioConfig::clear_traffic_light_unprotected_left_turn_config() {
  if (_internal_has_traffic_light_unprotected_left_turn_config()) {
    delete scenario_config_.traffic_light_unprotected_left_turn_config_;
    clear_has_scenario_config();
  }
}
inline ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* ScenarioConfig::release_traffic_light_unprotected_left_turn_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
  if (_internal_has_traffic_light_unprotected_left_turn_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* temp = scenario_config_.traffic_light_unprotected_left_turn_config_;
    scenario_config_.traffic_light_unprotected_left_turn_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig& ScenarioConfig::_internal_traffic_light_unprotected_left_turn_config() const {
  return _internal_has_traffic_light_unprotected_left_turn_config()
      ? *scenario_config_.traffic_light_unprotected_left_turn_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig*>(&::apollo::planning::_ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_);
}
inline const ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig& ScenarioConfig::traffic_light_unprotected_left_turn_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
  return _internal_traffic_light_unprotected_left_turn_config();
}
inline ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* ScenarioConfig::_internal_mutable_traffic_light_unprotected_left_turn_config() {
  if (!_internal_has_traffic_light_unprotected_left_turn_config()) {
    clear_scenario_config();
    set_has_traffic_light_unprotected_left_turn_config();
    scenario_config_.traffic_light_unprotected_left_turn_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig >(
        GetArenaNoVirtual());
  }
  return scenario_config_.traffic_light_unprotected_left_turn_config_;
}
inline ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* ScenarioConfig::mutable_traffic_light_unprotected_left_turn_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
  return _internal_mutable_traffic_light_unprotected_left_turn_config();
}

// optional .apollo.planning.ScenarioPullOverConfig pull_over_config = 9;
inline bool ScenarioConfig::_internal_has_pull_over_config() const {
  return scenario_config_case() == kPullOverConfig;
}
inline bool ScenarioConfig::has_pull_over_config() const {
  return _internal_has_pull_over_config();
}
inline void ScenarioConfig::set_has_pull_over_config() {
  _oneof_case_[0] = kPullOverConfig;
}
inline void ScenarioConfig::clear_pull_over_config() {
  if (_internal_has_pull_over_config()) {
    delete scenario_config_.pull_over_config_;
    clear_has_scenario_config();
  }
}
inline ::apollo::planning::ScenarioPullOverConfig* ScenarioConfig::release_pull_over_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.pull_over_config)
  if (_internal_has_pull_over_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioPullOverConfig* temp = scenario_config_.pull_over_config_;
    scenario_config_.pull_over_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ScenarioPullOverConfig& ScenarioConfig::_internal_pull_over_config() const {
  return _internal_has_pull_over_config()
      ? *scenario_config_.pull_over_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioPullOverConfig*>(&::apollo::planning::_ScenarioPullOverConfig_default_instance_);
}
inline const ::apollo::planning::ScenarioPullOverConfig& ScenarioConfig::pull_over_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.pull_over_config)
  return _internal_pull_over_config();
}
inline ::apollo::planning::ScenarioPullOverConfig* ScenarioConfig::_internal_mutable_pull_over_config() {
  if (!_internal_has_pull_over_config()) {
    clear_scenario_config();
    set_has_pull_over_config();
    scenario_config_.pull_over_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioPullOverConfig >(
        GetArenaNoVirtual());
  }
  return scenario_config_.pull_over_config_;
}
inline ::apollo::planning::ScenarioPullOverConfig* ScenarioConfig::mutable_pull_over_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.pull_over_config)
  return _internal_mutable_pull_over_config();
}

// optional .apollo.planning.ScenarioValetParkingConfig valet_parking_config = 10;
inline bool ScenarioConfig::_internal_has_valet_parking_config() const {
  return scenario_config_case() == kValetParkingConfig;
}
inline bool ScenarioConfig::has_valet_parking_config() const {
  return _internal_has_valet_parking_config();
}
inline void ScenarioConfig::set_has_valet_parking_config() {
  _oneof_case_[0] = kValetParkingConfig;
}
inline void ScenarioConfig::clear_valet_parking_config() {
  if (_internal_has_valet_parking_config()) {
    delete scenario_config_.valet_parking_config_;
    clear_has_scenario_config();
  }
}
inline ::apollo::planning::ScenarioValetParkingConfig* ScenarioConfig::release_valet_parking_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.valet_parking_config)
  if (_internal_has_valet_parking_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioValetParkingConfig* temp = scenario_config_.valet_parking_config_;
    scenario_config_.valet_parking_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ScenarioValetParkingConfig& ScenarioConfig::_internal_valet_parking_config() const {
  return _internal_has_valet_parking_config()
      ? *scenario_config_.valet_parking_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioValetParkingConfig*>(&::apollo::planning::_ScenarioValetParkingConfig_default_instance_);
}
inline const ::apollo::planning::ScenarioValetParkingConfig& ScenarioConfig::valet_parking_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.valet_parking_config)
  return _internal_valet_parking_config();
}
inline ::apollo::planning::ScenarioValetParkingConfig* ScenarioConfig::_internal_mutable_valet_parking_config() {
  if (!_internal_has_valet_parking_config()) {
    clear_scenario_config();
    set_has_valet_parking_config();
    scenario_config_.valet_parking_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioValetParkingConfig >(
        GetArenaNoVirtual());
  }
  return scenario_config_.valet_parking_config_;
}
inline ::apollo::planning::ScenarioValetParkingConfig* ScenarioConfig::mutable_valet_parking_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.valet_parking_config)
  return _internal_mutable_valet_parking_config();
}

// optional .apollo.planning.ScenarioNarrowStreetUTurnConfig narrow_street_u_turn_config = 11;
inline bool ScenarioConfig::_internal_has_narrow_street_u_turn_config() const {
  return scenario_config_case() == kNarrowStreetUTurnConfig;
}
inline bool ScenarioConfig::has_narrow_street_u_turn_config() const {
  return _internal_has_narrow_street_u_turn_config();
}
inline void ScenarioConfig::set_has_narrow_street_u_turn_config() {
  _oneof_case_[0] = kNarrowStreetUTurnConfig;
}
inline void ScenarioConfig::clear_narrow_street_u_turn_config() {
  if (_internal_has_narrow_street_u_turn_config()) {
    delete scenario_config_.narrow_street_u_turn_config_;
    clear_has_scenario_config();
  }
}
inline ::apollo::planning::ScenarioNarrowStreetUTurnConfig* ScenarioConfig::release_narrow_street_u_turn_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.narrow_street_u_turn_config)
  if (_internal_has_narrow_street_u_turn_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioNarrowStreetUTurnConfig* temp = scenario_config_.narrow_street_u_turn_config_;
    scenario_config_.narrow_street_u_turn_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ScenarioNarrowStreetUTurnConfig& ScenarioConfig::_internal_narrow_street_u_turn_config() const {
  return _internal_has_narrow_street_u_turn_config()
      ? *scenario_config_.narrow_street_u_turn_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioNarrowStreetUTurnConfig*>(&::apollo::planning::_ScenarioNarrowStreetUTurnConfig_default_instance_);
}
inline const ::apollo::planning::ScenarioNarrowStreetUTurnConfig& ScenarioConfig::narrow_street_u_turn_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.narrow_street_u_turn_config)
  return _internal_narrow_street_u_turn_config();
}
inline ::apollo::planning::ScenarioNarrowStreetUTurnConfig* ScenarioConfig::_internal_mutable_narrow_street_u_turn_config() {
  if (!_internal_has_narrow_street_u_turn_config()) {
    clear_scenario_config();
    set_has_narrow_street_u_turn_config();
    scenario_config_.narrow_street_u_turn_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioNarrowStreetUTurnConfig >(
        GetArenaNoVirtual());
  }
  return scenario_config_.narrow_street_u_turn_config_;
}
inline ::apollo::planning::ScenarioNarrowStreetUTurnConfig* ScenarioConfig::mutable_narrow_street_u_turn_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.narrow_street_u_turn_config)
  return _internal_mutable_narrow_street_u_turn_config();
}

// repeated .apollo.planning.ScenarioConfig.StageType stage_type = 12;
inline int ScenarioConfig::_internal_stage_type_size() const {
  return stage_type_.size();
}
inline int ScenarioConfig::stage_type_size() const {
  return _internal_stage_type_size();
}
inline void ScenarioConfig::clear_stage_type() {
  stage_type_.Clear();
}
inline ::apollo::planning::ScenarioConfig_StageType ScenarioConfig::_internal_stage_type(int index) const {
  return static_cast< ::apollo::planning::ScenarioConfig_StageType >(stage_type_.Get(index));
}
inline ::apollo::planning::ScenarioConfig_StageType ScenarioConfig::stage_type(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.stage_type)
  return _internal_stage_type(index);
}
inline void ScenarioConfig::set_stage_type(int index, ::apollo::planning::ScenarioConfig_StageType value) {
  assert(::apollo::planning::ScenarioConfig_StageType_IsValid(value));
  stage_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioConfig.stage_type)
}
inline void ScenarioConfig::_internal_add_stage_type(::apollo::planning::ScenarioConfig_StageType value) {
  assert(::apollo::planning::ScenarioConfig_StageType_IsValid(value));
  stage_type_.Add(value);
}
inline void ScenarioConfig::add_stage_type(::apollo::planning::ScenarioConfig_StageType value) {
  // @@protoc_insertion_point(field_add:apollo.planning.ScenarioConfig.stage_type)
  _internal_add_stage_type(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ScenarioConfig::stage_type() const {
  // @@protoc_insertion_point(field_list:apollo.planning.ScenarioConfig.stage_type)
  return stage_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ScenarioConfig::_internal_mutable_stage_type() {
  return &stage_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ScenarioConfig::mutable_stage_type() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.ScenarioConfig.stage_type)
  return _internal_mutable_stage_type();
}

// repeated .apollo.planning.ScenarioConfig.StageConfig stage_config = 13;
inline int ScenarioConfig::_internal_stage_config_size() const {
  return stage_config_.size();
}
inline int ScenarioConfig::stage_config_size() const {
  return _internal_stage_config_size();
}
inline void ScenarioConfig::clear_stage_config() {
  stage_config_.Clear();
}
inline ::apollo::planning::ScenarioConfig_StageConfig* ScenarioConfig::mutable_stage_config(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.stage_config)
  return stage_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ScenarioConfig_StageConfig >*
ScenarioConfig::mutable_stage_config() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.ScenarioConfig.stage_config)
  return &stage_config_;
}
inline const ::apollo::planning::ScenarioConfig_StageConfig& ScenarioConfig::_internal_stage_config(int index) const {
  return stage_config_.Get(index);
}
inline const ::apollo::planning::ScenarioConfig_StageConfig& ScenarioConfig::stage_config(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.stage_config)
  return _internal_stage_config(index);
}
inline ::apollo::planning::ScenarioConfig_StageConfig* ScenarioConfig::_internal_add_stage_config() {
  return stage_config_.Add();
}
inline ::apollo::planning::ScenarioConfig_StageConfig* ScenarioConfig::add_stage_config() {
  // @@protoc_insertion_point(field_add:apollo.planning.ScenarioConfig.stage_config)
  return _internal_add_stage_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ScenarioConfig_StageConfig >&
ScenarioConfig::stage_config() const {
  // @@protoc_insertion_point(field_list:apollo.planning.ScenarioConfig.stage_config)
  return stage_config_;
}

inline bool ScenarioConfig::has_scenario_config() const {
  return scenario_config_case() != SCENARIO_CONFIG_NOT_SET;
}
inline void ScenarioConfig::clear_has_scenario_config() {
  _oneof_case_[0] = SCENARIO_CONFIG_NOT_SET;
}
inline ScenarioConfig::ScenarioConfigCase ScenarioConfig::scenario_config_case() const {
  return ScenarioConfig::ScenarioConfigCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlannerPublicRoadConfig

// repeated .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
inline int PlannerPublicRoadConfig::_internal_scenario_type_size() const {
  return scenario_type_.size();
}
inline int PlannerPublicRoadConfig::scenario_type_size() const {
  return _internal_scenario_type_size();
}
inline void PlannerPublicRoadConfig::clear_scenario_type() {
  scenario_type_.Clear();
}
inline ::apollo::planning::ScenarioConfig_ScenarioType PlannerPublicRoadConfig::_internal_scenario_type(int index) const {
  return static_cast< ::apollo::planning::ScenarioConfig_ScenarioType >(scenario_type_.Get(index));
}
inline ::apollo::planning::ScenarioConfig_ScenarioType PlannerPublicRoadConfig::scenario_type(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlannerPublicRoadConfig.scenario_type)
  return _internal_scenario_type(index);
}
inline void PlannerPublicRoadConfig::set_scenario_type(int index, ::apollo::planning::ScenarioConfig_ScenarioType value) {
  assert(::apollo::planning::ScenarioConfig_ScenarioType_IsValid(value));
  scenario_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.PlannerPublicRoadConfig.scenario_type)
}
inline void PlannerPublicRoadConfig::_internal_add_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value) {
  assert(::apollo::planning::ScenarioConfig_ScenarioType_IsValid(value));
  scenario_type_.Add(value);
}
inline void PlannerPublicRoadConfig::add_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value) {
  // @@protoc_insertion_point(field_add:apollo.planning.PlannerPublicRoadConfig.scenario_type)
  _internal_add_scenario_type(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
PlannerPublicRoadConfig::scenario_type() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PlannerPublicRoadConfig.scenario_type)
  return scenario_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
PlannerPublicRoadConfig::_internal_mutable_scenario_type() {
  return &scenario_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
PlannerPublicRoadConfig::mutable_scenario_type() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PlannerPublicRoadConfig.scenario_type)
  return _internal_mutable_scenario_type();
}

// -------------------------------------------------------------------

// PlannerNaviConfig

// repeated .apollo.planning.TaskConfig.TaskType task = 1;
inline int PlannerNaviConfig::_internal_task_size() const {
  return task_.size();
}
inline int PlannerNaviConfig::task_size() const {
  return _internal_task_size();
}
inline void PlannerNaviConfig::clear_task() {
  task_.Clear();
}
inline ::apollo::planning::TaskConfig_TaskType PlannerNaviConfig::_internal_task(int index) const {
  return static_cast< ::apollo::planning::TaskConfig_TaskType >(task_.Get(index));
}
inline ::apollo::planning::TaskConfig_TaskType PlannerNaviConfig::task(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlannerNaviConfig.task)
  return _internal_task(index);
}
inline void PlannerNaviConfig::set_task(int index, ::apollo::planning::TaskConfig_TaskType value) {
  assert(::apollo::planning::TaskConfig_TaskType_IsValid(value));
  task_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.PlannerNaviConfig.task)
}
inline void PlannerNaviConfig::_internal_add_task(::apollo::planning::TaskConfig_TaskType value) {
  assert(::apollo::planning::TaskConfig_TaskType_IsValid(value));
  task_.Add(value);
}
inline void PlannerNaviConfig::add_task(::apollo::planning::TaskConfig_TaskType value) {
  // @@protoc_insertion_point(field_add:apollo.planning.PlannerNaviConfig.task)
  _internal_add_task(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
PlannerNaviConfig::task() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PlannerNaviConfig.task)
  return task_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
PlannerNaviConfig::_internal_mutable_task() {
  return &task_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
PlannerNaviConfig::mutable_task() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PlannerNaviConfig.task)
  return _internal_mutable_task();
}

// optional .apollo.planning.NaviPathDeciderConfig navi_path_decider_config = 2;
inline bool PlannerNaviConfig::_internal_has_navi_path_decider_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || navi_path_decider_config_ != nullptr);
  return value;
}
inline bool PlannerNaviConfig::has_navi_path_decider_config() const {
  return _internal_has_navi_path_decider_config();
}
inline const ::apollo::planning::NaviPathDeciderConfig& PlannerNaviConfig::_internal_navi_path_decider_config() const {
  const ::apollo::planning::NaviPathDeciderConfig* p = navi_path_decider_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::NaviPathDeciderConfig*>(
      &::apollo::planning::_NaviPathDeciderConfig_default_instance_);
}
inline const ::apollo::planning::NaviPathDeciderConfig& PlannerNaviConfig::navi_path_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlannerNaviConfig.navi_path_decider_config)
  return _internal_navi_path_decider_config();
}
inline ::apollo::planning::NaviPathDeciderConfig* PlannerNaviConfig::release_navi_path_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlannerNaviConfig.navi_path_decider_config)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::NaviPathDeciderConfig* temp = navi_path_decider_config_;
  navi_path_decider_config_ = nullptr;
  return temp;
}
inline ::apollo::planning::NaviPathDeciderConfig* PlannerNaviConfig::_internal_mutable_navi_path_decider_config() {
  _has_bits_[0] |= 0x00000001u;
  if (navi_path_decider_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::NaviPathDeciderConfig>(GetArenaNoVirtual());
    navi_path_decider_config_ = p;
  }
  return navi_path_decider_config_;
}
inline ::apollo::planning::NaviPathDeciderConfig* PlannerNaviConfig::mutable_navi_path_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlannerNaviConfig.navi_path_decider_config)
  return _internal_mutable_navi_path_decider_config();
}
inline void PlannerNaviConfig::set_allocated_navi_path_decider_config(::apollo::planning::NaviPathDeciderConfig* navi_path_decider_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(navi_path_decider_config_);
  }
  if (navi_path_decider_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      navi_path_decider_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, navi_path_decider_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  navi_path_decider_config_ = navi_path_decider_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlannerNaviConfig.navi_path_decider_config)
}

// optional .apollo.planning.NaviSpeedDeciderConfig navi_speed_decider_config = 3;
inline bool PlannerNaviConfig::_internal_has_navi_speed_decider_config() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || navi_speed_decider_config_ != nullptr);
  return value;
}
inline bool PlannerNaviConfig::has_navi_speed_decider_config() const {
  return _internal_has_navi_speed_decider_config();
}
inline const ::apollo::planning::NaviSpeedDeciderConfig& PlannerNaviConfig::_internal_navi_speed_decider_config() const {
  const ::apollo::planning::NaviSpeedDeciderConfig* p = navi_speed_decider_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::NaviSpeedDeciderConfig*>(
      &::apollo::planning::_NaviSpeedDeciderConfig_default_instance_);
}
inline const ::apollo::planning::NaviSpeedDeciderConfig& PlannerNaviConfig::navi_speed_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlannerNaviConfig.navi_speed_decider_config)
  return _internal_navi_speed_decider_config();
}
inline ::apollo::planning::NaviSpeedDeciderConfig* PlannerNaviConfig::release_navi_speed_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlannerNaviConfig.navi_speed_decider_config)
  _has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::NaviSpeedDeciderConfig* temp = navi_speed_decider_config_;
  navi_speed_decider_config_ = nullptr;
  return temp;
}
inline ::apollo::planning::NaviSpeedDeciderConfig* PlannerNaviConfig::_internal_mutable_navi_speed_decider_config() {
  _has_bits_[0] |= 0x00000002u;
  if (navi_speed_decider_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::NaviSpeedDeciderConfig>(GetArenaNoVirtual());
    navi_speed_decider_config_ = p;
  }
  return navi_speed_decider_config_;
}
inline ::apollo::planning::NaviSpeedDeciderConfig* PlannerNaviConfig::mutable_navi_speed_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlannerNaviConfig.navi_speed_decider_config)
  return _internal_mutable_navi_speed_decider_config();
}
inline void PlannerNaviConfig::set_allocated_navi_speed_decider_config(::apollo::planning::NaviSpeedDeciderConfig* navi_speed_decider_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(navi_speed_decider_config_);
  }
  if (navi_speed_decider_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      navi_speed_decider_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, navi_speed_decider_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  navi_speed_decider_config_ = navi_speed_decider_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlannerNaviConfig.navi_speed_decider_config)
}

// optional .apollo.planning.NaviObstacleDeciderConfig navi_obstacle_decider_config = 4;
inline bool PlannerNaviConfig::_internal_has_navi_obstacle_decider_config() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || navi_obstacle_decider_config_ != nullptr);
  return value;
}
inline bool PlannerNaviConfig::has_navi_obstacle_decider_config() const {
  return _internal_has_navi_obstacle_decider_config();
}
inline const ::apollo::planning::NaviObstacleDeciderConfig& PlannerNaviConfig::_internal_navi_obstacle_decider_config() const {
  const ::apollo::planning::NaviObstacleDeciderConfig* p = navi_obstacle_decider_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::NaviObstacleDeciderConfig*>(
      &::apollo::planning::_NaviObstacleDeciderConfig_default_instance_);
}
inline const ::apollo::planning::NaviObstacleDeciderConfig& PlannerNaviConfig::navi_obstacle_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlannerNaviConfig.navi_obstacle_decider_config)
  return _internal_navi_obstacle_decider_config();
}
inline ::apollo::planning::NaviObstacleDeciderConfig* PlannerNaviConfig::release_navi_obstacle_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlannerNaviConfig.navi_obstacle_decider_config)
  _has_bits_[0] &= ~0x00000004u;
  ::apollo::planning::NaviObstacleDeciderConfig* temp = navi_obstacle_decider_config_;
  navi_obstacle_decider_config_ = nullptr;
  return temp;
}
inline ::apollo::planning::NaviObstacleDeciderConfig* PlannerNaviConfig::_internal_mutable_navi_obstacle_decider_config() {
  _has_bits_[0] |= 0x00000004u;
  if (navi_obstacle_decider_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::NaviObstacleDeciderConfig>(GetArenaNoVirtual());
    navi_obstacle_decider_config_ = p;
  }
  return navi_obstacle_decider_config_;
}
inline ::apollo::planning::NaviObstacleDeciderConfig* PlannerNaviConfig::mutable_navi_obstacle_decider_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlannerNaviConfig.navi_obstacle_decider_config)
  return _internal_mutable_navi_obstacle_decider_config();
}
inline void PlannerNaviConfig::set_allocated_navi_obstacle_decider_config(::apollo::planning::NaviObstacleDeciderConfig* navi_obstacle_decider_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(navi_obstacle_decider_config_);
  }
  if (navi_obstacle_decider_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      navi_obstacle_decider_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, navi_obstacle_decider_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  navi_obstacle_decider_config_ = navi_obstacle_decider_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlannerNaviConfig.navi_obstacle_decider_config)
}

// -------------------------------------------------------------------

// RtkPlanningConfig

// optional .apollo.planning.PlannerType planner_type = 1;
inline bool RtkPlanningConfig::_internal_has_planner_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RtkPlanningConfig::has_planner_type() const {
  return _internal_has_planner_type();
}
inline void RtkPlanningConfig::clear_planner_type() {
  planner_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::planning::PlannerType RtkPlanningConfig::_internal_planner_type() const {
  return static_cast< ::apollo::planning::PlannerType >(planner_type_);
}
inline ::apollo::planning::PlannerType RtkPlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.RtkPlanningConfig.planner_type)
  return _internal_planner_type();
}
inline void RtkPlanningConfig::_internal_set_planner_type(::apollo::planning::PlannerType value) {
  assert(::apollo::planning::PlannerType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  planner_type_ = value;
}
inline void RtkPlanningConfig::set_planner_type(::apollo::planning::PlannerType value) {
  _internal_set_planner_type(value);
  // @@protoc_insertion_point(field_set:apollo.planning.RtkPlanningConfig.planner_type)
}

// -------------------------------------------------------------------

// StandardPlanningConfig

// repeated .apollo.planning.PlannerType planner_type = 1;
inline int StandardPlanningConfig::_internal_planner_type_size() const {
  return planner_type_.size();
}
inline int StandardPlanningConfig::planner_type_size() const {
  return _internal_planner_type_size();
}
inline void StandardPlanningConfig::clear_planner_type() {
  planner_type_.Clear();
}
inline ::apollo::planning::PlannerType StandardPlanningConfig::_internal_planner_type(int index) const {
  return static_cast< ::apollo::planning::PlannerType >(planner_type_.Get(index));
}
inline ::apollo::planning::PlannerType StandardPlanningConfig::planner_type(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.StandardPlanningConfig.planner_type)
  return _internal_planner_type(index);
}
inline void StandardPlanningConfig::set_planner_type(int index, ::apollo::planning::PlannerType value) {
  assert(::apollo::planning::PlannerType_IsValid(value));
  planner_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.StandardPlanningConfig.planner_type)
}
inline void StandardPlanningConfig::_internal_add_planner_type(::apollo::planning::PlannerType value) {
  assert(::apollo::planning::PlannerType_IsValid(value));
  planner_type_.Add(value);
}
inline void StandardPlanningConfig::add_planner_type(::apollo::planning::PlannerType value) {
  // @@protoc_insertion_point(field_add:apollo.planning.StandardPlanningConfig.planner_type)
  _internal_add_planner_type(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
StandardPlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_list:apollo.planning.StandardPlanningConfig.planner_type)
  return planner_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
StandardPlanningConfig::_internal_mutable_planner_type() {
  return &planner_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
StandardPlanningConfig::mutable_planner_type() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.StandardPlanningConfig.planner_type)
  return _internal_mutable_planner_type();
}

// optional .apollo.planning.PlannerPublicRoadConfig planner_public_road_config = 2;
inline bool StandardPlanningConfig::_internal_has_planner_public_road_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || planner_public_road_config_ != nullptr);
  return value;
}
inline bool StandardPlanningConfig::has_planner_public_road_config() const {
  return _internal_has_planner_public_road_config();
}
inline void StandardPlanningConfig::clear_planner_public_road_config() {
  if (planner_public_road_config_ != nullptr) planner_public_road_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::PlannerPublicRoadConfig& StandardPlanningConfig::_internal_planner_public_road_config() const {
  const ::apollo::planning::PlannerPublicRoadConfig* p = planner_public_road_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::PlannerPublicRoadConfig*>(
      &::apollo::planning::_PlannerPublicRoadConfig_default_instance_);
}
inline const ::apollo::planning::PlannerPublicRoadConfig& StandardPlanningConfig::planner_public_road_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StandardPlanningConfig.planner_public_road_config)
  return _internal_planner_public_road_config();
}
inline ::apollo::planning::PlannerPublicRoadConfig* StandardPlanningConfig::release_planner_public_road_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.StandardPlanningConfig.planner_public_road_config)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::PlannerPublicRoadConfig* temp = planner_public_road_config_;
  planner_public_road_config_ = nullptr;
  return temp;
}
inline ::apollo::planning::PlannerPublicRoadConfig* StandardPlanningConfig::_internal_mutable_planner_public_road_config() {
  _has_bits_[0] |= 0x00000001u;
  if (planner_public_road_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::PlannerPublicRoadConfig>(GetArenaNoVirtual());
    planner_public_road_config_ = p;
  }
  return planner_public_road_config_;
}
inline ::apollo::planning::PlannerPublicRoadConfig* StandardPlanningConfig::mutable_planner_public_road_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.StandardPlanningConfig.planner_public_road_config)
  return _internal_mutable_planner_public_road_config();
}
inline void StandardPlanningConfig::set_allocated_planner_public_road_config(::apollo::planning::PlannerPublicRoadConfig* planner_public_road_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete planner_public_road_config_;
  }
  if (planner_public_road_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      planner_public_road_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planner_public_road_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  planner_public_road_config_ = planner_public_road_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StandardPlanningConfig.planner_public_road_config)
}

// -------------------------------------------------------------------

// NavigationPlanningConfig

// repeated .apollo.planning.PlannerType planner_type = 1;
inline int NavigationPlanningConfig::_internal_planner_type_size() const {
  return planner_type_.size();
}
inline int NavigationPlanningConfig::planner_type_size() const {
  return _internal_planner_type_size();
}
inline void NavigationPlanningConfig::clear_planner_type() {
  planner_type_.Clear();
}
inline ::apollo::planning::PlannerType NavigationPlanningConfig::_internal_planner_type(int index) const {
  return static_cast< ::apollo::planning::PlannerType >(planner_type_.Get(index));
}
inline ::apollo::planning::PlannerType NavigationPlanningConfig::planner_type(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.NavigationPlanningConfig.planner_type)
  return _internal_planner_type(index);
}
inline void NavigationPlanningConfig::set_planner_type(int index, ::apollo::planning::PlannerType value) {
  assert(::apollo::planning::PlannerType_IsValid(value));
  planner_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.NavigationPlanningConfig.planner_type)
}
inline void NavigationPlanningConfig::_internal_add_planner_type(::apollo::planning::PlannerType value) {
  assert(::apollo::planning::PlannerType_IsValid(value));
  planner_type_.Add(value);
}
inline void NavigationPlanningConfig::add_planner_type(::apollo::planning::PlannerType value) {
  // @@protoc_insertion_point(field_add:apollo.planning.NavigationPlanningConfig.planner_type)
  _internal_add_planner_type(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
NavigationPlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_list:apollo.planning.NavigationPlanningConfig.planner_type)
  return planner_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
NavigationPlanningConfig::_internal_mutable_planner_type() {
  return &planner_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
NavigationPlanningConfig::mutable_planner_type() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.NavigationPlanningConfig.planner_type)
  return _internal_mutable_planner_type();
}

// optional .apollo.planning.PlannerNaviConfig planner_navi_config = 4;
inline bool NavigationPlanningConfig::_internal_has_planner_navi_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || planner_navi_config_ != nullptr);
  return value;
}
inline bool NavigationPlanningConfig::has_planner_navi_config() const {
  return _internal_has_planner_navi_config();
}
inline void NavigationPlanningConfig::clear_planner_navi_config() {
  if (planner_navi_config_ != nullptr) planner_navi_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::PlannerNaviConfig& NavigationPlanningConfig::_internal_planner_navi_config() const {
  const ::apollo::planning::PlannerNaviConfig* p = planner_navi_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::planning::PlannerNaviConfig*>(
      &::apollo::planning::_PlannerNaviConfig_default_instance_);
}
inline const ::apollo::planning::PlannerNaviConfig& NavigationPlanningConfig::planner_navi_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.NavigationPlanningConfig.planner_navi_config)
  return _internal_planner_navi_config();
}
inline ::apollo::planning::PlannerNaviConfig* NavigationPlanningConfig::release_planner_navi_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.NavigationPlanningConfig.planner_navi_config)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::PlannerNaviConfig* temp = planner_navi_config_;
  planner_navi_config_ = nullptr;
  return temp;
}
inline ::apollo::planning::PlannerNaviConfig* NavigationPlanningConfig::_internal_mutable_planner_navi_config() {
  _has_bits_[0] |= 0x00000001u;
  if (planner_navi_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::PlannerNaviConfig>(GetArenaNoVirtual());
    planner_navi_config_ = p;
  }
  return planner_navi_config_;
}
inline ::apollo::planning::PlannerNaviConfig* NavigationPlanningConfig::mutable_planner_navi_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.NavigationPlanningConfig.planner_navi_config)
  return _internal_mutable_planner_navi_config();
}
inline void NavigationPlanningConfig::set_allocated_planner_navi_config(::apollo::planning::PlannerNaviConfig* planner_navi_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete planner_navi_config_;
  }
  if (planner_navi_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      planner_navi_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planner_navi_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  planner_navi_config_ = planner_navi_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.NavigationPlanningConfig.planner_navi_config)
}

// -------------------------------------------------------------------

// PlanningConfig

// optional .apollo.planning.RtkPlanningConfig rtk_planning_config = 1;
inline bool PlanningConfig::_internal_has_rtk_planning_config() const {
  return planning_config_case() == kRtkPlanningConfig;
}
inline bool PlanningConfig::has_rtk_planning_config() const {
  return _internal_has_rtk_planning_config();
}
inline void PlanningConfig::set_has_rtk_planning_config() {
  _oneof_case_[0] = kRtkPlanningConfig;
}
inline void PlanningConfig::clear_rtk_planning_config() {
  if (_internal_has_rtk_planning_config()) {
    delete planning_config_.rtk_planning_config_;
    clear_has_planning_config();
  }
}
inline ::apollo::planning::RtkPlanningConfig* PlanningConfig::release_rtk_planning_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningConfig.rtk_planning_config)
  if (_internal_has_rtk_planning_config()) {
    clear_has_planning_config();
      ::apollo::planning::RtkPlanningConfig* temp = planning_config_.rtk_planning_config_;
    planning_config_.rtk_planning_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::RtkPlanningConfig& PlanningConfig::_internal_rtk_planning_config() const {
  return _internal_has_rtk_planning_config()
      ? *planning_config_.rtk_planning_config_
      : *reinterpret_cast< ::apollo::planning::RtkPlanningConfig*>(&::apollo::planning::_RtkPlanningConfig_default_instance_);
}
inline const ::apollo::planning::RtkPlanningConfig& PlanningConfig::rtk_planning_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningConfig.rtk_planning_config)
  return _internal_rtk_planning_config();
}
inline ::apollo::planning::RtkPlanningConfig* PlanningConfig::_internal_mutable_rtk_planning_config() {
  if (!_internal_has_rtk_planning_config()) {
    clear_planning_config();
    set_has_rtk_planning_config();
    planning_config_.rtk_planning_config_ = CreateMaybeMessage< ::apollo::planning::RtkPlanningConfig >(
        GetArenaNoVirtual());
  }
  return planning_config_.rtk_planning_config_;
}
inline ::apollo::planning::RtkPlanningConfig* PlanningConfig::mutable_rtk_planning_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningConfig.rtk_planning_config)
  return _internal_mutable_rtk_planning_config();
}

// optional .apollo.planning.StandardPlanningConfig standard_planning_config = 2;
inline bool PlanningConfig::_internal_has_standard_planning_config() const {
  return planning_config_case() == kStandardPlanningConfig;
}
inline bool PlanningConfig::has_standard_planning_config() const {
  return _internal_has_standard_planning_config();
}
inline void PlanningConfig::set_has_standard_planning_config() {
  _oneof_case_[0] = kStandardPlanningConfig;
}
inline void PlanningConfig::clear_standard_planning_config() {
  if (_internal_has_standard_planning_config()) {
    delete planning_config_.standard_planning_config_;
    clear_has_planning_config();
  }
}
inline ::apollo::planning::StandardPlanningConfig* PlanningConfig::release_standard_planning_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningConfig.standard_planning_config)
  if (_internal_has_standard_planning_config()) {
    clear_has_planning_config();
      ::apollo::planning::StandardPlanningConfig* temp = planning_config_.standard_planning_config_;
    planning_config_.standard_planning_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::StandardPlanningConfig& PlanningConfig::_internal_standard_planning_config() const {
  return _internal_has_standard_planning_config()
      ? *planning_config_.standard_planning_config_
      : *reinterpret_cast< ::apollo::planning::StandardPlanningConfig*>(&::apollo::planning::_StandardPlanningConfig_default_instance_);
}
inline const ::apollo::planning::StandardPlanningConfig& PlanningConfig::standard_planning_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningConfig.standard_planning_config)
  return _internal_standard_planning_config();
}
inline ::apollo::planning::StandardPlanningConfig* PlanningConfig::_internal_mutable_standard_planning_config() {
  if (!_internal_has_standard_planning_config()) {
    clear_planning_config();
    set_has_standard_planning_config();
    planning_config_.standard_planning_config_ = CreateMaybeMessage< ::apollo::planning::StandardPlanningConfig >(
        GetArenaNoVirtual());
  }
  return planning_config_.standard_planning_config_;
}
inline ::apollo::planning::StandardPlanningConfig* PlanningConfig::mutable_standard_planning_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningConfig.standard_planning_config)
  return _internal_mutable_standard_planning_config();
}

// optional .apollo.planning.NavigationPlanningConfig navigation_planning_config = 3;
inline bool PlanningConfig::_internal_has_navigation_planning_config() const {
  return planning_config_case() == kNavigationPlanningConfig;
}
inline bool PlanningConfig::has_navigation_planning_config() const {
  return _internal_has_navigation_planning_config();
}
inline void PlanningConfig::set_has_navigation_planning_config() {
  _oneof_case_[0] = kNavigationPlanningConfig;
}
inline void PlanningConfig::clear_navigation_planning_config() {
  if (_internal_has_navigation_planning_config()) {
    delete planning_config_.navigation_planning_config_;
    clear_has_planning_config();
  }
}
inline ::apollo::planning::NavigationPlanningConfig* PlanningConfig::release_navigation_planning_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningConfig.navigation_planning_config)
  if (_internal_has_navigation_planning_config()) {
    clear_has_planning_config();
      ::apollo::planning::NavigationPlanningConfig* temp = planning_config_.navigation_planning_config_;
    planning_config_.navigation_planning_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::NavigationPlanningConfig& PlanningConfig::_internal_navigation_planning_config() const {
  return _internal_has_navigation_planning_config()
      ? *planning_config_.navigation_planning_config_
      : *reinterpret_cast< ::apollo::planning::NavigationPlanningConfig*>(&::apollo::planning::_NavigationPlanningConfig_default_instance_);
}
inline const ::apollo::planning::NavigationPlanningConfig& PlanningConfig::navigation_planning_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningConfig.navigation_planning_config)
  return _internal_navigation_planning_config();
}
inline ::apollo::planning::NavigationPlanningConfig* PlanningConfig::_internal_mutable_navigation_planning_config() {
  if (!_internal_has_navigation_planning_config()) {
    clear_planning_config();
    set_has_navigation_planning_config();
    planning_config_.navigation_planning_config_ = CreateMaybeMessage< ::apollo::planning::NavigationPlanningConfig >(
        GetArenaNoVirtual());
  }
  return planning_config_.navigation_planning_config_;
}
inline ::apollo::planning::NavigationPlanningConfig* PlanningConfig::mutable_navigation_planning_config() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningConfig.navigation_planning_config)
  return _internal_mutable_navigation_planning_config();
}

// repeated .apollo.planning.TaskConfig default_task_config = 5;
inline int PlanningConfig::_internal_default_task_config_size() const {
  return default_task_config_.size();
}
inline int PlanningConfig::default_task_config_size() const {
  return _internal_default_task_config_size();
}
inline void PlanningConfig::clear_default_task_config() {
  default_task_config_.Clear();
}
inline ::apollo::planning::TaskConfig* PlanningConfig::mutable_default_task_config(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningConfig.default_task_config)
  return default_task_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TaskConfig >*
PlanningConfig::mutable_default_task_config() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PlanningConfig.default_task_config)
  return &default_task_config_;
}
inline const ::apollo::planning::TaskConfig& PlanningConfig::_internal_default_task_config(int index) const {
  return default_task_config_.Get(index);
}
inline const ::apollo::planning::TaskConfig& PlanningConfig::default_task_config(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningConfig.default_task_config)
  return _internal_default_task_config(index);
}
inline ::apollo::planning::TaskConfig* PlanningConfig::_internal_add_default_task_config() {
  return default_task_config_.Add();
}
inline ::apollo::planning::TaskConfig* PlanningConfig::add_default_task_config() {
  // @@protoc_insertion_point(field_add:apollo.planning.PlanningConfig.default_task_config)
  return _internal_add_default_task_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TaskConfig >&
PlanningConfig::default_task_config() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PlanningConfig.default_task_config)
  return default_task_config_;
}

inline bool PlanningConfig::has_planning_config() const {
  return planning_config_case() != PLANNING_CONFIG_NOT_SET;
}
inline void PlanningConfig::clear_has_planning_config() {
  _oneof_case_[0] = PLANNING_CONFIG_NOT_SET;
}
inline PlanningConfig::PlanningConfigCase PlanningConfig::planning_config_case() const {
  return PlanningConfig::PlanningConfigCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::planning::TaskConfig_TaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::TaskConfig_TaskType>() {
  return ::apollo::planning::TaskConfig_TaskType_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::ScenarioConfig_ScenarioType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::ScenarioConfig_ScenarioType>() {
  return ::apollo::planning::ScenarioConfig_ScenarioType_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::ScenarioConfig_StageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::ScenarioConfig_StageType>() {
  return ::apollo::planning::ScenarioConfig_StageType_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::PlannerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::PlannerType>() {
  return ::apollo::planning::PlannerType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto
