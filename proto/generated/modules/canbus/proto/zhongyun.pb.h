// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/canbus/proto/zhongyun.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fcanbus_2fproto_2fzhongyun_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fcanbus_2fproto_2fzhongyun_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fcanbus_2fproto_2fzhongyun_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fcanbus_2fproto_2fzhongyun_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto;
namespace apollo {
namespace canbus {
class Brake_control_a4;
class Brake_control_a4DefaultTypeInternal;
extern Brake_control_a4DefaultTypeInternal _Brake_control_a4_default_instance_;
class Enable_state_feedback_c3;
class Enable_state_feedback_c3DefaultTypeInternal;
extern Enable_state_feedback_c3DefaultTypeInternal _Enable_state_feedback_c3_default_instance_;
class Error_state_e1;
class Error_state_e1DefaultTypeInternal;
extern Error_state_e1DefaultTypeInternal _Error_state_e1_default_instance_;
class Gear_control_a1;
class Gear_control_a1DefaultTypeInternal;
extern Gear_control_a1DefaultTypeInternal _Gear_control_a1_default_instance_;
class Parking_control_a5;
class Parking_control_a5DefaultTypeInternal;
extern Parking_control_a5DefaultTypeInternal _Parking_control_a5_default_instance_;
class Steering_control_a2;
class Steering_control_a2DefaultTypeInternal;
extern Steering_control_a2DefaultTypeInternal _Steering_control_a2_default_instance_;
class Torque_control_a3;
class Torque_control_a3DefaultTypeInternal;
extern Torque_control_a3DefaultTypeInternal _Torque_control_a3_default_instance_;
class Vehicle_state_feedback_2_c4;
class Vehicle_state_feedback_2_c4DefaultTypeInternal;
extern Vehicle_state_feedback_2_c4DefaultTypeInternal _Vehicle_state_feedback_2_c4_default_instance_;
class Vehicle_state_feedback_c1;
class Vehicle_state_feedback_c1DefaultTypeInternal;
extern Vehicle_state_feedback_c1DefaultTypeInternal _Vehicle_state_feedback_c1_default_instance_;
class Zhongyun;
class ZhongyunDefaultTypeInternal;
extern ZhongyunDefaultTypeInternal _Zhongyun_default_instance_;
}  // namespace canbus
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::canbus::Brake_control_a4* Arena::CreateMaybeMessage<::apollo::canbus::Brake_control_a4>(Arena*);
template<> ::apollo::canbus::Enable_state_feedback_c3* Arena::CreateMaybeMessage<::apollo::canbus::Enable_state_feedback_c3>(Arena*);
template<> ::apollo::canbus::Error_state_e1* Arena::CreateMaybeMessage<::apollo::canbus::Error_state_e1>(Arena*);
template<> ::apollo::canbus::Gear_control_a1* Arena::CreateMaybeMessage<::apollo::canbus::Gear_control_a1>(Arena*);
template<> ::apollo::canbus::Parking_control_a5* Arena::CreateMaybeMessage<::apollo::canbus::Parking_control_a5>(Arena*);
template<> ::apollo::canbus::Steering_control_a2* Arena::CreateMaybeMessage<::apollo::canbus::Steering_control_a2>(Arena*);
template<> ::apollo::canbus::Torque_control_a3* Arena::CreateMaybeMessage<::apollo::canbus::Torque_control_a3>(Arena*);
template<> ::apollo::canbus::Vehicle_state_feedback_2_c4* Arena::CreateMaybeMessage<::apollo::canbus::Vehicle_state_feedback_2_c4>(Arena*);
template<> ::apollo::canbus::Vehicle_state_feedback_c1* Arena::CreateMaybeMessage<::apollo::canbus::Vehicle_state_feedback_c1>(Arena*);
template<> ::apollo::canbus::Zhongyun* Arena::CreateMaybeMessage<::apollo::canbus::Zhongyun>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace canbus {

enum Gear_control_a1_Gear_state_targetType : int {
  Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_P = 1,
  Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_N = 2,
  Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_D = 3,
  Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_R = 4,
  Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_INVALID = 5
};
bool Gear_control_a1_Gear_state_targetType_IsValid(int value);
constexpr Gear_control_a1_Gear_state_targetType Gear_control_a1_Gear_state_targetType_Gear_state_targetType_MIN = Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_P;
constexpr Gear_control_a1_Gear_state_targetType Gear_control_a1_Gear_state_targetType_Gear_state_targetType_MAX = Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_INVALID;
constexpr int Gear_control_a1_Gear_state_targetType_Gear_state_targetType_ARRAYSIZE = Gear_control_a1_Gear_state_targetType_Gear_state_targetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Gear_control_a1_Gear_state_targetType_descriptor();
template<typename T>
inline const std::string& Gear_control_a1_Gear_state_targetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Gear_control_a1_Gear_state_targetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Gear_control_a1_Gear_state_targetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Gear_control_a1_Gear_state_targetType_descriptor(), enum_t_value);
}
inline bool Gear_control_a1_Gear_state_targetType_Parse(
    const std::string& name, Gear_control_a1_Gear_state_targetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Gear_control_a1_Gear_state_targetType>(
    Gear_control_a1_Gear_state_targetType_descriptor(), name, value);
}
enum Gear_control_a1_Gear_enable_controlType : int {
  Gear_control_a1_Gear_enable_controlType_GEAR_ENABLE_CONTROL_GEAR_MANUALCONTROL = 0,
  Gear_control_a1_Gear_enable_controlType_GEAR_ENABLE_CONTROL_GEAR_AUTOCONTROL = 1
};
bool Gear_control_a1_Gear_enable_controlType_IsValid(int value);
constexpr Gear_control_a1_Gear_enable_controlType Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_MIN = Gear_control_a1_Gear_enable_controlType_GEAR_ENABLE_CONTROL_GEAR_MANUALCONTROL;
constexpr Gear_control_a1_Gear_enable_controlType Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_MAX = Gear_control_a1_Gear_enable_controlType_GEAR_ENABLE_CONTROL_GEAR_AUTOCONTROL;
constexpr int Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_ARRAYSIZE = Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Gear_control_a1_Gear_enable_controlType_descriptor();
template<typename T>
inline const std::string& Gear_control_a1_Gear_enable_controlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Gear_control_a1_Gear_enable_controlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Gear_control_a1_Gear_enable_controlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Gear_control_a1_Gear_enable_controlType_descriptor(), enum_t_value);
}
inline bool Gear_control_a1_Gear_enable_controlType_Parse(
    const std::string& name, Gear_control_a1_Gear_enable_controlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Gear_control_a1_Gear_enable_controlType>(
    Gear_control_a1_Gear_enable_controlType_descriptor(), name, value);
}
enum Torque_control_a3_Driven_enable_controlType : int {
  Torque_control_a3_Driven_enable_controlType_DRIVEN_ENABLE_CONTROL_DRIVE_MANUAL = 0,
  Torque_control_a3_Driven_enable_controlType_DRIVEN_ENABLE_CONTROL_DRIVE_AUTO = 1
};
bool Torque_control_a3_Driven_enable_controlType_IsValid(int value);
constexpr Torque_control_a3_Driven_enable_controlType Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_MIN = Torque_control_a3_Driven_enable_controlType_DRIVEN_ENABLE_CONTROL_DRIVE_MANUAL;
constexpr Torque_control_a3_Driven_enable_controlType Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_MAX = Torque_control_a3_Driven_enable_controlType_DRIVEN_ENABLE_CONTROL_DRIVE_AUTO;
constexpr int Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_ARRAYSIZE = Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Torque_control_a3_Driven_enable_controlType_descriptor();
template<typename T>
inline const std::string& Torque_control_a3_Driven_enable_controlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Torque_control_a3_Driven_enable_controlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Torque_control_a3_Driven_enable_controlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Torque_control_a3_Driven_enable_controlType_descriptor(), enum_t_value);
}
inline bool Torque_control_a3_Driven_enable_controlType_Parse(
    const std::string& name, Torque_control_a3_Driven_enable_controlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Torque_control_a3_Driven_enable_controlType>(
    Torque_control_a3_Driven_enable_controlType_descriptor(), name, value);
}
enum Steering_control_a2_Steering_enable_controlType : int {
  Steering_control_a2_Steering_enable_controlType_STEERING_ENABLE_CONTROL_STEERING_MANUALCONTROL = 0,
  Steering_control_a2_Steering_enable_controlType_STEERING_ENABLE_CONTROL_STEERING_AUTOCONTROL = 1
};
bool Steering_control_a2_Steering_enable_controlType_IsValid(int value);
constexpr Steering_control_a2_Steering_enable_controlType Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_MIN = Steering_control_a2_Steering_enable_controlType_STEERING_ENABLE_CONTROL_STEERING_MANUALCONTROL;
constexpr Steering_control_a2_Steering_enable_controlType Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_MAX = Steering_control_a2_Steering_enable_controlType_STEERING_ENABLE_CONTROL_STEERING_AUTOCONTROL;
constexpr int Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_ARRAYSIZE = Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Steering_control_a2_Steering_enable_controlType_descriptor();
template<typename T>
inline const std::string& Steering_control_a2_Steering_enable_controlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Steering_control_a2_Steering_enable_controlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Steering_control_a2_Steering_enable_controlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Steering_control_a2_Steering_enable_controlType_descriptor(), enum_t_value);
}
inline bool Steering_control_a2_Steering_enable_controlType_Parse(
    const std::string& name, Steering_control_a2_Steering_enable_controlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Steering_control_a2_Steering_enable_controlType>(
    Steering_control_a2_Steering_enable_controlType_descriptor(), name, value);
}
enum Parking_control_a5_Parking_targetType : int {
  Parking_control_a5_Parking_targetType_PARKING_TARGET_RELEASE = 0,
  Parking_control_a5_Parking_targetType_PARKING_TARGET_PARKING_TRIGGER = 1
};
bool Parking_control_a5_Parking_targetType_IsValid(int value);
constexpr Parking_control_a5_Parking_targetType Parking_control_a5_Parking_targetType_Parking_targetType_MIN = Parking_control_a5_Parking_targetType_PARKING_TARGET_RELEASE;
constexpr Parking_control_a5_Parking_targetType Parking_control_a5_Parking_targetType_Parking_targetType_MAX = Parking_control_a5_Parking_targetType_PARKING_TARGET_PARKING_TRIGGER;
constexpr int Parking_control_a5_Parking_targetType_Parking_targetType_ARRAYSIZE = Parking_control_a5_Parking_targetType_Parking_targetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Parking_control_a5_Parking_targetType_descriptor();
template<typename T>
inline const std::string& Parking_control_a5_Parking_targetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Parking_control_a5_Parking_targetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Parking_control_a5_Parking_targetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Parking_control_a5_Parking_targetType_descriptor(), enum_t_value);
}
inline bool Parking_control_a5_Parking_targetType_Parse(
    const std::string& name, Parking_control_a5_Parking_targetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Parking_control_a5_Parking_targetType>(
    Parking_control_a5_Parking_targetType_descriptor(), name, value);
}
enum Parking_control_a5_Parking_enable_controlType : int {
  Parking_control_a5_Parking_enable_controlType_PARKING_ENABLE_CONTROL_PARKING_MANUALCONTROL = 0,
  Parking_control_a5_Parking_enable_controlType_PARKING_ENABLE_CONTROL_PARKING_AUTOCONTROL = 1
};
bool Parking_control_a5_Parking_enable_controlType_IsValid(int value);
constexpr Parking_control_a5_Parking_enable_controlType Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_MIN = Parking_control_a5_Parking_enable_controlType_PARKING_ENABLE_CONTROL_PARKING_MANUALCONTROL;
constexpr Parking_control_a5_Parking_enable_controlType Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_MAX = Parking_control_a5_Parking_enable_controlType_PARKING_ENABLE_CONTROL_PARKING_AUTOCONTROL;
constexpr int Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_ARRAYSIZE = Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Parking_control_a5_Parking_enable_controlType_descriptor();
template<typename T>
inline const std::string& Parking_control_a5_Parking_enable_controlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Parking_control_a5_Parking_enable_controlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Parking_control_a5_Parking_enable_controlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Parking_control_a5_Parking_enable_controlType_descriptor(), enum_t_value);
}
inline bool Parking_control_a5_Parking_enable_controlType_Parse(
    const std::string& name, Parking_control_a5_Parking_enable_controlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Parking_control_a5_Parking_enable_controlType>(
    Parking_control_a5_Parking_enable_controlType_descriptor(), name, value);
}
enum Brake_control_a4_Brake_enable_controlType : int {
  Brake_control_a4_Brake_enable_controlType_BRAKE_ENABLE_CONTROL_BRAKE_MANUAL = 0,
  Brake_control_a4_Brake_enable_controlType_BRAKE_ENABLE_CONTROL_BRAKE_AUTO = 1
};
bool Brake_control_a4_Brake_enable_controlType_IsValid(int value);
constexpr Brake_control_a4_Brake_enable_controlType Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_MIN = Brake_control_a4_Brake_enable_controlType_BRAKE_ENABLE_CONTROL_BRAKE_MANUAL;
constexpr Brake_control_a4_Brake_enable_controlType Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_MAX = Brake_control_a4_Brake_enable_controlType_BRAKE_ENABLE_CONTROL_BRAKE_AUTO;
constexpr int Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_ARRAYSIZE = Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Brake_control_a4_Brake_enable_controlType_descriptor();
template<typename T>
inline const std::string& Brake_control_a4_Brake_enable_controlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Brake_control_a4_Brake_enable_controlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Brake_control_a4_Brake_enable_controlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Brake_control_a4_Brake_enable_controlType_descriptor(), enum_t_value);
}
inline bool Brake_control_a4_Brake_enable_controlType_Parse(
    const std::string& name, Brake_control_a4_Brake_enable_controlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Brake_control_a4_Brake_enable_controlType>(
    Brake_control_a4_Brake_enable_controlType_descriptor(), name, value);
}
enum Enable_state_feedback_c3_Parking_enable_stateType : int {
  Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_MANUALCONTROL = 0,
  Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_AUTOCONTROL = 1,
  Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_TAKEOVER = 2
};
bool Enable_state_feedback_c3_Parking_enable_stateType_IsValid(int value);
constexpr Enable_state_feedback_c3_Parking_enable_stateType Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_MIN = Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_MANUALCONTROL;
constexpr Enable_state_feedback_c3_Parking_enable_stateType Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_MAX = Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_TAKEOVER;
constexpr int Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_ARRAYSIZE = Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Enable_state_feedback_c3_Parking_enable_stateType_descriptor();
template<typename T>
inline const std::string& Enable_state_feedback_c3_Parking_enable_stateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Enable_state_feedback_c3_Parking_enable_stateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Enable_state_feedback_c3_Parking_enable_stateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Enable_state_feedback_c3_Parking_enable_stateType_descriptor(), enum_t_value);
}
inline bool Enable_state_feedback_c3_Parking_enable_stateType_Parse(
    const std::string& name, Enable_state_feedback_c3_Parking_enable_stateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Enable_state_feedback_c3_Parking_enable_stateType>(
    Enable_state_feedback_c3_Parking_enable_stateType_descriptor(), name, value);
}
enum Enable_state_feedback_c3_Steering_enable_stateType : int {
  Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_MANUALCONTROL = 0,
  Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_AUTOCONTROL = 1,
  Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_MANUAL_TAKEOVER = 2
};
bool Enable_state_feedback_c3_Steering_enable_stateType_IsValid(int value);
constexpr Enable_state_feedback_c3_Steering_enable_stateType Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_MIN = Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_MANUALCONTROL;
constexpr Enable_state_feedback_c3_Steering_enable_stateType Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_MAX = Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_MANUAL_TAKEOVER;
constexpr int Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_ARRAYSIZE = Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Enable_state_feedback_c3_Steering_enable_stateType_descriptor();
template<typename T>
inline const std::string& Enable_state_feedback_c3_Steering_enable_stateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Enable_state_feedback_c3_Steering_enable_stateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Enable_state_feedback_c3_Steering_enable_stateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Enable_state_feedback_c3_Steering_enable_stateType_descriptor(), enum_t_value);
}
inline bool Enable_state_feedback_c3_Steering_enable_stateType_Parse(
    const std::string& name, Enable_state_feedback_c3_Steering_enable_stateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Enable_state_feedback_c3_Steering_enable_stateType>(
    Enable_state_feedback_c3_Steering_enable_stateType_descriptor(), name, value);
}
enum Enable_state_feedback_c3_Gear_enable_actualType : int {
  Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_MANUALCONTROL = 0,
  Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_AUTOCONTROL = 1,
  Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_MANUAL_TAKEOVER = 2
};
bool Enable_state_feedback_c3_Gear_enable_actualType_IsValid(int value);
constexpr Enable_state_feedback_c3_Gear_enable_actualType Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_MIN = Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_MANUALCONTROL;
constexpr Enable_state_feedback_c3_Gear_enable_actualType Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_MAX = Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_MANUAL_TAKEOVER;
constexpr int Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_ARRAYSIZE = Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Enable_state_feedback_c3_Gear_enable_actualType_descriptor();
template<typename T>
inline const std::string& Enable_state_feedback_c3_Gear_enable_actualType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Enable_state_feedback_c3_Gear_enable_actualType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Enable_state_feedback_c3_Gear_enable_actualType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Enable_state_feedback_c3_Gear_enable_actualType_descriptor(), enum_t_value);
}
inline bool Enable_state_feedback_c3_Gear_enable_actualType_Parse(
    const std::string& name, Enable_state_feedback_c3_Gear_enable_actualType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Enable_state_feedback_c3_Gear_enable_actualType>(
    Enable_state_feedback_c3_Gear_enable_actualType_descriptor(), name, value);
}
enum Enable_state_feedback_c3_Driven_enable_stateType : int {
  Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_MANUAL = 0,
  Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_AUTO = 1,
  Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_TAKEOVER = 2
};
bool Enable_state_feedback_c3_Driven_enable_stateType_IsValid(int value);
constexpr Enable_state_feedback_c3_Driven_enable_stateType Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_MIN = Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_MANUAL;
constexpr Enable_state_feedback_c3_Driven_enable_stateType Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_MAX = Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_TAKEOVER;
constexpr int Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_ARRAYSIZE = Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Enable_state_feedback_c3_Driven_enable_stateType_descriptor();
template<typename T>
inline const std::string& Enable_state_feedback_c3_Driven_enable_stateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Enable_state_feedback_c3_Driven_enable_stateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Enable_state_feedback_c3_Driven_enable_stateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Enable_state_feedback_c3_Driven_enable_stateType_descriptor(), enum_t_value);
}
inline bool Enable_state_feedback_c3_Driven_enable_stateType_Parse(
    const std::string& name, Enable_state_feedback_c3_Driven_enable_stateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Enable_state_feedback_c3_Driven_enable_stateType>(
    Enable_state_feedback_c3_Driven_enable_stateType_descriptor(), name, value);
}
enum Enable_state_feedback_c3_Brake_enable_stateType : int {
  Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_MANUAL = 0,
  Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_AUTO = 1,
  Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_TAKEOVER = 2
};
bool Enable_state_feedback_c3_Brake_enable_stateType_IsValid(int value);
constexpr Enable_state_feedback_c3_Brake_enable_stateType Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_MIN = Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_MANUAL;
constexpr Enable_state_feedback_c3_Brake_enable_stateType Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_MAX = Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_TAKEOVER;
constexpr int Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_ARRAYSIZE = Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Enable_state_feedback_c3_Brake_enable_stateType_descriptor();
template<typename T>
inline const std::string& Enable_state_feedback_c3_Brake_enable_stateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Enable_state_feedback_c3_Brake_enable_stateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Enable_state_feedback_c3_Brake_enable_stateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Enable_state_feedback_c3_Brake_enable_stateType_descriptor(), enum_t_value);
}
inline bool Enable_state_feedback_c3_Brake_enable_stateType_Parse(
    const std::string& name, Enable_state_feedback_c3_Brake_enable_stateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Enable_state_feedback_c3_Brake_enable_stateType>(
    Enable_state_feedback_c3_Brake_enable_stateType_descriptor(), name, value);
}
enum Vehicle_state_feedback_c1_Parking_actualType : int {
  Vehicle_state_feedback_c1_Parking_actualType_PARKING_ACTUAL_RELEASE = 0,
  Vehicle_state_feedback_c1_Parking_actualType_PARKING_ACTUAL_PARKING_TRIGGER = 1
};
bool Vehicle_state_feedback_c1_Parking_actualType_IsValid(int value);
constexpr Vehicle_state_feedback_c1_Parking_actualType Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_MIN = Vehicle_state_feedback_c1_Parking_actualType_PARKING_ACTUAL_RELEASE;
constexpr Vehicle_state_feedback_c1_Parking_actualType Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_MAX = Vehicle_state_feedback_c1_Parking_actualType_PARKING_ACTUAL_PARKING_TRIGGER;
constexpr int Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_ARRAYSIZE = Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Vehicle_state_feedback_c1_Parking_actualType_descriptor();
template<typename T>
inline const std::string& Vehicle_state_feedback_c1_Parking_actualType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Vehicle_state_feedback_c1_Parking_actualType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Vehicle_state_feedback_c1_Parking_actualType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Vehicle_state_feedback_c1_Parking_actualType_descriptor(), enum_t_value);
}
inline bool Vehicle_state_feedback_c1_Parking_actualType_Parse(
    const std::string& name, Vehicle_state_feedback_c1_Parking_actualType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Vehicle_state_feedback_c1_Parking_actualType>(
    Vehicle_state_feedback_c1_Parking_actualType_descriptor(), name, value);
}
enum Vehicle_state_feedback_c1_Gear_state_actualType : int {
  Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_P = 1,
  Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_N = 2,
  Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_D = 3,
  Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_R = 4,
  Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_INVALID = 5
};
bool Vehicle_state_feedback_c1_Gear_state_actualType_IsValid(int value);
constexpr Vehicle_state_feedback_c1_Gear_state_actualType Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_MIN = Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_P;
constexpr Vehicle_state_feedback_c1_Gear_state_actualType Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_MAX = Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_INVALID;
constexpr int Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_ARRAYSIZE = Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Vehicle_state_feedback_c1_Gear_state_actualType_descriptor();
template<typename T>
inline const std::string& Vehicle_state_feedback_c1_Gear_state_actualType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Vehicle_state_feedback_c1_Gear_state_actualType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Vehicle_state_feedback_c1_Gear_state_actualType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Vehicle_state_feedback_c1_Gear_state_actualType_descriptor(), enum_t_value);
}
inline bool Vehicle_state_feedback_c1_Gear_state_actualType_Parse(
    const std::string& name, Vehicle_state_feedback_c1_Gear_state_actualType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Vehicle_state_feedback_c1_Gear_state_actualType>(
    Vehicle_state_feedback_c1_Gear_state_actualType_descriptor(), name, value);
}
enum Error_state_e1_Brake_error_codeType : int {
  Error_state_e1_Brake_error_codeType_BRAKE_ERROR_CODE_NO_ERROR = 0,
  Error_state_e1_Brake_error_codeType_BRAKE_ERROR_CODE_ERROR = 1
};
bool Error_state_e1_Brake_error_codeType_IsValid(int value);
constexpr Error_state_e1_Brake_error_codeType Error_state_e1_Brake_error_codeType_Brake_error_codeType_MIN = Error_state_e1_Brake_error_codeType_BRAKE_ERROR_CODE_NO_ERROR;
constexpr Error_state_e1_Brake_error_codeType Error_state_e1_Brake_error_codeType_Brake_error_codeType_MAX = Error_state_e1_Brake_error_codeType_BRAKE_ERROR_CODE_ERROR;
constexpr int Error_state_e1_Brake_error_codeType_Brake_error_codeType_ARRAYSIZE = Error_state_e1_Brake_error_codeType_Brake_error_codeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Error_state_e1_Brake_error_codeType_descriptor();
template<typename T>
inline const std::string& Error_state_e1_Brake_error_codeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Error_state_e1_Brake_error_codeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Error_state_e1_Brake_error_codeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Error_state_e1_Brake_error_codeType_descriptor(), enum_t_value);
}
inline bool Error_state_e1_Brake_error_codeType_Parse(
    const std::string& name, Error_state_e1_Brake_error_codeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Error_state_e1_Brake_error_codeType>(
    Error_state_e1_Brake_error_codeType_descriptor(), name, value);
}
enum Error_state_e1_Driven_error_codeType : int {
  Error_state_e1_Driven_error_codeType_DRIVEN_ERROR_CODE_NO_ERROR = 0,
  Error_state_e1_Driven_error_codeType_DRIVEN_ERROR_CODE_ERROR = 1
};
bool Error_state_e1_Driven_error_codeType_IsValid(int value);
constexpr Error_state_e1_Driven_error_codeType Error_state_e1_Driven_error_codeType_Driven_error_codeType_MIN = Error_state_e1_Driven_error_codeType_DRIVEN_ERROR_CODE_NO_ERROR;
constexpr Error_state_e1_Driven_error_codeType Error_state_e1_Driven_error_codeType_Driven_error_codeType_MAX = Error_state_e1_Driven_error_codeType_DRIVEN_ERROR_CODE_ERROR;
constexpr int Error_state_e1_Driven_error_codeType_Driven_error_codeType_ARRAYSIZE = Error_state_e1_Driven_error_codeType_Driven_error_codeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Error_state_e1_Driven_error_codeType_descriptor();
template<typename T>
inline const std::string& Error_state_e1_Driven_error_codeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Error_state_e1_Driven_error_codeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Error_state_e1_Driven_error_codeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Error_state_e1_Driven_error_codeType_descriptor(), enum_t_value);
}
inline bool Error_state_e1_Driven_error_codeType_Parse(
    const std::string& name, Error_state_e1_Driven_error_codeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Error_state_e1_Driven_error_codeType>(
    Error_state_e1_Driven_error_codeType_descriptor(), name, value);
}
enum Error_state_e1_Steering_error_codeType : int {
  Error_state_e1_Steering_error_codeType_STEERING_ERROR_CODE_NO_ERROR = 0,
  Error_state_e1_Steering_error_codeType_STEERING_ERROR_CODE_ERROR = 1
};
bool Error_state_e1_Steering_error_codeType_IsValid(int value);
constexpr Error_state_e1_Steering_error_codeType Error_state_e1_Steering_error_codeType_Steering_error_codeType_MIN = Error_state_e1_Steering_error_codeType_STEERING_ERROR_CODE_NO_ERROR;
constexpr Error_state_e1_Steering_error_codeType Error_state_e1_Steering_error_codeType_Steering_error_codeType_MAX = Error_state_e1_Steering_error_codeType_STEERING_ERROR_CODE_ERROR;
constexpr int Error_state_e1_Steering_error_codeType_Steering_error_codeType_ARRAYSIZE = Error_state_e1_Steering_error_codeType_Steering_error_codeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Error_state_e1_Steering_error_codeType_descriptor();
template<typename T>
inline const std::string& Error_state_e1_Steering_error_codeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Error_state_e1_Steering_error_codeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Error_state_e1_Steering_error_codeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Error_state_e1_Steering_error_codeType_descriptor(), enum_t_value);
}
inline bool Error_state_e1_Steering_error_codeType_Parse(
    const std::string& name, Error_state_e1_Steering_error_codeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Error_state_e1_Steering_error_codeType>(
    Error_state_e1_Steering_error_codeType_descriptor(), name, value);
}
enum Error_state_e1_Parking_error_codeType : int {
  Error_state_e1_Parking_error_codeType_PARKING_ERROR_CODE_NO_ERROR = 0,
  Error_state_e1_Parking_error_codeType_PARKING_ERROR_CODE_ERROR = 1
};
bool Error_state_e1_Parking_error_codeType_IsValid(int value);
constexpr Error_state_e1_Parking_error_codeType Error_state_e1_Parking_error_codeType_Parking_error_codeType_MIN = Error_state_e1_Parking_error_codeType_PARKING_ERROR_CODE_NO_ERROR;
constexpr Error_state_e1_Parking_error_codeType Error_state_e1_Parking_error_codeType_Parking_error_codeType_MAX = Error_state_e1_Parking_error_codeType_PARKING_ERROR_CODE_ERROR;
constexpr int Error_state_e1_Parking_error_codeType_Parking_error_codeType_ARRAYSIZE = Error_state_e1_Parking_error_codeType_Parking_error_codeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Error_state_e1_Parking_error_codeType_descriptor();
template<typename T>
inline const std::string& Error_state_e1_Parking_error_codeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Error_state_e1_Parking_error_codeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Error_state_e1_Parking_error_codeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Error_state_e1_Parking_error_codeType_descriptor(), enum_t_value);
}
inline bool Error_state_e1_Parking_error_codeType_Parse(
    const std::string& name, Error_state_e1_Parking_error_codeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Error_state_e1_Parking_error_codeType>(
    Error_state_e1_Parking_error_codeType_descriptor(), name, value);
}
enum Error_state_e1_Gear_error_msgType : int {
  Error_state_e1_Gear_error_msgType_GEAR_ERROR_MSG_NO_ERROR = 0,
  Error_state_e1_Gear_error_msgType_GEAR_ERROR_MSG_ERROR = 1
};
bool Error_state_e1_Gear_error_msgType_IsValid(int value);
constexpr Error_state_e1_Gear_error_msgType Error_state_e1_Gear_error_msgType_Gear_error_msgType_MIN = Error_state_e1_Gear_error_msgType_GEAR_ERROR_MSG_NO_ERROR;
constexpr Error_state_e1_Gear_error_msgType Error_state_e1_Gear_error_msgType_Gear_error_msgType_MAX = Error_state_e1_Gear_error_msgType_GEAR_ERROR_MSG_ERROR;
constexpr int Error_state_e1_Gear_error_msgType_Gear_error_msgType_ARRAYSIZE = Error_state_e1_Gear_error_msgType_Gear_error_msgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Error_state_e1_Gear_error_msgType_descriptor();
template<typename T>
inline const std::string& Error_state_e1_Gear_error_msgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Error_state_e1_Gear_error_msgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Error_state_e1_Gear_error_msgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Error_state_e1_Gear_error_msgType_descriptor(), enum_t_value);
}
inline bool Error_state_e1_Gear_error_msgType_Parse(
    const std::string& name, Error_state_e1_Gear_error_msgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Error_state_e1_Gear_error_msgType>(
    Error_state_e1_Gear_error_msgType_descriptor(), name, value);
}
// ===================================================================

class Gear_control_a1 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Gear_control_a1) */ {
 public:
  Gear_control_a1();
  virtual ~Gear_control_a1();

  Gear_control_a1(const Gear_control_a1& from);
  Gear_control_a1(Gear_control_a1&& from) noexcept
    : Gear_control_a1() {
    *this = ::std::move(from);
  }

  inline Gear_control_a1& operator=(const Gear_control_a1& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gear_control_a1& operator=(Gear_control_a1&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Gear_control_a1& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Gear_control_a1* internal_default_instance() {
    return reinterpret_cast<const Gear_control_a1*>(
               &_Gear_control_a1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Gear_control_a1& a, Gear_control_a1& b) {
    a.Swap(&b);
  }
  inline void Swap(Gear_control_a1* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Gear_control_a1* New() const final {
    return CreateMaybeMessage<Gear_control_a1>(nullptr);
  }

  Gear_control_a1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Gear_control_a1>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Gear_control_a1& from);
  void MergeFrom(const Gear_control_a1& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gear_control_a1* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Gear_control_a1";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Gear_control_a1_Gear_state_targetType Gear_state_targetType;
  static constexpr Gear_state_targetType GEAR_STATE_TARGET_P =
    Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_P;
  static constexpr Gear_state_targetType GEAR_STATE_TARGET_N =
    Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_N;
  static constexpr Gear_state_targetType GEAR_STATE_TARGET_D =
    Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_D;
  static constexpr Gear_state_targetType GEAR_STATE_TARGET_R =
    Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_R;
  static constexpr Gear_state_targetType GEAR_STATE_TARGET_INVALID =
    Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_INVALID;
  static inline bool Gear_state_targetType_IsValid(int value) {
    return Gear_control_a1_Gear_state_targetType_IsValid(value);
  }
  static constexpr Gear_state_targetType Gear_state_targetType_MIN =
    Gear_control_a1_Gear_state_targetType_Gear_state_targetType_MIN;
  static constexpr Gear_state_targetType Gear_state_targetType_MAX =
    Gear_control_a1_Gear_state_targetType_Gear_state_targetType_MAX;
  static constexpr int Gear_state_targetType_ARRAYSIZE =
    Gear_control_a1_Gear_state_targetType_Gear_state_targetType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Gear_state_targetType_descriptor() {
    return Gear_control_a1_Gear_state_targetType_descriptor();
  }
  template<typename T>
  static inline const std::string& Gear_state_targetType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Gear_state_targetType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Gear_state_targetType_Name.");
    return Gear_control_a1_Gear_state_targetType_Name(enum_t_value);
  }
  static inline bool Gear_state_targetType_Parse(const std::string& name,
      Gear_state_targetType* value) {
    return Gear_control_a1_Gear_state_targetType_Parse(name, value);
  }

  typedef Gear_control_a1_Gear_enable_controlType Gear_enable_controlType;
  static constexpr Gear_enable_controlType GEAR_ENABLE_CONTROL_GEAR_MANUALCONTROL =
    Gear_control_a1_Gear_enable_controlType_GEAR_ENABLE_CONTROL_GEAR_MANUALCONTROL;
  static constexpr Gear_enable_controlType GEAR_ENABLE_CONTROL_GEAR_AUTOCONTROL =
    Gear_control_a1_Gear_enable_controlType_GEAR_ENABLE_CONTROL_GEAR_AUTOCONTROL;
  static inline bool Gear_enable_controlType_IsValid(int value) {
    return Gear_control_a1_Gear_enable_controlType_IsValid(value);
  }
  static constexpr Gear_enable_controlType Gear_enable_controlType_MIN =
    Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_MIN;
  static constexpr Gear_enable_controlType Gear_enable_controlType_MAX =
    Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_MAX;
  static constexpr int Gear_enable_controlType_ARRAYSIZE =
    Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Gear_enable_controlType_descriptor() {
    return Gear_control_a1_Gear_enable_controlType_descriptor();
  }
  template<typename T>
  static inline const std::string& Gear_enable_controlType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Gear_enable_controlType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Gear_enable_controlType_Name.");
    return Gear_control_a1_Gear_enable_controlType_Name(enum_t_value);
  }
  static inline bool Gear_enable_controlType_Parse(const std::string& name,
      Gear_enable_controlType* value) {
    return Gear_control_a1_Gear_enable_controlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGearEnableControlFieldNumber = 2,
    kGearStateTargetFieldNumber = 1,
  };
  // optional .apollo.canbus.Gear_control_a1.Gear_enable_controlType gear_enable_control = 2;
  bool has_gear_enable_control() const;
  private:
  bool _internal_has_gear_enable_control() const;
  public:
  void clear_gear_enable_control();
  ::apollo::canbus::Gear_control_a1_Gear_enable_controlType gear_enable_control() const;
  void set_gear_enable_control(::apollo::canbus::Gear_control_a1_Gear_enable_controlType value);
  private:
  ::apollo::canbus::Gear_control_a1_Gear_enable_controlType _internal_gear_enable_control() const;
  void _internal_set_gear_enable_control(::apollo::canbus::Gear_control_a1_Gear_enable_controlType value);
  public:

  // optional .apollo.canbus.Gear_control_a1.Gear_state_targetType gear_state_target = 1;
  bool has_gear_state_target() const;
  private:
  bool _internal_has_gear_state_target() const;
  public:
  void clear_gear_state_target();
  ::apollo::canbus::Gear_control_a1_Gear_state_targetType gear_state_target() const;
  void set_gear_state_target(::apollo::canbus::Gear_control_a1_Gear_state_targetType value);
  private:
  ::apollo::canbus::Gear_control_a1_Gear_state_targetType _internal_gear_state_target() const;
  void _internal_set_gear_state_target(::apollo::canbus::Gear_control_a1_Gear_state_targetType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Gear_control_a1)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int gear_enable_control_;
  int gear_state_target_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fzhongyun_2eproto;
};
// -------------------------------------------------------------------

class Torque_control_a3 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Torque_control_a3) */ {
 public:
  Torque_control_a3();
  virtual ~Torque_control_a3();

  Torque_control_a3(const Torque_control_a3& from);
  Torque_control_a3(Torque_control_a3&& from) noexcept
    : Torque_control_a3() {
    *this = ::std::move(from);
  }

  inline Torque_control_a3& operator=(const Torque_control_a3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Torque_control_a3& operator=(Torque_control_a3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Torque_control_a3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Torque_control_a3* internal_default_instance() {
    return reinterpret_cast<const Torque_control_a3*>(
               &_Torque_control_a3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Torque_control_a3& a, Torque_control_a3& b) {
    a.Swap(&b);
  }
  inline void Swap(Torque_control_a3* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Torque_control_a3* New() const final {
    return CreateMaybeMessage<Torque_control_a3>(nullptr);
  }

  Torque_control_a3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Torque_control_a3>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Torque_control_a3& from);
  void MergeFrom(const Torque_control_a3& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Torque_control_a3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Torque_control_a3";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Torque_control_a3_Driven_enable_controlType Driven_enable_controlType;
  static constexpr Driven_enable_controlType DRIVEN_ENABLE_CONTROL_DRIVE_MANUAL =
    Torque_control_a3_Driven_enable_controlType_DRIVEN_ENABLE_CONTROL_DRIVE_MANUAL;
  static constexpr Driven_enable_controlType DRIVEN_ENABLE_CONTROL_DRIVE_AUTO =
    Torque_control_a3_Driven_enable_controlType_DRIVEN_ENABLE_CONTROL_DRIVE_AUTO;
  static inline bool Driven_enable_controlType_IsValid(int value) {
    return Torque_control_a3_Driven_enable_controlType_IsValid(value);
  }
  static constexpr Driven_enable_controlType Driven_enable_controlType_MIN =
    Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_MIN;
  static constexpr Driven_enable_controlType Driven_enable_controlType_MAX =
    Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_MAX;
  static constexpr int Driven_enable_controlType_ARRAYSIZE =
    Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Driven_enable_controlType_descriptor() {
    return Torque_control_a3_Driven_enable_controlType_descriptor();
  }
  template<typename T>
  static inline const std::string& Driven_enable_controlType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Driven_enable_controlType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Driven_enable_controlType_Name.");
    return Torque_control_a3_Driven_enable_controlType_Name(enum_t_value);
  }
  static inline bool Driven_enable_controlType_Parse(const std::string& name,
      Driven_enable_controlType* value) {
    return Torque_control_a3_Driven_enable_controlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDrivenTorqueFieldNumber = 1,
    kDrivenEnableControlFieldNumber = 2,
  };
  // optional double driven_torque = 1;
  bool has_driven_torque() const;
  private:
  bool _internal_has_driven_torque() const;
  public:
  void clear_driven_torque();
  double driven_torque() const;
  void set_driven_torque(double value);
  private:
  double _internal_driven_torque() const;
  void _internal_set_driven_torque(double value);
  public:

  // optional .apollo.canbus.Torque_control_a3.Driven_enable_controlType driven_enable_control = 2;
  bool has_driven_enable_control() const;
  private:
  bool _internal_has_driven_enable_control() const;
  public:
  void clear_driven_enable_control();
  ::apollo::canbus::Torque_control_a3_Driven_enable_controlType driven_enable_control() const;
  void set_driven_enable_control(::apollo::canbus::Torque_control_a3_Driven_enable_controlType value);
  private:
  ::apollo::canbus::Torque_control_a3_Driven_enable_controlType _internal_driven_enable_control() const;
  void _internal_set_driven_enable_control(::apollo::canbus::Torque_control_a3_Driven_enable_controlType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Torque_control_a3)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double driven_torque_;
  int driven_enable_control_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fzhongyun_2eproto;
};
// -------------------------------------------------------------------

class Steering_control_a2 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Steering_control_a2) */ {
 public:
  Steering_control_a2();
  virtual ~Steering_control_a2();

  Steering_control_a2(const Steering_control_a2& from);
  Steering_control_a2(Steering_control_a2&& from) noexcept
    : Steering_control_a2() {
    *this = ::std::move(from);
  }

  inline Steering_control_a2& operator=(const Steering_control_a2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Steering_control_a2& operator=(Steering_control_a2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Steering_control_a2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Steering_control_a2* internal_default_instance() {
    return reinterpret_cast<const Steering_control_a2*>(
               &_Steering_control_a2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Steering_control_a2& a, Steering_control_a2& b) {
    a.Swap(&b);
  }
  inline void Swap(Steering_control_a2* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Steering_control_a2* New() const final {
    return CreateMaybeMessage<Steering_control_a2>(nullptr);
  }

  Steering_control_a2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Steering_control_a2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Steering_control_a2& from);
  void MergeFrom(const Steering_control_a2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Steering_control_a2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Steering_control_a2";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Steering_control_a2_Steering_enable_controlType Steering_enable_controlType;
  static constexpr Steering_enable_controlType STEERING_ENABLE_CONTROL_STEERING_MANUALCONTROL =
    Steering_control_a2_Steering_enable_controlType_STEERING_ENABLE_CONTROL_STEERING_MANUALCONTROL;
  static constexpr Steering_enable_controlType STEERING_ENABLE_CONTROL_STEERING_AUTOCONTROL =
    Steering_control_a2_Steering_enable_controlType_STEERING_ENABLE_CONTROL_STEERING_AUTOCONTROL;
  static inline bool Steering_enable_controlType_IsValid(int value) {
    return Steering_control_a2_Steering_enable_controlType_IsValid(value);
  }
  static constexpr Steering_enable_controlType Steering_enable_controlType_MIN =
    Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_MIN;
  static constexpr Steering_enable_controlType Steering_enable_controlType_MAX =
    Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_MAX;
  static constexpr int Steering_enable_controlType_ARRAYSIZE =
    Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Steering_enable_controlType_descriptor() {
    return Steering_control_a2_Steering_enable_controlType_descriptor();
  }
  template<typename T>
  static inline const std::string& Steering_enable_controlType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Steering_enable_controlType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Steering_enable_controlType_Name.");
    return Steering_control_a2_Steering_enable_controlType_Name(enum_t_value);
  }
  static inline bool Steering_enable_controlType_Parse(const std::string& name,
      Steering_enable_controlType* value) {
    return Steering_control_a2_Steering_enable_controlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSteeringTargetFieldNumber = 1,
    kSteeringEnableControlFieldNumber = 2,
  };
  // optional double steering_target = 1;
  bool has_steering_target() const;
  private:
  bool _internal_has_steering_target() const;
  public:
  void clear_steering_target();
  double steering_target() const;
  void set_steering_target(double value);
  private:
  double _internal_steering_target() const;
  void _internal_set_steering_target(double value);
  public:

  // optional .apollo.canbus.Steering_control_a2.Steering_enable_controlType steering_enable_control = 2;
  bool has_steering_enable_control() const;
  private:
  bool _internal_has_steering_enable_control() const;
  public:
  void clear_steering_enable_control();
  ::apollo::canbus::Steering_control_a2_Steering_enable_controlType steering_enable_control() const;
  void set_steering_enable_control(::apollo::canbus::Steering_control_a2_Steering_enable_controlType value);
  private:
  ::apollo::canbus::Steering_control_a2_Steering_enable_controlType _internal_steering_enable_control() const;
  void _internal_set_steering_enable_control(::apollo::canbus::Steering_control_a2_Steering_enable_controlType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Steering_control_a2)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double steering_target_;
  int steering_enable_control_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fzhongyun_2eproto;
};
// -------------------------------------------------------------------

class Parking_control_a5 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Parking_control_a5) */ {
 public:
  Parking_control_a5();
  virtual ~Parking_control_a5();

  Parking_control_a5(const Parking_control_a5& from);
  Parking_control_a5(Parking_control_a5&& from) noexcept
    : Parking_control_a5() {
    *this = ::std::move(from);
  }

  inline Parking_control_a5& operator=(const Parking_control_a5& from) {
    CopyFrom(from);
    return *this;
  }
  inline Parking_control_a5& operator=(Parking_control_a5&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Parking_control_a5& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Parking_control_a5* internal_default_instance() {
    return reinterpret_cast<const Parking_control_a5*>(
               &_Parking_control_a5_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Parking_control_a5& a, Parking_control_a5& b) {
    a.Swap(&b);
  }
  inline void Swap(Parking_control_a5* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Parking_control_a5* New() const final {
    return CreateMaybeMessage<Parking_control_a5>(nullptr);
  }

  Parking_control_a5* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Parking_control_a5>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Parking_control_a5& from);
  void MergeFrom(const Parking_control_a5& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Parking_control_a5* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Parking_control_a5";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Parking_control_a5_Parking_targetType Parking_targetType;
  static constexpr Parking_targetType PARKING_TARGET_RELEASE =
    Parking_control_a5_Parking_targetType_PARKING_TARGET_RELEASE;
  static constexpr Parking_targetType PARKING_TARGET_PARKING_TRIGGER =
    Parking_control_a5_Parking_targetType_PARKING_TARGET_PARKING_TRIGGER;
  static inline bool Parking_targetType_IsValid(int value) {
    return Parking_control_a5_Parking_targetType_IsValid(value);
  }
  static constexpr Parking_targetType Parking_targetType_MIN =
    Parking_control_a5_Parking_targetType_Parking_targetType_MIN;
  static constexpr Parking_targetType Parking_targetType_MAX =
    Parking_control_a5_Parking_targetType_Parking_targetType_MAX;
  static constexpr int Parking_targetType_ARRAYSIZE =
    Parking_control_a5_Parking_targetType_Parking_targetType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Parking_targetType_descriptor() {
    return Parking_control_a5_Parking_targetType_descriptor();
  }
  template<typename T>
  static inline const std::string& Parking_targetType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Parking_targetType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Parking_targetType_Name.");
    return Parking_control_a5_Parking_targetType_Name(enum_t_value);
  }
  static inline bool Parking_targetType_Parse(const std::string& name,
      Parking_targetType* value) {
    return Parking_control_a5_Parking_targetType_Parse(name, value);
  }

  typedef Parking_control_a5_Parking_enable_controlType Parking_enable_controlType;
  static constexpr Parking_enable_controlType PARKING_ENABLE_CONTROL_PARKING_MANUALCONTROL =
    Parking_control_a5_Parking_enable_controlType_PARKING_ENABLE_CONTROL_PARKING_MANUALCONTROL;
  static constexpr Parking_enable_controlType PARKING_ENABLE_CONTROL_PARKING_AUTOCONTROL =
    Parking_control_a5_Parking_enable_controlType_PARKING_ENABLE_CONTROL_PARKING_AUTOCONTROL;
  static inline bool Parking_enable_controlType_IsValid(int value) {
    return Parking_control_a5_Parking_enable_controlType_IsValid(value);
  }
  static constexpr Parking_enable_controlType Parking_enable_controlType_MIN =
    Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_MIN;
  static constexpr Parking_enable_controlType Parking_enable_controlType_MAX =
    Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_MAX;
  static constexpr int Parking_enable_controlType_ARRAYSIZE =
    Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Parking_enable_controlType_descriptor() {
    return Parking_control_a5_Parking_enable_controlType_descriptor();
  }
  template<typename T>
  static inline const std::string& Parking_enable_controlType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Parking_enable_controlType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Parking_enable_controlType_Name.");
    return Parking_control_a5_Parking_enable_controlType_Name(enum_t_value);
  }
  static inline bool Parking_enable_controlType_Parse(const std::string& name,
      Parking_enable_controlType* value) {
    return Parking_control_a5_Parking_enable_controlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParkingTargetFieldNumber = 1,
    kParkingEnableControlFieldNumber = 2,
  };
  // optional .apollo.canbus.Parking_control_a5.Parking_targetType parking_target = 1;
  bool has_parking_target() const;
  private:
  bool _internal_has_parking_target() const;
  public:
  void clear_parking_target();
  ::apollo::canbus::Parking_control_a5_Parking_targetType parking_target() const;
  void set_parking_target(::apollo::canbus::Parking_control_a5_Parking_targetType value);
  private:
  ::apollo::canbus::Parking_control_a5_Parking_targetType _internal_parking_target() const;
  void _internal_set_parking_target(::apollo::canbus::Parking_control_a5_Parking_targetType value);
  public:

  // optional .apollo.canbus.Parking_control_a5.Parking_enable_controlType parking_enable_control = 2;
  bool has_parking_enable_control() const;
  private:
  bool _internal_has_parking_enable_control() const;
  public:
  void clear_parking_enable_control();
  ::apollo::canbus::Parking_control_a5_Parking_enable_controlType parking_enable_control() const;
  void set_parking_enable_control(::apollo::canbus::Parking_control_a5_Parking_enable_controlType value);
  private:
  ::apollo::canbus::Parking_control_a5_Parking_enable_controlType _internal_parking_enable_control() const;
  void _internal_set_parking_enable_control(::apollo::canbus::Parking_control_a5_Parking_enable_controlType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Parking_control_a5)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int parking_target_;
  int parking_enable_control_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fzhongyun_2eproto;
};
// -------------------------------------------------------------------

class Brake_control_a4 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Brake_control_a4) */ {
 public:
  Brake_control_a4();
  virtual ~Brake_control_a4();

  Brake_control_a4(const Brake_control_a4& from);
  Brake_control_a4(Brake_control_a4&& from) noexcept
    : Brake_control_a4() {
    *this = ::std::move(from);
  }

  inline Brake_control_a4& operator=(const Brake_control_a4& from) {
    CopyFrom(from);
    return *this;
  }
  inline Brake_control_a4& operator=(Brake_control_a4&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Brake_control_a4& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Brake_control_a4* internal_default_instance() {
    return reinterpret_cast<const Brake_control_a4*>(
               &_Brake_control_a4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Brake_control_a4& a, Brake_control_a4& b) {
    a.Swap(&b);
  }
  inline void Swap(Brake_control_a4* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Brake_control_a4* New() const final {
    return CreateMaybeMessage<Brake_control_a4>(nullptr);
  }

  Brake_control_a4* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Brake_control_a4>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Brake_control_a4& from);
  void MergeFrom(const Brake_control_a4& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Brake_control_a4* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Brake_control_a4";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Brake_control_a4_Brake_enable_controlType Brake_enable_controlType;
  static constexpr Brake_enable_controlType BRAKE_ENABLE_CONTROL_BRAKE_MANUAL =
    Brake_control_a4_Brake_enable_controlType_BRAKE_ENABLE_CONTROL_BRAKE_MANUAL;
  static constexpr Brake_enable_controlType BRAKE_ENABLE_CONTROL_BRAKE_AUTO =
    Brake_control_a4_Brake_enable_controlType_BRAKE_ENABLE_CONTROL_BRAKE_AUTO;
  static inline bool Brake_enable_controlType_IsValid(int value) {
    return Brake_control_a4_Brake_enable_controlType_IsValid(value);
  }
  static constexpr Brake_enable_controlType Brake_enable_controlType_MIN =
    Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_MIN;
  static constexpr Brake_enable_controlType Brake_enable_controlType_MAX =
    Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_MAX;
  static constexpr int Brake_enable_controlType_ARRAYSIZE =
    Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Brake_enable_controlType_descriptor() {
    return Brake_control_a4_Brake_enable_controlType_descriptor();
  }
  template<typename T>
  static inline const std::string& Brake_enable_controlType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Brake_enable_controlType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Brake_enable_controlType_Name.");
    return Brake_control_a4_Brake_enable_controlType_Name(enum_t_value);
  }
  static inline bool Brake_enable_controlType_Parse(const std::string& name,
      Brake_enable_controlType* value) {
    return Brake_control_a4_Brake_enable_controlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBrakeTorqueFieldNumber = 1,
    kBrakeEnableControlFieldNumber = 2,
  };
  // optional double brake_torque = 1;
  bool has_brake_torque() const;
  private:
  bool _internal_has_brake_torque() const;
  public:
  void clear_brake_torque();
  double brake_torque() const;
  void set_brake_torque(double value);
  private:
  double _internal_brake_torque() const;
  void _internal_set_brake_torque(double value);
  public:

  // optional .apollo.canbus.Brake_control_a4.Brake_enable_controlType brake_enable_control = 2;
  bool has_brake_enable_control() const;
  private:
  bool _internal_has_brake_enable_control() const;
  public:
  void clear_brake_enable_control();
  ::apollo::canbus::Brake_control_a4_Brake_enable_controlType brake_enable_control() const;
  void set_brake_enable_control(::apollo::canbus::Brake_control_a4_Brake_enable_controlType value);
  private:
  ::apollo::canbus::Brake_control_a4_Brake_enable_controlType _internal_brake_enable_control() const;
  void _internal_set_brake_enable_control(::apollo::canbus::Brake_control_a4_Brake_enable_controlType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Brake_control_a4)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double brake_torque_;
  int brake_enable_control_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fzhongyun_2eproto;
};
// -------------------------------------------------------------------

class Enable_state_feedback_c3 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Enable_state_feedback_c3) */ {
 public:
  Enable_state_feedback_c3();
  virtual ~Enable_state_feedback_c3();

  Enable_state_feedback_c3(const Enable_state_feedback_c3& from);
  Enable_state_feedback_c3(Enable_state_feedback_c3&& from) noexcept
    : Enable_state_feedback_c3() {
    *this = ::std::move(from);
  }

  inline Enable_state_feedback_c3& operator=(const Enable_state_feedback_c3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Enable_state_feedback_c3& operator=(Enable_state_feedback_c3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Enable_state_feedback_c3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Enable_state_feedback_c3* internal_default_instance() {
    return reinterpret_cast<const Enable_state_feedback_c3*>(
               &_Enable_state_feedback_c3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Enable_state_feedback_c3& a, Enable_state_feedback_c3& b) {
    a.Swap(&b);
  }
  inline void Swap(Enable_state_feedback_c3* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Enable_state_feedback_c3* New() const final {
    return CreateMaybeMessage<Enable_state_feedback_c3>(nullptr);
  }

  Enable_state_feedback_c3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Enable_state_feedback_c3>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Enable_state_feedback_c3& from);
  void MergeFrom(const Enable_state_feedback_c3& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Enable_state_feedback_c3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Enable_state_feedback_c3";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Enable_state_feedback_c3_Parking_enable_stateType Parking_enable_stateType;
  static constexpr Parking_enable_stateType PARKING_ENABLE_STATE_PARKING_MANUALCONTROL =
    Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_MANUALCONTROL;
  static constexpr Parking_enable_stateType PARKING_ENABLE_STATE_PARKING_AUTOCONTROL =
    Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_AUTOCONTROL;
  static constexpr Parking_enable_stateType PARKING_ENABLE_STATE_PARKING_TAKEOVER =
    Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_TAKEOVER;
  static inline bool Parking_enable_stateType_IsValid(int value) {
    return Enable_state_feedback_c3_Parking_enable_stateType_IsValid(value);
  }
  static constexpr Parking_enable_stateType Parking_enable_stateType_MIN =
    Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_MIN;
  static constexpr Parking_enable_stateType Parking_enable_stateType_MAX =
    Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_MAX;
  static constexpr int Parking_enable_stateType_ARRAYSIZE =
    Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Parking_enable_stateType_descriptor() {
    return Enable_state_feedback_c3_Parking_enable_stateType_descriptor();
  }
  template<typename T>
  static inline const std::string& Parking_enable_stateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Parking_enable_stateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Parking_enable_stateType_Name.");
    return Enable_state_feedback_c3_Parking_enable_stateType_Name(enum_t_value);
  }
  static inline bool Parking_enable_stateType_Parse(const std::string& name,
      Parking_enable_stateType* value) {
    return Enable_state_feedback_c3_Parking_enable_stateType_Parse(name, value);
  }

  typedef Enable_state_feedback_c3_Steering_enable_stateType Steering_enable_stateType;
  static constexpr Steering_enable_stateType STEERING_ENABLE_STATE_STEERING_MANUALCONTROL =
    Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_MANUALCONTROL;
  static constexpr Steering_enable_stateType STEERING_ENABLE_STATE_STEERING_AUTOCONTROL =
    Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_AUTOCONTROL;
  static constexpr Steering_enable_stateType STEERING_ENABLE_STATE_STEERING_MANUAL_TAKEOVER =
    Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_MANUAL_TAKEOVER;
  static inline bool Steering_enable_stateType_IsValid(int value) {
    return Enable_state_feedback_c3_Steering_enable_stateType_IsValid(value);
  }
  static constexpr Steering_enable_stateType Steering_enable_stateType_MIN =
    Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_MIN;
  static constexpr Steering_enable_stateType Steering_enable_stateType_MAX =
    Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_MAX;
  static constexpr int Steering_enable_stateType_ARRAYSIZE =
    Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Steering_enable_stateType_descriptor() {
    return Enable_state_feedback_c3_Steering_enable_stateType_descriptor();
  }
  template<typename T>
  static inline const std::string& Steering_enable_stateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Steering_enable_stateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Steering_enable_stateType_Name.");
    return Enable_state_feedback_c3_Steering_enable_stateType_Name(enum_t_value);
  }
  static inline bool Steering_enable_stateType_Parse(const std::string& name,
      Steering_enable_stateType* value) {
    return Enable_state_feedback_c3_Steering_enable_stateType_Parse(name, value);
  }

  typedef Enable_state_feedback_c3_Gear_enable_actualType Gear_enable_actualType;
  static constexpr Gear_enable_actualType GEAR_ENABLE_ACTUAL_GEAR_MANUALCONTROL =
    Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_MANUALCONTROL;
  static constexpr Gear_enable_actualType GEAR_ENABLE_ACTUAL_GEAR_AUTOCONTROL =
    Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_AUTOCONTROL;
  static constexpr Gear_enable_actualType GEAR_ENABLE_ACTUAL_GEAR_MANUAL_TAKEOVER =
    Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_MANUAL_TAKEOVER;
  static inline bool Gear_enable_actualType_IsValid(int value) {
    return Enable_state_feedback_c3_Gear_enable_actualType_IsValid(value);
  }
  static constexpr Gear_enable_actualType Gear_enable_actualType_MIN =
    Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_MIN;
  static constexpr Gear_enable_actualType Gear_enable_actualType_MAX =
    Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_MAX;
  static constexpr int Gear_enable_actualType_ARRAYSIZE =
    Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Gear_enable_actualType_descriptor() {
    return Enable_state_feedback_c3_Gear_enable_actualType_descriptor();
  }
  template<typename T>
  static inline const std::string& Gear_enable_actualType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Gear_enable_actualType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Gear_enable_actualType_Name.");
    return Enable_state_feedback_c3_Gear_enable_actualType_Name(enum_t_value);
  }
  static inline bool Gear_enable_actualType_Parse(const std::string& name,
      Gear_enable_actualType* value) {
    return Enable_state_feedback_c3_Gear_enable_actualType_Parse(name, value);
  }

  typedef Enable_state_feedback_c3_Driven_enable_stateType Driven_enable_stateType;
  static constexpr Driven_enable_stateType DRIVEN_ENABLE_STATE_DRIVE_MANUAL =
    Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_MANUAL;
  static constexpr Driven_enable_stateType DRIVEN_ENABLE_STATE_DRIVE_AUTO =
    Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_AUTO;
  static constexpr Driven_enable_stateType DRIVEN_ENABLE_STATE_DRIVE_TAKEOVER =
    Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_TAKEOVER;
  static inline bool Driven_enable_stateType_IsValid(int value) {
    return Enable_state_feedback_c3_Driven_enable_stateType_IsValid(value);
  }
  static constexpr Driven_enable_stateType Driven_enable_stateType_MIN =
    Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_MIN;
  static constexpr Driven_enable_stateType Driven_enable_stateType_MAX =
    Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_MAX;
  static constexpr int Driven_enable_stateType_ARRAYSIZE =
    Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Driven_enable_stateType_descriptor() {
    return Enable_state_feedback_c3_Driven_enable_stateType_descriptor();
  }
  template<typename T>
  static inline const std::string& Driven_enable_stateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Driven_enable_stateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Driven_enable_stateType_Name.");
    return Enable_state_feedback_c3_Driven_enable_stateType_Name(enum_t_value);
  }
  static inline bool Driven_enable_stateType_Parse(const std::string& name,
      Driven_enable_stateType* value) {
    return Enable_state_feedback_c3_Driven_enable_stateType_Parse(name, value);
  }

  typedef Enable_state_feedback_c3_Brake_enable_stateType Brake_enable_stateType;
  static constexpr Brake_enable_stateType BRAKE_ENABLE_STATE_BRAKE_MANUAL =
    Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_MANUAL;
  static constexpr Brake_enable_stateType BRAKE_ENABLE_STATE_BRAKE_AUTO =
    Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_AUTO;
  static constexpr Brake_enable_stateType BRAKE_ENABLE_STATE_BRAKE_TAKEOVER =
    Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_TAKEOVER;
  static inline bool Brake_enable_stateType_IsValid(int value) {
    return Enable_state_feedback_c3_Brake_enable_stateType_IsValid(value);
  }
  static constexpr Brake_enable_stateType Brake_enable_stateType_MIN =
    Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_MIN;
  static constexpr Brake_enable_stateType Brake_enable_stateType_MAX =
    Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_MAX;
  static constexpr int Brake_enable_stateType_ARRAYSIZE =
    Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Brake_enable_stateType_descriptor() {
    return Enable_state_feedback_c3_Brake_enable_stateType_descriptor();
  }
  template<typename T>
  static inline const std::string& Brake_enable_stateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Brake_enable_stateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Brake_enable_stateType_Name.");
    return Enable_state_feedback_c3_Brake_enable_stateType_Name(enum_t_value);
  }
  static inline bool Brake_enable_stateType_Parse(const std::string& name,
      Brake_enable_stateType* value) {
    return Enable_state_feedback_c3_Brake_enable_stateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParkingEnableStateFieldNumber = 1,
    kSteeringEnableStateFieldNumber = 2,
    kGearEnableActualFieldNumber = 3,
    kDrivenEnableStateFieldNumber = 4,
    kBrakeEnableStateFieldNumber = 5,
  };
  // optional .apollo.canbus.Enable_state_feedback_c3.Parking_enable_stateType parking_enable_state = 1;
  bool has_parking_enable_state() const;
  private:
  bool _internal_has_parking_enable_state() const;
  public:
  void clear_parking_enable_state();
  ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType parking_enable_state() const;
  void set_parking_enable_state(::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType value);
  private:
  ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType _internal_parking_enable_state() const;
  void _internal_set_parking_enable_state(::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType value);
  public:

  // optional .apollo.canbus.Enable_state_feedback_c3.Steering_enable_stateType steering_enable_state = 2;
  bool has_steering_enable_state() const;
  private:
  bool _internal_has_steering_enable_state() const;
  public:
  void clear_steering_enable_state();
  ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType steering_enable_state() const;
  void set_steering_enable_state(::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType value);
  private:
  ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType _internal_steering_enable_state() const;
  void _internal_set_steering_enable_state(::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType value);
  public:

  // optional .apollo.canbus.Enable_state_feedback_c3.Gear_enable_actualType gear_enable_actual = 3;
  bool has_gear_enable_actual() const;
  private:
  bool _internal_has_gear_enable_actual() const;
  public:
  void clear_gear_enable_actual();
  ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType gear_enable_actual() const;
  void set_gear_enable_actual(::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType value);
  private:
  ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType _internal_gear_enable_actual() const;
  void _internal_set_gear_enable_actual(::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType value);
  public:

  // optional .apollo.canbus.Enable_state_feedback_c3.Driven_enable_stateType driven_enable_state = 4;
  bool has_driven_enable_state() const;
  private:
  bool _internal_has_driven_enable_state() const;
  public:
  void clear_driven_enable_state();
  ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType driven_enable_state() const;
  void set_driven_enable_state(::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType value);
  private:
  ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType _internal_driven_enable_state() const;
  void _internal_set_driven_enable_state(::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType value);
  public:

  // optional .apollo.canbus.Enable_state_feedback_c3.Brake_enable_stateType brake_enable_state = 5;
  bool has_brake_enable_state() const;
  private:
  bool _internal_has_brake_enable_state() const;
  public:
  void clear_brake_enable_state();
  ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType brake_enable_state() const;
  void set_brake_enable_state(::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType value);
  private:
  ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType _internal_brake_enable_state() const;
  void _internal_set_brake_enable_state(::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Enable_state_feedback_c3)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int parking_enable_state_;
  int steering_enable_state_;
  int gear_enable_actual_;
  int driven_enable_state_;
  int brake_enable_state_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fzhongyun_2eproto;
};
// -------------------------------------------------------------------

class Vehicle_state_feedback_c1 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Vehicle_state_feedback_c1) */ {
 public:
  Vehicle_state_feedback_c1();
  virtual ~Vehicle_state_feedback_c1();

  Vehicle_state_feedback_c1(const Vehicle_state_feedback_c1& from);
  Vehicle_state_feedback_c1(Vehicle_state_feedback_c1&& from) noexcept
    : Vehicle_state_feedback_c1() {
    *this = ::std::move(from);
  }

  inline Vehicle_state_feedback_c1& operator=(const Vehicle_state_feedback_c1& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle_state_feedback_c1& operator=(Vehicle_state_feedback_c1&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vehicle_state_feedback_c1& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle_state_feedback_c1* internal_default_instance() {
    return reinterpret_cast<const Vehicle_state_feedback_c1*>(
               &_Vehicle_state_feedback_c1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Vehicle_state_feedback_c1& a, Vehicle_state_feedback_c1& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle_state_feedback_c1* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vehicle_state_feedback_c1* New() const final {
    return CreateMaybeMessage<Vehicle_state_feedback_c1>(nullptr);
  }

  Vehicle_state_feedback_c1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle_state_feedback_c1>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vehicle_state_feedback_c1& from);
  void MergeFrom(const Vehicle_state_feedback_c1& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_state_feedback_c1* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Vehicle_state_feedback_c1";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Vehicle_state_feedback_c1_Parking_actualType Parking_actualType;
  static constexpr Parking_actualType PARKING_ACTUAL_RELEASE =
    Vehicle_state_feedback_c1_Parking_actualType_PARKING_ACTUAL_RELEASE;
  static constexpr Parking_actualType PARKING_ACTUAL_PARKING_TRIGGER =
    Vehicle_state_feedback_c1_Parking_actualType_PARKING_ACTUAL_PARKING_TRIGGER;
  static inline bool Parking_actualType_IsValid(int value) {
    return Vehicle_state_feedback_c1_Parking_actualType_IsValid(value);
  }
  static constexpr Parking_actualType Parking_actualType_MIN =
    Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_MIN;
  static constexpr Parking_actualType Parking_actualType_MAX =
    Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_MAX;
  static constexpr int Parking_actualType_ARRAYSIZE =
    Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Parking_actualType_descriptor() {
    return Vehicle_state_feedback_c1_Parking_actualType_descriptor();
  }
  template<typename T>
  static inline const std::string& Parking_actualType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Parking_actualType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Parking_actualType_Name.");
    return Vehicle_state_feedback_c1_Parking_actualType_Name(enum_t_value);
  }
  static inline bool Parking_actualType_Parse(const std::string& name,
      Parking_actualType* value) {
    return Vehicle_state_feedback_c1_Parking_actualType_Parse(name, value);
  }

  typedef Vehicle_state_feedback_c1_Gear_state_actualType Gear_state_actualType;
  static constexpr Gear_state_actualType GEAR_STATE_ACTUAL_P =
    Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_P;
  static constexpr Gear_state_actualType GEAR_STATE_ACTUAL_N =
    Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_N;
  static constexpr Gear_state_actualType GEAR_STATE_ACTUAL_D =
    Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_D;
  static constexpr Gear_state_actualType GEAR_STATE_ACTUAL_R =
    Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_R;
  static constexpr Gear_state_actualType GEAR_STATE_ACTUAL_INVALID =
    Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_INVALID;
  static inline bool Gear_state_actualType_IsValid(int value) {
    return Vehicle_state_feedback_c1_Gear_state_actualType_IsValid(value);
  }
  static constexpr Gear_state_actualType Gear_state_actualType_MIN =
    Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_MIN;
  static constexpr Gear_state_actualType Gear_state_actualType_MAX =
    Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_MAX;
  static constexpr int Gear_state_actualType_ARRAYSIZE =
    Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Gear_state_actualType_descriptor() {
    return Vehicle_state_feedback_c1_Gear_state_actualType_descriptor();
  }
  template<typename T>
  static inline const std::string& Gear_state_actualType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Gear_state_actualType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Gear_state_actualType_Name.");
    return Vehicle_state_feedback_c1_Gear_state_actualType_Name(enum_t_value);
  }
  static inline bool Gear_state_actualType_Parse(const std::string& name,
      Gear_state_actualType* value) {
    return Vehicle_state_feedback_c1_Gear_state_actualType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBrakeTorqueFeedbackFieldNumber = 2,
    kSteeringActualFieldNumber = 4,
    kSpeedFieldNumber = 5,
    kParkingActualFieldNumber = 1,
    kGearStateActualFieldNumber = 3,
  };
  // optional double brake_torque_feedback = 2;
  bool has_brake_torque_feedback() const;
  private:
  bool _internal_has_brake_torque_feedback() const;
  public:
  void clear_brake_torque_feedback();
  double brake_torque_feedback() const;
  void set_brake_torque_feedback(double value);
  private:
  double _internal_brake_torque_feedback() const;
  void _internal_set_brake_torque_feedback(double value);
  public:

  // optional double steering_actual = 4;
  bool has_steering_actual() const;
  private:
  bool _internal_has_steering_actual() const;
  public:
  void clear_steering_actual();
  double steering_actual() const;
  void set_steering_actual(double value);
  private:
  double _internal_steering_actual() const;
  void _internal_set_steering_actual(double value);
  public:

  // optional double speed = 5;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // optional .apollo.canbus.Vehicle_state_feedback_c1.Parking_actualType parking_actual = 1;
  bool has_parking_actual() const;
  private:
  bool _internal_has_parking_actual() const;
  public:
  void clear_parking_actual();
  ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType parking_actual() const;
  void set_parking_actual(::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType value);
  private:
  ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType _internal_parking_actual() const;
  void _internal_set_parking_actual(::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType value);
  public:

  // optional .apollo.canbus.Vehicle_state_feedback_c1.Gear_state_actualType gear_state_actual = 3;
  bool has_gear_state_actual() const;
  private:
  bool _internal_has_gear_state_actual() const;
  public:
  void clear_gear_state_actual();
  ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType gear_state_actual() const;
  void set_gear_state_actual(::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType value);
  private:
  ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType _internal_gear_state_actual() const;
  void _internal_set_gear_state_actual(::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Vehicle_state_feedback_c1)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double brake_torque_feedback_;
  double steering_actual_;
  double speed_;
  int parking_actual_;
  int gear_state_actual_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fzhongyun_2eproto;
};
// -------------------------------------------------------------------

class Error_state_e1 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Error_state_e1) */ {
 public:
  Error_state_e1();
  virtual ~Error_state_e1();

  Error_state_e1(const Error_state_e1& from);
  Error_state_e1(Error_state_e1&& from) noexcept
    : Error_state_e1() {
    *this = ::std::move(from);
  }

  inline Error_state_e1& operator=(const Error_state_e1& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error_state_e1& operator=(Error_state_e1&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Error_state_e1& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error_state_e1* internal_default_instance() {
    return reinterpret_cast<const Error_state_e1*>(
               &_Error_state_e1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Error_state_e1& a, Error_state_e1& b) {
    a.Swap(&b);
  }
  inline void Swap(Error_state_e1* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Error_state_e1* New() const final {
    return CreateMaybeMessage<Error_state_e1>(nullptr);
  }

  Error_state_e1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Error_state_e1>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Error_state_e1& from);
  void MergeFrom(const Error_state_e1& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error_state_e1* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Error_state_e1";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Error_state_e1_Brake_error_codeType Brake_error_codeType;
  static constexpr Brake_error_codeType BRAKE_ERROR_CODE_NO_ERROR =
    Error_state_e1_Brake_error_codeType_BRAKE_ERROR_CODE_NO_ERROR;
  static constexpr Brake_error_codeType BRAKE_ERROR_CODE_ERROR =
    Error_state_e1_Brake_error_codeType_BRAKE_ERROR_CODE_ERROR;
  static inline bool Brake_error_codeType_IsValid(int value) {
    return Error_state_e1_Brake_error_codeType_IsValid(value);
  }
  static constexpr Brake_error_codeType Brake_error_codeType_MIN =
    Error_state_e1_Brake_error_codeType_Brake_error_codeType_MIN;
  static constexpr Brake_error_codeType Brake_error_codeType_MAX =
    Error_state_e1_Brake_error_codeType_Brake_error_codeType_MAX;
  static constexpr int Brake_error_codeType_ARRAYSIZE =
    Error_state_e1_Brake_error_codeType_Brake_error_codeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Brake_error_codeType_descriptor() {
    return Error_state_e1_Brake_error_codeType_descriptor();
  }
  template<typename T>
  static inline const std::string& Brake_error_codeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Brake_error_codeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Brake_error_codeType_Name.");
    return Error_state_e1_Brake_error_codeType_Name(enum_t_value);
  }
  static inline bool Brake_error_codeType_Parse(const std::string& name,
      Brake_error_codeType* value) {
    return Error_state_e1_Brake_error_codeType_Parse(name, value);
  }

  typedef Error_state_e1_Driven_error_codeType Driven_error_codeType;
  static constexpr Driven_error_codeType DRIVEN_ERROR_CODE_NO_ERROR =
    Error_state_e1_Driven_error_codeType_DRIVEN_ERROR_CODE_NO_ERROR;
  static constexpr Driven_error_codeType DRIVEN_ERROR_CODE_ERROR =
    Error_state_e1_Driven_error_codeType_DRIVEN_ERROR_CODE_ERROR;
  static inline bool Driven_error_codeType_IsValid(int value) {
    return Error_state_e1_Driven_error_codeType_IsValid(value);
  }
  static constexpr Driven_error_codeType Driven_error_codeType_MIN =
    Error_state_e1_Driven_error_codeType_Driven_error_codeType_MIN;
  static constexpr Driven_error_codeType Driven_error_codeType_MAX =
    Error_state_e1_Driven_error_codeType_Driven_error_codeType_MAX;
  static constexpr int Driven_error_codeType_ARRAYSIZE =
    Error_state_e1_Driven_error_codeType_Driven_error_codeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Driven_error_codeType_descriptor() {
    return Error_state_e1_Driven_error_codeType_descriptor();
  }
  template<typename T>
  static inline const std::string& Driven_error_codeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Driven_error_codeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Driven_error_codeType_Name.");
    return Error_state_e1_Driven_error_codeType_Name(enum_t_value);
  }
  static inline bool Driven_error_codeType_Parse(const std::string& name,
      Driven_error_codeType* value) {
    return Error_state_e1_Driven_error_codeType_Parse(name, value);
  }

  typedef Error_state_e1_Steering_error_codeType Steering_error_codeType;
  static constexpr Steering_error_codeType STEERING_ERROR_CODE_NO_ERROR =
    Error_state_e1_Steering_error_codeType_STEERING_ERROR_CODE_NO_ERROR;
  static constexpr Steering_error_codeType STEERING_ERROR_CODE_ERROR =
    Error_state_e1_Steering_error_codeType_STEERING_ERROR_CODE_ERROR;
  static inline bool Steering_error_codeType_IsValid(int value) {
    return Error_state_e1_Steering_error_codeType_IsValid(value);
  }
  static constexpr Steering_error_codeType Steering_error_codeType_MIN =
    Error_state_e1_Steering_error_codeType_Steering_error_codeType_MIN;
  static constexpr Steering_error_codeType Steering_error_codeType_MAX =
    Error_state_e1_Steering_error_codeType_Steering_error_codeType_MAX;
  static constexpr int Steering_error_codeType_ARRAYSIZE =
    Error_state_e1_Steering_error_codeType_Steering_error_codeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Steering_error_codeType_descriptor() {
    return Error_state_e1_Steering_error_codeType_descriptor();
  }
  template<typename T>
  static inline const std::string& Steering_error_codeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Steering_error_codeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Steering_error_codeType_Name.");
    return Error_state_e1_Steering_error_codeType_Name(enum_t_value);
  }
  static inline bool Steering_error_codeType_Parse(const std::string& name,
      Steering_error_codeType* value) {
    return Error_state_e1_Steering_error_codeType_Parse(name, value);
  }

  typedef Error_state_e1_Parking_error_codeType Parking_error_codeType;
  static constexpr Parking_error_codeType PARKING_ERROR_CODE_NO_ERROR =
    Error_state_e1_Parking_error_codeType_PARKING_ERROR_CODE_NO_ERROR;
  static constexpr Parking_error_codeType PARKING_ERROR_CODE_ERROR =
    Error_state_e1_Parking_error_codeType_PARKING_ERROR_CODE_ERROR;
  static inline bool Parking_error_codeType_IsValid(int value) {
    return Error_state_e1_Parking_error_codeType_IsValid(value);
  }
  static constexpr Parking_error_codeType Parking_error_codeType_MIN =
    Error_state_e1_Parking_error_codeType_Parking_error_codeType_MIN;
  static constexpr Parking_error_codeType Parking_error_codeType_MAX =
    Error_state_e1_Parking_error_codeType_Parking_error_codeType_MAX;
  static constexpr int Parking_error_codeType_ARRAYSIZE =
    Error_state_e1_Parking_error_codeType_Parking_error_codeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Parking_error_codeType_descriptor() {
    return Error_state_e1_Parking_error_codeType_descriptor();
  }
  template<typename T>
  static inline const std::string& Parking_error_codeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Parking_error_codeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Parking_error_codeType_Name.");
    return Error_state_e1_Parking_error_codeType_Name(enum_t_value);
  }
  static inline bool Parking_error_codeType_Parse(const std::string& name,
      Parking_error_codeType* value) {
    return Error_state_e1_Parking_error_codeType_Parse(name, value);
  }

  typedef Error_state_e1_Gear_error_msgType Gear_error_msgType;
  static constexpr Gear_error_msgType GEAR_ERROR_MSG_NO_ERROR =
    Error_state_e1_Gear_error_msgType_GEAR_ERROR_MSG_NO_ERROR;
  static constexpr Gear_error_msgType GEAR_ERROR_MSG_ERROR =
    Error_state_e1_Gear_error_msgType_GEAR_ERROR_MSG_ERROR;
  static inline bool Gear_error_msgType_IsValid(int value) {
    return Error_state_e1_Gear_error_msgType_IsValid(value);
  }
  static constexpr Gear_error_msgType Gear_error_msgType_MIN =
    Error_state_e1_Gear_error_msgType_Gear_error_msgType_MIN;
  static constexpr Gear_error_msgType Gear_error_msgType_MAX =
    Error_state_e1_Gear_error_msgType_Gear_error_msgType_MAX;
  static constexpr int Gear_error_msgType_ARRAYSIZE =
    Error_state_e1_Gear_error_msgType_Gear_error_msgType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Gear_error_msgType_descriptor() {
    return Error_state_e1_Gear_error_msgType_descriptor();
  }
  template<typename T>
  static inline const std::string& Gear_error_msgType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Gear_error_msgType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Gear_error_msgType_Name.");
    return Error_state_e1_Gear_error_msgType_Name(enum_t_value);
  }
  static inline bool Gear_error_msgType_Parse(const std::string& name,
      Gear_error_msgType* value) {
    return Error_state_e1_Gear_error_msgType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBrakeErrorCodeFieldNumber = 1,
    kDrivenErrorCodeFieldNumber = 2,
    kSteeringErrorCodeFieldNumber = 3,
    kParkingErrorCodeFieldNumber = 4,
    kGearErrorMsgFieldNumber = 5,
  };
  // optional .apollo.canbus.Error_state_e1.Brake_error_codeType brake_error_code = 1;
  bool has_brake_error_code() const;
  private:
  bool _internal_has_brake_error_code() const;
  public:
  void clear_brake_error_code();
  ::apollo::canbus::Error_state_e1_Brake_error_codeType brake_error_code() const;
  void set_brake_error_code(::apollo::canbus::Error_state_e1_Brake_error_codeType value);
  private:
  ::apollo::canbus::Error_state_e1_Brake_error_codeType _internal_brake_error_code() const;
  void _internal_set_brake_error_code(::apollo::canbus::Error_state_e1_Brake_error_codeType value);
  public:

  // optional .apollo.canbus.Error_state_e1.Driven_error_codeType driven_error_code = 2;
  bool has_driven_error_code() const;
  private:
  bool _internal_has_driven_error_code() const;
  public:
  void clear_driven_error_code();
  ::apollo::canbus::Error_state_e1_Driven_error_codeType driven_error_code() const;
  void set_driven_error_code(::apollo::canbus::Error_state_e1_Driven_error_codeType value);
  private:
  ::apollo::canbus::Error_state_e1_Driven_error_codeType _internal_driven_error_code() const;
  void _internal_set_driven_error_code(::apollo::canbus::Error_state_e1_Driven_error_codeType value);
  public:

  // optional .apollo.canbus.Error_state_e1.Steering_error_codeType steering_error_code = 3;
  bool has_steering_error_code() const;
  private:
  bool _internal_has_steering_error_code() const;
  public:
  void clear_steering_error_code();
  ::apollo::canbus::Error_state_e1_Steering_error_codeType steering_error_code() const;
  void set_steering_error_code(::apollo::canbus::Error_state_e1_Steering_error_codeType value);
  private:
  ::apollo::canbus::Error_state_e1_Steering_error_codeType _internal_steering_error_code() const;
  void _internal_set_steering_error_code(::apollo::canbus::Error_state_e1_Steering_error_codeType value);
  public:

  // optional .apollo.canbus.Error_state_e1.Parking_error_codeType parking_error_code = 4;
  bool has_parking_error_code() const;
  private:
  bool _internal_has_parking_error_code() const;
  public:
  void clear_parking_error_code();
  ::apollo::canbus::Error_state_e1_Parking_error_codeType parking_error_code() const;
  void set_parking_error_code(::apollo::canbus::Error_state_e1_Parking_error_codeType value);
  private:
  ::apollo::canbus::Error_state_e1_Parking_error_codeType _internal_parking_error_code() const;
  void _internal_set_parking_error_code(::apollo::canbus::Error_state_e1_Parking_error_codeType value);
  public:

  // optional .apollo.canbus.Error_state_e1.Gear_error_msgType gear_error_msg = 5;
  bool has_gear_error_msg() const;
  private:
  bool _internal_has_gear_error_msg() const;
  public:
  void clear_gear_error_msg();
  ::apollo::canbus::Error_state_e1_Gear_error_msgType gear_error_msg() const;
  void set_gear_error_msg(::apollo::canbus::Error_state_e1_Gear_error_msgType value);
  private:
  ::apollo::canbus::Error_state_e1_Gear_error_msgType _internal_gear_error_msg() const;
  void _internal_set_gear_error_msg(::apollo::canbus::Error_state_e1_Gear_error_msgType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Error_state_e1)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int brake_error_code_;
  int driven_error_code_;
  int steering_error_code_;
  int parking_error_code_;
  int gear_error_msg_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fzhongyun_2eproto;
};
// -------------------------------------------------------------------

class Vehicle_state_feedback_2_c4 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Vehicle_state_feedback_2_c4) */ {
 public:
  Vehicle_state_feedback_2_c4();
  virtual ~Vehicle_state_feedback_2_c4();

  Vehicle_state_feedback_2_c4(const Vehicle_state_feedback_2_c4& from);
  Vehicle_state_feedback_2_c4(Vehicle_state_feedback_2_c4&& from) noexcept
    : Vehicle_state_feedback_2_c4() {
    *this = ::std::move(from);
  }

  inline Vehicle_state_feedback_2_c4& operator=(const Vehicle_state_feedback_2_c4& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle_state_feedback_2_c4& operator=(Vehicle_state_feedback_2_c4&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vehicle_state_feedback_2_c4& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle_state_feedback_2_c4* internal_default_instance() {
    return reinterpret_cast<const Vehicle_state_feedback_2_c4*>(
               &_Vehicle_state_feedback_2_c4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Vehicle_state_feedback_2_c4& a, Vehicle_state_feedback_2_c4& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle_state_feedback_2_c4* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vehicle_state_feedback_2_c4* New() const final {
    return CreateMaybeMessage<Vehicle_state_feedback_2_c4>(nullptr);
  }

  Vehicle_state_feedback_2_c4* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle_state_feedback_2_c4>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vehicle_state_feedback_2_c4& from);
  void MergeFrom(const Vehicle_state_feedback_2_c4& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_state_feedback_2_c4* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Vehicle_state_feedback_2_c4";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrivenTorqueFeedbackFieldNumber = 2,
    kMotorSpeedFieldNumber = 1,
  };
  // optional double driven_torque_feedback = 2;
  bool has_driven_torque_feedback() const;
  private:
  bool _internal_has_driven_torque_feedback() const;
  public:
  void clear_driven_torque_feedback();
  double driven_torque_feedback() const;
  void set_driven_torque_feedback(double value);
  private:
  double _internal_driven_torque_feedback() const;
  void _internal_set_driven_torque_feedback(double value);
  public:

  // optional int32 motor_speed = 1;
  bool has_motor_speed() const;
  private:
  bool _internal_has_motor_speed() const;
  public:
  void clear_motor_speed();
  ::PROTOBUF_NAMESPACE_ID::int32 motor_speed() const;
  void set_motor_speed(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_motor_speed() const;
  void _internal_set_motor_speed(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Vehicle_state_feedback_2_c4)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double driven_torque_feedback_;
  ::PROTOBUF_NAMESPACE_ID::int32 motor_speed_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fzhongyun_2eproto;
};
// -------------------------------------------------------------------

class Zhongyun :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Zhongyun) */ {
 public:
  Zhongyun();
  virtual ~Zhongyun();

  Zhongyun(const Zhongyun& from);
  Zhongyun(Zhongyun&& from) noexcept
    : Zhongyun() {
    *this = ::std::move(from);
  }

  inline Zhongyun& operator=(const Zhongyun& from) {
    CopyFrom(from);
    return *this;
  }
  inline Zhongyun& operator=(Zhongyun&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Zhongyun& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Zhongyun* internal_default_instance() {
    return reinterpret_cast<const Zhongyun*>(
               &_Zhongyun_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Zhongyun& a, Zhongyun& b) {
    a.Swap(&b);
  }
  inline void Swap(Zhongyun* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Zhongyun* New() const final {
    return CreateMaybeMessage<Zhongyun>(nullptr);
  }

  Zhongyun* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Zhongyun>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Zhongyun& from);
  void MergeFrom(const Zhongyun& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Zhongyun* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Zhongyun";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fzhongyun_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGearControlA1FieldNumber = 1,
    kTorqueControlA3FieldNumber = 2,
    kSteeringControlA2FieldNumber = 3,
    kParkingControlA5FieldNumber = 4,
    kBrakeControlA4FieldNumber = 5,
    kEnableStateFeedbackC3FieldNumber = 6,
    kVehicleStateFeedbackC1FieldNumber = 7,
    kErrorStateE1FieldNumber = 8,
    kVehicleStateFeedback2C4FieldNumber = 9,
  };
  // optional .apollo.canbus.Gear_control_a1 gear_control_a1 = 1;
  bool has_gear_control_a1() const;
  private:
  bool _internal_has_gear_control_a1() const;
  public:
  void clear_gear_control_a1();
  const ::apollo::canbus::Gear_control_a1& gear_control_a1() const;
  ::apollo::canbus::Gear_control_a1* release_gear_control_a1();
  ::apollo::canbus::Gear_control_a1* mutable_gear_control_a1();
  void set_allocated_gear_control_a1(::apollo::canbus::Gear_control_a1* gear_control_a1);
  private:
  const ::apollo::canbus::Gear_control_a1& _internal_gear_control_a1() const;
  ::apollo::canbus::Gear_control_a1* _internal_mutable_gear_control_a1();
  public:

  // optional .apollo.canbus.Torque_control_a3 torque_control_a3 = 2;
  bool has_torque_control_a3() const;
  private:
  bool _internal_has_torque_control_a3() const;
  public:
  void clear_torque_control_a3();
  const ::apollo::canbus::Torque_control_a3& torque_control_a3() const;
  ::apollo::canbus::Torque_control_a3* release_torque_control_a3();
  ::apollo::canbus::Torque_control_a3* mutable_torque_control_a3();
  void set_allocated_torque_control_a3(::apollo::canbus::Torque_control_a3* torque_control_a3);
  private:
  const ::apollo::canbus::Torque_control_a3& _internal_torque_control_a3() const;
  ::apollo::canbus::Torque_control_a3* _internal_mutable_torque_control_a3();
  public:

  // optional .apollo.canbus.Steering_control_a2 steering_control_a2 = 3;
  bool has_steering_control_a2() const;
  private:
  bool _internal_has_steering_control_a2() const;
  public:
  void clear_steering_control_a2();
  const ::apollo::canbus::Steering_control_a2& steering_control_a2() const;
  ::apollo::canbus::Steering_control_a2* release_steering_control_a2();
  ::apollo::canbus::Steering_control_a2* mutable_steering_control_a2();
  void set_allocated_steering_control_a2(::apollo::canbus::Steering_control_a2* steering_control_a2);
  private:
  const ::apollo::canbus::Steering_control_a2& _internal_steering_control_a2() const;
  ::apollo::canbus::Steering_control_a2* _internal_mutable_steering_control_a2();
  public:

  // optional .apollo.canbus.Parking_control_a5 parking_control_a5 = 4;
  bool has_parking_control_a5() const;
  private:
  bool _internal_has_parking_control_a5() const;
  public:
  void clear_parking_control_a5();
  const ::apollo::canbus::Parking_control_a5& parking_control_a5() const;
  ::apollo::canbus::Parking_control_a5* release_parking_control_a5();
  ::apollo::canbus::Parking_control_a5* mutable_parking_control_a5();
  void set_allocated_parking_control_a5(::apollo::canbus::Parking_control_a5* parking_control_a5);
  private:
  const ::apollo::canbus::Parking_control_a5& _internal_parking_control_a5() const;
  ::apollo::canbus::Parking_control_a5* _internal_mutable_parking_control_a5();
  public:

  // optional .apollo.canbus.Brake_control_a4 brake_control_a4 = 5;
  bool has_brake_control_a4() const;
  private:
  bool _internal_has_brake_control_a4() const;
  public:
  void clear_brake_control_a4();
  const ::apollo::canbus::Brake_control_a4& brake_control_a4() const;
  ::apollo::canbus::Brake_control_a4* release_brake_control_a4();
  ::apollo::canbus::Brake_control_a4* mutable_brake_control_a4();
  void set_allocated_brake_control_a4(::apollo::canbus::Brake_control_a4* brake_control_a4);
  private:
  const ::apollo::canbus::Brake_control_a4& _internal_brake_control_a4() const;
  ::apollo::canbus::Brake_control_a4* _internal_mutable_brake_control_a4();
  public:

  // optional .apollo.canbus.Enable_state_feedback_c3 enable_state_feedback_c3 = 6;
  bool has_enable_state_feedback_c3() const;
  private:
  bool _internal_has_enable_state_feedback_c3() const;
  public:
  void clear_enable_state_feedback_c3();
  const ::apollo::canbus::Enable_state_feedback_c3& enable_state_feedback_c3() const;
  ::apollo::canbus::Enable_state_feedback_c3* release_enable_state_feedback_c3();
  ::apollo::canbus::Enable_state_feedback_c3* mutable_enable_state_feedback_c3();
  void set_allocated_enable_state_feedback_c3(::apollo::canbus::Enable_state_feedback_c3* enable_state_feedback_c3);
  private:
  const ::apollo::canbus::Enable_state_feedback_c3& _internal_enable_state_feedback_c3() const;
  ::apollo::canbus::Enable_state_feedback_c3* _internal_mutable_enable_state_feedback_c3();
  public:

  // optional .apollo.canbus.Vehicle_state_feedback_c1 vehicle_state_feedback_c1 = 7;
  bool has_vehicle_state_feedback_c1() const;
  private:
  bool _internal_has_vehicle_state_feedback_c1() const;
  public:
  void clear_vehicle_state_feedback_c1();
  const ::apollo::canbus::Vehicle_state_feedback_c1& vehicle_state_feedback_c1() const;
  ::apollo::canbus::Vehicle_state_feedback_c1* release_vehicle_state_feedback_c1();
  ::apollo::canbus::Vehicle_state_feedback_c1* mutable_vehicle_state_feedback_c1();
  void set_allocated_vehicle_state_feedback_c1(::apollo::canbus::Vehicle_state_feedback_c1* vehicle_state_feedback_c1);
  private:
  const ::apollo::canbus::Vehicle_state_feedback_c1& _internal_vehicle_state_feedback_c1() const;
  ::apollo::canbus::Vehicle_state_feedback_c1* _internal_mutable_vehicle_state_feedback_c1();
  public:

  // optional .apollo.canbus.Error_state_e1 error_state_e1 = 8;
  bool has_error_state_e1() const;
  private:
  bool _internal_has_error_state_e1() const;
  public:
  void clear_error_state_e1();
  const ::apollo::canbus::Error_state_e1& error_state_e1() const;
  ::apollo::canbus::Error_state_e1* release_error_state_e1();
  ::apollo::canbus::Error_state_e1* mutable_error_state_e1();
  void set_allocated_error_state_e1(::apollo::canbus::Error_state_e1* error_state_e1);
  private:
  const ::apollo::canbus::Error_state_e1& _internal_error_state_e1() const;
  ::apollo::canbus::Error_state_e1* _internal_mutable_error_state_e1();
  public:

  // optional .apollo.canbus.Vehicle_state_feedback_2_c4 vehicle_state_feedback_2_c4 = 9;
  bool has_vehicle_state_feedback_2_c4() const;
  private:
  bool _internal_has_vehicle_state_feedback_2_c4() const;
  public:
  void clear_vehicle_state_feedback_2_c4();
  const ::apollo::canbus::Vehicle_state_feedback_2_c4& vehicle_state_feedback_2_c4() const;
  ::apollo::canbus::Vehicle_state_feedback_2_c4* release_vehicle_state_feedback_2_c4();
  ::apollo::canbus::Vehicle_state_feedback_2_c4* mutable_vehicle_state_feedback_2_c4();
  void set_allocated_vehicle_state_feedback_2_c4(::apollo::canbus::Vehicle_state_feedback_2_c4* vehicle_state_feedback_2_c4);
  private:
  const ::apollo::canbus::Vehicle_state_feedback_2_c4& _internal_vehicle_state_feedback_2_c4() const;
  ::apollo::canbus::Vehicle_state_feedback_2_c4* _internal_mutable_vehicle_state_feedback_2_c4();
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Zhongyun)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::canbus::Gear_control_a1* gear_control_a1_;
  ::apollo::canbus::Torque_control_a3* torque_control_a3_;
  ::apollo::canbus::Steering_control_a2* steering_control_a2_;
  ::apollo::canbus::Parking_control_a5* parking_control_a5_;
  ::apollo::canbus::Brake_control_a4* brake_control_a4_;
  ::apollo::canbus::Enable_state_feedback_c3* enable_state_feedback_c3_;
  ::apollo::canbus::Vehicle_state_feedback_c1* vehicle_state_feedback_c1_;
  ::apollo::canbus::Error_state_e1* error_state_e1_;
  ::apollo::canbus::Vehicle_state_feedback_2_c4* vehicle_state_feedback_2_c4_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fzhongyun_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Gear_control_a1

// optional .apollo.canbus.Gear_control_a1.Gear_state_targetType gear_state_target = 1;
inline bool Gear_control_a1::_internal_has_gear_state_target() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Gear_control_a1::has_gear_state_target() const {
  return _internal_has_gear_state_target();
}
inline void Gear_control_a1::clear_gear_state_target() {
  gear_state_target_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Gear_control_a1_Gear_state_targetType Gear_control_a1::_internal_gear_state_target() const {
  return static_cast< ::apollo::canbus::Gear_control_a1_Gear_state_targetType >(gear_state_target_);
}
inline ::apollo::canbus::Gear_control_a1_Gear_state_targetType Gear_control_a1::gear_state_target() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear_control_a1.gear_state_target)
  return _internal_gear_state_target();
}
inline void Gear_control_a1::_internal_set_gear_state_target(::apollo::canbus::Gear_control_a1_Gear_state_targetType value) {
  assert(::apollo::canbus::Gear_control_a1_Gear_state_targetType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  gear_state_target_ = value;
}
inline void Gear_control_a1::set_gear_state_target(::apollo::canbus::Gear_control_a1_Gear_state_targetType value) {
  _internal_set_gear_state_target(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear_control_a1.gear_state_target)
}

// optional .apollo.canbus.Gear_control_a1.Gear_enable_controlType gear_enable_control = 2;
inline bool Gear_control_a1::_internal_has_gear_enable_control() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Gear_control_a1::has_gear_enable_control() const {
  return _internal_has_gear_enable_control();
}
inline void Gear_control_a1::clear_gear_enable_control() {
  gear_enable_control_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Gear_control_a1_Gear_enable_controlType Gear_control_a1::_internal_gear_enable_control() const {
  return static_cast< ::apollo::canbus::Gear_control_a1_Gear_enable_controlType >(gear_enable_control_);
}
inline ::apollo::canbus::Gear_control_a1_Gear_enable_controlType Gear_control_a1::gear_enable_control() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear_control_a1.gear_enable_control)
  return _internal_gear_enable_control();
}
inline void Gear_control_a1::_internal_set_gear_enable_control(::apollo::canbus::Gear_control_a1_Gear_enable_controlType value) {
  assert(::apollo::canbus::Gear_control_a1_Gear_enable_controlType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  gear_enable_control_ = value;
}
inline void Gear_control_a1::set_gear_enable_control(::apollo::canbus::Gear_control_a1_Gear_enable_controlType value) {
  _internal_set_gear_enable_control(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear_control_a1.gear_enable_control)
}

// -------------------------------------------------------------------

// Torque_control_a3

// optional double driven_torque = 1;
inline bool Torque_control_a3::_internal_has_driven_torque() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Torque_control_a3::has_driven_torque() const {
  return _internal_has_driven_torque();
}
inline void Torque_control_a3::clear_driven_torque() {
  driven_torque_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Torque_control_a3::_internal_driven_torque() const {
  return driven_torque_;
}
inline double Torque_control_a3::driven_torque() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Torque_control_a3.driven_torque)
  return _internal_driven_torque();
}
inline void Torque_control_a3::_internal_set_driven_torque(double value) {
  _has_bits_[0] |= 0x00000001u;
  driven_torque_ = value;
}
inline void Torque_control_a3::set_driven_torque(double value) {
  _internal_set_driven_torque(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Torque_control_a3.driven_torque)
}

// optional .apollo.canbus.Torque_control_a3.Driven_enable_controlType driven_enable_control = 2;
inline bool Torque_control_a3::_internal_has_driven_enable_control() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Torque_control_a3::has_driven_enable_control() const {
  return _internal_has_driven_enable_control();
}
inline void Torque_control_a3::clear_driven_enable_control() {
  driven_enable_control_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Torque_control_a3_Driven_enable_controlType Torque_control_a3::_internal_driven_enable_control() const {
  return static_cast< ::apollo::canbus::Torque_control_a3_Driven_enable_controlType >(driven_enable_control_);
}
inline ::apollo::canbus::Torque_control_a3_Driven_enable_controlType Torque_control_a3::driven_enable_control() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Torque_control_a3.driven_enable_control)
  return _internal_driven_enable_control();
}
inline void Torque_control_a3::_internal_set_driven_enable_control(::apollo::canbus::Torque_control_a3_Driven_enable_controlType value) {
  assert(::apollo::canbus::Torque_control_a3_Driven_enable_controlType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  driven_enable_control_ = value;
}
inline void Torque_control_a3::set_driven_enable_control(::apollo::canbus::Torque_control_a3_Driven_enable_controlType value) {
  _internal_set_driven_enable_control(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Torque_control_a3.driven_enable_control)
}

// -------------------------------------------------------------------

// Steering_control_a2

// optional double steering_target = 1;
inline bool Steering_control_a2::_internal_has_steering_target() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Steering_control_a2::has_steering_target() const {
  return _internal_has_steering_target();
}
inline void Steering_control_a2::clear_steering_target() {
  steering_target_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Steering_control_a2::_internal_steering_target() const {
  return steering_target_;
}
inline double Steering_control_a2::steering_target() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_control_a2.steering_target)
  return _internal_steering_target();
}
inline void Steering_control_a2::_internal_set_steering_target(double value) {
  _has_bits_[0] |= 0x00000001u;
  steering_target_ = value;
}
inline void Steering_control_a2::set_steering_target(double value) {
  _internal_set_steering_target(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_control_a2.steering_target)
}

// optional .apollo.canbus.Steering_control_a2.Steering_enable_controlType steering_enable_control = 2;
inline bool Steering_control_a2::_internal_has_steering_enable_control() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Steering_control_a2::has_steering_enable_control() const {
  return _internal_has_steering_enable_control();
}
inline void Steering_control_a2::clear_steering_enable_control() {
  steering_enable_control_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Steering_control_a2_Steering_enable_controlType Steering_control_a2::_internal_steering_enable_control() const {
  return static_cast< ::apollo::canbus::Steering_control_a2_Steering_enable_controlType >(steering_enable_control_);
}
inline ::apollo::canbus::Steering_control_a2_Steering_enable_controlType Steering_control_a2::steering_enable_control() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_control_a2.steering_enable_control)
  return _internal_steering_enable_control();
}
inline void Steering_control_a2::_internal_set_steering_enable_control(::apollo::canbus::Steering_control_a2_Steering_enable_controlType value) {
  assert(::apollo::canbus::Steering_control_a2_Steering_enable_controlType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  steering_enable_control_ = value;
}
inline void Steering_control_a2::set_steering_enable_control(::apollo::canbus::Steering_control_a2_Steering_enable_controlType value) {
  _internal_set_steering_enable_control(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_control_a2.steering_enable_control)
}

// -------------------------------------------------------------------

// Parking_control_a5

// optional .apollo.canbus.Parking_control_a5.Parking_targetType parking_target = 1;
inline bool Parking_control_a5::_internal_has_parking_target() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Parking_control_a5::has_parking_target() const {
  return _internal_has_parking_target();
}
inline void Parking_control_a5::clear_parking_target() {
  parking_target_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Parking_control_a5_Parking_targetType Parking_control_a5::_internal_parking_target() const {
  return static_cast< ::apollo::canbus::Parking_control_a5_Parking_targetType >(parking_target_);
}
inline ::apollo::canbus::Parking_control_a5_Parking_targetType Parking_control_a5::parking_target() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Parking_control_a5.parking_target)
  return _internal_parking_target();
}
inline void Parking_control_a5::_internal_set_parking_target(::apollo::canbus::Parking_control_a5_Parking_targetType value) {
  assert(::apollo::canbus::Parking_control_a5_Parking_targetType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  parking_target_ = value;
}
inline void Parking_control_a5::set_parking_target(::apollo::canbus::Parking_control_a5_Parking_targetType value) {
  _internal_set_parking_target(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Parking_control_a5.parking_target)
}

// optional .apollo.canbus.Parking_control_a5.Parking_enable_controlType parking_enable_control = 2;
inline bool Parking_control_a5::_internal_has_parking_enable_control() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Parking_control_a5::has_parking_enable_control() const {
  return _internal_has_parking_enable_control();
}
inline void Parking_control_a5::clear_parking_enable_control() {
  parking_enable_control_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Parking_control_a5_Parking_enable_controlType Parking_control_a5::_internal_parking_enable_control() const {
  return static_cast< ::apollo::canbus::Parking_control_a5_Parking_enable_controlType >(parking_enable_control_);
}
inline ::apollo::canbus::Parking_control_a5_Parking_enable_controlType Parking_control_a5::parking_enable_control() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Parking_control_a5.parking_enable_control)
  return _internal_parking_enable_control();
}
inline void Parking_control_a5::_internal_set_parking_enable_control(::apollo::canbus::Parking_control_a5_Parking_enable_controlType value) {
  assert(::apollo::canbus::Parking_control_a5_Parking_enable_controlType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  parking_enable_control_ = value;
}
inline void Parking_control_a5::set_parking_enable_control(::apollo::canbus::Parking_control_a5_Parking_enable_controlType value) {
  _internal_set_parking_enable_control(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Parking_control_a5.parking_enable_control)
}

// -------------------------------------------------------------------

// Brake_control_a4

// optional double brake_torque = 1;
inline bool Brake_control_a4::_internal_has_brake_torque() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Brake_control_a4::has_brake_torque() const {
  return _internal_has_brake_torque();
}
inline void Brake_control_a4::clear_brake_torque() {
  brake_torque_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Brake_control_a4::_internal_brake_torque() const {
  return brake_torque_;
}
inline double Brake_control_a4::brake_torque() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_control_a4.brake_torque)
  return _internal_brake_torque();
}
inline void Brake_control_a4::_internal_set_brake_torque(double value) {
  _has_bits_[0] |= 0x00000001u;
  brake_torque_ = value;
}
inline void Brake_control_a4::set_brake_torque(double value) {
  _internal_set_brake_torque(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_control_a4.brake_torque)
}

// optional .apollo.canbus.Brake_control_a4.Brake_enable_controlType brake_enable_control = 2;
inline bool Brake_control_a4::_internal_has_brake_enable_control() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Brake_control_a4::has_brake_enable_control() const {
  return _internal_has_brake_enable_control();
}
inline void Brake_control_a4::clear_brake_enable_control() {
  brake_enable_control_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Brake_control_a4_Brake_enable_controlType Brake_control_a4::_internal_brake_enable_control() const {
  return static_cast< ::apollo::canbus::Brake_control_a4_Brake_enable_controlType >(brake_enable_control_);
}
inline ::apollo::canbus::Brake_control_a4_Brake_enable_controlType Brake_control_a4::brake_enable_control() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_control_a4.brake_enable_control)
  return _internal_brake_enable_control();
}
inline void Brake_control_a4::_internal_set_brake_enable_control(::apollo::canbus::Brake_control_a4_Brake_enable_controlType value) {
  assert(::apollo::canbus::Brake_control_a4_Brake_enable_controlType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  brake_enable_control_ = value;
}
inline void Brake_control_a4::set_brake_enable_control(::apollo::canbus::Brake_control_a4_Brake_enable_controlType value) {
  _internal_set_brake_enable_control(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_control_a4.brake_enable_control)
}

// -------------------------------------------------------------------

// Enable_state_feedback_c3

// optional .apollo.canbus.Enable_state_feedback_c3.Parking_enable_stateType parking_enable_state = 1;
inline bool Enable_state_feedback_c3::_internal_has_parking_enable_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Enable_state_feedback_c3::has_parking_enable_state() const {
  return _internal_has_parking_enable_state();
}
inline void Enable_state_feedback_c3::clear_parking_enable_state() {
  parking_enable_state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType Enable_state_feedback_c3::_internal_parking_enable_state() const {
  return static_cast< ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType >(parking_enable_state_);
}
inline ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType Enable_state_feedback_c3::parking_enable_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Enable_state_feedback_c3.parking_enable_state)
  return _internal_parking_enable_state();
}
inline void Enable_state_feedback_c3::_internal_set_parking_enable_state(::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType value) {
  assert(::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  parking_enable_state_ = value;
}
inline void Enable_state_feedback_c3::set_parking_enable_state(::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType value) {
  _internal_set_parking_enable_state(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Enable_state_feedback_c3.parking_enable_state)
}

// optional .apollo.canbus.Enable_state_feedback_c3.Steering_enable_stateType steering_enable_state = 2;
inline bool Enable_state_feedback_c3::_internal_has_steering_enable_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Enable_state_feedback_c3::has_steering_enable_state() const {
  return _internal_has_steering_enable_state();
}
inline void Enable_state_feedback_c3::clear_steering_enable_state() {
  steering_enable_state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType Enable_state_feedback_c3::_internal_steering_enable_state() const {
  return static_cast< ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType >(steering_enable_state_);
}
inline ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType Enable_state_feedback_c3::steering_enable_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Enable_state_feedback_c3.steering_enable_state)
  return _internal_steering_enable_state();
}
inline void Enable_state_feedback_c3::_internal_set_steering_enable_state(::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType value) {
  assert(::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  steering_enable_state_ = value;
}
inline void Enable_state_feedback_c3::set_steering_enable_state(::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType value) {
  _internal_set_steering_enable_state(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Enable_state_feedback_c3.steering_enable_state)
}

// optional .apollo.canbus.Enable_state_feedback_c3.Gear_enable_actualType gear_enable_actual = 3;
inline bool Enable_state_feedback_c3::_internal_has_gear_enable_actual() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Enable_state_feedback_c3::has_gear_enable_actual() const {
  return _internal_has_gear_enable_actual();
}
inline void Enable_state_feedback_c3::clear_gear_enable_actual() {
  gear_enable_actual_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType Enable_state_feedback_c3::_internal_gear_enable_actual() const {
  return static_cast< ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType >(gear_enable_actual_);
}
inline ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType Enable_state_feedback_c3::gear_enable_actual() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Enable_state_feedback_c3.gear_enable_actual)
  return _internal_gear_enable_actual();
}
inline void Enable_state_feedback_c3::_internal_set_gear_enable_actual(::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType value) {
  assert(::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  gear_enable_actual_ = value;
}
inline void Enable_state_feedback_c3::set_gear_enable_actual(::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType value) {
  _internal_set_gear_enable_actual(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Enable_state_feedback_c3.gear_enable_actual)
}

// optional .apollo.canbus.Enable_state_feedback_c3.Driven_enable_stateType driven_enable_state = 4;
inline bool Enable_state_feedback_c3::_internal_has_driven_enable_state() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Enable_state_feedback_c3::has_driven_enable_state() const {
  return _internal_has_driven_enable_state();
}
inline void Enable_state_feedback_c3::clear_driven_enable_state() {
  driven_enable_state_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType Enable_state_feedback_c3::_internal_driven_enable_state() const {
  return static_cast< ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType >(driven_enable_state_);
}
inline ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType Enable_state_feedback_c3::driven_enable_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Enable_state_feedback_c3.driven_enable_state)
  return _internal_driven_enable_state();
}
inline void Enable_state_feedback_c3::_internal_set_driven_enable_state(::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType value) {
  assert(::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  driven_enable_state_ = value;
}
inline void Enable_state_feedback_c3::set_driven_enable_state(::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType value) {
  _internal_set_driven_enable_state(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Enable_state_feedback_c3.driven_enable_state)
}

// optional .apollo.canbus.Enable_state_feedback_c3.Brake_enable_stateType brake_enable_state = 5;
inline bool Enable_state_feedback_c3::_internal_has_brake_enable_state() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Enable_state_feedback_c3::has_brake_enable_state() const {
  return _internal_has_brake_enable_state();
}
inline void Enable_state_feedback_c3::clear_brake_enable_state() {
  brake_enable_state_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType Enable_state_feedback_c3::_internal_brake_enable_state() const {
  return static_cast< ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType >(brake_enable_state_);
}
inline ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType Enable_state_feedback_c3::brake_enable_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Enable_state_feedback_c3.brake_enable_state)
  return _internal_brake_enable_state();
}
inline void Enable_state_feedback_c3::_internal_set_brake_enable_state(::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType value) {
  assert(::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  brake_enable_state_ = value;
}
inline void Enable_state_feedback_c3::set_brake_enable_state(::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType value) {
  _internal_set_brake_enable_state(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Enable_state_feedback_c3.brake_enable_state)
}

// -------------------------------------------------------------------

// Vehicle_state_feedback_c1

// optional .apollo.canbus.Vehicle_state_feedback_c1.Parking_actualType parking_actual = 1;
inline bool Vehicle_state_feedback_c1::_internal_has_parking_actual() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Vehicle_state_feedback_c1::has_parking_actual() const {
  return _internal_has_parking_actual();
}
inline void Vehicle_state_feedback_c1::clear_parking_actual() {
  parking_actual_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType Vehicle_state_feedback_c1::_internal_parking_actual() const {
  return static_cast< ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType >(parking_actual_);
}
inline ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType Vehicle_state_feedback_c1::parking_actual() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_c1.parking_actual)
  return _internal_parking_actual();
}
inline void Vehicle_state_feedback_c1::_internal_set_parking_actual(::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType value) {
  assert(::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  parking_actual_ = value;
}
inline void Vehicle_state_feedback_c1::set_parking_actual(::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType value) {
  _internal_set_parking_actual(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_c1.parking_actual)
}

// optional double brake_torque_feedback = 2;
inline bool Vehicle_state_feedback_c1::_internal_has_brake_torque_feedback() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Vehicle_state_feedback_c1::has_brake_torque_feedback() const {
  return _internal_has_brake_torque_feedback();
}
inline void Vehicle_state_feedback_c1::clear_brake_torque_feedback() {
  brake_torque_feedback_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Vehicle_state_feedback_c1::_internal_brake_torque_feedback() const {
  return brake_torque_feedback_;
}
inline double Vehicle_state_feedback_c1::brake_torque_feedback() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_c1.brake_torque_feedback)
  return _internal_brake_torque_feedback();
}
inline void Vehicle_state_feedback_c1::_internal_set_brake_torque_feedback(double value) {
  _has_bits_[0] |= 0x00000001u;
  brake_torque_feedback_ = value;
}
inline void Vehicle_state_feedback_c1::set_brake_torque_feedback(double value) {
  _internal_set_brake_torque_feedback(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_c1.brake_torque_feedback)
}

// optional .apollo.canbus.Vehicle_state_feedback_c1.Gear_state_actualType gear_state_actual = 3;
inline bool Vehicle_state_feedback_c1::_internal_has_gear_state_actual() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Vehicle_state_feedback_c1::has_gear_state_actual() const {
  return _internal_has_gear_state_actual();
}
inline void Vehicle_state_feedback_c1::clear_gear_state_actual() {
  gear_state_actual_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType Vehicle_state_feedback_c1::_internal_gear_state_actual() const {
  return static_cast< ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType >(gear_state_actual_);
}
inline ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType Vehicle_state_feedback_c1::gear_state_actual() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_c1.gear_state_actual)
  return _internal_gear_state_actual();
}
inline void Vehicle_state_feedback_c1::_internal_set_gear_state_actual(::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType value) {
  assert(::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  gear_state_actual_ = value;
}
inline void Vehicle_state_feedback_c1::set_gear_state_actual(::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType value) {
  _internal_set_gear_state_actual(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_c1.gear_state_actual)
}

// optional double steering_actual = 4;
inline bool Vehicle_state_feedback_c1::_internal_has_steering_actual() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Vehicle_state_feedback_c1::has_steering_actual() const {
  return _internal_has_steering_actual();
}
inline void Vehicle_state_feedback_c1::clear_steering_actual() {
  steering_actual_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Vehicle_state_feedback_c1::_internal_steering_actual() const {
  return steering_actual_;
}
inline double Vehicle_state_feedback_c1::steering_actual() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_c1.steering_actual)
  return _internal_steering_actual();
}
inline void Vehicle_state_feedback_c1::_internal_set_steering_actual(double value) {
  _has_bits_[0] |= 0x00000002u;
  steering_actual_ = value;
}
inline void Vehicle_state_feedback_c1::set_steering_actual(double value) {
  _internal_set_steering_actual(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_c1.steering_actual)
}

// optional double speed = 5;
inline bool Vehicle_state_feedback_c1::_internal_has_speed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Vehicle_state_feedback_c1::has_speed() const {
  return _internal_has_speed();
}
inline void Vehicle_state_feedback_c1::clear_speed() {
  speed_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Vehicle_state_feedback_c1::_internal_speed() const {
  return speed_;
}
inline double Vehicle_state_feedback_c1::speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_c1.speed)
  return _internal_speed();
}
inline void Vehicle_state_feedback_c1::_internal_set_speed(double value) {
  _has_bits_[0] |= 0x00000004u;
  speed_ = value;
}
inline void Vehicle_state_feedback_c1::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_c1.speed)
}

// -------------------------------------------------------------------

// Error_state_e1

// optional .apollo.canbus.Error_state_e1.Brake_error_codeType brake_error_code = 1;
inline bool Error_state_e1::_internal_has_brake_error_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Error_state_e1::has_brake_error_code() const {
  return _internal_has_brake_error_code();
}
inline void Error_state_e1::clear_brake_error_code() {
  brake_error_code_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Error_state_e1_Brake_error_codeType Error_state_e1::_internal_brake_error_code() const {
  return static_cast< ::apollo::canbus::Error_state_e1_Brake_error_codeType >(brake_error_code_);
}
inline ::apollo::canbus::Error_state_e1_Brake_error_codeType Error_state_e1::brake_error_code() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Error_state_e1.brake_error_code)
  return _internal_brake_error_code();
}
inline void Error_state_e1::_internal_set_brake_error_code(::apollo::canbus::Error_state_e1_Brake_error_codeType value) {
  assert(::apollo::canbus::Error_state_e1_Brake_error_codeType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  brake_error_code_ = value;
}
inline void Error_state_e1::set_brake_error_code(::apollo::canbus::Error_state_e1_Brake_error_codeType value) {
  _internal_set_brake_error_code(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Error_state_e1.brake_error_code)
}

// optional .apollo.canbus.Error_state_e1.Driven_error_codeType driven_error_code = 2;
inline bool Error_state_e1::_internal_has_driven_error_code() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Error_state_e1::has_driven_error_code() const {
  return _internal_has_driven_error_code();
}
inline void Error_state_e1::clear_driven_error_code() {
  driven_error_code_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Error_state_e1_Driven_error_codeType Error_state_e1::_internal_driven_error_code() const {
  return static_cast< ::apollo::canbus::Error_state_e1_Driven_error_codeType >(driven_error_code_);
}
inline ::apollo::canbus::Error_state_e1_Driven_error_codeType Error_state_e1::driven_error_code() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Error_state_e1.driven_error_code)
  return _internal_driven_error_code();
}
inline void Error_state_e1::_internal_set_driven_error_code(::apollo::canbus::Error_state_e1_Driven_error_codeType value) {
  assert(::apollo::canbus::Error_state_e1_Driven_error_codeType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  driven_error_code_ = value;
}
inline void Error_state_e1::set_driven_error_code(::apollo::canbus::Error_state_e1_Driven_error_codeType value) {
  _internal_set_driven_error_code(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Error_state_e1.driven_error_code)
}

// optional .apollo.canbus.Error_state_e1.Steering_error_codeType steering_error_code = 3;
inline bool Error_state_e1::_internal_has_steering_error_code() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Error_state_e1::has_steering_error_code() const {
  return _internal_has_steering_error_code();
}
inline void Error_state_e1::clear_steering_error_code() {
  steering_error_code_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::canbus::Error_state_e1_Steering_error_codeType Error_state_e1::_internal_steering_error_code() const {
  return static_cast< ::apollo::canbus::Error_state_e1_Steering_error_codeType >(steering_error_code_);
}
inline ::apollo::canbus::Error_state_e1_Steering_error_codeType Error_state_e1::steering_error_code() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Error_state_e1.steering_error_code)
  return _internal_steering_error_code();
}
inline void Error_state_e1::_internal_set_steering_error_code(::apollo::canbus::Error_state_e1_Steering_error_codeType value) {
  assert(::apollo::canbus::Error_state_e1_Steering_error_codeType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  steering_error_code_ = value;
}
inline void Error_state_e1::set_steering_error_code(::apollo::canbus::Error_state_e1_Steering_error_codeType value) {
  _internal_set_steering_error_code(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Error_state_e1.steering_error_code)
}

// optional .apollo.canbus.Error_state_e1.Parking_error_codeType parking_error_code = 4;
inline bool Error_state_e1::_internal_has_parking_error_code() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Error_state_e1::has_parking_error_code() const {
  return _internal_has_parking_error_code();
}
inline void Error_state_e1::clear_parking_error_code() {
  parking_error_code_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::apollo::canbus::Error_state_e1_Parking_error_codeType Error_state_e1::_internal_parking_error_code() const {
  return static_cast< ::apollo::canbus::Error_state_e1_Parking_error_codeType >(parking_error_code_);
}
inline ::apollo::canbus::Error_state_e1_Parking_error_codeType Error_state_e1::parking_error_code() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Error_state_e1.parking_error_code)
  return _internal_parking_error_code();
}
inline void Error_state_e1::_internal_set_parking_error_code(::apollo::canbus::Error_state_e1_Parking_error_codeType value) {
  assert(::apollo::canbus::Error_state_e1_Parking_error_codeType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  parking_error_code_ = value;
}
inline void Error_state_e1::set_parking_error_code(::apollo::canbus::Error_state_e1_Parking_error_codeType value) {
  _internal_set_parking_error_code(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Error_state_e1.parking_error_code)
}

// optional .apollo.canbus.Error_state_e1.Gear_error_msgType gear_error_msg = 5;
inline bool Error_state_e1::_internal_has_gear_error_msg() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Error_state_e1::has_gear_error_msg() const {
  return _internal_has_gear_error_msg();
}
inline void Error_state_e1::clear_gear_error_msg() {
  gear_error_msg_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::apollo::canbus::Error_state_e1_Gear_error_msgType Error_state_e1::_internal_gear_error_msg() const {
  return static_cast< ::apollo::canbus::Error_state_e1_Gear_error_msgType >(gear_error_msg_);
}
inline ::apollo::canbus::Error_state_e1_Gear_error_msgType Error_state_e1::gear_error_msg() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Error_state_e1.gear_error_msg)
  return _internal_gear_error_msg();
}
inline void Error_state_e1::_internal_set_gear_error_msg(::apollo::canbus::Error_state_e1_Gear_error_msgType value) {
  assert(::apollo::canbus::Error_state_e1_Gear_error_msgType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  gear_error_msg_ = value;
}
inline void Error_state_e1::set_gear_error_msg(::apollo::canbus::Error_state_e1_Gear_error_msgType value) {
  _internal_set_gear_error_msg(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Error_state_e1.gear_error_msg)
}

// -------------------------------------------------------------------

// Vehicle_state_feedback_2_c4

// optional int32 motor_speed = 1;
inline bool Vehicle_state_feedback_2_c4::_internal_has_motor_speed() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Vehicle_state_feedback_2_c4::has_motor_speed() const {
  return _internal_has_motor_speed();
}
inline void Vehicle_state_feedback_2_c4::clear_motor_speed() {
  motor_speed_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vehicle_state_feedback_2_c4::_internal_motor_speed() const {
  return motor_speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vehicle_state_feedback_2_c4::motor_speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_2_c4.motor_speed)
  return _internal_motor_speed();
}
inline void Vehicle_state_feedback_2_c4::_internal_set_motor_speed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  motor_speed_ = value;
}
inline void Vehicle_state_feedback_2_c4::set_motor_speed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_motor_speed(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_2_c4.motor_speed)
}

// optional double driven_torque_feedback = 2;
inline bool Vehicle_state_feedback_2_c4::_internal_has_driven_torque_feedback() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Vehicle_state_feedback_2_c4::has_driven_torque_feedback() const {
  return _internal_has_driven_torque_feedback();
}
inline void Vehicle_state_feedback_2_c4::clear_driven_torque_feedback() {
  driven_torque_feedback_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Vehicle_state_feedback_2_c4::_internal_driven_torque_feedback() const {
  return driven_torque_feedback_;
}
inline double Vehicle_state_feedback_2_c4::driven_torque_feedback() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_2_c4.driven_torque_feedback)
  return _internal_driven_torque_feedback();
}
inline void Vehicle_state_feedback_2_c4::_internal_set_driven_torque_feedback(double value) {
  _has_bits_[0] |= 0x00000001u;
  driven_torque_feedback_ = value;
}
inline void Vehicle_state_feedback_2_c4::set_driven_torque_feedback(double value) {
  _internal_set_driven_torque_feedback(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_2_c4.driven_torque_feedback)
}

// -------------------------------------------------------------------

// Zhongyun

// optional .apollo.canbus.Gear_control_a1 gear_control_a1 = 1;
inline bool Zhongyun::_internal_has_gear_control_a1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || gear_control_a1_ != nullptr);
  return value;
}
inline bool Zhongyun::has_gear_control_a1() const {
  return _internal_has_gear_control_a1();
}
inline void Zhongyun::clear_gear_control_a1() {
  if (gear_control_a1_ != nullptr) gear_control_a1_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::canbus::Gear_control_a1& Zhongyun::_internal_gear_control_a1() const {
  const ::apollo::canbus::Gear_control_a1* p = gear_control_a1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Gear_control_a1*>(
      &::apollo::canbus::_Gear_control_a1_default_instance_);
}
inline const ::apollo::canbus::Gear_control_a1& Zhongyun::gear_control_a1() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.gear_control_a1)
  return _internal_gear_control_a1();
}
inline ::apollo::canbus::Gear_control_a1* Zhongyun::release_gear_control_a1() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.gear_control_a1)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::canbus::Gear_control_a1* temp = gear_control_a1_;
  gear_control_a1_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Gear_control_a1* Zhongyun::_internal_mutable_gear_control_a1() {
  _has_bits_[0] |= 0x00000001u;
  if (gear_control_a1_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Gear_control_a1>(GetArenaNoVirtual());
    gear_control_a1_ = p;
  }
  return gear_control_a1_;
}
inline ::apollo::canbus::Gear_control_a1* Zhongyun::mutable_gear_control_a1() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.gear_control_a1)
  return _internal_mutable_gear_control_a1();
}
inline void Zhongyun::set_allocated_gear_control_a1(::apollo::canbus::Gear_control_a1* gear_control_a1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gear_control_a1_;
  }
  if (gear_control_a1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gear_control_a1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gear_control_a1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gear_control_a1_ = gear_control_a1;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.gear_control_a1)
}

// optional .apollo.canbus.Torque_control_a3 torque_control_a3 = 2;
inline bool Zhongyun::_internal_has_torque_control_a3() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || torque_control_a3_ != nullptr);
  return value;
}
inline bool Zhongyun::has_torque_control_a3() const {
  return _internal_has_torque_control_a3();
}
inline void Zhongyun::clear_torque_control_a3() {
  if (torque_control_a3_ != nullptr) torque_control_a3_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::canbus::Torque_control_a3& Zhongyun::_internal_torque_control_a3() const {
  const ::apollo::canbus::Torque_control_a3* p = torque_control_a3_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Torque_control_a3*>(
      &::apollo::canbus::_Torque_control_a3_default_instance_);
}
inline const ::apollo::canbus::Torque_control_a3& Zhongyun::torque_control_a3() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.torque_control_a3)
  return _internal_torque_control_a3();
}
inline ::apollo::canbus::Torque_control_a3* Zhongyun::release_torque_control_a3() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.torque_control_a3)
  _has_bits_[0] &= ~0x00000002u;
  ::apollo::canbus::Torque_control_a3* temp = torque_control_a3_;
  torque_control_a3_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Torque_control_a3* Zhongyun::_internal_mutable_torque_control_a3() {
  _has_bits_[0] |= 0x00000002u;
  if (torque_control_a3_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Torque_control_a3>(GetArenaNoVirtual());
    torque_control_a3_ = p;
  }
  return torque_control_a3_;
}
inline ::apollo::canbus::Torque_control_a3* Zhongyun::mutable_torque_control_a3() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.torque_control_a3)
  return _internal_mutable_torque_control_a3();
}
inline void Zhongyun::set_allocated_torque_control_a3(::apollo::canbus::Torque_control_a3* torque_control_a3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete torque_control_a3_;
  }
  if (torque_control_a3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      torque_control_a3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, torque_control_a3, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  torque_control_a3_ = torque_control_a3;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.torque_control_a3)
}

// optional .apollo.canbus.Steering_control_a2 steering_control_a2 = 3;
inline bool Zhongyun::_internal_has_steering_control_a2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || steering_control_a2_ != nullptr);
  return value;
}
inline bool Zhongyun::has_steering_control_a2() const {
  return _internal_has_steering_control_a2();
}
inline void Zhongyun::clear_steering_control_a2() {
  if (steering_control_a2_ != nullptr) steering_control_a2_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::canbus::Steering_control_a2& Zhongyun::_internal_steering_control_a2() const {
  const ::apollo::canbus::Steering_control_a2* p = steering_control_a2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Steering_control_a2*>(
      &::apollo::canbus::_Steering_control_a2_default_instance_);
}
inline const ::apollo::canbus::Steering_control_a2& Zhongyun::steering_control_a2() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.steering_control_a2)
  return _internal_steering_control_a2();
}
inline ::apollo::canbus::Steering_control_a2* Zhongyun::release_steering_control_a2() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.steering_control_a2)
  _has_bits_[0] &= ~0x00000004u;
  ::apollo::canbus::Steering_control_a2* temp = steering_control_a2_;
  steering_control_a2_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Steering_control_a2* Zhongyun::_internal_mutable_steering_control_a2() {
  _has_bits_[0] |= 0x00000004u;
  if (steering_control_a2_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Steering_control_a2>(GetArenaNoVirtual());
    steering_control_a2_ = p;
  }
  return steering_control_a2_;
}
inline ::apollo::canbus::Steering_control_a2* Zhongyun::mutable_steering_control_a2() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.steering_control_a2)
  return _internal_mutable_steering_control_a2();
}
inline void Zhongyun::set_allocated_steering_control_a2(::apollo::canbus::Steering_control_a2* steering_control_a2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete steering_control_a2_;
  }
  if (steering_control_a2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      steering_control_a2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steering_control_a2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  steering_control_a2_ = steering_control_a2;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.steering_control_a2)
}

// optional .apollo.canbus.Parking_control_a5 parking_control_a5 = 4;
inline bool Zhongyun::_internal_has_parking_control_a5() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || parking_control_a5_ != nullptr);
  return value;
}
inline bool Zhongyun::has_parking_control_a5() const {
  return _internal_has_parking_control_a5();
}
inline void Zhongyun::clear_parking_control_a5() {
  if (parking_control_a5_ != nullptr) parking_control_a5_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::canbus::Parking_control_a5& Zhongyun::_internal_parking_control_a5() const {
  const ::apollo::canbus::Parking_control_a5* p = parking_control_a5_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Parking_control_a5*>(
      &::apollo::canbus::_Parking_control_a5_default_instance_);
}
inline const ::apollo::canbus::Parking_control_a5& Zhongyun::parking_control_a5() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.parking_control_a5)
  return _internal_parking_control_a5();
}
inline ::apollo::canbus::Parking_control_a5* Zhongyun::release_parking_control_a5() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.parking_control_a5)
  _has_bits_[0] &= ~0x00000008u;
  ::apollo::canbus::Parking_control_a5* temp = parking_control_a5_;
  parking_control_a5_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Parking_control_a5* Zhongyun::_internal_mutable_parking_control_a5() {
  _has_bits_[0] |= 0x00000008u;
  if (parking_control_a5_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Parking_control_a5>(GetArenaNoVirtual());
    parking_control_a5_ = p;
  }
  return parking_control_a5_;
}
inline ::apollo::canbus::Parking_control_a5* Zhongyun::mutable_parking_control_a5() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.parking_control_a5)
  return _internal_mutable_parking_control_a5();
}
inline void Zhongyun::set_allocated_parking_control_a5(::apollo::canbus::Parking_control_a5* parking_control_a5) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete parking_control_a5_;
  }
  if (parking_control_a5) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      parking_control_a5 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parking_control_a5, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  parking_control_a5_ = parking_control_a5;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.parking_control_a5)
}

// optional .apollo.canbus.Brake_control_a4 brake_control_a4 = 5;
inline bool Zhongyun::_internal_has_brake_control_a4() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || brake_control_a4_ != nullptr);
  return value;
}
inline bool Zhongyun::has_brake_control_a4() const {
  return _internal_has_brake_control_a4();
}
inline void Zhongyun::clear_brake_control_a4() {
  if (brake_control_a4_ != nullptr) brake_control_a4_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::apollo::canbus::Brake_control_a4& Zhongyun::_internal_brake_control_a4() const {
  const ::apollo::canbus::Brake_control_a4* p = brake_control_a4_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Brake_control_a4*>(
      &::apollo::canbus::_Brake_control_a4_default_instance_);
}
inline const ::apollo::canbus::Brake_control_a4& Zhongyun::brake_control_a4() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.brake_control_a4)
  return _internal_brake_control_a4();
}
inline ::apollo::canbus::Brake_control_a4* Zhongyun::release_brake_control_a4() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.brake_control_a4)
  _has_bits_[0] &= ~0x00000010u;
  ::apollo::canbus::Brake_control_a4* temp = brake_control_a4_;
  brake_control_a4_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Brake_control_a4* Zhongyun::_internal_mutable_brake_control_a4() {
  _has_bits_[0] |= 0x00000010u;
  if (brake_control_a4_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Brake_control_a4>(GetArenaNoVirtual());
    brake_control_a4_ = p;
  }
  return brake_control_a4_;
}
inline ::apollo::canbus::Brake_control_a4* Zhongyun::mutable_brake_control_a4() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.brake_control_a4)
  return _internal_mutable_brake_control_a4();
}
inline void Zhongyun::set_allocated_brake_control_a4(::apollo::canbus::Brake_control_a4* brake_control_a4) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete brake_control_a4_;
  }
  if (brake_control_a4) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      brake_control_a4 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brake_control_a4, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  brake_control_a4_ = brake_control_a4;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.brake_control_a4)
}

// optional .apollo.canbus.Enable_state_feedback_c3 enable_state_feedback_c3 = 6;
inline bool Zhongyun::_internal_has_enable_state_feedback_c3() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || enable_state_feedback_c3_ != nullptr);
  return value;
}
inline bool Zhongyun::has_enable_state_feedback_c3() const {
  return _internal_has_enable_state_feedback_c3();
}
inline void Zhongyun::clear_enable_state_feedback_c3() {
  if (enable_state_feedback_c3_ != nullptr) enable_state_feedback_c3_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::apollo::canbus::Enable_state_feedback_c3& Zhongyun::_internal_enable_state_feedback_c3() const {
  const ::apollo::canbus::Enable_state_feedback_c3* p = enable_state_feedback_c3_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Enable_state_feedback_c3*>(
      &::apollo::canbus::_Enable_state_feedback_c3_default_instance_);
}
inline const ::apollo::canbus::Enable_state_feedback_c3& Zhongyun::enable_state_feedback_c3() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.enable_state_feedback_c3)
  return _internal_enable_state_feedback_c3();
}
inline ::apollo::canbus::Enable_state_feedback_c3* Zhongyun::release_enable_state_feedback_c3() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.enable_state_feedback_c3)
  _has_bits_[0] &= ~0x00000020u;
  ::apollo::canbus::Enable_state_feedback_c3* temp = enable_state_feedback_c3_;
  enable_state_feedback_c3_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Enable_state_feedback_c3* Zhongyun::_internal_mutable_enable_state_feedback_c3() {
  _has_bits_[0] |= 0x00000020u;
  if (enable_state_feedback_c3_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Enable_state_feedback_c3>(GetArenaNoVirtual());
    enable_state_feedback_c3_ = p;
  }
  return enable_state_feedback_c3_;
}
inline ::apollo::canbus::Enable_state_feedback_c3* Zhongyun::mutable_enable_state_feedback_c3() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.enable_state_feedback_c3)
  return _internal_mutable_enable_state_feedback_c3();
}
inline void Zhongyun::set_allocated_enable_state_feedback_c3(::apollo::canbus::Enable_state_feedback_c3* enable_state_feedback_c3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete enable_state_feedback_c3_;
  }
  if (enable_state_feedback_c3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      enable_state_feedback_c3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enable_state_feedback_c3, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  enable_state_feedback_c3_ = enable_state_feedback_c3;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.enable_state_feedback_c3)
}

// optional .apollo.canbus.Vehicle_state_feedback_c1 vehicle_state_feedback_c1 = 7;
inline bool Zhongyun::_internal_has_vehicle_state_feedback_c1() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || vehicle_state_feedback_c1_ != nullptr);
  return value;
}
inline bool Zhongyun::has_vehicle_state_feedback_c1() const {
  return _internal_has_vehicle_state_feedback_c1();
}
inline void Zhongyun::clear_vehicle_state_feedback_c1() {
  if (vehicle_state_feedback_c1_ != nullptr) vehicle_state_feedback_c1_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::apollo::canbus::Vehicle_state_feedback_c1& Zhongyun::_internal_vehicle_state_feedback_c1() const {
  const ::apollo::canbus::Vehicle_state_feedback_c1* p = vehicle_state_feedback_c1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Vehicle_state_feedback_c1*>(
      &::apollo::canbus::_Vehicle_state_feedback_c1_default_instance_);
}
inline const ::apollo::canbus::Vehicle_state_feedback_c1& Zhongyun::vehicle_state_feedback_c1() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.vehicle_state_feedback_c1)
  return _internal_vehicle_state_feedback_c1();
}
inline ::apollo::canbus::Vehicle_state_feedback_c1* Zhongyun::release_vehicle_state_feedback_c1() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.vehicle_state_feedback_c1)
  _has_bits_[0] &= ~0x00000040u;
  ::apollo::canbus::Vehicle_state_feedback_c1* temp = vehicle_state_feedback_c1_;
  vehicle_state_feedback_c1_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Vehicle_state_feedback_c1* Zhongyun::_internal_mutable_vehicle_state_feedback_c1() {
  _has_bits_[0] |= 0x00000040u;
  if (vehicle_state_feedback_c1_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Vehicle_state_feedback_c1>(GetArenaNoVirtual());
    vehicle_state_feedback_c1_ = p;
  }
  return vehicle_state_feedback_c1_;
}
inline ::apollo::canbus::Vehicle_state_feedback_c1* Zhongyun::mutable_vehicle_state_feedback_c1() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.vehicle_state_feedback_c1)
  return _internal_mutable_vehicle_state_feedback_c1();
}
inline void Zhongyun::set_allocated_vehicle_state_feedback_c1(::apollo::canbus::Vehicle_state_feedback_c1* vehicle_state_feedback_c1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vehicle_state_feedback_c1_;
  }
  if (vehicle_state_feedback_c1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vehicle_state_feedback_c1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle_state_feedback_c1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  vehicle_state_feedback_c1_ = vehicle_state_feedback_c1;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.vehicle_state_feedback_c1)
}

// optional .apollo.canbus.Error_state_e1 error_state_e1 = 8;
inline bool Zhongyun::_internal_has_error_state_e1() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || error_state_e1_ != nullptr);
  return value;
}
inline bool Zhongyun::has_error_state_e1() const {
  return _internal_has_error_state_e1();
}
inline void Zhongyun::clear_error_state_e1() {
  if (error_state_e1_ != nullptr) error_state_e1_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::apollo::canbus::Error_state_e1& Zhongyun::_internal_error_state_e1() const {
  const ::apollo::canbus::Error_state_e1* p = error_state_e1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Error_state_e1*>(
      &::apollo::canbus::_Error_state_e1_default_instance_);
}
inline const ::apollo::canbus::Error_state_e1& Zhongyun::error_state_e1() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.error_state_e1)
  return _internal_error_state_e1();
}
inline ::apollo::canbus::Error_state_e1* Zhongyun::release_error_state_e1() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.error_state_e1)
  _has_bits_[0] &= ~0x00000080u;
  ::apollo::canbus::Error_state_e1* temp = error_state_e1_;
  error_state_e1_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Error_state_e1* Zhongyun::_internal_mutable_error_state_e1() {
  _has_bits_[0] |= 0x00000080u;
  if (error_state_e1_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Error_state_e1>(GetArenaNoVirtual());
    error_state_e1_ = p;
  }
  return error_state_e1_;
}
inline ::apollo::canbus::Error_state_e1* Zhongyun::mutable_error_state_e1() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.error_state_e1)
  return _internal_mutable_error_state_e1();
}
inline void Zhongyun::set_allocated_error_state_e1(::apollo::canbus::Error_state_e1* error_state_e1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete error_state_e1_;
  }
  if (error_state_e1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      error_state_e1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error_state_e1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  error_state_e1_ = error_state_e1;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.error_state_e1)
}

// optional .apollo.canbus.Vehicle_state_feedback_2_c4 vehicle_state_feedback_2_c4 = 9;
inline bool Zhongyun::_internal_has_vehicle_state_feedback_2_c4() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || vehicle_state_feedback_2_c4_ != nullptr);
  return value;
}
inline bool Zhongyun::has_vehicle_state_feedback_2_c4() const {
  return _internal_has_vehicle_state_feedback_2_c4();
}
inline void Zhongyun::clear_vehicle_state_feedback_2_c4() {
  if (vehicle_state_feedback_2_c4_ != nullptr) vehicle_state_feedback_2_c4_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::apollo::canbus::Vehicle_state_feedback_2_c4& Zhongyun::_internal_vehicle_state_feedback_2_c4() const {
  const ::apollo::canbus::Vehicle_state_feedback_2_c4* p = vehicle_state_feedback_2_c4_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Vehicle_state_feedback_2_c4*>(
      &::apollo::canbus::_Vehicle_state_feedback_2_c4_default_instance_);
}
inline const ::apollo::canbus::Vehicle_state_feedback_2_c4& Zhongyun::vehicle_state_feedback_2_c4() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.vehicle_state_feedback_2_c4)
  return _internal_vehicle_state_feedback_2_c4();
}
inline ::apollo::canbus::Vehicle_state_feedback_2_c4* Zhongyun::release_vehicle_state_feedback_2_c4() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.vehicle_state_feedback_2_c4)
  _has_bits_[0] &= ~0x00000100u;
  ::apollo::canbus::Vehicle_state_feedback_2_c4* temp = vehicle_state_feedback_2_c4_;
  vehicle_state_feedback_2_c4_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Vehicle_state_feedback_2_c4* Zhongyun::_internal_mutable_vehicle_state_feedback_2_c4() {
  _has_bits_[0] |= 0x00000100u;
  if (vehicle_state_feedback_2_c4_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Vehicle_state_feedback_2_c4>(GetArenaNoVirtual());
    vehicle_state_feedback_2_c4_ = p;
  }
  return vehicle_state_feedback_2_c4_;
}
inline ::apollo::canbus::Vehicle_state_feedback_2_c4* Zhongyun::mutable_vehicle_state_feedback_2_c4() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.vehicle_state_feedback_2_c4)
  return _internal_mutable_vehicle_state_feedback_2_c4();
}
inline void Zhongyun::set_allocated_vehicle_state_feedback_2_c4(::apollo::canbus::Vehicle_state_feedback_2_c4* vehicle_state_feedback_2_c4) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vehicle_state_feedback_2_c4_;
  }
  if (vehicle_state_feedback_2_c4) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vehicle_state_feedback_2_c4 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle_state_feedback_2_c4, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  vehicle_state_feedback_2_c4_ = vehicle_state_feedback_2_c4;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.vehicle_state_feedback_2_c4)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace canbus
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::canbus::Gear_control_a1_Gear_state_targetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Gear_control_a1_Gear_state_targetType>() {
  return ::apollo::canbus::Gear_control_a1_Gear_state_targetType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Gear_control_a1_Gear_enable_controlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Gear_control_a1_Gear_enable_controlType>() {
  return ::apollo::canbus::Gear_control_a1_Gear_enable_controlType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Torque_control_a3_Driven_enable_controlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Torque_control_a3_Driven_enable_controlType>() {
  return ::apollo::canbus::Torque_control_a3_Driven_enable_controlType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Steering_control_a2_Steering_enable_controlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Steering_control_a2_Steering_enable_controlType>() {
  return ::apollo::canbus::Steering_control_a2_Steering_enable_controlType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Parking_control_a5_Parking_targetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Parking_control_a5_Parking_targetType>() {
  return ::apollo::canbus::Parking_control_a5_Parking_targetType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Parking_control_a5_Parking_enable_controlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Parking_control_a5_Parking_enable_controlType>() {
  return ::apollo::canbus::Parking_control_a5_Parking_enable_controlType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Brake_control_a4_Brake_enable_controlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Brake_control_a4_Brake_enable_controlType>() {
  return ::apollo::canbus::Brake_control_a4_Brake_enable_controlType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType>() {
  return ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType>() {
  return ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType>() {
  return ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType>() {
  return ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType>() {
  return ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType>() {
  return ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType>() {
  return ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Error_state_e1_Brake_error_codeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Error_state_e1_Brake_error_codeType>() {
  return ::apollo::canbus::Error_state_e1_Brake_error_codeType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Error_state_e1_Driven_error_codeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Error_state_e1_Driven_error_codeType>() {
  return ::apollo::canbus::Error_state_e1_Driven_error_codeType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Error_state_e1_Steering_error_codeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Error_state_e1_Steering_error_codeType>() {
  return ::apollo::canbus::Error_state_e1_Steering_error_codeType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Error_state_e1_Parking_error_codeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Error_state_e1_Parking_error_codeType>() {
  return ::apollo::canbus::Error_state_e1_Parking_error_codeType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Error_state_e1_Gear_error_msgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Error_state_e1_Gear_error_msgType>() {
  return ::apollo::canbus::Error_state_e1_Gear_error_msgType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fcanbus_2fproto_2fzhongyun_2eproto
