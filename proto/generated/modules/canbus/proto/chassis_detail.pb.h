// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/canbus/proto/chassis_detail.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/common/configs/proto/vehicle_config.pb.h"
#include "modules/canbus/proto/chassis.pb.h"
#include "modules/canbus/proto/ge3.pb.h"
#include "modules/canbus/proto/lexus.pb.h"
#include "modules/canbus/proto/transit.pb.h"
#include "modules/canbus/proto/wey.pb.h"
#include "modules/canbus/proto/zhongyun.pb.h"
#include "modules/canbus/proto/ch.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[46]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
namespace apollo {
namespace canbus {
class Accel_cmd_67;
class Accel_cmd_67DefaultTypeInternal;
extern Accel_cmd_67DefaultTypeInternal _Accel_cmd_67_default_instance_;
class Accel_rpt_68;
class Accel_rpt_68DefaultTypeInternal;
extern Accel_rpt_68DefaultTypeInternal _Accel_rpt_68_default_instance_;
class BasicInfo;
class BasicInfoDefaultTypeInternal;
extern BasicInfoDefaultTypeInternal _BasicInfo_default_instance_;
class Battery;
class BatteryDefaultTypeInternal;
extern BatteryDefaultTypeInternal _Battery_default_instance_;
class Brake;
class BrakeDefaultTypeInternal;
extern BrakeDefaultTypeInternal _Brake_default_instance_;
class Brake_cmd_6b;
class Brake_cmd_6bDefaultTypeInternal;
extern Brake_cmd_6bDefaultTypeInternal _Brake_cmd_6b_default_instance_;
class Brake_motor_rpt_1_70;
class Brake_motor_rpt_1_70DefaultTypeInternal;
extern Brake_motor_rpt_1_70DefaultTypeInternal _Brake_motor_rpt_1_70_default_instance_;
class Brake_motor_rpt_2_71;
class Brake_motor_rpt_2_71DefaultTypeInternal;
extern Brake_motor_rpt_2_71DefaultTypeInternal _Brake_motor_rpt_2_71_default_instance_;
class Brake_motor_rpt_3_72;
class Brake_motor_rpt_3_72DefaultTypeInternal;
extern Brake_motor_rpt_3_72DefaultTypeInternal _Brake_motor_rpt_3_72_default_instance_;
class Brake_rpt_6c;
class Brake_rpt_6cDefaultTypeInternal;
extern Brake_rpt_6cDefaultTypeInternal _Brake_rpt_6c_default_instance_;
class ChassisDetail;
class ChassisDetailDefaultTypeInternal;
extern ChassisDetailDefaultTypeInternal _ChassisDetail_default_instance_;
class CheckResponseSignal;
class CheckResponseSignalDefaultTypeInternal;
extern CheckResponseSignalDefaultTypeInternal _CheckResponseSignal_default_instance_;
class Date_time_rpt_83;
class Date_time_rpt_83DefaultTypeInternal;
extern Date_time_rpt_83DefaultTypeInternal _Date_time_rpt_83_default_instance_;
class Deceleration;
class DecelerationDefaultTypeInternal;
extern DecelerationDefaultTypeInternal _Deceleration_default_instance_;
class Ems;
class EmsDefaultTypeInternal;
extern EmsDefaultTypeInternal _Ems_default_instance_;
class Epb;
class EpbDefaultTypeInternal;
extern EpbDefaultTypeInternal _Epb_default_instance_;
class Eps;
class EpsDefaultTypeInternal;
extern EpsDefaultTypeInternal _Eps_default_instance_;
class Esp;
class EspDefaultTypeInternal;
extern EspDefaultTypeInternal _Esp_default_instance_;
class Gas;
class GasDefaultTypeInternal;
extern GasDefaultTypeInternal _Gas_default_instance_;
class Gear;
class GearDefaultTypeInternal;
extern GearDefaultTypeInternal _Gear_default_instance_;
class Gem;
class GemDefaultTypeInternal;
extern GemDefaultTypeInternal _Gem_default_instance_;
class Global_cmd_69;
class Global_cmd_69DefaultTypeInternal;
extern Global_cmd_69DefaultTypeInternal _Global_cmd_69_default_instance_;
class Global_rpt_6a;
class Global_rpt_6aDefaultTypeInternal;
extern Global_rpt_6aDefaultTypeInternal _Global_rpt_6a_default_instance_;
class Headlight_cmd_76;
class Headlight_cmd_76DefaultTypeInternal;
extern Headlight_cmd_76DefaultTypeInternal _Headlight_cmd_76_default_instance_;
class Headlight_rpt_77;
class Headlight_rpt_77DefaultTypeInternal;
extern Headlight_rpt_77DefaultTypeInternal _Headlight_rpt_77_default_instance_;
class Horn_cmd_78;
class Horn_cmd_78DefaultTypeInternal;
extern Horn_cmd_78DefaultTypeInternal _Horn_cmd_78_default_instance_;
class Horn_rpt_79;
class Horn_rpt_79DefaultTypeInternal;
extern Horn_rpt_79DefaultTypeInternal _Horn_rpt_79_default_instance_;
class Lat_lon_heading_rpt_82;
class Lat_lon_heading_rpt_82DefaultTypeInternal;
extern Lat_lon_heading_rpt_82DefaultTypeInternal _Lat_lon_heading_rpt_82_default_instance_;
class Light;
class LightDefaultTypeInternal;
extern LightDefaultTypeInternal _Light_default_instance_;
class Parking_brake_status_rpt_80;
class Parking_brake_status_rpt_80DefaultTypeInternal;
extern Parking_brake_status_rpt_80DefaultTypeInternal _Parking_brake_status_rpt_80_default_instance_;
class Safety;
class SafetyDefaultTypeInternal;
extern SafetyDefaultTypeInternal _Safety_default_instance_;
class Shift_cmd_65;
class Shift_cmd_65DefaultTypeInternal;
extern Shift_cmd_65DefaultTypeInternal _Shift_cmd_65_default_instance_;
class Shift_rpt_66;
class Shift_rpt_66DefaultTypeInternal;
extern Shift_rpt_66DefaultTypeInternal _Shift_rpt_66_default_instance_;
class Steering_cmd_6d;
class Steering_cmd_6dDefaultTypeInternal;
extern Steering_cmd_6dDefaultTypeInternal _Steering_cmd_6d_default_instance_;
class Steering_motor_rpt_1_73;
class Steering_motor_rpt_1_73DefaultTypeInternal;
extern Steering_motor_rpt_1_73DefaultTypeInternal _Steering_motor_rpt_1_73_default_instance_;
class Steering_motor_rpt_2_74;
class Steering_motor_rpt_2_74DefaultTypeInternal;
extern Steering_motor_rpt_2_74DefaultTypeInternal _Steering_motor_rpt_2_74_default_instance_;
class Steering_motor_rpt_3_75;
class Steering_motor_rpt_3_75DefaultTypeInternal;
extern Steering_motor_rpt_3_75DefaultTypeInternal _Steering_motor_rpt_3_75_default_instance_;
class Steering_rpt_1_6e;
class Steering_rpt_1_6eDefaultTypeInternal;
extern Steering_rpt_1_6eDefaultTypeInternal _Steering_rpt_1_6e_default_instance_;
class Turn_cmd_63;
class Turn_cmd_63DefaultTypeInternal;
extern Turn_cmd_63DefaultTypeInternal _Turn_cmd_63_default_instance_;
class Turn_rpt_64;
class Turn_rpt_64DefaultTypeInternal;
extern Turn_rpt_64DefaultTypeInternal _Turn_rpt_64_default_instance_;
class VehicleSpd;
class VehicleSpdDefaultTypeInternal;
extern VehicleSpdDefaultTypeInternal _VehicleSpd_default_instance_;
class Vehicle_speed_rpt_6f;
class Vehicle_speed_rpt_6fDefaultTypeInternal;
extern Vehicle_speed_rpt_6fDefaultTypeInternal _Vehicle_speed_rpt_6f_default_instance_;
class Wheel_speed_rpt_7a;
class Wheel_speed_rpt_7aDefaultTypeInternal;
extern Wheel_speed_rpt_7aDefaultTypeInternal _Wheel_speed_rpt_7a_default_instance_;
class Wiper_cmd_90;
class Wiper_cmd_90DefaultTypeInternal;
extern Wiper_cmd_90DefaultTypeInternal _Wiper_cmd_90_default_instance_;
class Wiper_rpt_91;
class Wiper_rpt_91DefaultTypeInternal;
extern Wiper_rpt_91DefaultTypeInternal _Wiper_rpt_91_default_instance_;
class Yaw_rate_rpt_81;
class Yaw_rate_rpt_81DefaultTypeInternal;
extern Yaw_rate_rpt_81DefaultTypeInternal _Yaw_rate_rpt_81_default_instance_;
}  // namespace canbus
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::canbus::Accel_cmd_67* Arena::CreateMaybeMessage<::apollo::canbus::Accel_cmd_67>(Arena*);
template<> ::apollo::canbus::Accel_rpt_68* Arena::CreateMaybeMessage<::apollo::canbus::Accel_rpt_68>(Arena*);
template<> ::apollo::canbus::BasicInfo* Arena::CreateMaybeMessage<::apollo::canbus::BasicInfo>(Arena*);
template<> ::apollo::canbus::Battery* Arena::CreateMaybeMessage<::apollo::canbus::Battery>(Arena*);
template<> ::apollo::canbus::Brake* Arena::CreateMaybeMessage<::apollo::canbus::Brake>(Arena*);
template<> ::apollo::canbus::Brake_cmd_6b* Arena::CreateMaybeMessage<::apollo::canbus::Brake_cmd_6b>(Arena*);
template<> ::apollo::canbus::Brake_motor_rpt_1_70* Arena::CreateMaybeMessage<::apollo::canbus::Brake_motor_rpt_1_70>(Arena*);
template<> ::apollo::canbus::Brake_motor_rpt_2_71* Arena::CreateMaybeMessage<::apollo::canbus::Brake_motor_rpt_2_71>(Arena*);
template<> ::apollo::canbus::Brake_motor_rpt_3_72* Arena::CreateMaybeMessage<::apollo::canbus::Brake_motor_rpt_3_72>(Arena*);
template<> ::apollo::canbus::Brake_rpt_6c* Arena::CreateMaybeMessage<::apollo::canbus::Brake_rpt_6c>(Arena*);
template<> ::apollo::canbus::ChassisDetail* Arena::CreateMaybeMessage<::apollo::canbus::ChassisDetail>(Arena*);
template<> ::apollo::canbus::CheckResponseSignal* Arena::CreateMaybeMessage<::apollo::canbus::CheckResponseSignal>(Arena*);
template<> ::apollo::canbus::Date_time_rpt_83* Arena::CreateMaybeMessage<::apollo::canbus::Date_time_rpt_83>(Arena*);
template<> ::apollo::canbus::Deceleration* Arena::CreateMaybeMessage<::apollo::canbus::Deceleration>(Arena*);
template<> ::apollo::canbus::Ems* Arena::CreateMaybeMessage<::apollo::canbus::Ems>(Arena*);
template<> ::apollo::canbus::Epb* Arena::CreateMaybeMessage<::apollo::canbus::Epb>(Arena*);
template<> ::apollo::canbus::Eps* Arena::CreateMaybeMessage<::apollo::canbus::Eps>(Arena*);
template<> ::apollo::canbus::Esp* Arena::CreateMaybeMessage<::apollo::canbus::Esp>(Arena*);
template<> ::apollo::canbus::Gas* Arena::CreateMaybeMessage<::apollo::canbus::Gas>(Arena*);
template<> ::apollo::canbus::Gear* Arena::CreateMaybeMessage<::apollo::canbus::Gear>(Arena*);
template<> ::apollo::canbus::Gem* Arena::CreateMaybeMessage<::apollo::canbus::Gem>(Arena*);
template<> ::apollo::canbus::Global_cmd_69* Arena::CreateMaybeMessage<::apollo::canbus::Global_cmd_69>(Arena*);
template<> ::apollo::canbus::Global_rpt_6a* Arena::CreateMaybeMessage<::apollo::canbus::Global_rpt_6a>(Arena*);
template<> ::apollo::canbus::Headlight_cmd_76* Arena::CreateMaybeMessage<::apollo::canbus::Headlight_cmd_76>(Arena*);
template<> ::apollo::canbus::Headlight_rpt_77* Arena::CreateMaybeMessage<::apollo::canbus::Headlight_rpt_77>(Arena*);
template<> ::apollo::canbus::Horn_cmd_78* Arena::CreateMaybeMessage<::apollo::canbus::Horn_cmd_78>(Arena*);
template<> ::apollo::canbus::Horn_rpt_79* Arena::CreateMaybeMessage<::apollo::canbus::Horn_rpt_79>(Arena*);
template<> ::apollo::canbus::Lat_lon_heading_rpt_82* Arena::CreateMaybeMessage<::apollo::canbus::Lat_lon_heading_rpt_82>(Arena*);
template<> ::apollo::canbus::Light* Arena::CreateMaybeMessage<::apollo::canbus::Light>(Arena*);
template<> ::apollo::canbus::Parking_brake_status_rpt_80* Arena::CreateMaybeMessage<::apollo::canbus::Parking_brake_status_rpt_80>(Arena*);
template<> ::apollo::canbus::Safety* Arena::CreateMaybeMessage<::apollo::canbus::Safety>(Arena*);
template<> ::apollo::canbus::Shift_cmd_65* Arena::CreateMaybeMessage<::apollo::canbus::Shift_cmd_65>(Arena*);
template<> ::apollo::canbus::Shift_rpt_66* Arena::CreateMaybeMessage<::apollo::canbus::Shift_rpt_66>(Arena*);
template<> ::apollo::canbus::Steering_cmd_6d* Arena::CreateMaybeMessage<::apollo::canbus::Steering_cmd_6d>(Arena*);
template<> ::apollo::canbus::Steering_motor_rpt_1_73* Arena::CreateMaybeMessage<::apollo::canbus::Steering_motor_rpt_1_73>(Arena*);
template<> ::apollo::canbus::Steering_motor_rpt_2_74* Arena::CreateMaybeMessage<::apollo::canbus::Steering_motor_rpt_2_74>(Arena*);
template<> ::apollo::canbus::Steering_motor_rpt_3_75* Arena::CreateMaybeMessage<::apollo::canbus::Steering_motor_rpt_3_75>(Arena*);
template<> ::apollo::canbus::Steering_rpt_1_6e* Arena::CreateMaybeMessage<::apollo::canbus::Steering_rpt_1_6e>(Arena*);
template<> ::apollo::canbus::Turn_cmd_63* Arena::CreateMaybeMessage<::apollo::canbus::Turn_cmd_63>(Arena*);
template<> ::apollo::canbus::Turn_rpt_64* Arena::CreateMaybeMessage<::apollo::canbus::Turn_rpt_64>(Arena*);
template<> ::apollo::canbus::VehicleSpd* Arena::CreateMaybeMessage<::apollo::canbus::VehicleSpd>(Arena*);
template<> ::apollo::canbus::Vehicle_speed_rpt_6f* Arena::CreateMaybeMessage<::apollo::canbus::Vehicle_speed_rpt_6f>(Arena*);
template<> ::apollo::canbus::Wheel_speed_rpt_7a* Arena::CreateMaybeMessage<::apollo::canbus::Wheel_speed_rpt_7a>(Arena*);
template<> ::apollo::canbus::Wiper_cmd_90* Arena::CreateMaybeMessage<::apollo::canbus::Wiper_cmd_90>(Arena*);
template<> ::apollo::canbus::Wiper_rpt_91* Arena::CreateMaybeMessage<::apollo::canbus::Wiper_rpt_91>(Arena*);
template<> ::apollo::canbus::Yaw_rate_rpt_81* Arena::CreateMaybeMessage<::apollo::canbus::Yaw_rate_rpt_81>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace canbus {

enum ChassisDetail_Type : int {
  ChassisDetail_Type_QIRUI_EQ_15 = 0,
  ChassisDetail_Type_CHANGAN_RUICHENG = 1
};
bool ChassisDetail_Type_IsValid(int value);
constexpr ChassisDetail_Type ChassisDetail_Type_Type_MIN = ChassisDetail_Type_QIRUI_EQ_15;
constexpr ChassisDetail_Type ChassisDetail_Type_Type_MAX = ChassisDetail_Type_CHANGAN_RUICHENG;
constexpr int ChassisDetail_Type_Type_ARRAYSIZE = ChassisDetail_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChassisDetail_Type_descriptor();
template<typename T>
inline const std::string& ChassisDetail_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChassisDetail_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChassisDetail_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChassisDetail_Type_descriptor(), enum_t_value);
}
inline bool ChassisDetail_Type_Parse(
    const std::string& name, ChassisDetail_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChassisDetail_Type>(
    ChassisDetail_Type_descriptor(), name, value);
}
enum Light_TurnLightType : int {
  Light_TurnLightType_TURN_LIGHT_OFF = 0,
  Light_TurnLightType_TURN_LEFT_ON = 1,
  Light_TurnLightType_TURN_RIGHT_ON = 2,
  Light_TurnLightType_TURN_LIGHT_ON = 3
};
bool Light_TurnLightType_IsValid(int value);
constexpr Light_TurnLightType Light_TurnLightType_TurnLightType_MIN = Light_TurnLightType_TURN_LIGHT_OFF;
constexpr Light_TurnLightType Light_TurnLightType_TurnLightType_MAX = Light_TurnLightType_TURN_LIGHT_ON;
constexpr int Light_TurnLightType_TurnLightType_ARRAYSIZE = Light_TurnLightType_TurnLightType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Light_TurnLightType_descriptor();
template<typename T>
inline const std::string& Light_TurnLightType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Light_TurnLightType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Light_TurnLightType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Light_TurnLightType_descriptor(), enum_t_value);
}
inline bool Light_TurnLightType_Parse(
    const std::string& name, Light_TurnLightType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Light_TurnLightType>(
    Light_TurnLightType_descriptor(), name, value);
}
enum Light_BeamLampType : int {
  Light_BeamLampType_BEAM_OFF = 0,
  Light_BeamLampType_HIGH_BEAM_ON = 1,
  Light_BeamLampType_LOW_BEAM_ON = 2
};
bool Light_BeamLampType_IsValid(int value);
constexpr Light_BeamLampType Light_BeamLampType_BeamLampType_MIN = Light_BeamLampType_BEAM_OFF;
constexpr Light_BeamLampType Light_BeamLampType_BeamLampType_MAX = Light_BeamLampType_LOW_BEAM_ON;
constexpr int Light_BeamLampType_BeamLampType_ARRAYSIZE = Light_BeamLampType_BeamLampType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Light_BeamLampType_descriptor();
template<typename T>
inline const std::string& Light_BeamLampType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Light_BeamLampType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Light_BeamLampType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Light_BeamLampType_descriptor(), enum_t_value);
}
inline bool Light_BeamLampType_Parse(
    const std::string& name, Light_BeamLampType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Light_BeamLampType>(
    Light_BeamLampType_descriptor(), name, value);
}
enum Light_LincolnLampType : int {
  Light_LincolnLampType_BEAM_NULL = 0,
  Light_LincolnLampType_BEAM_FLASH_TO_PASS = 1,
  Light_LincolnLampType_BEAM_HIGH = 2,
  Light_LincolnLampType_BEAM_INVALID = 3
};
bool Light_LincolnLampType_IsValid(int value);
constexpr Light_LincolnLampType Light_LincolnLampType_LincolnLampType_MIN = Light_LincolnLampType_BEAM_NULL;
constexpr Light_LincolnLampType Light_LincolnLampType_LincolnLampType_MAX = Light_LincolnLampType_BEAM_INVALID;
constexpr int Light_LincolnLampType_LincolnLampType_ARRAYSIZE = Light_LincolnLampType_LincolnLampType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Light_LincolnLampType_descriptor();
template<typename T>
inline const std::string& Light_LincolnLampType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Light_LincolnLampType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Light_LincolnLampType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Light_LincolnLampType_descriptor(), enum_t_value);
}
inline bool Light_LincolnLampType_Parse(
    const std::string& name, Light_LincolnLampType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Light_LincolnLampType>(
    Light_LincolnLampType_descriptor(), name, value);
}
enum Light_LincolnWiperType : int {
  Light_LincolnWiperType_WIPER_OFF = 0,
  Light_LincolnWiperType_WIPER_AUTO_OFF = 1,
  Light_LincolnWiperType_WIPER_OFF_MOVING = 2,
  Light_LincolnWiperType_WIPER_MANUAL_OFF = 3,
  Light_LincolnWiperType_WIPER_MANUAL_ON = 4,
  Light_LincolnWiperType_WIPER_MANUAL_LOW = 5,
  Light_LincolnWiperType_WIPER_MANUAL_HIGH = 6,
  Light_LincolnWiperType_WIPER_MIST_FLICK = 7,
  Light_LincolnWiperType_WIPER_WASH = 8,
  Light_LincolnWiperType_WIPER_AUTO_LOW = 9,
  Light_LincolnWiperType_WIPER_AUTO_HIGH = 10,
  Light_LincolnWiperType_WIPER_COURTESY_WIPE = 11,
  Light_LincolnWiperType_WIPER_AUTO_ADJUST = 12,
  Light_LincolnWiperType_WIPER_RESERVED = 13,
  Light_LincolnWiperType_WIPER_STALLED = 14,
  Light_LincolnWiperType_WIPER_NO_DATA = 15
};
bool Light_LincolnWiperType_IsValid(int value);
constexpr Light_LincolnWiperType Light_LincolnWiperType_LincolnWiperType_MIN = Light_LincolnWiperType_WIPER_OFF;
constexpr Light_LincolnWiperType Light_LincolnWiperType_LincolnWiperType_MAX = Light_LincolnWiperType_WIPER_NO_DATA;
constexpr int Light_LincolnWiperType_LincolnWiperType_ARRAYSIZE = Light_LincolnWiperType_LincolnWiperType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Light_LincolnWiperType_descriptor();
template<typename T>
inline const std::string& Light_LincolnWiperType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Light_LincolnWiperType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Light_LincolnWiperType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Light_LincolnWiperType_descriptor(), enum_t_value);
}
inline bool Light_LincolnWiperType_Parse(
    const std::string& name, Light_LincolnWiperType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Light_LincolnWiperType>(
    Light_LincolnWiperType_descriptor(), name, value);
}
enum Light_LincolnAmbientType : int {
  Light_LincolnAmbientType_AMBIENT_DARK = 0,
  Light_LincolnAmbientType_AMBIENT_LIGHT = 1,
  Light_LincolnAmbientType_AMBIENT_TWILIGHT = 2,
  Light_LincolnAmbientType_AMBIENT_TUNNEL_ON = 3,
  Light_LincolnAmbientType_AMBIENT_TUNNEL_OFF = 4,
  Light_LincolnAmbientType_AMBIENT_INVALID = 5,
  Light_LincolnAmbientType_AMBIENT_NO_DATA = 7
};
bool Light_LincolnAmbientType_IsValid(int value);
constexpr Light_LincolnAmbientType Light_LincolnAmbientType_LincolnAmbientType_MIN = Light_LincolnAmbientType_AMBIENT_DARK;
constexpr Light_LincolnAmbientType Light_LincolnAmbientType_LincolnAmbientType_MAX = Light_LincolnAmbientType_AMBIENT_NO_DATA;
constexpr int Light_LincolnAmbientType_LincolnAmbientType_ARRAYSIZE = Light_LincolnAmbientType_LincolnAmbientType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Light_LincolnAmbientType_descriptor();
template<typename T>
inline const std::string& Light_LincolnAmbientType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Light_LincolnAmbientType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Light_LincolnAmbientType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Light_LincolnAmbientType_descriptor(), enum_t_value);
}
inline bool Light_LincolnAmbientType_Parse(
    const std::string& name, Light_LincolnAmbientType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Light_LincolnAmbientType>(
    Light_LincolnAmbientType_descriptor(), name, value);
}
enum Eps_Type : int {
  Eps_Type_NOT_AVAILABLE = 0,
  Eps_Type_READY = 1,
  Eps_Type_ACTIVE = 2,
  Eps_Type_INVALID = 3
};
bool Eps_Type_IsValid(int value);
constexpr Eps_Type Eps_Type_Type_MIN = Eps_Type_NOT_AVAILABLE;
constexpr Eps_Type Eps_Type_Type_MAX = Eps_Type_INVALID;
constexpr int Eps_Type_Type_ARRAYSIZE = Eps_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Eps_Type_descriptor();
template<typename T>
inline const std::string& Eps_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Eps_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Eps_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Eps_Type_descriptor(), enum_t_value);
}
inline bool Eps_Type_Parse(
    const std::string& name, Eps_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Eps_Type>(
    Eps_Type_descriptor(), name, value);
}
enum Brake_HSAStatusType : int {
  Brake_HSAStatusType_HSA_INACTIVE = 0,
  Brake_HSAStatusType_HSA_FINDING_GRADIENT = 1,
  Brake_HSAStatusType_HSA_ACTIVE_PRESSED = 2,
  Brake_HSAStatusType_HSA_ACTIVE_RELEASED = 3,
  Brake_HSAStatusType_HSA_FAST_RELEASE = 4,
  Brake_HSAStatusType_HSA_SLOW_RELEASE = 5,
  Brake_HSAStatusType_HSA_FAILED = 6,
  Brake_HSAStatusType_HSA_UNDEFINED = 7
};
bool Brake_HSAStatusType_IsValid(int value);
constexpr Brake_HSAStatusType Brake_HSAStatusType_HSAStatusType_MIN = Brake_HSAStatusType_HSA_INACTIVE;
constexpr Brake_HSAStatusType Brake_HSAStatusType_HSAStatusType_MAX = Brake_HSAStatusType_HSA_UNDEFINED;
constexpr int Brake_HSAStatusType_HSAStatusType_ARRAYSIZE = Brake_HSAStatusType_HSAStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Brake_HSAStatusType_descriptor();
template<typename T>
inline const std::string& Brake_HSAStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Brake_HSAStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Brake_HSAStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Brake_HSAStatusType_descriptor(), enum_t_value);
}
inline bool Brake_HSAStatusType_Parse(
    const std::string& name, Brake_HSAStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Brake_HSAStatusType>(
    Brake_HSAStatusType_descriptor(), name, value);
}
enum Brake_HSAModeType : int {
  Brake_HSAModeType_HSA_OFF = 0,
  Brake_HSAModeType_HSA_AUTO = 1,
  Brake_HSAModeType_HSA_MANUAL = 2,
  Brake_HSAModeType_HSA_MODE_UNDEFINED = 3
};
bool Brake_HSAModeType_IsValid(int value);
constexpr Brake_HSAModeType Brake_HSAModeType_HSAModeType_MIN = Brake_HSAModeType_HSA_OFF;
constexpr Brake_HSAModeType Brake_HSAModeType_HSAModeType_MAX = Brake_HSAModeType_HSA_MODE_UNDEFINED;
constexpr int Brake_HSAModeType_HSAModeType_ARRAYSIZE = Brake_HSAModeType_HSAModeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Brake_HSAModeType_descriptor();
template<typename T>
inline const std::string& Brake_HSAModeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Brake_HSAModeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Brake_HSAModeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Brake_HSAModeType_descriptor(), enum_t_value);
}
inline bool Brake_HSAModeType_Parse(
    const std::string& name, Brake_HSAModeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Brake_HSAModeType>(
    Brake_HSAModeType_descriptor(), name, value);
}
enum Epb_PBrakeType : int {
  Epb_PBrakeType_PBRAKE_OFF = 0,
  Epb_PBrakeType_PBRAKE_TRANSITION = 1,
  Epb_PBrakeType_PBRAKE_ON = 2,
  Epb_PBrakeType_PBRAKE_FAULT = 3
};
bool Epb_PBrakeType_IsValid(int value);
constexpr Epb_PBrakeType Epb_PBrakeType_PBrakeType_MIN = Epb_PBrakeType_PBRAKE_OFF;
constexpr Epb_PBrakeType Epb_PBrakeType_PBrakeType_MAX = Epb_PBrakeType_PBRAKE_FAULT;
constexpr int Epb_PBrakeType_PBrakeType_ARRAYSIZE = Epb_PBrakeType_PBrakeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Epb_PBrakeType_descriptor();
template<typename T>
inline const std::string& Epb_PBrakeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Epb_PBrakeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Epb_PBrakeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Epb_PBrakeType_descriptor(), enum_t_value);
}
inline bool Epb_PBrakeType_Parse(
    const std::string& name, Epb_PBrakeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Epb_PBrakeType>(
    Epb_PBrakeType_descriptor(), name, value);
}
enum Ems_Type : int {
  Ems_Type_STOP = 0,
  Ems_Type_CRANK = 1,
  Ems_Type_RUNNING = 2,
  Ems_Type_INVALID = 3
};
bool Ems_Type_IsValid(int value);
constexpr Ems_Type Ems_Type_Type_MIN = Ems_Type_STOP;
constexpr Ems_Type Ems_Type_Type_MAX = Ems_Type_INVALID;
constexpr int Ems_Type_Type_ARRAYSIZE = Ems_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Ems_Type_descriptor();
template<typename T>
inline const std::string& Ems_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Ems_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Ems_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Ems_Type_descriptor(), enum_t_value);
}
inline bool Ems_Type_Parse(
    const std::string& name, Ems_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Ems_Type>(
    Ems_Type_descriptor(), name, value);
}
enum BasicInfo_Type : int {
  BasicInfo_Type_OFF = 0,
  BasicInfo_Type_ACC = 1,
  BasicInfo_Type_ON = 2,
  BasicInfo_Type_START = 3,
  BasicInfo_Type_INVALID = 4
};
bool BasicInfo_Type_IsValid(int value);
constexpr BasicInfo_Type BasicInfo_Type_Type_MIN = BasicInfo_Type_OFF;
constexpr BasicInfo_Type BasicInfo_Type_Type_MAX = BasicInfo_Type_INVALID;
constexpr int BasicInfo_Type_Type_ARRAYSIZE = BasicInfo_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BasicInfo_Type_descriptor();
template<typename T>
inline const std::string& BasicInfo_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BasicInfo_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BasicInfo_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BasicInfo_Type_descriptor(), enum_t_value);
}
inline bool BasicInfo_Type_Parse(
    const std::string& name, BasicInfo_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BasicInfo_Type>(
    BasicInfo_Type_descriptor(), name, value);
}
enum Global_rpt_6a_Pacmod_statusType : int {
  Global_rpt_6a_Pacmod_statusType_PACMOD_STATUS_CONTROL_DISABLED = 0,
  Global_rpt_6a_Pacmod_statusType_PACMOD_STATUS_CONTROL_ENABLED = 1
};
bool Global_rpt_6a_Pacmod_statusType_IsValid(int value);
constexpr Global_rpt_6a_Pacmod_statusType Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_MIN = Global_rpt_6a_Pacmod_statusType_PACMOD_STATUS_CONTROL_DISABLED;
constexpr Global_rpt_6a_Pacmod_statusType Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_MAX = Global_rpt_6a_Pacmod_statusType_PACMOD_STATUS_CONTROL_ENABLED;
constexpr int Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_ARRAYSIZE = Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Global_rpt_6a_Pacmod_statusType_descriptor();
template<typename T>
inline const std::string& Global_rpt_6a_Pacmod_statusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Global_rpt_6a_Pacmod_statusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Global_rpt_6a_Pacmod_statusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Global_rpt_6a_Pacmod_statusType_descriptor(), enum_t_value);
}
inline bool Global_rpt_6a_Pacmod_statusType_Parse(
    const std::string& name, Global_rpt_6a_Pacmod_statusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Global_rpt_6a_Pacmod_statusType>(
    Global_rpt_6a_Pacmod_statusType_descriptor(), name, value);
}
enum Global_rpt_6a_Override_statusType : int {
  Global_rpt_6a_Override_statusType_OVERRIDE_STATUS_NOT_OVERRIDDEN = 0,
  Global_rpt_6a_Override_statusType_OVERRIDE_STATUS_OVERRIDDEN = 1
};
bool Global_rpt_6a_Override_statusType_IsValid(int value);
constexpr Global_rpt_6a_Override_statusType Global_rpt_6a_Override_statusType_Override_statusType_MIN = Global_rpt_6a_Override_statusType_OVERRIDE_STATUS_NOT_OVERRIDDEN;
constexpr Global_rpt_6a_Override_statusType Global_rpt_6a_Override_statusType_Override_statusType_MAX = Global_rpt_6a_Override_statusType_OVERRIDE_STATUS_OVERRIDDEN;
constexpr int Global_rpt_6a_Override_statusType_Override_statusType_ARRAYSIZE = Global_rpt_6a_Override_statusType_Override_statusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Global_rpt_6a_Override_statusType_descriptor();
template<typename T>
inline const std::string& Global_rpt_6a_Override_statusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Global_rpt_6a_Override_statusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Global_rpt_6a_Override_statusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Global_rpt_6a_Override_statusType_descriptor(), enum_t_value);
}
inline bool Global_rpt_6a_Override_statusType_Parse(
    const std::string& name, Global_rpt_6a_Override_statusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Global_rpt_6a_Override_statusType>(
    Global_rpt_6a_Override_statusType_descriptor(), name, value);
}
enum Global_rpt_6a_Brk_can_timeoutType : int {
  Global_rpt_6a_Brk_can_timeoutType_BRK_CAN_TIMEOUT_NO_ACTIVE_CAN_TIMEOUT = 0,
  Global_rpt_6a_Brk_can_timeoutType_BRK_CAN_TIMEOUT_ACTIVE_CAN_TIMEOUT = 1
};
bool Global_rpt_6a_Brk_can_timeoutType_IsValid(int value);
constexpr Global_rpt_6a_Brk_can_timeoutType Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_MIN = Global_rpt_6a_Brk_can_timeoutType_BRK_CAN_TIMEOUT_NO_ACTIVE_CAN_TIMEOUT;
constexpr Global_rpt_6a_Brk_can_timeoutType Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_MAX = Global_rpt_6a_Brk_can_timeoutType_BRK_CAN_TIMEOUT_ACTIVE_CAN_TIMEOUT;
constexpr int Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_ARRAYSIZE = Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Global_rpt_6a_Brk_can_timeoutType_descriptor();
template<typename T>
inline const std::string& Global_rpt_6a_Brk_can_timeoutType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Global_rpt_6a_Brk_can_timeoutType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Global_rpt_6a_Brk_can_timeoutType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Global_rpt_6a_Brk_can_timeoutType_descriptor(), enum_t_value);
}
inline bool Global_rpt_6a_Brk_can_timeoutType_Parse(
    const std::string& name, Global_rpt_6a_Brk_can_timeoutType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Global_rpt_6a_Brk_can_timeoutType>(
    Global_rpt_6a_Brk_can_timeoutType_descriptor(), name, value);
}
enum Brake_rpt_6c_Brake_on_offType : int {
  Brake_rpt_6c_Brake_on_offType_BRAKE_ON_OFF_OFF = 0,
  Brake_rpt_6c_Brake_on_offType_BRAKE_ON_OFF_ON = 1
};
bool Brake_rpt_6c_Brake_on_offType_IsValid(int value);
constexpr Brake_rpt_6c_Brake_on_offType Brake_rpt_6c_Brake_on_offType_Brake_on_offType_MIN = Brake_rpt_6c_Brake_on_offType_BRAKE_ON_OFF_OFF;
constexpr Brake_rpt_6c_Brake_on_offType Brake_rpt_6c_Brake_on_offType_Brake_on_offType_MAX = Brake_rpt_6c_Brake_on_offType_BRAKE_ON_OFF_ON;
constexpr int Brake_rpt_6c_Brake_on_offType_Brake_on_offType_ARRAYSIZE = Brake_rpt_6c_Brake_on_offType_Brake_on_offType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Brake_rpt_6c_Brake_on_offType_descriptor();
template<typename T>
inline const std::string& Brake_rpt_6c_Brake_on_offType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Brake_rpt_6c_Brake_on_offType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Brake_rpt_6c_Brake_on_offType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Brake_rpt_6c_Brake_on_offType_descriptor(), enum_t_value);
}
inline bool Brake_rpt_6c_Brake_on_offType_Parse(
    const std::string& name, Brake_rpt_6c_Brake_on_offType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Brake_rpt_6c_Brake_on_offType>(
    Brake_rpt_6c_Brake_on_offType_descriptor(), name, value);
}
enum Headlight_rpt_77_Output_valueType : int {
  Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_HEADLIGHTS_OFF = 0,
  Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_LOW_BEAMS = 1,
  Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_HIGH_BEAMS = 2
};
bool Headlight_rpt_77_Output_valueType_IsValid(int value);
constexpr Headlight_rpt_77_Output_valueType Headlight_rpt_77_Output_valueType_Output_valueType_MIN = Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_HEADLIGHTS_OFF;
constexpr Headlight_rpt_77_Output_valueType Headlight_rpt_77_Output_valueType_Output_valueType_MAX = Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_HIGH_BEAMS;
constexpr int Headlight_rpt_77_Output_valueType_Output_valueType_ARRAYSIZE = Headlight_rpt_77_Output_valueType_Output_valueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Headlight_rpt_77_Output_valueType_descriptor();
template<typename T>
inline const std::string& Headlight_rpt_77_Output_valueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Headlight_rpt_77_Output_valueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Headlight_rpt_77_Output_valueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Headlight_rpt_77_Output_valueType_descriptor(), enum_t_value);
}
inline bool Headlight_rpt_77_Output_valueType_Parse(
    const std::string& name, Headlight_rpt_77_Output_valueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Headlight_rpt_77_Output_valueType>(
    Headlight_rpt_77_Output_valueType_descriptor(), name, value);
}
enum Headlight_rpt_77_Manual_inputType : int {
  Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_HEADLIGHTS_OFF = 0,
  Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_LOW_BEAMS = 1,
  Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_HIGH_BEAMS = 2
};
bool Headlight_rpt_77_Manual_inputType_IsValid(int value);
constexpr Headlight_rpt_77_Manual_inputType Headlight_rpt_77_Manual_inputType_Manual_inputType_MIN = Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_HEADLIGHTS_OFF;
constexpr Headlight_rpt_77_Manual_inputType Headlight_rpt_77_Manual_inputType_Manual_inputType_MAX = Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_HIGH_BEAMS;
constexpr int Headlight_rpt_77_Manual_inputType_Manual_inputType_ARRAYSIZE = Headlight_rpt_77_Manual_inputType_Manual_inputType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Headlight_rpt_77_Manual_inputType_descriptor();
template<typename T>
inline const std::string& Headlight_rpt_77_Manual_inputType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Headlight_rpt_77_Manual_inputType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Headlight_rpt_77_Manual_inputType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Headlight_rpt_77_Manual_inputType_descriptor(), enum_t_value);
}
inline bool Headlight_rpt_77_Manual_inputType_Parse(
    const std::string& name, Headlight_rpt_77_Manual_inputType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Headlight_rpt_77_Manual_inputType>(
    Headlight_rpt_77_Manual_inputType_descriptor(), name, value);
}
enum Headlight_rpt_77_Commanded_valueType : int {
  Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_HEADLIGHTS_OFF = 0,
  Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_LOW_BEAMS = 1,
  Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_HIGH_BEAMS = 2
};
bool Headlight_rpt_77_Commanded_valueType_IsValid(int value);
constexpr Headlight_rpt_77_Commanded_valueType Headlight_rpt_77_Commanded_valueType_Commanded_valueType_MIN = Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_HEADLIGHTS_OFF;
constexpr Headlight_rpt_77_Commanded_valueType Headlight_rpt_77_Commanded_valueType_Commanded_valueType_MAX = Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_HIGH_BEAMS;
constexpr int Headlight_rpt_77_Commanded_valueType_Commanded_valueType_ARRAYSIZE = Headlight_rpt_77_Commanded_valueType_Commanded_valueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Headlight_rpt_77_Commanded_valueType_descriptor();
template<typename T>
inline const std::string& Headlight_rpt_77_Commanded_valueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Headlight_rpt_77_Commanded_valueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Headlight_rpt_77_Commanded_valueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Headlight_rpt_77_Commanded_valueType_descriptor(), enum_t_value);
}
inline bool Headlight_rpt_77_Commanded_valueType_Parse(
    const std::string& name, Headlight_rpt_77_Commanded_valueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Headlight_rpt_77_Commanded_valueType>(
    Headlight_rpt_77_Commanded_valueType_descriptor(), name, value);
}
enum Turn_cmd_63_Turn_signal_cmdType : int {
  Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_RIGHT = 0,
  Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_NONE = 1,
  Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_LEFT = 2,
  Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_HAZARD = 3
};
bool Turn_cmd_63_Turn_signal_cmdType_IsValid(int value);
constexpr Turn_cmd_63_Turn_signal_cmdType Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_MIN = Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_RIGHT;
constexpr Turn_cmd_63_Turn_signal_cmdType Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_MAX = Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_HAZARD;
constexpr int Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_ARRAYSIZE = Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Turn_cmd_63_Turn_signal_cmdType_descriptor();
template<typename T>
inline const std::string& Turn_cmd_63_Turn_signal_cmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Turn_cmd_63_Turn_signal_cmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Turn_cmd_63_Turn_signal_cmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Turn_cmd_63_Turn_signal_cmdType_descriptor(), enum_t_value);
}
inline bool Turn_cmd_63_Turn_signal_cmdType_Parse(
    const std::string& name, Turn_cmd_63_Turn_signal_cmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Turn_cmd_63_Turn_signal_cmdType>(
    Turn_cmd_63_Turn_signal_cmdType_descriptor(), name, value);
}
enum Turn_rpt_64_Manual_inputType : int {
  Turn_rpt_64_Manual_inputType_MANUAL_INPUT_RIGHT = 0,
  Turn_rpt_64_Manual_inputType_MANUAL_INPUT_NONE = 1,
  Turn_rpt_64_Manual_inputType_MANUAL_INPUT_LEFT = 2,
  Turn_rpt_64_Manual_inputType_MANUAL_INPUT_HAZARD = 3
};
bool Turn_rpt_64_Manual_inputType_IsValid(int value);
constexpr Turn_rpt_64_Manual_inputType Turn_rpt_64_Manual_inputType_Manual_inputType_MIN = Turn_rpt_64_Manual_inputType_MANUAL_INPUT_RIGHT;
constexpr Turn_rpt_64_Manual_inputType Turn_rpt_64_Manual_inputType_Manual_inputType_MAX = Turn_rpt_64_Manual_inputType_MANUAL_INPUT_HAZARD;
constexpr int Turn_rpt_64_Manual_inputType_Manual_inputType_ARRAYSIZE = Turn_rpt_64_Manual_inputType_Manual_inputType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Turn_rpt_64_Manual_inputType_descriptor();
template<typename T>
inline const std::string& Turn_rpt_64_Manual_inputType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Turn_rpt_64_Manual_inputType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Turn_rpt_64_Manual_inputType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Turn_rpt_64_Manual_inputType_descriptor(), enum_t_value);
}
inline bool Turn_rpt_64_Manual_inputType_Parse(
    const std::string& name, Turn_rpt_64_Manual_inputType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Turn_rpt_64_Manual_inputType>(
    Turn_rpt_64_Manual_inputType_descriptor(), name, value);
}
enum Turn_rpt_64_Commanded_valueType : int {
  Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_RIGHT = 0,
  Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_NONE = 1,
  Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_LEFT = 2,
  Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_HAZARD = 3
};
bool Turn_rpt_64_Commanded_valueType_IsValid(int value);
constexpr Turn_rpt_64_Commanded_valueType Turn_rpt_64_Commanded_valueType_Commanded_valueType_MIN = Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_RIGHT;
constexpr Turn_rpt_64_Commanded_valueType Turn_rpt_64_Commanded_valueType_Commanded_valueType_MAX = Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_HAZARD;
constexpr int Turn_rpt_64_Commanded_valueType_Commanded_valueType_ARRAYSIZE = Turn_rpt_64_Commanded_valueType_Commanded_valueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Turn_rpt_64_Commanded_valueType_descriptor();
template<typename T>
inline const std::string& Turn_rpt_64_Commanded_valueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Turn_rpt_64_Commanded_valueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Turn_rpt_64_Commanded_valueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Turn_rpt_64_Commanded_valueType_descriptor(), enum_t_value);
}
inline bool Turn_rpt_64_Commanded_valueType_Parse(
    const std::string& name, Turn_rpt_64_Commanded_valueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Turn_rpt_64_Commanded_valueType>(
    Turn_rpt_64_Commanded_valueType_descriptor(), name, value);
}
enum Turn_rpt_64_Output_valueType : int {
  Turn_rpt_64_Output_valueType_OUTPUT_VALUE_RIGHT = 0,
  Turn_rpt_64_Output_valueType_OUTPUT_VALUE_NONE = 1,
  Turn_rpt_64_Output_valueType_OUTPUT_VALUE_LEFT = 2,
  Turn_rpt_64_Output_valueType_OUTPUT_VALUE_HAZARD = 3
};
bool Turn_rpt_64_Output_valueType_IsValid(int value);
constexpr Turn_rpt_64_Output_valueType Turn_rpt_64_Output_valueType_Output_valueType_MIN = Turn_rpt_64_Output_valueType_OUTPUT_VALUE_RIGHT;
constexpr Turn_rpt_64_Output_valueType Turn_rpt_64_Output_valueType_Output_valueType_MAX = Turn_rpt_64_Output_valueType_OUTPUT_VALUE_HAZARD;
constexpr int Turn_rpt_64_Output_valueType_Output_valueType_ARRAYSIZE = Turn_rpt_64_Output_valueType_Output_valueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Turn_rpt_64_Output_valueType_descriptor();
template<typename T>
inline const std::string& Turn_rpt_64_Output_valueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Turn_rpt_64_Output_valueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Turn_rpt_64_Output_valueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Turn_rpt_64_Output_valueType_descriptor(), enum_t_value);
}
inline bool Turn_rpt_64_Output_valueType_Parse(
    const std::string& name, Turn_rpt_64_Output_valueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Turn_rpt_64_Output_valueType>(
    Turn_rpt_64_Output_valueType_descriptor(), name, value);
}
enum Shift_cmd_65_Shift_cmdType : int {
  Shift_cmd_65_Shift_cmdType_SHIFT_CMD_PARK = 0,
  Shift_cmd_65_Shift_cmdType_SHIFT_CMD_REVERSE = 1,
  Shift_cmd_65_Shift_cmdType_SHIFT_CMD_NEUTRAL = 2,
  Shift_cmd_65_Shift_cmdType_SHIFT_CMD_FORWARD = 3,
  Shift_cmd_65_Shift_cmdType_SHIFT_CMD_LOW = 4
};
bool Shift_cmd_65_Shift_cmdType_IsValid(int value);
constexpr Shift_cmd_65_Shift_cmdType Shift_cmd_65_Shift_cmdType_Shift_cmdType_MIN = Shift_cmd_65_Shift_cmdType_SHIFT_CMD_PARK;
constexpr Shift_cmd_65_Shift_cmdType Shift_cmd_65_Shift_cmdType_Shift_cmdType_MAX = Shift_cmd_65_Shift_cmdType_SHIFT_CMD_LOW;
constexpr int Shift_cmd_65_Shift_cmdType_Shift_cmdType_ARRAYSIZE = Shift_cmd_65_Shift_cmdType_Shift_cmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Shift_cmd_65_Shift_cmdType_descriptor();
template<typename T>
inline const std::string& Shift_cmd_65_Shift_cmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Shift_cmd_65_Shift_cmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Shift_cmd_65_Shift_cmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Shift_cmd_65_Shift_cmdType_descriptor(), enum_t_value);
}
inline bool Shift_cmd_65_Shift_cmdType_Parse(
    const std::string& name, Shift_cmd_65_Shift_cmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Shift_cmd_65_Shift_cmdType>(
    Shift_cmd_65_Shift_cmdType_descriptor(), name, value);
}
enum Shift_rpt_66_Manual_inputType : int {
  Shift_rpt_66_Manual_inputType_MANUAL_INPUT_PARK = 0,
  Shift_rpt_66_Manual_inputType_MANUAL_INPUT_REVERSE = 1,
  Shift_rpt_66_Manual_inputType_MANUAL_INPUT_NEUTRAL = 2,
  Shift_rpt_66_Manual_inputType_MANUAL_INPUT_FORWARD = 3,
  Shift_rpt_66_Manual_inputType_MANUAL_INPUT_HIGH = 4
};
bool Shift_rpt_66_Manual_inputType_IsValid(int value);
constexpr Shift_rpt_66_Manual_inputType Shift_rpt_66_Manual_inputType_Manual_inputType_MIN = Shift_rpt_66_Manual_inputType_MANUAL_INPUT_PARK;
constexpr Shift_rpt_66_Manual_inputType Shift_rpt_66_Manual_inputType_Manual_inputType_MAX = Shift_rpt_66_Manual_inputType_MANUAL_INPUT_HIGH;
constexpr int Shift_rpt_66_Manual_inputType_Manual_inputType_ARRAYSIZE = Shift_rpt_66_Manual_inputType_Manual_inputType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Shift_rpt_66_Manual_inputType_descriptor();
template<typename T>
inline const std::string& Shift_rpt_66_Manual_inputType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Shift_rpt_66_Manual_inputType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Shift_rpt_66_Manual_inputType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Shift_rpt_66_Manual_inputType_descriptor(), enum_t_value);
}
inline bool Shift_rpt_66_Manual_inputType_Parse(
    const std::string& name, Shift_rpt_66_Manual_inputType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Shift_rpt_66_Manual_inputType>(
    Shift_rpt_66_Manual_inputType_descriptor(), name, value);
}
enum Shift_rpt_66_Commanded_valueType : int {
  Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_PARK = 0,
  Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_REVERSE = 1,
  Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_NEUTRAL = 2,
  Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_FORWARD = 3,
  Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_HIGH = 4
};
bool Shift_rpt_66_Commanded_valueType_IsValid(int value);
constexpr Shift_rpt_66_Commanded_valueType Shift_rpt_66_Commanded_valueType_Commanded_valueType_MIN = Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_PARK;
constexpr Shift_rpt_66_Commanded_valueType Shift_rpt_66_Commanded_valueType_Commanded_valueType_MAX = Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_HIGH;
constexpr int Shift_rpt_66_Commanded_valueType_Commanded_valueType_ARRAYSIZE = Shift_rpt_66_Commanded_valueType_Commanded_valueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Shift_rpt_66_Commanded_valueType_descriptor();
template<typename T>
inline const std::string& Shift_rpt_66_Commanded_valueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Shift_rpt_66_Commanded_valueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Shift_rpt_66_Commanded_valueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Shift_rpt_66_Commanded_valueType_descriptor(), enum_t_value);
}
inline bool Shift_rpt_66_Commanded_valueType_Parse(
    const std::string& name, Shift_rpt_66_Commanded_valueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Shift_rpt_66_Commanded_valueType>(
    Shift_rpt_66_Commanded_valueType_descriptor(), name, value);
}
enum Shift_rpt_66_Output_valueType : int {
  Shift_rpt_66_Output_valueType_OUTPUT_VALUE_PARK = 0,
  Shift_rpt_66_Output_valueType_OUTPUT_VALUE_REVERSE = 1,
  Shift_rpt_66_Output_valueType_OUTPUT_VALUE_NEUTRAL = 2,
  Shift_rpt_66_Output_valueType_OUTPUT_VALUE_FORWARD = 3,
  Shift_rpt_66_Output_valueType_OUTPUT_VALUE_HIGH = 4
};
bool Shift_rpt_66_Output_valueType_IsValid(int value);
constexpr Shift_rpt_66_Output_valueType Shift_rpt_66_Output_valueType_Output_valueType_MIN = Shift_rpt_66_Output_valueType_OUTPUT_VALUE_PARK;
constexpr Shift_rpt_66_Output_valueType Shift_rpt_66_Output_valueType_Output_valueType_MAX = Shift_rpt_66_Output_valueType_OUTPUT_VALUE_HIGH;
constexpr int Shift_rpt_66_Output_valueType_Output_valueType_ARRAYSIZE = Shift_rpt_66_Output_valueType_Output_valueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Shift_rpt_66_Output_valueType_descriptor();
template<typename T>
inline const std::string& Shift_rpt_66_Output_valueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Shift_rpt_66_Output_valueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Shift_rpt_66_Output_valueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Shift_rpt_66_Output_valueType_descriptor(), enum_t_value);
}
inline bool Shift_rpt_66_Output_valueType_Parse(
    const std::string& name, Shift_rpt_66_Output_valueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Shift_rpt_66_Output_valueType>(
    Shift_rpt_66_Output_valueType_descriptor(), name, value);
}
enum Global_cmd_69_Pacmod_enableType : int {
  Global_cmd_69_Pacmod_enableType_PACMOD_ENABLE_CONTROL_DISABLED = 0,
  Global_cmd_69_Pacmod_enableType_PACMOD_ENABLE_CONTROL_ENABLED = 1
};
bool Global_cmd_69_Pacmod_enableType_IsValid(int value);
constexpr Global_cmd_69_Pacmod_enableType Global_cmd_69_Pacmod_enableType_Pacmod_enableType_MIN = Global_cmd_69_Pacmod_enableType_PACMOD_ENABLE_CONTROL_DISABLED;
constexpr Global_cmd_69_Pacmod_enableType Global_cmd_69_Pacmod_enableType_Pacmod_enableType_MAX = Global_cmd_69_Pacmod_enableType_PACMOD_ENABLE_CONTROL_ENABLED;
constexpr int Global_cmd_69_Pacmod_enableType_Pacmod_enableType_ARRAYSIZE = Global_cmd_69_Pacmod_enableType_Pacmod_enableType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Global_cmd_69_Pacmod_enableType_descriptor();
template<typename T>
inline const std::string& Global_cmd_69_Pacmod_enableType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Global_cmd_69_Pacmod_enableType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Global_cmd_69_Pacmod_enableType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Global_cmd_69_Pacmod_enableType_descriptor(), enum_t_value);
}
inline bool Global_cmd_69_Pacmod_enableType_Parse(
    const std::string& name, Global_cmd_69_Pacmod_enableType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Global_cmd_69_Pacmod_enableType>(
    Global_cmd_69_Pacmod_enableType_descriptor(), name, value);
}
enum Global_cmd_69_Clear_overrideType : int {
  Global_cmd_69_Clear_overrideType_CLEAR_OVERRIDE_DON_T_CLEAR_ACTIVE_OVERRIDES = 0,
  Global_cmd_69_Clear_overrideType_CLEAR_OVERRIDE_CLEAR_ACTIVE_OVERRIDES = 1
};
bool Global_cmd_69_Clear_overrideType_IsValid(int value);
constexpr Global_cmd_69_Clear_overrideType Global_cmd_69_Clear_overrideType_Clear_overrideType_MIN = Global_cmd_69_Clear_overrideType_CLEAR_OVERRIDE_DON_T_CLEAR_ACTIVE_OVERRIDES;
constexpr Global_cmd_69_Clear_overrideType Global_cmd_69_Clear_overrideType_Clear_overrideType_MAX = Global_cmd_69_Clear_overrideType_CLEAR_OVERRIDE_CLEAR_ACTIVE_OVERRIDES;
constexpr int Global_cmd_69_Clear_overrideType_Clear_overrideType_ARRAYSIZE = Global_cmd_69_Clear_overrideType_Clear_overrideType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Global_cmd_69_Clear_overrideType_descriptor();
template<typename T>
inline const std::string& Global_cmd_69_Clear_overrideType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Global_cmd_69_Clear_overrideType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Global_cmd_69_Clear_overrideType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Global_cmd_69_Clear_overrideType_descriptor(), enum_t_value);
}
inline bool Global_cmd_69_Clear_overrideType_Parse(
    const std::string& name, Global_cmd_69_Clear_overrideType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Global_cmd_69_Clear_overrideType>(
    Global_cmd_69_Clear_overrideType_descriptor(), name, value);
}
enum Global_cmd_69_Ignore_overrideType : int {
  Global_cmd_69_Ignore_overrideType_IGNORE_OVERRIDE_DON_T_IGNORE_USER_OVERRIDES = 0,
  Global_cmd_69_Ignore_overrideType_IGNORE_OVERRIDE_IGNORE_USER_OVERRIDES = 1
};
bool Global_cmd_69_Ignore_overrideType_IsValid(int value);
constexpr Global_cmd_69_Ignore_overrideType Global_cmd_69_Ignore_overrideType_Ignore_overrideType_MIN = Global_cmd_69_Ignore_overrideType_IGNORE_OVERRIDE_DON_T_IGNORE_USER_OVERRIDES;
constexpr Global_cmd_69_Ignore_overrideType Global_cmd_69_Ignore_overrideType_Ignore_overrideType_MAX = Global_cmd_69_Ignore_overrideType_IGNORE_OVERRIDE_IGNORE_USER_OVERRIDES;
constexpr int Global_cmd_69_Ignore_overrideType_Ignore_overrideType_ARRAYSIZE = Global_cmd_69_Ignore_overrideType_Ignore_overrideType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Global_cmd_69_Ignore_overrideType_descriptor();
template<typename T>
inline const std::string& Global_cmd_69_Ignore_overrideType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Global_cmd_69_Ignore_overrideType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Global_cmd_69_Ignore_overrideType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Global_cmd_69_Ignore_overrideType_descriptor(), enum_t_value);
}
inline bool Global_cmd_69_Ignore_overrideType_Parse(
    const std::string& name, Global_cmd_69_Ignore_overrideType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Global_cmd_69_Ignore_overrideType>(
    Global_cmd_69_Ignore_overrideType_descriptor(), name, value);
}
enum Parking_brake_status_rpt_80_Parking_brake_enabledType : int {
  Parking_brake_status_rpt_80_Parking_brake_enabledType_PARKING_BRAKE_ENABLED_OFF = 0,
  Parking_brake_status_rpt_80_Parking_brake_enabledType_PARKING_BRAKE_ENABLED_ON = 1
};
bool Parking_brake_status_rpt_80_Parking_brake_enabledType_IsValid(int value);
constexpr Parking_brake_status_rpt_80_Parking_brake_enabledType Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_MIN = Parking_brake_status_rpt_80_Parking_brake_enabledType_PARKING_BRAKE_ENABLED_OFF;
constexpr Parking_brake_status_rpt_80_Parking_brake_enabledType Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_MAX = Parking_brake_status_rpt_80_Parking_brake_enabledType_PARKING_BRAKE_ENABLED_ON;
constexpr int Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_ARRAYSIZE = Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Parking_brake_status_rpt_80_Parking_brake_enabledType_descriptor();
template<typename T>
inline const std::string& Parking_brake_status_rpt_80_Parking_brake_enabledType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Parking_brake_status_rpt_80_Parking_brake_enabledType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Parking_brake_status_rpt_80_Parking_brake_enabledType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Parking_brake_status_rpt_80_Parking_brake_enabledType_descriptor(), enum_t_value);
}
inline bool Parking_brake_status_rpt_80_Parking_brake_enabledType_Parse(
    const std::string& name, Parking_brake_status_rpt_80_Parking_brake_enabledType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Parking_brake_status_rpt_80_Parking_brake_enabledType>(
    Parking_brake_status_rpt_80_Parking_brake_enabledType_descriptor(), name, value);
}
enum Horn_rpt_79_Output_valueType : int {
  Horn_rpt_79_Output_valueType_OUTPUT_VALUE_OFF = 0,
  Horn_rpt_79_Output_valueType_OUTPUT_VALUE_ON = 1
};
bool Horn_rpt_79_Output_valueType_IsValid(int value);
constexpr Horn_rpt_79_Output_valueType Horn_rpt_79_Output_valueType_Output_valueType_MIN = Horn_rpt_79_Output_valueType_OUTPUT_VALUE_OFF;
constexpr Horn_rpt_79_Output_valueType Horn_rpt_79_Output_valueType_Output_valueType_MAX = Horn_rpt_79_Output_valueType_OUTPUT_VALUE_ON;
constexpr int Horn_rpt_79_Output_valueType_Output_valueType_ARRAYSIZE = Horn_rpt_79_Output_valueType_Output_valueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Horn_rpt_79_Output_valueType_descriptor();
template<typename T>
inline const std::string& Horn_rpt_79_Output_valueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Horn_rpt_79_Output_valueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Horn_rpt_79_Output_valueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Horn_rpt_79_Output_valueType_descriptor(), enum_t_value);
}
inline bool Horn_rpt_79_Output_valueType_Parse(
    const std::string& name, Horn_rpt_79_Output_valueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Horn_rpt_79_Output_valueType>(
    Horn_rpt_79_Output_valueType_descriptor(), name, value);
}
enum Horn_rpt_79_Commanded_valueType : int {
  Horn_rpt_79_Commanded_valueType_COMMANDED_VALUE_OFF = 0,
  Horn_rpt_79_Commanded_valueType_COMMANDED_VALUE_ON = 1
};
bool Horn_rpt_79_Commanded_valueType_IsValid(int value);
constexpr Horn_rpt_79_Commanded_valueType Horn_rpt_79_Commanded_valueType_Commanded_valueType_MIN = Horn_rpt_79_Commanded_valueType_COMMANDED_VALUE_OFF;
constexpr Horn_rpt_79_Commanded_valueType Horn_rpt_79_Commanded_valueType_Commanded_valueType_MAX = Horn_rpt_79_Commanded_valueType_COMMANDED_VALUE_ON;
constexpr int Horn_rpt_79_Commanded_valueType_Commanded_valueType_ARRAYSIZE = Horn_rpt_79_Commanded_valueType_Commanded_valueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Horn_rpt_79_Commanded_valueType_descriptor();
template<typename T>
inline const std::string& Horn_rpt_79_Commanded_valueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Horn_rpt_79_Commanded_valueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Horn_rpt_79_Commanded_valueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Horn_rpt_79_Commanded_valueType_descriptor(), enum_t_value);
}
inline bool Horn_rpt_79_Commanded_valueType_Parse(
    const std::string& name, Horn_rpt_79_Commanded_valueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Horn_rpt_79_Commanded_valueType>(
    Horn_rpt_79_Commanded_valueType_descriptor(), name, value);
}
enum Horn_rpt_79_Manual_inputType : int {
  Horn_rpt_79_Manual_inputType_MANUAL_INPUT_OFF = 0,
  Horn_rpt_79_Manual_inputType_MANUAL_INPUT_ON = 1
};
bool Horn_rpt_79_Manual_inputType_IsValid(int value);
constexpr Horn_rpt_79_Manual_inputType Horn_rpt_79_Manual_inputType_Manual_inputType_MIN = Horn_rpt_79_Manual_inputType_MANUAL_INPUT_OFF;
constexpr Horn_rpt_79_Manual_inputType Horn_rpt_79_Manual_inputType_Manual_inputType_MAX = Horn_rpt_79_Manual_inputType_MANUAL_INPUT_ON;
constexpr int Horn_rpt_79_Manual_inputType_Manual_inputType_ARRAYSIZE = Horn_rpt_79_Manual_inputType_Manual_inputType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Horn_rpt_79_Manual_inputType_descriptor();
template<typename T>
inline const std::string& Horn_rpt_79_Manual_inputType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Horn_rpt_79_Manual_inputType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Horn_rpt_79_Manual_inputType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Horn_rpt_79_Manual_inputType_descriptor(), enum_t_value);
}
inline bool Horn_rpt_79_Manual_inputType_Parse(
    const std::string& name, Horn_rpt_79_Manual_inputType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Horn_rpt_79_Manual_inputType>(
    Horn_rpt_79_Manual_inputType_descriptor(), name, value);
}
enum Horn_cmd_78_Horn_cmdType : int {
  Horn_cmd_78_Horn_cmdType_HORN_CMD_OFF = 0,
  Horn_cmd_78_Horn_cmdType_HORN_CMD_ON = 1
};
bool Horn_cmd_78_Horn_cmdType_IsValid(int value);
constexpr Horn_cmd_78_Horn_cmdType Horn_cmd_78_Horn_cmdType_Horn_cmdType_MIN = Horn_cmd_78_Horn_cmdType_HORN_CMD_OFF;
constexpr Horn_cmd_78_Horn_cmdType Horn_cmd_78_Horn_cmdType_Horn_cmdType_MAX = Horn_cmd_78_Horn_cmdType_HORN_CMD_ON;
constexpr int Horn_cmd_78_Horn_cmdType_Horn_cmdType_ARRAYSIZE = Horn_cmd_78_Horn_cmdType_Horn_cmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Horn_cmd_78_Horn_cmdType_descriptor();
template<typename T>
inline const std::string& Horn_cmd_78_Horn_cmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Horn_cmd_78_Horn_cmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Horn_cmd_78_Horn_cmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Horn_cmd_78_Horn_cmdType_descriptor(), enum_t_value);
}
inline bool Horn_cmd_78_Horn_cmdType_Parse(
    const std::string& name, Horn_cmd_78_Horn_cmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Horn_cmd_78_Horn_cmdType>(
    Horn_cmd_78_Horn_cmdType_descriptor(), name, value);
}
enum Wiper_rpt_91_Output_valueType : int {
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_WIPERS_OFF = 0,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_1 = 1,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_2 = 2,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_3 = 3,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_4 = 4,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_5 = 5,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_LOW = 6,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_HIGH = 7
};
bool Wiper_rpt_91_Output_valueType_IsValid(int value);
constexpr Wiper_rpt_91_Output_valueType Wiper_rpt_91_Output_valueType_Output_valueType_MIN = Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_WIPERS_OFF;
constexpr Wiper_rpt_91_Output_valueType Wiper_rpt_91_Output_valueType_Output_valueType_MAX = Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_HIGH;
constexpr int Wiper_rpt_91_Output_valueType_Output_valueType_ARRAYSIZE = Wiper_rpt_91_Output_valueType_Output_valueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Wiper_rpt_91_Output_valueType_descriptor();
template<typename T>
inline const std::string& Wiper_rpt_91_Output_valueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Wiper_rpt_91_Output_valueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Wiper_rpt_91_Output_valueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Wiper_rpt_91_Output_valueType_descriptor(), enum_t_value);
}
inline bool Wiper_rpt_91_Output_valueType_Parse(
    const std::string& name, Wiper_rpt_91_Output_valueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Wiper_rpt_91_Output_valueType>(
    Wiper_rpt_91_Output_valueType_descriptor(), name, value);
}
enum Wiper_rpt_91_Commanded_valueType : int {
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_WIPERS_OFF = 0,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_1 = 1,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_2 = 2,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_3 = 3,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_4 = 4,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_5 = 5,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_LOW = 6,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_HIGH = 7
};
bool Wiper_rpt_91_Commanded_valueType_IsValid(int value);
constexpr Wiper_rpt_91_Commanded_valueType Wiper_rpt_91_Commanded_valueType_Commanded_valueType_MIN = Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_WIPERS_OFF;
constexpr Wiper_rpt_91_Commanded_valueType Wiper_rpt_91_Commanded_valueType_Commanded_valueType_MAX = Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_HIGH;
constexpr int Wiper_rpt_91_Commanded_valueType_Commanded_valueType_ARRAYSIZE = Wiper_rpt_91_Commanded_valueType_Commanded_valueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Wiper_rpt_91_Commanded_valueType_descriptor();
template<typename T>
inline const std::string& Wiper_rpt_91_Commanded_valueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Wiper_rpt_91_Commanded_valueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Wiper_rpt_91_Commanded_valueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Wiper_rpt_91_Commanded_valueType_descriptor(), enum_t_value);
}
inline bool Wiper_rpt_91_Commanded_valueType_Parse(
    const std::string& name, Wiper_rpt_91_Commanded_valueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Wiper_rpt_91_Commanded_valueType>(
    Wiper_rpt_91_Commanded_valueType_descriptor(), name, value);
}
enum Wiper_rpt_91_Manual_inputType : int {
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_WIPERS_OFF = 0,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_1 = 1,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_2 = 2,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_3 = 3,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_4 = 4,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_5 = 5,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_LOW = 6,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_HIGH = 7
};
bool Wiper_rpt_91_Manual_inputType_IsValid(int value);
constexpr Wiper_rpt_91_Manual_inputType Wiper_rpt_91_Manual_inputType_Manual_inputType_MIN = Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_WIPERS_OFF;
constexpr Wiper_rpt_91_Manual_inputType Wiper_rpt_91_Manual_inputType_Manual_inputType_MAX = Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_HIGH;
constexpr int Wiper_rpt_91_Manual_inputType_Manual_inputType_ARRAYSIZE = Wiper_rpt_91_Manual_inputType_Manual_inputType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Wiper_rpt_91_Manual_inputType_descriptor();
template<typename T>
inline const std::string& Wiper_rpt_91_Manual_inputType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Wiper_rpt_91_Manual_inputType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Wiper_rpt_91_Manual_inputType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Wiper_rpt_91_Manual_inputType_descriptor(), enum_t_value);
}
inline bool Wiper_rpt_91_Manual_inputType_Parse(
    const std::string& name, Wiper_rpt_91_Manual_inputType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Wiper_rpt_91_Manual_inputType>(
    Wiper_rpt_91_Manual_inputType_descriptor(), name, value);
}
enum Vehicle_speed_rpt_6f_Vehicle_speed_validType : int {
  Vehicle_speed_rpt_6f_Vehicle_speed_validType_VEHICLE_SPEED_VALID_INVALID = 0,
  Vehicle_speed_rpt_6f_Vehicle_speed_validType_VEHICLE_SPEED_VALID_VALID = 1
};
bool Vehicle_speed_rpt_6f_Vehicle_speed_validType_IsValid(int value);
constexpr Vehicle_speed_rpt_6f_Vehicle_speed_validType Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_MIN = Vehicle_speed_rpt_6f_Vehicle_speed_validType_VEHICLE_SPEED_VALID_INVALID;
constexpr Vehicle_speed_rpt_6f_Vehicle_speed_validType Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_MAX = Vehicle_speed_rpt_6f_Vehicle_speed_validType_VEHICLE_SPEED_VALID_VALID;
constexpr int Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_ARRAYSIZE = Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Vehicle_speed_rpt_6f_Vehicle_speed_validType_descriptor();
template<typename T>
inline const std::string& Vehicle_speed_rpt_6f_Vehicle_speed_validType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Vehicle_speed_rpt_6f_Vehicle_speed_validType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Vehicle_speed_rpt_6f_Vehicle_speed_validType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_descriptor(), enum_t_value);
}
inline bool Vehicle_speed_rpt_6f_Vehicle_speed_validType_Parse(
    const std::string& name, Vehicle_speed_rpt_6f_Vehicle_speed_validType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Vehicle_speed_rpt_6f_Vehicle_speed_validType>(
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_descriptor(), name, value);
}
enum Headlight_cmd_76_Headlight_cmdType : int {
  Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_HEADLIGHTS_OFF = 0,
  Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_LOW_BEAMS = 1,
  Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_HIGH_BEAMS = 2
};
bool Headlight_cmd_76_Headlight_cmdType_IsValid(int value);
constexpr Headlight_cmd_76_Headlight_cmdType Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_MIN = Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_HEADLIGHTS_OFF;
constexpr Headlight_cmd_76_Headlight_cmdType Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_MAX = Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_HIGH_BEAMS;
constexpr int Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_ARRAYSIZE = Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Headlight_cmd_76_Headlight_cmdType_descriptor();
template<typename T>
inline const std::string& Headlight_cmd_76_Headlight_cmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Headlight_cmd_76_Headlight_cmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Headlight_cmd_76_Headlight_cmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Headlight_cmd_76_Headlight_cmdType_descriptor(), enum_t_value);
}
inline bool Headlight_cmd_76_Headlight_cmdType_Parse(
    const std::string& name, Headlight_cmd_76_Headlight_cmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Headlight_cmd_76_Headlight_cmdType>(
    Headlight_cmd_76_Headlight_cmdType_descriptor(), name, value);
}
enum Wiper_cmd_90_Wiper_cmdType : int {
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_WIPERS_OFF = 0,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_1 = 1,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_2 = 2,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_3 = 3,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_4 = 4,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_5 = 5,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_LOW = 6,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_HIGH = 7
};
bool Wiper_cmd_90_Wiper_cmdType_IsValid(int value);
constexpr Wiper_cmd_90_Wiper_cmdType Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_MIN = Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_WIPERS_OFF;
constexpr Wiper_cmd_90_Wiper_cmdType Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_MAX = Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_HIGH;
constexpr int Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_ARRAYSIZE = Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Wiper_cmd_90_Wiper_cmdType_descriptor();
template<typename T>
inline const std::string& Wiper_cmd_90_Wiper_cmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Wiper_cmd_90_Wiper_cmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Wiper_cmd_90_Wiper_cmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Wiper_cmd_90_Wiper_cmdType_descriptor(), enum_t_value);
}
inline bool Wiper_cmd_90_Wiper_cmdType_Parse(
    const std::string& name, Wiper_cmd_90_Wiper_cmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Wiper_cmd_90_Wiper_cmdType>(
    Wiper_cmd_90_Wiper_cmdType_descriptor(), name, value);
}
// ===================================================================

class ChassisDetail :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.ChassisDetail) */ {
 public:
  ChassisDetail();
  virtual ~ChassisDetail();

  ChassisDetail(const ChassisDetail& from);
  ChassisDetail(ChassisDetail&& from) noexcept
    : ChassisDetail() {
    *this = ::std::move(from);
  }

  inline ChassisDetail& operator=(const ChassisDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChassisDetail& operator=(ChassisDetail&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChassisDetail& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChassisDetail* internal_default_instance() {
    return reinterpret_cast<const ChassisDetail*>(
               &_ChassisDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ChassisDetail& a, ChassisDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(ChassisDetail* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChassisDetail* New() const final {
    return CreateMaybeMessage<ChassisDetail>(nullptr);
  }

  ChassisDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChassisDetail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChassisDetail& from);
  void MergeFrom(const ChassisDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChassisDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.ChassisDetail";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ChassisDetail_Type Type;
  static constexpr Type QIRUI_EQ_15 =
    ChassisDetail_Type_QIRUI_EQ_15;
  static constexpr Type CHANGAN_RUICHENG =
    ChassisDetail_Type_CHANGAN_RUICHENG;
  static inline bool Type_IsValid(int value) {
    return ChassisDetail_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ChassisDetail_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ChassisDetail_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ChassisDetail_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ChassisDetail_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ChassisDetail_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return ChassisDetail_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBasicFieldNumber = 2,
    kSafetyFieldNumber = 3,
    kGearFieldNumber = 4,
    kEmsFieldNumber = 5,
    kEspFieldNumber = 6,
    kGasFieldNumber = 7,
    kEpbFieldNumber = 8,
    kBrakeFieldNumber = 9,
    kDecelerationFieldNumber = 10,
    kVehicleSpdFieldNumber = 11,
    kEpsFieldNumber = 12,
    kLightFieldNumber = 13,
    kBatteryFieldNumber = 14,
    kCheckResponseFieldNumber = 15,
    kLicenseFieldNumber = 16,
    kSurroundFieldNumber = 17,
    kGemFieldNumber = 18,
    kLexusFieldNumber = 19,
    kTransitFieldNumber = 20,
    kGe3FieldNumber = 21,
    kWeyFieldNumber = 22,
    kZhongyunFieldNumber = 23,
    kChFieldNumber = 24,
    kVehicleIdFieldNumber = 101,
    kCarTypeFieldNumber = 1,
  };
  // optional .apollo.canbus.BasicInfo basic = 2;
  bool has_basic() const;
  private:
  bool _internal_has_basic() const;
  public:
  void clear_basic();
  const ::apollo::canbus::BasicInfo& basic() const;
  ::apollo::canbus::BasicInfo* release_basic();
  ::apollo::canbus::BasicInfo* mutable_basic();
  void set_allocated_basic(::apollo::canbus::BasicInfo* basic);
  private:
  const ::apollo::canbus::BasicInfo& _internal_basic() const;
  ::apollo::canbus::BasicInfo* _internal_mutable_basic();
  public:

  // optional .apollo.canbus.Safety safety = 3;
  bool has_safety() const;
  private:
  bool _internal_has_safety() const;
  public:
  void clear_safety();
  const ::apollo::canbus::Safety& safety() const;
  ::apollo::canbus::Safety* release_safety();
  ::apollo::canbus::Safety* mutable_safety();
  void set_allocated_safety(::apollo::canbus::Safety* safety);
  private:
  const ::apollo::canbus::Safety& _internal_safety() const;
  ::apollo::canbus::Safety* _internal_mutable_safety();
  public:

  // optional .apollo.canbus.Gear gear = 4;
  bool has_gear() const;
  private:
  bool _internal_has_gear() const;
  public:
  void clear_gear();
  const ::apollo::canbus::Gear& gear() const;
  ::apollo::canbus::Gear* release_gear();
  ::apollo::canbus::Gear* mutable_gear();
  void set_allocated_gear(::apollo::canbus::Gear* gear);
  private:
  const ::apollo::canbus::Gear& _internal_gear() const;
  ::apollo::canbus::Gear* _internal_mutable_gear();
  public:

  // optional .apollo.canbus.Ems ems = 5;
  bool has_ems() const;
  private:
  bool _internal_has_ems() const;
  public:
  void clear_ems();
  const ::apollo::canbus::Ems& ems() const;
  ::apollo::canbus::Ems* release_ems();
  ::apollo::canbus::Ems* mutable_ems();
  void set_allocated_ems(::apollo::canbus::Ems* ems);
  private:
  const ::apollo::canbus::Ems& _internal_ems() const;
  ::apollo::canbus::Ems* _internal_mutable_ems();
  public:

  // optional .apollo.canbus.Esp esp = 6;
  bool has_esp() const;
  private:
  bool _internal_has_esp() const;
  public:
  void clear_esp();
  const ::apollo::canbus::Esp& esp() const;
  ::apollo::canbus::Esp* release_esp();
  ::apollo::canbus::Esp* mutable_esp();
  void set_allocated_esp(::apollo::canbus::Esp* esp);
  private:
  const ::apollo::canbus::Esp& _internal_esp() const;
  ::apollo::canbus::Esp* _internal_mutable_esp();
  public:

  // optional .apollo.canbus.Gas gas = 7;
  bool has_gas() const;
  private:
  bool _internal_has_gas() const;
  public:
  void clear_gas();
  const ::apollo::canbus::Gas& gas() const;
  ::apollo::canbus::Gas* release_gas();
  ::apollo::canbus::Gas* mutable_gas();
  void set_allocated_gas(::apollo::canbus::Gas* gas);
  private:
  const ::apollo::canbus::Gas& _internal_gas() const;
  ::apollo::canbus::Gas* _internal_mutable_gas();
  public:

  // optional .apollo.canbus.Epb epb = 8;
  bool has_epb() const;
  private:
  bool _internal_has_epb() const;
  public:
  void clear_epb();
  const ::apollo::canbus::Epb& epb() const;
  ::apollo::canbus::Epb* release_epb();
  ::apollo::canbus::Epb* mutable_epb();
  void set_allocated_epb(::apollo::canbus::Epb* epb);
  private:
  const ::apollo::canbus::Epb& _internal_epb() const;
  ::apollo::canbus::Epb* _internal_mutable_epb();
  public:

  // optional .apollo.canbus.Brake brake = 9;
  bool has_brake() const;
  private:
  bool _internal_has_brake() const;
  public:
  void clear_brake();
  const ::apollo::canbus::Brake& brake() const;
  ::apollo::canbus::Brake* release_brake();
  ::apollo::canbus::Brake* mutable_brake();
  void set_allocated_brake(::apollo::canbus::Brake* brake);
  private:
  const ::apollo::canbus::Brake& _internal_brake() const;
  ::apollo::canbus::Brake* _internal_mutable_brake();
  public:

  // optional .apollo.canbus.Deceleration deceleration = 10;
  bool has_deceleration() const;
  private:
  bool _internal_has_deceleration() const;
  public:
  void clear_deceleration();
  const ::apollo::canbus::Deceleration& deceleration() const;
  ::apollo::canbus::Deceleration* release_deceleration();
  ::apollo::canbus::Deceleration* mutable_deceleration();
  void set_allocated_deceleration(::apollo::canbus::Deceleration* deceleration);
  private:
  const ::apollo::canbus::Deceleration& _internal_deceleration() const;
  ::apollo::canbus::Deceleration* _internal_mutable_deceleration();
  public:

  // optional .apollo.canbus.VehicleSpd vehicle_spd = 11;
  bool has_vehicle_spd() const;
  private:
  bool _internal_has_vehicle_spd() const;
  public:
  void clear_vehicle_spd();
  const ::apollo::canbus::VehicleSpd& vehicle_spd() const;
  ::apollo::canbus::VehicleSpd* release_vehicle_spd();
  ::apollo::canbus::VehicleSpd* mutable_vehicle_spd();
  void set_allocated_vehicle_spd(::apollo::canbus::VehicleSpd* vehicle_spd);
  private:
  const ::apollo::canbus::VehicleSpd& _internal_vehicle_spd() const;
  ::apollo::canbus::VehicleSpd* _internal_mutable_vehicle_spd();
  public:

  // optional .apollo.canbus.Eps eps = 12;
  bool has_eps() const;
  private:
  bool _internal_has_eps() const;
  public:
  void clear_eps();
  const ::apollo::canbus::Eps& eps() const;
  ::apollo::canbus::Eps* release_eps();
  ::apollo::canbus::Eps* mutable_eps();
  void set_allocated_eps(::apollo::canbus::Eps* eps);
  private:
  const ::apollo::canbus::Eps& _internal_eps() const;
  ::apollo::canbus::Eps* _internal_mutable_eps();
  public:

  // optional .apollo.canbus.Light light = 13;
  bool has_light() const;
  private:
  bool _internal_has_light() const;
  public:
  void clear_light();
  const ::apollo::canbus::Light& light() const;
  ::apollo::canbus::Light* release_light();
  ::apollo::canbus::Light* mutable_light();
  void set_allocated_light(::apollo::canbus::Light* light);
  private:
  const ::apollo::canbus::Light& _internal_light() const;
  ::apollo::canbus::Light* _internal_mutable_light();
  public:

  // optional .apollo.canbus.Battery battery = 14;
  bool has_battery() const;
  private:
  bool _internal_has_battery() const;
  public:
  void clear_battery();
  const ::apollo::canbus::Battery& battery() const;
  ::apollo::canbus::Battery* release_battery();
  ::apollo::canbus::Battery* mutable_battery();
  void set_allocated_battery(::apollo::canbus::Battery* battery);
  private:
  const ::apollo::canbus::Battery& _internal_battery() const;
  ::apollo::canbus::Battery* _internal_mutable_battery();
  public:

  // optional .apollo.canbus.CheckResponseSignal check_response = 15;
  bool has_check_response() const;
  private:
  bool _internal_has_check_response() const;
  public:
  void clear_check_response();
  const ::apollo::canbus::CheckResponseSignal& check_response() const;
  ::apollo::canbus::CheckResponseSignal* release_check_response();
  ::apollo::canbus::CheckResponseSignal* mutable_check_response();
  void set_allocated_check_response(::apollo::canbus::CheckResponseSignal* check_response);
  private:
  const ::apollo::canbus::CheckResponseSignal& _internal_check_response() const;
  ::apollo::canbus::CheckResponseSignal* _internal_mutable_check_response();
  public:

  // optional .apollo.canbus.License license = 16 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_license() const;
  private:
  bool _internal_has_license() const;
  public:
  PROTOBUF_DEPRECATED void clear_license();
  PROTOBUF_DEPRECATED const ::apollo::canbus::License& license() const;
  PROTOBUF_DEPRECATED ::apollo::canbus::License* release_license();
  PROTOBUF_DEPRECATED ::apollo::canbus::License* mutable_license();
  PROTOBUF_DEPRECATED void set_allocated_license(::apollo::canbus::License* license);
  private:
  const ::apollo::canbus::License& _internal_license() const;
  ::apollo::canbus::License* _internal_mutable_license();
  public:

  // optional .apollo.canbus.Surround surround = 17;
  bool has_surround() const;
  private:
  bool _internal_has_surround() const;
  public:
  void clear_surround();
  const ::apollo::canbus::Surround& surround() const;
  ::apollo::canbus::Surround* release_surround();
  ::apollo::canbus::Surround* mutable_surround();
  void set_allocated_surround(::apollo::canbus::Surround* surround);
  private:
  const ::apollo::canbus::Surround& _internal_surround() const;
  ::apollo::canbus::Surround* _internal_mutable_surround();
  public:

  // optional .apollo.canbus.Gem gem = 18;
  bool has_gem() const;
  private:
  bool _internal_has_gem() const;
  public:
  void clear_gem();
  const ::apollo::canbus::Gem& gem() const;
  ::apollo::canbus::Gem* release_gem();
  ::apollo::canbus::Gem* mutable_gem();
  void set_allocated_gem(::apollo::canbus::Gem* gem);
  private:
  const ::apollo::canbus::Gem& _internal_gem() const;
  ::apollo::canbus::Gem* _internal_mutable_gem();
  public:

  // optional .apollo.canbus.Lexus lexus = 19;
  bool has_lexus() const;
  private:
  bool _internal_has_lexus() const;
  public:
  void clear_lexus();
  const ::apollo::canbus::Lexus& lexus() const;
  ::apollo::canbus::Lexus* release_lexus();
  ::apollo::canbus::Lexus* mutable_lexus();
  void set_allocated_lexus(::apollo::canbus::Lexus* lexus);
  private:
  const ::apollo::canbus::Lexus& _internal_lexus() const;
  ::apollo::canbus::Lexus* _internal_mutable_lexus();
  public:

  // optional .apollo.canbus.Transit transit = 20;
  bool has_transit() const;
  private:
  bool _internal_has_transit() const;
  public:
  void clear_transit();
  const ::apollo::canbus::Transit& transit() const;
  ::apollo::canbus::Transit* release_transit();
  ::apollo::canbus::Transit* mutable_transit();
  void set_allocated_transit(::apollo::canbus::Transit* transit);
  private:
  const ::apollo::canbus::Transit& _internal_transit() const;
  ::apollo::canbus::Transit* _internal_mutable_transit();
  public:

  // optional .apollo.canbus.Ge3 ge3 = 21;
  bool has_ge3() const;
  private:
  bool _internal_has_ge3() const;
  public:
  void clear_ge3();
  const ::apollo::canbus::Ge3& ge3() const;
  ::apollo::canbus::Ge3* release_ge3();
  ::apollo::canbus::Ge3* mutable_ge3();
  void set_allocated_ge3(::apollo::canbus::Ge3* ge3);
  private:
  const ::apollo::canbus::Ge3& _internal_ge3() const;
  ::apollo::canbus::Ge3* _internal_mutable_ge3();
  public:

  // optional .apollo.canbus.Wey wey = 22;
  bool has_wey() const;
  private:
  bool _internal_has_wey() const;
  public:
  void clear_wey();
  const ::apollo::canbus::Wey& wey() const;
  ::apollo::canbus::Wey* release_wey();
  ::apollo::canbus::Wey* mutable_wey();
  void set_allocated_wey(::apollo::canbus::Wey* wey);
  private:
  const ::apollo::canbus::Wey& _internal_wey() const;
  ::apollo::canbus::Wey* _internal_mutable_wey();
  public:

  // optional .apollo.canbus.Zhongyun zhongyun = 23;
  bool has_zhongyun() const;
  private:
  bool _internal_has_zhongyun() const;
  public:
  void clear_zhongyun();
  const ::apollo::canbus::Zhongyun& zhongyun() const;
  ::apollo::canbus::Zhongyun* release_zhongyun();
  ::apollo::canbus::Zhongyun* mutable_zhongyun();
  void set_allocated_zhongyun(::apollo::canbus::Zhongyun* zhongyun);
  private:
  const ::apollo::canbus::Zhongyun& _internal_zhongyun() const;
  ::apollo::canbus::Zhongyun* _internal_mutable_zhongyun();
  public:

  // optional .apollo.canbus.Ch ch = 24;
  bool has_ch() const;
  private:
  bool _internal_has_ch() const;
  public:
  void clear_ch();
  const ::apollo::canbus::Ch& ch() const;
  ::apollo::canbus::Ch* release_ch();
  ::apollo::canbus::Ch* mutable_ch();
  void set_allocated_ch(::apollo::canbus::Ch* ch);
  private:
  const ::apollo::canbus::Ch& _internal_ch() const;
  ::apollo::canbus::Ch* _internal_mutable_ch();
  public:

  // optional .apollo.common.VehicleID vehicle_id = 101;
  bool has_vehicle_id() const;
  private:
  bool _internal_has_vehicle_id() const;
  public:
  void clear_vehicle_id();
  const ::apollo::common::VehicleID& vehicle_id() const;
  ::apollo::common::VehicleID* release_vehicle_id();
  ::apollo::common::VehicleID* mutable_vehicle_id();
  void set_allocated_vehicle_id(::apollo::common::VehicleID* vehicle_id);
  private:
  const ::apollo::common::VehicleID& _internal_vehicle_id() const;
  ::apollo::common::VehicleID* _internal_mutable_vehicle_id();
  public:

  // optional .apollo.canbus.ChassisDetail.Type car_type = 1;
  bool has_car_type() const;
  private:
  bool _internal_has_car_type() const;
  public:
  void clear_car_type();
  ::apollo::canbus::ChassisDetail_Type car_type() const;
  void set_car_type(::apollo::canbus::ChassisDetail_Type value);
  private:
  ::apollo::canbus::ChassisDetail_Type _internal_car_type() const;
  void _internal_set_car_type(::apollo::canbus::ChassisDetail_Type value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.ChassisDetail)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::canbus::BasicInfo* basic_;
  ::apollo::canbus::Safety* safety_;
  ::apollo::canbus::Gear* gear_;
  ::apollo::canbus::Ems* ems_;
  ::apollo::canbus::Esp* esp_;
  ::apollo::canbus::Gas* gas_;
  ::apollo::canbus::Epb* epb_;
  ::apollo::canbus::Brake* brake_;
  ::apollo::canbus::Deceleration* deceleration_;
  ::apollo::canbus::VehicleSpd* vehicle_spd_;
  ::apollo::canbus::Eps* eps_;
  ::apollo::canbus::Light* light_;
  ::apollo::canbus::Battery* battery_;
  ::apollo::canbus::CheckResponseSignal* check_response_;
  ::apollo::canbus::License* license_;
  ::apollo::canbus::Surround* surround_;
  ::apollo::canbus::Gem* gem_;
  ::apollo::canbus::Lexus* lexus_;
  ::apollo::canbus::Transit* transit_;
  ::apollo::canbus::Ge3* ge3_;
  ::apollo::canbus::Wey* wey_;
  ::apollo::canbus::Zhongyun* zhongyun_;
  ::apollo::canbus::Ch* ch_;
  ::apollo::common::VehicleID* vehicle_id_;
  int car_type_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class CheckResponseSignal :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.CheckResponseSignal) */ {
 public:
  CheckResponseSignal();
  virtual ~CheckResponseSignal();

  CheckResponseSignal(const CheckResponseSignal& from);
  CheckResponseSignal(CheckResponseSignal&& from) noexcept
    : CheckResponseSignal() {
    *this = ::std::move(from);
  }

  inline CheckResponseSignal& operator=(const CheckResponseSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckResponseSignal& operator=(CheckResponseSignal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckResponseSignal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckResponseSignal* internal_default_instance() {
    return reinterpret_cast<const CheckResponseSignal*>(
               &_CheckResponseSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CheckResponseSignal& a, CheckResponseSignal& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckResponseSignal* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckResponseSignal* New() const final {
    return CreateMaybeMessage<CheckResponseSignal>(nullptr);
  }

  CheckResponseSignal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckResponseSignal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckResponseSignal& from);
  void MergeFrom(const CheckResponseSignal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckResponseSignal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.CheckResponseSignal";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsEpsOnlineFieldNumber = 1,
    kIsEpbOnlineFieldNumber = 2,
    kIsEspOnlineFieldNumber = 3,
    kIsVtogOnlineFieldNumber = 4,
    kIsScuOnlineFieldNumber = 5,
    kIsSwitchOnlineFieldNumber = 6,
    kIsVcuOnlineFieldNumber = 7,
  };
  // optional bool is_eps_online = 1 [default = false];
  bool has_is_eps_online() const;
  private:
  bool _internal_has_is_eps_online() const;
  public:
  void clear_is_eps_online();
  bool is_eps_online() const;
  void set_is_eps_online(bool value);
  private:
  bool _internal_is_eps_online() const;
  void _internal_set_is_eps_online(bool value);
  public:

  // optional bool is_epb_online = 2 [default = false];
  bool has_is_epb_online() const;
  private:
  bool _internal_has_is_epb_online() const;
  public:
  void clear_is_epb_online();
  bool is_epb_online() const;
  void set_is_epb_online(bool value);
  private:
  bool _internal_is_epb_online() const;
  void _internal_set_is_epb_online(bool value);
  public:

  // optional bool is_esp_online = 3 [default = false];
  bool has_is_esp_online() const;
  private:
  bool _internal_has_is_esp_online() const;
  public:
  void clear_is_esp_online();
  bool is_esp_online() const;
  void set_is_esp_online(bool value);
  private:
  bool _internal_is_esp_online() const;
  void _internal_set_is_esp_online(bool value);
  public:

  // optional bool is_vtog_online = 4 [default = false];
  bool has_is_vtog_online() const;
  private:
  bool _internal_has_is_vtog_online() const;
  public:
  void clear_is_vtog_online();
  bool is_vtog_online() const;
  void set_is_vtog_online(bool value);
  private:
  bool _internal_is_vtog_online() const;
  void _internal_set_is_vtog_online(bool value);
  public:

  // optional bool is_scu_online = 5 [default = false];
  bool has_is_scu_online() const;
  private:
  bool _internal_has_is_scu_online() const;
  public:
  void clear_is_scu_online();
  bool is_scu_online() const;
  void set_is_scu_online(bool value);
  private:
  bool _internal_is_scu_online() const;
  void _internal_set_is_scu_online(bool value);
  public:

  // optional bool is_switch_online = 6 [default = false];
  bool has_is_switch_online() const;
  private:
  bool _internal_has_is_switch_online() const;
  public:
  void clear_is_switch_online();
  bool is_switch_online() const;
  void set_is_switch_online(bool value);
  private:
  bool _internal_is_switch_online() const;
  void _internal_set_is_switch_online(bool value);
  public:

  // optional bool is_vcu_online = 7 [default = false];
  bool has_is_vcu_online() const;
  private:
  bool _internal_has_is_vcu_online() const;
  public:
  void clear_is_vcu_online();
  bool is_vcu_online() const;
  void set_is_vcu_online(bool value);
  private:
  bool _internal_is_vcu_online() const;
  void _internal_set_is_vcu_online(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.CheckResponseSignal)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool is_eps_online_;
  bool is_epb_online_;
  bool is_esp_online_;
  bool is_vtog_online_;
  bool is_scu_online_;
  bool is_switch_online_;
  bool is_vcu_online_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Battery :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Battery) */ {
 public:
  Battery();
  virtual ~Battery();

  Battery(const Battery& from);
  Battery(Battery&& from) noexcept
    : Battery() {
    *this = ::std::move(from);
  }

  inline Battery& operator=(const Battery& from) {
    CopyFrom(from);
    return *this;
  }
  inline Battery& operator=(Battery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Battery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Battery* internal_default_instance() {
    return reinterpret_cast<const Battery*>(
               &_Battery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Battery& a, Battery& b) {
    a.Swap(&b);
  }
  inline void Swap(Battery* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Battery* New() const final {
    return CreateMaybeMessage<Battery>(nullptr);
  }

  Battery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Battery>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Battery& from);
  void MergeFrom(const Battery& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Battery* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Battery";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatteryPercentFieldNumber = 1,
    kFuelLevelFieldNumber = 2,
  };
  // optional double battery_percent = 1;
  bool has_battery_percent() const;
  private:
  bool _internal_has_battery_percent() const;
  public:
  void clear_battery_percent();
  double battery_percent() const;
  void set_battery_percent(double value);
  private:
  double _internal_battery_percent() const;
  void _internal_set_battery_percent(double value);
  public:

  // optional double fuel_level = 2;
  bool has_fuel_level() const;
  private:
  bool _internal_has_fuel_level() const;
  public:
  void clear_fuel_level();
  double fuel_level() const;
  void set_fuel_level(double value);
  private:
  double _internal_fuel_level() const;
  void _internal_set_fuel_level(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Battery)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double battery_percent_;
  double fuel_level_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Light :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Light) */ {
 public:
  Light();
  virtual ~Light();

  Light(const Light& from);
  Light(Light&& from) noexcept
    : Light() {
    *this = ::std::move(from);
  }

  inline Light& operator=(const Light& from) {
    CopyFrom(from);
    return *this;
  }
  inline Light& operator=(Light&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Light& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Light* internal_default_instance() {
    return reinterpret_cast<const Light*>(
               &_Light_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Light& a, Light& b) {
    a.Swap(&b);
  }
  inline void Swap(Light* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Light* New() const final {
    return CreateMaybeMessage<Light>(nullptr);
  }

  Light* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Light>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Light& from);
  void MergeFrom(const Light& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Light* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Light";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Light_TurnLightType TurnLightType;
  static constexpr TurnLightType TURN_LIGHT_OFF =
    Light_TurnLightType_TURN_LIGHT_OFF;
  static constexpr TurnLightType TURN_LEFT_ON =
    Light_TurnLightType_TURN_LEFT_ON;
  static constexpr TurnLightType TURN_RIGHT_ON =
    Light_TurnLightType_TURN_RIGHT_ON;
  static constexpr TurnLightType TURN_LIGHT_ON =
    Light_TurnLightType_TURN_LIGHT_ON;
  static inline bool TurnLightType_IsValid(int value) {
    return Light_TurnLightType_IsValid(value);
  }
  static constexpr TurnLightType TurnLightType_MIN =
    Light_TurnLightType_TurnLightType_MIN;
  static constexpr TurnLightType TurnLightType_MAX =
    Light_TurnLightType_TurnLightType_MAX;
  static constexpr int TurnLightType_ARRAYSIZE =
    Light_TurnLightType_TurnLightType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TurnLightType_descriptor() {
    return Light_TurnLightType_descriptor();
  }
  template<typename T>
  static inline const std::string& TurnLightType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TurnLightType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TurnLightType_Name.");
    return Light_TurnLightType_Name(enum_t_value);
  }
  static inline bool TurnLightType_Parse(const std::string& name,
      TurnLightType* value) {
    return Light_TurnLightType_Parse(name, value);
  }

  typedef Light_BeamLampType BeamLampType;
  static constexpr BeamLampType BEAM_OFF =
    Light_BeamLampType_BEAM_OFF;
  static constexpr BeamLampType HIGH_BEAM_ON =
    Light_BeamLampType_HIGH_BEAM_ON;
  static constexpr BeamLampType LOW_BEAM_ON =
    Light_BeamLampType_LOW_BEAM_ON;
  static inline bool BeamLampType_IsValid(int value) {
    return Light_BeamLampType_IsValid(value);
  }
  static constexpr BeamLampType BeamLampType_MIN =
    Light_BeamLampType_BeamLampType_MIN;
  static constexpr BeamLampType BeamLampType_MAX =
    Light_BeamLampType_BeamLampType_MAX;
  static constexpr int BeamLampType_ARRAYSIZE =
    Light_BeamLampType_BeamLampType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BeamLampType_descriptor() {
    return Light_BeamLampType_descriptor();
  }
  template<typename T>
  static inline const std::string& BeamLampType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BeamLampType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BeamLampType_Name.");
    return Light_BeamLampType_Name(enum_t_value);
  }
  static inline bool BeamLampType_Parse(const std::string& name,
      BeamLampType* value) {
    return Light_BeamLampType_Parse(name, value);
  }

  typedef Light_LincolnLampType LincolnLampType;
  static constexpr LincolnLampType BEAM_NULL =
    Light_LincolnLampType_BEAM_NULL;
  static constexpr LincolnLampType BEAM_FLASH_TO_PASS =
    Light_LincolnLampType_BEAM_FLASH_TO_PASS;
  static constexpr LincolnLampType BEAM_HIGH =
    Light_LincolnLampType_BEAM_HIGH;
  static constexpr LincolnLampType BEAM_INVALID =
    Light_LincolnLampType_BEAM_INVALID;
  static inline bool LincolnLampType_IsValid(int value) {
    return Light_LincolnLampType_IsValid(value);
  }
  static constexpr LincolnLampType LincolnLampType_MIN =
    Light_LincolnLampType_LincolnLampType_MIN;
  static constexpr LincolnLampType LincolnLampType_MAX =
    Light_LincolnLampType_LincolnLampType_MAX;
  static constexpr int LincolnLampType_ARRAYSIZE =
    Light_LincolnLampType_LincolnLampType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LincolnLampType_descriptor() {
    return Light_LincolnLampType_descriptor();
  }
  template<typename T>
  static inline const std::string& LincolnLampType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LincolnLampType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LincolnLampType_Name.");
    return Light_LincolnLampType_Name(enum_t_value);
  }
  static inline bool LincolnLampType_Parse(const std::string& name,
      LincolnLampType* value) {
    return Light_LincolnLampType_Parse(name, value);
  }

  typedef Light_LincolnWiperType LincolnWiperType;
  static constexpr LincolnWiperType WIPER_OFF =
    Light_LincolnWiperType_WIPER_OFF;
  static constexpr LincolnWiperType WIPER_AUTO_OFF =
    Light_LincolnWiperType_WIPER_AUTO_OFF;
  static constexpr LincolnWiperType WIPER_OFF_MOVING =
    Light_LincolnWiperType_WIPER_OFF_MOVING;
  static constexpr LincolnWiperType WIPER_MANUAL_OFF =
    Light_LincolnWiperType_WIPER_MANUAL_OFF;
  static constexpr LincolnWiperType WIPER_MANUAL_ON =
    Light_LincolnWiperType_WIPER_MANUAL_ON;
  static constexpr LincolnWiperType WIPER_MANUAL_LOW =
    Light_LincolnWiperType_WIPER_MANUAL_LOW;
  static constexpr LincolnWiperType WIPER_MANUAL_HIGH =
    Light_LincolnWiperType_WIPER_MANUAL_HIGH;
  static constexpr LincolnWiperType WIPER_MIST_FLICK =
    Light_LincolnWiperType_WIPER_MIST_FLICK;
  static constexpr LincolnWiperType WIPER_WASH =
    Light_LincolnWiperType_WIPER_WASH;
  static constexpr LincolnWiperType WIPER_AUTO_LOW =
    Light_LincolnWiperType_WIPER_AUTO_LOW;
  static constexpr LincolnWiperType WIPER_AUTO_HIGH =
    Light_LincolnWiperType_WIPER_AUTO_HIGH;
  static constexpr LincolnWiperType WIPER_COURTESY_WIPE =
    Light_LincolnWiperType_WIPER_COURTESY_WIPE;
  static constexpr LincolnWiperType WIPER_AUTO_ADJUST =
    Light_LincolnWiperType_WIPER_AUTO_ADJUST;
  static constexpr LincolnWiperType WIPER_RESERVED =
    Light_LincolnWiperType_WIPER_RESERVED;
  static constexpr LincolnWiperType WIPER_STALLED =
    Light_LincolnWiperType_WIPER_STALLED;
  static constexpr LincolnWiperType WIPER_NO_DATA =
    Light_LincolnWiperType_WIPER_NO_DATA;
  static inline bool LincolnWiperType_IsValid(int value) {
    return Light_LincolnWiperType_IsValid(value);
  }
  static constexpr LincolnWiperType LincolnWiperType_MIN =
    Light_LincolnWiperType_LincolnWiperType_MIN;
  static constexpr LincolnWiperType LincolnWiperType_MAX =
    Light_LincolnWiperType_LincolnWiperType_MAX;
  static constexpr int LincolnWiperType_ARRAYSIZE =
    Light_LincolnWiperType_LincolnWiperType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LincolnWiperType_descriptor() {
    return Light_LincolnWiperType_descriptor();
  }
  template<typename T>
  static inline const std::string& LincolnWiperType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LincolnWiperType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LincolnWiperType_Name.");
    return Light_LincolnWiperType_Name(enum_t_value);
  }
  static inline bool LincolnWiperType_Parse(const std::string& name,
      LincolnWiperType* value) {
    return Light_LincolnWiperType_Parse(name, value);
  }

  typedef Light_LincolnAmbientType LincolnAmbientType;
  static constexpr LincolnAmbientType AMBIENT_DARK =
    Light_LincolnAmbientType_AMBIENT_DARK;
  static constexpr LincolnAmbientType AMBIENT_LIGHT =
    Light_LincolnAmbientType_AMBIENT_LIGHT;
  static constexpr LincolnAmbientType AMBIENT_TWILIGHT =
    Light_LincolnAmbientType_AMBIENT_TWILIGHT;
  static constexpr LincolnAmbientType AMBIENT_TUNNEL_ON =
    Light_LincolnAmbientType_AMBIENT_TUNNEL_ON;
  static constexpr LincolnAmbientType AMBIENT_TUNNEL_OFF =
    Light_LincolnAmbientType_AMBIENT_TUNNEL_OFF;
  static constexpr LincolnAmbientType AMBIENT_INVALID =
    Light_LincolnAmbientType_AMBIENT_INVALID;
  static constexpr LincolnAmbientType AMBIENT_NO_DATA =
    Light_LincolnAmbientType_AMBIENT_NO_DATA;
  static inline bool LincolnAmbientType_IsValid(int value) {
    return Light_LincolnAmbientType_IsValid(value);
  }
  static constexpr LincolnAmbientType LincolnAmbientType_MIN =
    Light_LincolnAmbientType_LincolnAmbientType_MIN;
  static constexpr LincolnAmbientType LincolnAmbientType_MAX =
    Light_LincolnAmbientType_LincolnAmbientType_MAX;
  static constexpr int LincolnAmbientType_ARRAYSIZE =
    Light_LincolnAmbientType_LincolnAmbientType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LincolnAmbientType_descriptor() {
    return Light_LincolnAmbientType_descriptor();
  }
  template<typename T>
  static inline const std::string& LincolnAmbientType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LincolnAmbientType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LincolnAmbientType_Name.");
    return Light_LincolnAmbientType_Name(enum_t_value);
  }
  static inline bool LincolnAmbientType_Parse(const std::string& name,
      LincolnAmbientType* value) {
    return Light_LincolnAmbientType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTurnLightTypeFieldNumber = 1,
    kBeamLampTypeFieldNumber = 2,
    kIsBrakeLampOnFieldNumber = 3,
    kIsAutoLightFieldNumber = 4,
    kIsHornOnFieldNumber = 7,
    kWiperGearFieldNumber = 5,
    kLotionGearFieldNumber = 6,
    kLincolnLampTypeFieldNumber = 8,
    kLincolnWiperFieldNumber = 9,
    kLincolnAmbientFieldNumber = 10,
  };
  // optional .apollo.canbus.Light.TurnLightType turn_light_type = 1;
  bool has_turn_light_type() const;
  private:
  bool _internal_has_turn_light_type() const;
  public:
  void clear_turn_light_type();
  ::apollo::canbus::Light_TurnLightType turn_light_type() const;
  void set_turn_light_type(::apollo::canbus::Light_TurnLightType value);
  private:
  ::apollo::canbus::Light_TurnLightType _internal_turn_light_type() const;
  void _internal_set_turn_light_type(::apollo::canbus::Light_TurnLightType value);
  public:

  // optional .apollo.canbus.Light.BeamLampType beam_lamp_type = 2;
  bool has_beam_lamp_type() const;
  private:
  bool _internal_has_beam_lamp_type() const;
  public:
  void clear_beam_lamp_type();
  ::apollo::canbus::Light_BeamLampType beam_lamp_type() const;
  void set_beam_lamp_type(::apollo::canbus::Light_BeamLampType value);
  private:
  ::apollo::canbus::Light_BeamLampType _internal_beam_lamp_type() const;
  void _internal_set_beam_lamp_type(::apollo::canbus::Light_BeamLampType value);
  public:

  // optional bool is_brake_lamp_on = 3;
  bool has_is_brake_lamp_on() const;
  private:
  bool _internal_has_is_brake_lamp_on() const;
  public:
  void clear_is_brake_lamp_on();
  bool is_brake_lamp_on() const;
  void set_is_brake_lamp_on(bool value);
  private:
  bool _internal_is_brake_lamp_on() const;
  void _internal_set_is_brake_lamp_on(bool value);
  public:

  // optional bool is_auto_light = 4;
  bool has_is_auto_light() const;
  private:
  bool _internal_has_is_auto_light() const;
  public:
  void clear_is_auto_light();
  bool is_auto_light() const;
  void set_is_auto_light(bool value);
  private:
  bool _internal_is_auto_light() const;
  void _internal_set_is_auto_light(bool value);
  public:

  // optional bool is_horn_on = 7;
  bool has_is_horn_on() const;
  private:
  bool _internal_has_is_horn_on() const;
  public:
  void clear_is_horn_on();
  bool is_horn_on() const;
  void set_is_horn_on(bool value);
  private:
  bool _internal_is_horn_on() const;
  void _internal_set_is_horn_on(bool value);
  public:

  // optional int32 wiper_gear = 5;
  bool has_wiper_gear() const;
  private:
  bool _internal_has_wiper_gear() const;
  public:
  void clear_wiper_gear();
  ::PROTOBUF_NAMESPACE_ID::int32 wiper_gear() const;
  void set_wiper_gear(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wiper_gear() const;
  void _internal_set_wiper_gear(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 lotion_gear = 6;
  bool has_lotion_gear() const;
  private:
  bool _internal_has_lotion_gear() const;
  public:
  void clear_lotion_gear();
  ::PROTOBUF_NAMESPACE_ID::int32 lotion_gear() const;
  void set_lotion_gear(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lotion_gear() const;
  void _internal_set_lotion_gear(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .apollo.canbus.Light.LincolnLampType lincoln_lamp_type = 8;
  bool has_lincoln_lamp_type() const;
  private:
  bool _internal_has_lincoln_lamp_type() const;
  public:
  void clear_lincoln_lamp_type();
  ::apollo::canbus::Light_LincolnLampType lincoln_lamp_type() const;
  void set_lincoln_lamp_type(::apollo::canbus::Light_LincolnLampType value);
  private:
  ::apollo::canbus::Light_LincolnLampType _internal_lincoln_lamp_type() const;
  void _internal_set_lincoln_lamp_type(::apollo::canbus::Light_LincolnLampType value);
  public:

  // optional .apollo.canbus.Light.LincolnWiperType lincoln_wiper = 9;
  bool has_lincoln_wiper() const;
  private:
  bool _internal_has_lincoln_wiper() const;
  public:
  void clear_lincoln_wiper();
  ::apollo::canbus::Light_LincolnWiperType lincoln_wiper() const;
  void set_lincoln_wiper(::apollo::canbus::Light_LincolnWiperType value);
  private:
  ::apollo::canbus::Light_LincolnWiperType _internal_lincoln_wiper() const;
  void _internal_set_lincoln_wiper(::apollo::canbus::Light_LincolnWiperType value);
  public:

  // optional .apollo.canbus.Light.LincolnAmbientType lincoln_ambient = 10;
  bool has_lincoln_ambient() const;
  private:
  bool _internal_has_lincoln_ambient() const;
  public:
  void clear_lincoln_ambient();
  ::apollo::canbus::Light_LincolnAmbientType lincoln_ambient() const;
  void set_lincoln_ambient(::apollo::canbus::Light_LincolnAmbientType value);
  private:
  ::apollo::canbus::Light_LincolnAmbientType _internal_lincoln_ambient() const;
  void _internal_set_lincoln_ambient(::apollo::canbus::Light_LincolnAmbientType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Light)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int turn_light_type_;
  int beam_lamp_type_;
  bool is_brake_lamp_on_;
  bool is_auto_light_;
  bool is_horn_on_;
  ::PROTOBUF_NAMESPACE_ID::int32 wiper_gear_;
  ::PROTOBUF_NAMESPACE_ID::int32 lotion_gear_;
  int lincoln_lamp_type_;
  int lincoln_wiper_;
  int lincoln_ambient_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Eps :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Eps) */ {
 public:
  Eps();
  virtual ~Eps();

  Eps(const Eps& from);
  Eps(Eps&& from) noexcept
    : Eps() {
    *this = ::std::move(from);
  }

  inline Eps& operator=(const Eps& from) {
    CopyFrom(from);
    return *this;
  }
  inline Eps& operator=(Eps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Eps& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Eps* internal_default_instance() {
    return reinterpret_cast<const Eps*>(
               &_Eps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Eps& a, Eps& b) {
    a.Swap(&b);
  }
  inline void Swap(Eps* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Eps* New() const final {
    return CreateMaybeMessage<Eps>(nullptr);
  }

  Eps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Eps>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Eps& from);
  void MergeFrom(const Eps& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Eps* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Eps";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Eps_Type Type;
  static constexpr Type NOT_AVAILABLE =
    Eps_Type_NOT_AVAILABLE;
  static constexpr Type READY =
    Eps_Type_READY;
  static constexpr Type ACTIVE =
    Eps_Type_ACTIVE;
  static constexpr Type INVALID =
    Eps_Type_INVALID;
  static inline bool Type_IsValid(int value) {
    return Eps_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Eps_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Eps_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Eps_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Eps_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Eps_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return Eps_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEpsDriverHandTorqFieldNumber = 3,
    kEpsControlStateFieldNumber = 2,
    kIsEpsFailFieldNumber = 1,
    kIsSteeringAngleValidFieldNumber = 4,
    kIsTrimmingStatusFieldNumber = 7,
    kIsCalibrationStatusFieldNumber = 8,
    kSteeringAngleFieldNumber = 5,
    kSteeringAngleSpdFieldNumber = 6,
    kAllowEnterAutonomousModeFieldNumber = 10,
    kCurrentDrivingModeFieldNumber = 11,
    kSteeringAngleCmdFieldNumber = 12,
    kVehicleSpeedFieldNumber = 13,
    kEpasTorqueFieldNumber = 14,
    kIsFailureStatusFieldNumber = 9,
    kSteeringEnabledFieldNumber = 15,
    kDriverOverrideFieldNumber = 16,
    kDriverActivityFieldNumber = 17,
    kWatchdogFaultFieldNumber = 18,
    kChannel1FaultFieldNumber = 19,
    kChannel2FaultFieldNumber = 20,
    kCalibrationFaultFieldNumber = 21,
    kTimestamp65FieldNumber = 23,
    kConnectorFaultFieldNumber = 22,
    kMajorVersionFieldNumber = 24,
    kMinorVersionFieldNumber = 25,
    kBuildNumberFieldNumber = 26,
  };
  // optional double eps_driver_hand_torq = 3;
  bool has_eps_driver_hand_torq() const;
  private:
  bool _internal_has_eps_driver_hand_torq() const;
  public:
  void clear_eps_driver_hand_torq();
  double eps_driver_hand_torq() const;
  void set_eps_driver_hand_torq(double value);
  private:
  double _internal_eps_driver_hand_torq() const;
  void _internal_set_eps_driver_hand_torq(double value);
  public:

  // optional .apollo.canbus.Eps.Type eps_control_state = 2;
  bool has_eps_control_state() const;
  private:
  bool _internal_has_eps_control_state() const;
  public:
  void clear_eps_control_state();
  ::apollo::canbus::Eps_Type eps_control_state() const;
  void set_eps_control_state(::apollo::canbus::Eps_Type value);
  private:
  ::apollo::canbus::Eps_Type _internal_eps_control_state() const;
  void _internal_set_eps_control_state(::apollo::canbus::Eps_Type value);
  public:

  // optional bool is_eps_fail = 1;
  bool has_is_eps_fail() const;
  private:
  bool _internal_has_is_eps_fail() const;
  public:
  void clear_is_eps_fail();
  bool is_eps_fail() const;
  void set_is_eps_fail(bool value);
  private:
  bool _internal_is_eps_fail() const;
  void _internal_set_is_eps_fail(bool value);
  public:

  // optional bool is_steering_angle_valid = 4;
  bool has_is_steering_angle_valid() const;
  private:
  bool _internal_has_is_steering_angle_valid() const;
  public:
  void clear_is_steering_angle_valid();
  bool is_steering_angle_valid() const;
  void set_is_steering_angle_valid(bool value);
  private:
  bool _internal_is_steering_angle_valid() const;
  void _internal_set_is_steering_angle_valid(bool value);
  public:

  // optional bool is_trimming_status = 7;
  bool has_is_trimming_status() const;
  private:
  bool _internal_has_is_trimming_status() const;
  public:
  void clear_is_trimming_status();
  bool is_trimming_status() const;
  void set_is_trimming_status(bool value);
  private:
  bool _internal_is_trimming_status() const;
  void _internal_set_is_trimming_status(bool value);
  public:

  // optional bool is_calibration_status = 8;
  bool has_is_calibration_status() const;
  private:
  bool _internal_has_is_calibration_status() const;
  public:
  void clear_is_calibration_status();
  bool is_calibration_status() const;
  void set_is_calibration_status(bool value);
  private:
  bool _internal_is_calibration_status() const;
  void _internal_set_is_calibration_status(bool value);
  public:

  // optional double steering_angle = 5;
  bool has_steering_angle() const;
  private:
  bool _internal_has_steering_angle() const;
  public:
  void clear_steering_angle();
  double steering_angle() const;
  void set_steering_angle(double value);
  private:
  double _internal_steering_angle() const;
  void _internal_set_steering_angle(double value);
  public:

  // optional double steering_angle_spd = 6;
  bool has_steering_angle_spd() const;
  private:
  bool _internal_has_steering_angle_spd() const;
  public:
  void clear_steering_angle_spd();
  double steering_angle_spd() const;
  void set_steering_angle_spd(double value);
  private:
  double _internal_steering_angle_spd() const;
  void _internal_set_steering_angle_spd(double value);
  public:

  // optional int32 allow_enter_autonomous_mode = 10;
  bool has_allow_enter_autonomous_mode() const;
  private:
  bool _internal_has_allow_enter_autonomous_mode() const;
  public:
  void clear_allow_enter_autonomous_mode();
  ::PROTOBUF_NAMESPACE_ID::int32 allow_enter_autonomous_mode() const;
  void set_allow_enter_autonomous_mode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_allow_enter_autonomous_mode() const;
  void _internal_set_allow_enter_autonomous_mode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 current_driving_mode = 11;
  bool has_current_driving_mode() const;
  private:
  bool _internal_has_current_driving_mode() const;
  public:
  void clear_current_driving_mode();
  ::PROTOBUF_NAMESPACE_ID::int32 current_driving_mode() const;
  void set_current_driving_mode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_current_driving_mode() const;
  void _internal_set_current_driving_mode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double steering_angle_cmd = 12;
  bool has_steering_angle_cmd() const;
  private:
  bool _internal_has_steering_angle_cmd() const;
  public:
  void clear_steering_angle_cmd();
  double steering_angle_cmd() const;
  void set_steering_angle_cmd(double value);
  private:
  double _internal_steering_angle_cmd() const;
  void _internal_set_steering_angle_cmd(double value);
  public:

  // optional double vehicle_speed = 13;
  bool has_vehicle_speed() const;
  private:
  bool _internal_has_vehicle_speed() const;
  public:
  void clear_vehicle_speed();
  double vehicle_speed() const;
  void set_vehicle_speed(double value);
  private:
  double _internal_vehicle_speed() const;
  void _internal_set_vehicle_speed(double value);
  public:

  // optional double epas_torque = 14;
  bool has_epas_torque() const;
  private:
  bool _internal_has_epas_torque() const;
  public:
  void clear_epas_torque();
  double epas_torque() const;
  void set_epas_torque(double value);
  private:
  double _internal_epas_torque() const;
  void _internal_set_epas_torque(double value);
  public:

  // optional bool is_failure_status = 9;
  bool has_is_failure_status() const;
  private:
  bool _internal_has_is_failure_status() const;
  public:
  void clear_is_failure_status();
  bool is_failure_status() const;
  void set_is_failure_status(bool value);
  private:
  bool _internal_is_failure_status() const;
  void _internal_set_is_failure_status(bool value);
  public:

  // optional bool steering_enabled = 15;
  bool has_steering_enabled() const;
  private:
  bool _internal_has_steering_enabled() const;
  public:
  void clear_steering_enabled();
  bool steering_enabled() const;
  void set_steering_enabled(bool value);
  private:
  bool _internal_steering_enabled() const;
  void _internal_set_steering_enabled(bool value);
  public:

  // optional bool driver_override = 16;
  bool has_driver_override() const;
  private:
  bool _internal_has_driver_override() const;
  public:
  void clear_driver_override();
  bool driver_override() const;
  void set_driver_override(bool value);
  private:
  bool _internal_driver_override() const;
  void _internal_set_driver_override(bool value);
  public:

  // optional bool driver_activity = 17;
  bool has_driver_activity() const;
  private:
  bool _internal_has_driver_activity() const;
  public:
  void clear_driver_activity();
  bool driver_activity() const;
  void set_driver_activity(bool value);
  private:
  bool _internal_driver_activity() const;
  void _internal_set_driver_activity(bool value);
  public:

  // optional bool watchdog_fault = 18;
  bool has_watchdog_fault() const;
  private:
  bool _internal_has_watchdog_fault() const;
  public:
  void clear_watchdog_fault();
  bool watchdog_fault() const;
  void set_watchdog_fault(bool value);
  private:
  bool _internal_watchdog_fault() const;
  void _internal_set_watchdog_fault(bool value);
  public:

  // optional bool channel_1_fault = 19;
  bool has_channel_1_fault() const;
  private:
  bool _internal_has_channel_1_fault() const;
  public:
  void clear_channel_1_fault();
  bool channel_1_fault() const;
  void set_channel_1_fault(bool value);
  private:
  bool _internal_channel_1_fault() const;
  void _internal_set_channel_1_fault(bool value);
  public:

  // optional bool channel_2_fault = 20;
  bool has_channel_2_fault() const;
  private:
  bool _internal_has_channel_2_fault() const;
  public:
  void clear_channel_2_fault();
  bool channel_2_fault() const;
  void set_channel_2_fault(bool value);
  private:
  bool _internal_channel_2_fault() const;
  void _internal_set_channel_2_fault(bool value);
  public:

  // optional bool calibration_fault = 21;
  bool has_calibration_fault() const;
  private:
  bool _internal_has_calibration_fault() const;
  public:
  void clear_calibration_fault();
  bool calibration_fault() const;
  void set_calibration_fault(bool value);
  private:
  bool _internal_calibration_fault() const;
  void _internal_set_calibration_fault(bool value);
  public:

  // optional double timestamp_65 = 23;
  bool has_timestamp_65() const;
  private:
  bool _internal_has_timestamp_65() const;
  public:
  void clear_timestamp_65();
  double timestamp_65() const;
  void set_timestamp_65(double value);
  private:
  double _internal_timestamp_65() const;
  void _internal_set_timestamp_65(double value);
  public:

  // optional bool connector_fault = 22;
  bool has_connector_fault() const;
  private:
  bool _internal_has_connector_fault() const;
  public:
  void clear_connector_fault();
  bool connector_fault() const;
  void set_connector_fault(bool value);
  private:
  bool _internal_connector_fault() const;
  void _internal_set_connector_fault(bool value);
  public:

  // optional int32 major_version = 24;
  bool has_major_version() const;
  private:
  bool _internal_has_major_version() const;
  public:
  void clear_major_version();
  ::PROTOBUF_NAMESPACE_ID::int32 major_version() const;
  void set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_major_version() const;
  void _internal_set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 minor_version = 25;
  bool has_minor_version() const;
  private:
  bool _internal_has_minor_version() const;
  public:
  void clear_minor_version();
  ::PROTOBUF_NAMESPACE_ID::int32 minor_version() const;
  void set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_minor_version() const;
  void _internal_set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 build_number = 26;
  bool has_build_number() const;
  private:
  bool _internal_has_build_number() const;
  public:
  void clear_build_number();
  ::PROTOBUF_NAMESPACE_ID::int32 build_number() const;
  void set_build_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_build_number() const;
  void _internal_set_build_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Eps)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double eps_driver_hand_torq_;
  int eps_control_state_;
  bool is_eps_fail_;
  bool is_steering_angle_valid_;
  bool is_trimming_status_;
  bool is_calibration_status_;
  double steering_angle_;
  double steering_angle_spd_;
  ::PROTOBUF_NAMESPACE_ID::int32 allow_enter_autonomous_mode_;
  ::PROTOBUF_NAMESPACE_ID::int32 current_driving_mode_;
  double steering_angle_cmd_;
  double vehicle_speed_;
  double epas_torque_;
  bool is_failure_status_;
  bool steering_enabled_;
  bool driver_override_;
  bool driver_activity_;
  bool watchdog_fault_;
  bool channel_1_fault_;
  bool channel_2_fault_;
  bool calibration_fault_;
  double timestamp_65_;
  bool connector_fault_;
  ::PROTOBUF_NAMESPACE_ID::int32 major_version_;
  ::PROTOBUF_NAMESPACE_ID::int32 minor_version_;
  ::PROTOBUF_NAMESPACE_ID::int32 build_number_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class VehicleSpd :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.VehicleSpd) */ {
 public:
  VehicleSpd();
  virtual ~VehicleSpd();

  VehicleSpd(const VehicleSpd& from);
  VehicleSpd(VehicleSpd&& from) noexcept
    : VehicleSpd() {
    *this = ::std::move(from);
  }

  inline VehicleSpd& operator=(const VehicleSpd& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleSpd& operator=(VehicleSpd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VehicleSpd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleSpd* internal_default_instance() {
    return reinterpret_cast<const VehicleSpd*>(
               &_VehicleSpd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VehicleSpd& a, VehicleSpd& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleSpd* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VehicleSpd* New() const final {
    return CreateMaybeMessage<VehicleSpd>(nullptr);
  }

  VehicleSpd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VehicleSpd>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VehicleSpd& from);
  void MergeFrom(const VehicleSpd& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleSpd* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.VehicleSpd";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleSpdFieldNumber = 3,
    kIsVehicleStandstillFieldNumber = 1,
    kIsVehicleSpdValidFieldNumber = 2,
    kIsWheelSpdRrValidFieldNumber = 4,
    kIsWheelSpdRlValidFieldNumber = 7,
    kWheelDirectionRrFieldNumber = 5,
    kWheelSpdRrFieldNumber = 6,
    kWheelSpdRlFieldNumber = 9,
    kWheelDirectionRlFieldNumber = 8,
    kWheelDirectionFrFieldNumber = 11,
    kWheelSpdFrFieldNumber = 12,
    kWheelDirectionFlFieldNumber = 14,
    kIsWheelSpdFrValidFieldNumber = 10,
    kIsWheelSpdFlValidFieldNumber = 13,
    kIsYawRateValidFieldNumber = 16,
    kIsAxValidFieldNumber = 19,
    kWheelSpdFlFieldNumber = 15,
    kYawRateFieldNumber = 17,
    kYawRateOffsetFieldNumber = 18,
    kAxFieldNumber = 20,
    kAxOffsetFieldNumber = 21,
    kAyFieldNumber = 23,
    kAyOffsetFieldNumber = 24,
    kLatAccFieldNumber = 25,
    kLongAccFieldNumber = 26,
    kVertAccFieldNumber = 27,
    kRollRateFieldNumber = 28,
    kAccEstFieldNumber = 29,
    kTimestampSecFieldNumber = 30,
    kIsAyValidFieldNumber = 22,
  };
  // optional double vehicle_spd = 3 [default = 0];
  bool has_vehicle_spd() const;
  private:
  bool _internal_has_vehicle_spd() const;
  public:
  void clear_vehicle_spd();
  double vehicle_spd() const;
  void set_vehicle_spd(double value);
  private:
  double _internal_vehicle_spd() const;
  void _internal_set_vehicle_spd(double value);
  public:

  // optional bool is_vehicle_standstill = 1;
  bool has_is_vehicle_standstill() const;
  private:
  bool _internal_has_is_vehicle_standstill() const;
  public:
  void clear_is_vehicle_standstill();
  bool is_vehicle_standstill() const;
  void set_is_vehicle_standstill(bool value);
  private:
  bool _internal_is_vehicle_standstill() const;
  void _internal_set_is_vehicle_standstill(bool value);
  public:

  // optional bool is_vehicle_spd_valid = 2;
  bool has_is_vehicle_spd_valid() const;
  private:
  bool _internal_has_is_vehicle_spd_valid() const;
  public:
  void clear_is_vehicle_spd_valid();
  bool is_vehicle_spd_valid() const;
  void set_is_vehicle_spd_valid(bool value);
  private:
  bool _internal_is_vehicle_spd_valid() const;
  void _internal_set_is_vehicle_spd_valid(bool value);
  public:

  // optional bool is_wheel_spd_rr_valid = 4;
  bool has_is_wheel_spd_rr_valid() const;
  private:
  bool _internal_has_is_wheel_spd_rr_valid() const;
  public:
  void clear_is_wheel_spd_rr_valid();
  bool is_wheel_spd_rr_valid() const;
  void set_is_wheel_spd_rr_valid(bool value);
  private:
  bool _internal_is_wheel_spd_rr_valid() const;
  void _internal_set_is_wheel_spd_rr_valid(bool value);
  public:

  // optional bool is_wheel_spd_rl_valid = 7;
  bool has_is_wheel_spd_rl_valid() const;
  private:
  bool _internal_has_is_wheel_spd_rl_valid() const;
  public:
  void clear_is_wheel_spd_rl_valid();
  bool is_wheel_spd_rl_valid() const;
  void set_is_wheel_spd_rl_valid(bool value);
  private:
  bool _internal_is_wheel_spd_rl_valid() const;
  void _internal_set_is_wheel_spd_rl_valid(bool value);
  public:

  // optional .apollo.canbus.WheelSpeed.WheelSpeedType wheel_direction_rr = 5;
  bool has_wheel_direction_rr() const;
  private:
  bool _internal_has_wheel_direction_rr() const;
  public:
  void clear_wheel_direction_rr();
  ::apollo::canbus::WheelSpeed_WheelSpeedType wheel_direction_rr() const;
  void set_wheel_direction_rr(::apollo::canbus::WheelSpeed_WheelSpeedType value);
  private:
  ::apollo::canbus::WheelSpeed_WheelSpeedType _internal_wheel_direction_rr() const;
  void _internal_set_wheel_direction_rr(::apollo::canbus::WheelSpeed_WheelSpeedType value);
  public:

  // optional double wheel_spd_rr = 6;
  bool has_wheel_spd_rr() const;
  private:
  bool _internal_has_wheel_spd_rr() const;
  public:
  void clear_wheel_spd_rr();
  double wheel_spd_rr() const;
  void set_wheel_spd_rr(double value);
  private:
  double _internal_wheel_spd_rr() const;
  void _internal_set_wheel_spd_rr(double value);
  public:

  // optional double wheel_spd_rl = 9;
  bool has_wheel_spd_rl() const;
  private:
  bool _internal_has_wheel_spd_rl() const;
  public:
  void clear_wheel_spd_rl();
  double wheel_spd_rl() const;
  void set_wheel_spd_rl(double value);
  private:
  double _internal_wheel_spd_rl() const;
  void _internal_set_wheel_spd_rl(double value);
  public:

  // optional .apollo.canbus.WheelSpeed.WheelSpeedType wheel_direction_rl = 8;
  bool has_wheel_direction_rl() const;
  private:
  bool _internal_has_wheel_direction_rl() const;
  public:
  void clear_wheel_direction_rl();
  ::apollo::canbus::WheelSpeed_WheelSpeedType wheel_direction_rl() const;
  void set_wheel_direction_rl(::apollo::canbus::WheelSpeed_WheelSpeedType value);
  private:
  ::apollo::canbus::WheelSpeed_WheelSpeedType _internal_wheel_direction_rl() const;
  void _internal_set_wheel_direction_rl(::apollo::canbus::WheelSpeed_WheelSpeedType value);
  public:

  // optional .apollo.canbus.WheelSpeed.WheelSpeedType wheel_direction_fr = 11;
  bool has_wheel_direction_fr() const;
  private:
  bool _internal_has_wheel_direction_fr() const;
  public:
  void clear_wheel_direction_fr();
  ::apollo::canbus::WheelSpeed_WheelSpeedType wheel_direction_fr() const;
  void set_wheel_direction_fr(::apollo::canbus::WheelSpeed_WheelSpeedType value);
  private:
  ::apollo::canbus::WheelSpeed_WheelSpeedType _internal_wheel_direction_fr() const;
  void _internal_set_wheel_direction_fr(::apollo::canbus::WheelSpeed_WheelSpeedType value);
  public:

  // optional double wheel_spd_fr = 12;
  bool has_wheel_spd_fr() const;
  private:
  bool _internal_has_wheel_spd_fr() const;
  public:
  void clear_wheel_spd_fr();
  double wheel_spd_fr() const;
  void set_wheel_spd_fr(double value);
  private:
  double _internal_wheel_spd_fr() const;
  void _internal_set_wheel_spd_fr(double value);
  public:

  // optional .apollo.canbus.WheelSpeed.WheelSpeedType wheel_direction_fl = 14;
  bool has_wheel_direction_fl() const;
  private:
  bool _internal_has_wheel_direction_fl() const;
  public:
  void clear_wheel_direction_fl();
  ::apollo::canbus::WheelSpeed_WheelSpeedType wheel_direction_fl() const;
  void set_wheel_direction_fl(::apollo::canbus::WheelSpeed_WheelSpeedType value);
  private:
  ::apollo::canbus::WheelSpeed_WheelSpeedType _internal_wheel_direction_fl() const;
  void _internal_set_wheel_direction_fl(::apollo::canbus::WheelSpeed_WheelSpeedType value);
  public:

  // optional bool is_wheel_spd_fr_valid = 10;
  bool has_is_wheel_spd_fr_valid() const;
  private:
  bool _internal_has_is_wheel_spd_fr_valid() const;
  public:
  void clear_is_wheel_spd_fr_valid();
  bool is_wheel_spd_fr_valid() const;
  void set_is_wheel_spd_fr_valid(bool value);
  private:
  bool _internal_is_wheel_spd_fr_valid() const;
  void _internal_set_is_wheel_spd_fr_valid(bool value);
  public:

  // optional bool is_wheel_spd_fl_valid = 13;
  bool has_is_wheel_spd_fl_valid() const;
  private:
  bool _internal_has_is_wheel_spd_fl_valid() const;
  public:
  void clear_is_wheel_spd_fl_valid();
  bool is_wheel_spd_fl_valid() const;
  void set_is_wheel_spd_fl_valid(bool value);
  private:
  bool _internal_is_wheel_spd_fl_valid() const;
  void _internal_set_is_wheel_spd_fl_valid(bool value);
  public:

  // optional bool is_yaw_rate_valid = 16;
  bool has_is_yaw_rate_valid() const;
  private:
  bool _internal_has_is_yaw_rate_valid() const;
  public:
  void clear_is_yaw_rate_valid();
  bool is_yaw_rate_valid() const;
  void set_is_yaw_rate_valid(bool value);
  private:
  bool _internal_is_yaw_rate_valid() const;
  void _internal_set_is_yaw_rate_valid(bool value);
  public:

  // optional bool is_ax_valid = 19;
  bool has_is_ax_valid() const;
  private:
  bool _internal_has_is_ax_valid() const;
  public:
  void clear_is_ax_valid();
  bool is_ax_valid() const;
  void set_is_ax_valid(bool value);
  private:
  bool _internal_is_ax_valid() const;
  void _internal_set_is_ax_valid(bool value);
  public:

  // optional double wheel_spd_fl = 15;
  bool has_wheel_spd_fl() const;
  private:
  bool _internal_has_wheel_spd_fl() const;
  public:
  void clear_wheel_spd_fl();
  double wheel_spd_fl() const;
  void set_wheel_spd_fl(double value);
  private:
  double _internal_wheel_spd_fl() const;
  void _internal_set_wheel_spd_fl(double value);
  public:

  // optional double yaw_rate = 17;
  bool has_yaw_rate() const;
  private:
  bool _internal_has_yaw_rate() const;
  public:
  void clear_yaw_rate();
  double yaw_rate() const;
  void set_yaw_rate(double value);
  private:
  double _internal_yaw_rate() const;
  void _internal_set_yaw_rate(double value);
  public:

  // optional double yaw_rate_offset = 18;
  bool has_yaw_rate_offset() const;
  private:
  bool _internal_has_yaw_rate_offset() const;
  public:
  void clear_yaw_rate_offset();
  double yaw_rate_offset() const;
  void set_yaw_rate_offset(double value);
  private:
  double _internal_yaw_rate_offset() const;
  void _internal_set_yaw_rate_offset(double value);
  public:

  // optional double ax = 20;
  bool has_ax() const;
  private:
  bool _internal_has_ax() const;
  public:
  void clear_ax();
  double ax() const;
  void set_ax(double value);
  private:
  double _internal_ax() const;
  void _internal_set_ax(double value);
  public:

  // optional double ax_offset = 21;
  bool has_ax_offset() const;
  private:
  bool _internal_has_ax_offset() const;
  public:
  void clear_ax_offset();
  double ax_offset() const;
  void set_ax_offset(double value);
  private:
  double _internal_ax_offset() const;
  void _internal_set_ax_offset(double value);
  public:

  // optional double ay = 23;
  bool has_ay() const;
  private:
  bool _internal_has_ay() const;
  public:
  void clear_ay();
  double ay() const;
  void set_ay(double value);
  private:
  double _internal_ay() const;
  void _internal_set_ay(double value);
  public:

  // optional double ay_offset = 24;
  bool has_ay_offset() const;
  private:
  bool _internal_has_ay_offset() const;
  public:
  void clear_ay_offset();
  double ay_offset() const;
  void set_ay_offset(double value);
  private:
  double _internal_ay_offset() const;
  void _internal_set_ay_offset(double value);
  public:

  // optional double lat_acc = 25;
  bool has_lat_acc() const;
  private:
  bool _internal_has_lat_acc() const;
  public:
  void clear_lat_acc();
  double lat_acc() const;
  void set_lat_acc(double value);
  private:
  double _internal_lat_acc() const;
  void _internal_set_lat_acc(double value);
  public:

  // optional double long_acc = 26;
  bool has_long_acc() const;
  private:
  bool _internal_has_long_acc() const;
  public:
  void clear_long_acc();
  double long_acc() const;
  void set_long_acc(double value);
  private:
  double _internal_long_acc() const;
  void _internal_set_long_acc(double value);
  public:

  // optional double vert_acc = 27;
  bool has_vert_acc() const;
  private:
  bool _internal_has_vert_acc() const;
  public:
  void clear_vert_acc();
  double vert_acc() const;
  void set_vert_acc(double value);
  private:
  double _internal_vert_acc() const;
  void _internal_set_vert_acc(double value);
  public:

  // optional double roll_rate = 28;
  bool has_roll_rate() const;
  private:
  bool _internal_has_roll_rate() const;
  public:
  void clear_roll_rate();
  double roll_rate() const;
  void set_roll_rate(double value);
  private:
  double _internal_roll_rate() const;
  void _internal_set_roll_rate(double value);
  public:

  // optional double acc_est = 29;
  bool has_acc_est() const;
  private:
  bool _internal_has_acc_est() const;
  public:
  void clear_acc_est();
  double acc_est() const;
  void set_acc_est(double value);
  private:
  double _internal_acc_est() const;
  void _internal_set_acc_est(double value);
  public:

  // optional double timestamp_sec = 30;
  bool has_timestamp_sec() const;
  private:
  bool _internal_has_timestamp_sec() const;
  public:
  void clear_timestamp_sec();
  double timestamp_sec() const;
  void set_timestamp_sec(double value);
  private:
  double _internal_timestamp_sec() const;
  void _internal_set_timestamp_sec(double value);
  public:

  // optional bool is_ay_valid = 22;
  bool has_is_ay_valid() const;
  private:
  bool _internal_has_is_ay_valid() const;
  public:
  void clear_is_ay_valid();
  bool is_ay_valid() const;
  void set_is_ay_valid(bool value);
  private:
  bool _internal_is_ay_valid() const;
  void _internal_set_is_ay_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.VehicleSpd)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double vehicle_spd_;
  bool is_vehicle_standstill_;
  bool is_vehicle_spd_valid_;
  bool is_wheel_spd_rr_valid_;
  bool is_wheel_spd_rl_valid_;
  int wheel_direction_rr_;
  double wheel_spd_rr_;
  double wheel_spd_rl_;
  int wheel_direction_rl_;
  int wheel_direction_fr_;
  double wheel_spd_fr_;
  int wheel_direction_fl_;
  bool is_wheel_spd_fr_valid_;
  bool is_wheel_spd_fl_valid_;
  bool is_yaw_rate_valid_;
  bool is_ax_valid_;
  double wheel_spd_fl_;
  double yaw_rate_;
  double yaw_rate_offset_;
  double ax_;
  double ax_offset_;
  double ay_;
  double ay_offset_;
  double lat_acc_;
  double long_acc_;
  double vert_acc_;
  double roll_rate_;
  double acc_est_;
  double timestamp_sec_;
  bool is_ay_valid_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Deceleration :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Deceleration) */ {
 public:
  Deceleration();
  virtual ~Deceleration();

  Deceleration(const Deceleration& from);
  Deceleration(Deceleration&& from) noexcept
    : Deceleration() {
    *this = ::std::move(from);
  }

  inline Deceleration& operator=(const Deceleration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Deceleration& operator=(Deceleration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Deceleration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Deceleration* internal_default_instance() {
    return reinterpret_cast<const Deceleration*>(
               &_Deceleration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Deceleration& a, Deceleration& b) {
    a.Swap(&b);
  }
  inline void Swap(Deceleration* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Deceleration* New() const final {
    return CreateMaybeMessage<Deceleration>(nullptr);
  }

  Deceleration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Deceleration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Deceleration& from);
  void MergeFrom(const Deceleration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Deceleration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Deceleration";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecelerationFieldNumber = 3,
    kIsEvbFailFieldNumber = 4,
    kEvbPressureFieldNumber = 5,
    kBrakePressureFieldNumber = 6,
    kBrakePressureSpdFieldNumber = 7,
    kIsDecelerationAvailableFieldNumber = 1,
    kIsDecelerationActiveFieldNumber = 2,
  };
  // optional double deceleration = 3 [default = 0];
  bool has_deceleration() const;
  private:
  bool _internal_has_deceleration() const;
  public:
  void clear_deceleration();
  double deceleration() const;
  void set_deceleration(double value);
  private:
  double _internal_deceleration() const;
  void _internal_set_deceleration(double value);
  public:

  // optional double is_evb_fail = 4;
  bool has_is_evb_fail() const;
  private:
  bool _internal_has_is_evb_fail() const;
  public:
  void clear_is_evb_fail();
  double is_evb_fail() const;
  void set_is_evb_fail(double value);
  private:
  double _internal_is_evb_fail() const;
  void _internal_set_is_evb_fail(double value);
  public:

  // optional double evb_pressure = 5 [default = 0];
  bool has_evb_pressure() const;
  private:
  bool _internal_has_evb_pressure() const;
  public:
  void clear_evb_pressure();
  double evb_pressure() const;
  void set_evb_pressure(double value);
  private:
  double _internal_evb_pressure() const;
  void _internal_set_evb_pressure(double value);
  public:

  // optional double brake_pressure = 6 [default = 0];
  bool has_brake_pressure() const;
  private:
  bool _internal_has_brake_pressure() const;
  public:
  void clear_brake_pressure();
  double brake_pressure() const;
  void set_brake_pressure(double value);
  private:
  double _internal_brake_pressure() const;
  void _internal_set_brake_pressure(double value);
  public:

  // optional double brake_pressure_spd = 7 [default = 0];
  bool has_brake_pressure_spd() const;
  private:
  bool _internal_has_brake_pressure_spd() const;
  public:
  void clear_brake_pressure_spd();
  double brake_pressure_spd() const;
  void set_brake_pressure_spd(double value);
  private:
  double _internal_brake_pressure_spd() const;
  void _internal_set_brake_pressure_spd(double value);
  public:

  // optional bool is_deceleration_available = 1;
  bool has_is_deceleration_available() const;
  private:
  bool _internal_has_is_deceleration_available() const;
  public:
  void clear_is_deceleration_available();
  bool is_deceleration_available() const;
  void set_is_deceleration_available(bool value);
  private:
  bool _internal_is_deceleration_available() const;
  void _internal_set_is_deceleration_available(bool value);
  public:

  // optional bool is_deceleration_active = 2;
  bool has_is_deceleration_active() const;
  private:
  bool _internal_has_is_deceleration_active() const;
  public:
  void clear_is_deceleration_active();
  bool is_deceleration_active() const;
  void set_is_deceleration_active(bool value);
  private:
  bool _internal_is_deceleration_active() const;
  void _internal_set_is_deceleration_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Deceleration)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double deceleration_;
  double is_evb_fail_;
  double evb_pressure_;
  double brake_pressure_;
  double brake_pressure_spd_;
  bool is_deceleration_available_;
  bool is_deceleration_active_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Brake :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Brake) */ {
 public:
  Brake();
  virtual ~Brake();

  Brake(const Brake& from);
  Brake(Brake&& from) noexcept
    : Brake() {
    *this = ::std::move(from);
  }

  inline Brake& operator=(const Brake& from) {
    CopyFrom(from);
    return *this;
  }
  inline Brake& operator=(Brake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Brake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Brake* internal_default_instance() {
    return reinterpret_cast<const Brake*>(
               &_Brake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Brake& a, Brake& b) {
    a.Swap(&b);
  }
  inline void Swap(Brake* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Brake* New() const final {
    return CreateMaybeMessage<Brake>(nullptr);
  }

  Brake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Brake>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Brake& from);
  void MergeFrom(const Brake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Brake* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Brake";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Brake_HSAStatusType HSAStatusType;
  static constexpr HSAStatusType HSA_INACTIVE =
    Brake_HSAStatusType_HSA_INACTIVE;
  static constexpr HSAStatusType HSA_FINDING_GRADIENT =
    Brake_HSAStatusType_HSA_FINDING_GRADIENT;
  static constexpr HSAStatusType HSA_ACTIVE_PRESSED =
    Brake_HSAStatusType_HSA_ACTIVE_PRESSED;
  static constexpr HSAStatusType HSA_ACTIVE_RELEASED =
    Brake_HSAStatusType_HSA_ACTIVE_RELEASED;
  static constexpr HSAStatusType HSA_FAST_RELEASE =
    Brake_HSAStatusType_HSA_FAST_RELEASE;
  static constexpr HSAStatusType HSA_SLOW_RELEASE =
    Brake_HSAStatusType_HSA_SLOW_RELEASE;
  static constexpr HSAStatusType HSA_FAILED =
    Brake_HSAStatusType_HSA_FAILED;
  static constexpr HSAStatusType HSA_UNDEFINED =
    Brake_HSAStatusType_HSA_UNDEFINED;
  static inline bool HSAStatusType_IsValid(int value) {
    return Brake_HSAStatusType_IsValid(value);
  }
  static constexpr HSAStatusType HSAStatusType_MIN =
    Brake_HSAStatusType_HSAStatusType_MIN;
  static constexpr HSAStatusType HSAStatusType_MAX =
    Brake_HSAStatusType_HSAStatusType_MAX;
  static constexpr int HSAStatusType_ARRAYSIZE =
    Brake_HSAStatusType_HSAStatusType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HSAStatusType_descriptor() {
    return Brake_HSAStatusType_descriptor();
  }
  template<typename T>
  static inline const std::string& HSAStatusType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HSAStatusType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HSAStatusType_Name.");
    return Brake_HSAStatusType_Name(enum_t_value);
  }
  static inline bool HSAStatusType_Parse(const std::string& name,
      HSAStatusType* value) {
    return Brake_HSAStatusType_Parse(name, value);
  }

  typedef Brake_HSAModeType HSAModeType;
  static constexpr HSAModeType HSA_OFF =
    Brake_HSAModeType_HSA_OFF;
  static constexpr HSAModeType HSA_AUTO =
    Brake_HSAModeType_HSA_AUTO;
  static constexpr HSAModeType HSA_MANUAL =
    Brake_HSAModeType_HSA_MANUAL;
  static constexpr HSAModeType HSA_MODE_UNDEFINED =
    Brake_HSAModeType_HSA_MODE_UNDEFINED;
  static inline bool HSAModeType_IsValid(int value) {
    return Brake_HSAModeType_IsValid(value);
  }
  static constexpr HSAModeType HSAModeType_MIN =
    Brake_HSAModeType_HSAModeType_MIN;
  static constexpr HSAModeType HSAModeType_MAX =
    Brake_HSAModeType_HSAModeType_MAX;
  static constexpr int HSAModeType_ARRAYSIZE =
    Brake_HSAModeType_HSAModeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HSAModeType_descriptor() {
    return Brake_HSAModeType_descriptor();
  }
  template<typename T>
  static inline const std::string& HSAModeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HSAModeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HSAModeType_Name.");
    return Brake_HSAModeType_Name(enum_t_value);
  }
  static inline bool HSAModeType_Parse(const std::string& name,
      HSAModeType* value) {
    return Brake_HSAModeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBrakePedalPositionFieldNumber = 5,
    kIsBrakePedalPressedFieldNumber = 1,
    kIsBrakeForceExistFieldNumber = 2,
    kIsBrakeOverHeatFieldNumber = 3,
    kIsHandBrakeOnFieldNumber = 4,
    kIsBrakeValidFieldNumber = 6,
    kBooInputFieldNumber = 10,
    kBooCmdFieldNumber = 11,
    kBooOutputFieldNumber = 12,
    kBrakeInputFieldNumber = 7,
    kBrakeCmdFieldNumber = 8,
    kBrakeOutputFieldNumber = 9,
    kWatchdogSourceFieldNumber = 14,
    kWatchdogApplyingBrakesFieldNumber = 13,
    kBrakeEnabledFieldNumber = 15,
    kDriverOverrideFieldNumber = 16,
    kDriverActivityFieldNumber = 17,
    kWatchdogFaultFieldNumber = 18,
    kChannel1FaultFieldNumber = 19,
    kChannel2FaultFieldNumber = 20,
    kBooFaultFieldNumber = 21,
    kConnectorFaultFieldNumber = 22,
    kBrakeTorqueReqFieldNumber = 23,
    kBrakeTorqueActFieldNumber = 25,
    kHsaStatusFieldNumber = 24,
    kHsaModeFieldNumber = 26,
    kWheelTorqueActFieldNumber = 27,
    kMajorVersionFieldNumber = 28,
    kMinorVersionFieldNumber = 29,
    kBuildNumberFieldNumber = 30,
  };
  // optional double brake_pedal_position = 5;
  bool has_brake_pedal_position() const;
  private:
  bool _internal_has_brake_pedal_position() const;
  public:
  void clear_brake_pedal_position();
  double brake_pedal_position() const;
  void set_brake_pedal_position(double value);
  private:
  double _internal_brake_pedal_position() const;
  void _internal_set_brake_pedal_position(double value);
  public:

  // optional bool is_brake_pedal_pressed = 1 [default = false];
  bool has_is_brake_pedal_pressed() const;
  private:
  bool _internal_has_is_brake_pedal_pressed() const;
  public:
  void clear_is_brake_pedal_pressed();
  bool is_brake_pedal_pressed() const;
  void set_is_brake_pedal_pressed(bool value);
  private:
  bool _internal_is_brake_pedal_pressed() const;
  void _internal_set_is_brake_pedal_pressed(bool value);
  public:

  // optional bool is_brake_force_exist = 2;
  bool has_is_brake_force_exist() const;
  private:
  bool _internal_has_is_brake_force_exist() const;
  public:
  void clear_is_brake_force_exist();
  bool is_brake_force_exist() const;
  void set_is_brake_force_exist(bool value);
  private:
  bool _internal_is_brake_force_exist() const;
  void _internal_set_is_brake_force_exist(bool value);
  public:

  // optional bool is_brake_over_heat = 3;
  bool has_is_brake_over_heat() const;
  private:
  bool _internal_has_is_brake_over_heat() const;
  public:
  void clear_is_brake_over_heat();
  bool is_brake_over_heat() const;
  void set_is_brake_over_heat(bool value);
  private:
  bool _internal_is_brake_over_heat() const;
  void _internal_set_is_brake_over_heat(bool value);
  public:

  // optional bool is_hand_brake_on = 4;
  bool has_is_hand_brake_on() const;
  private:
  bool _internal_has_is_hand_brake_on() const;
  public:
  void clear_is_hand_brake_on();
  bool is_hand_brake_on() const;
  void set_is_hand_brake_on(bool value);
  private:
  bool _internal_is_hand_brake_on() const;
  void _internal_set_is_hand_brake_on(bool value);
  public:

  // optional bool is_brake_valid = 6;
  bool has_is_brake_valid() const;
  private:
  bool _internal_has_is_brake_valid() const;
  public:
  void clear_is_brake_valid();
  bool is_brake_valid() const;
  void set_is_brake_valid(bool value);
  private:
  bool _internal_is_brake_valid() const;
  void _internal_set_is_brake_valid(bool value);
  public:

  // optional bool boo_input = 10;
  bool has_boo_input() const;
  private:
  bool _internal_has_boo_input() const;
  public:
  void clear_boo_input();
  bool boo_input() const;
  void set_boo_input(bool value);
  private:
  bool _internal_boo_input() const;
  void _internal_set_boo_input(bool value);
  public:

  // optional bool boo_cmd = 11;
  bool has_boo_cmd() const;
  private:
  bool _internal_has_boo_cmd() const;
  public:
  void clear_boo_cmd();
  bool boo_cmd() const;
  void set_boo_cmd(bool value);
  private:
  bool _internal_boo_cmd() const;
  void _internal_set_boo_cmd(bool value);
  public:

  // optional bool boo_output = 12;
  bool has_boo_output() const;
  private:
  bool _internal_has_boo_output() const;
  public:
  void clear_boo_output();
  bool boo_output() const;
  void set_boo_output(bool value);
  private:
  bool _internal_boo_output() const;
  void _internal_set_boo_output(bool value);
  public:

  // optional double brake_input = 7;
  bool has_brake_input() const;
  private:
  bool _internal_has_brake_input() const;
  public:
  void clear_brake_input();
  double brake_input() const;
  void set_brake_input(double value);
  private:
  double _internal_brake_input() const;
  void _internal_set_brake_input(double value);
  public:

  // optional double brake_cmd = 8;
  bool has_brake_cmd() const;
  private:
  bool _internal_has_brake_cmd() const;
  public:
  void clear_brake_cmd();
  double brake_cmd() const;
  void set_brake_cmd(double value);
  private:
  double _internal_brake_cmd() const;
  void _internal_set_brake_cmd(double value);
  public:

  // optional double brake_output = 9;
  bool has_brake_output() const;
  private:
  bool _internal_has_brake_output() const;
  public:
  void clear_brake_output();
  double brake_output() const;
  void set_brake_output(double value);
  private:
  double _internal_brake_output() const;
  void _internal_set_brake_output(double value);
  public:

  // optional int32 watchdog_source = 14;
  bool has_watchdog_source() const;
  private:
  bool _internal_has_watchdog_source() const;
  public:
  void clear_watchdog_source();
  ::PROTOBUF_NAMESPACE_ID::int32 watchdog_source() const;
  void set_watchdog_source(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_watchdog_source() const;
  void _internal_set_watchdog_source(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool watchdog_applying_brakes = 13;
  bool has_watchdog_applying_brakes() const;
  private:
  bool _internal_has_watchdog_applying_brakes() const;
  public:
  void clear_watchdog_applying_brakes();
  bool watchdog_applying_brakes() const;
  void set_watchdog_applying_brakes(bool value);
  private:
  bool _internal_watchdog_applying_brakes() const;
  void _internal_set_watchdog_applying_brakes(bool value);
  public:

  // optional bool brake_enabled = 15;
  bool has_brake_enabled() const;
  private:
  bool _internal_has_brake_enabled() const;
  public:
  void clear_brake_enabled();
  bool brake_enabled() const;
  void set_brake_enabled(bool value);
  private:
  bool _internal_brake_enabled() const;
  void _internal_set_brake_enabled(bool value);
  public:

  // optional bool driver_override = 16;
  bool has_driver_override() const;
  private:
  bool _internal_has_driver_override() const;
  public:
  void clear_driver_override();
  bool driver_override() const;
  void set_driver_override(bool value);
  private:
  bool _internal_driver_override() const;
  void _internal_set_driver_override(bool value);
  public:

  // optional bool driver_activity = 17;
  bool has_driver_activity() const;
  private:
  bool _internal_has_driver_activity() const;
  public:
  void clear_driver_activity();
  bool driver_activity() const;
  void set_driver_activity(bool value);
  private:
  bool _internal_driver_activity() const;
  void _internal_set_driver_activity(bool value);
  public:

  // optional bool watchdog_fault = 18;
  bool has_watchdog_fault() const;
  private:
  bool _internal_has_watchdog_fault() const;
  public:
  void clear_watchdog_fault();
  bool watchdog_fault() const;
  void set_watchdog_fault(bool value);
  private:
  bool _internal_watchdog_fault() const;
  void _internal_set_watchdog_fault(bool value);
  public:

  // optional bool channel_1_fault = 19;
  bool has_channel_1_fault() const;
  private:
  bool _internal_has_channel_1_fault() const;
  public:
  void clear_channel_1_fault();
  bool channel_1_fault() const;
  void set_channel_1_fault(bool value);
  private:
  bool _internal_channel_1_fault() const;
  void _internal_set_channel_1_fault(bool value);
  public:

  // optional bool channel_2_fault = 20;
  bool has_channel_2_fault() const;
  private:
  bool _internal_has_channel_2_fault() const;
  public:
  void clear_channel_2_fault();
  bool channel_2_fault() const;
  void set_channel_2_fault(bool value);
  private:
  bool _internal_channel_2_fault() const;
  void _internal_set_channel_2_fault(bool value);
  public:

  // optional bool boo_fault = 21;
  bool has_boo_fault() const;
  private:
  bool _internal_has_boo_fault() const;
  public:
  void clear_boo_fault();
  bool boo_fault() const;
  void set_boo_fault(bool value);
  private:
  bool _internal_boo_fault() const;
  void _internal_set_boo_fault(bool value);
  public:

  // optional bool connector_fault = 22;
  bool has_connector_fault() const;
  private:
  bool _internal_has_connector_fault() const;
  public:
  void clear_connector_fault();
  bool connector_fault() const;
  void set_connector_fault(bool value);
  private:
  bool _internal_connector_fault() const;
  void _internal_set_connector_fault(bool value);
  public:

  // optional double brake_torque_req = 23;
  bool has_brake_torque_req() const;
  private:
  bool _internal_has_brake_torque_req() const;
  public:
  void clear_brake_torque_req();
  double brake_torque_req() const;
  void set_brake_torque_req(double value);
  private:
  double _internal_brake_torque_req() const;
  void _internal_set_brake_torque_req(double value);
  public:

  // optional double brake_torque_act = 25;
  bool has_brake_torque_act() const;
  private:
  bool _internal_has_brake_torque_act() const;
  public:
  void clear_brake_torque_act();
  double brake_torque_act() const;
  void set_brake_torque_act(double value);
  private:
  double _internal_brake_torque_act() const;
  void _internal_set_brake_torque_act(double value);
  public:

  // optional .apollo.canbus.Brake.HSAStatusType hsa_status = 24;
  bool has_hsa_status() const;
  private:
  bool _internal_has_hsa_status() const;
  public:
  void clear_hsa_status();
  ::apollo::canbus::Brake_HSAStatusType hsa_status() const;
  void set_hsa_status(::apollo::canbus::Brake_HSAStatusType value);
  private:
  ::apollo::canbus::Brake_HSAStatusType _internal_hsa_status() const;
  void _internal_set_hsa_status(::apollo::canbus::Brake_HSAStatusType value);
  public:

  // optional .apollo.canbus.Brake.HSAModeType hsa_mode = 26;
  bool has_hsa_mode() const;
  private:
  bool _internal_has_hsa_mode() const;
  public:
  void clear_hsa_mode();
  ::apollo::canbus::Brake_HSAModeType hsa_mode() const;
  void set_hsa_mode(::apollo::canbus::Brake_HSAModeType value);
  private:
  ::apollo::canbus::Brake_HSAModeType _internal_hsa_mode() const;
  void _internal_set_hsa_mode(::apollo::canbus::Brake_HSAModeType value);
  public:

  // optional double wheel_torque_act = 27;
  bool has_wheel_torque_act() const;
  private:
  bool _internal_has_wheel_torque_act() const;
  public:
  void clear_wheel_torque_act();
  double wheel_torque_act() const;
  void set_wheel_torque_act(double value);
  private:
  double _internal_wheel_torque_act() const;
  void _internal_set_wheel_torque_act(double value);
  public:

  // optional int32 major_version = 28;
  bool has_major_version() const;
  private:
  bool _internal_has_major_version() const;
  public:
  void clear_major_version();
  ::PROTOBUF_NAMESPACE_ID::int32 major_version() const;
  void set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_major_version() const;
  void _internal_set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 minor_version = 29;
  bool has_minor_version() const;
  private:
  bool _internal_has_minor_version() const;
  public:
  void clear_minor_version();
  ::PROTOBUF_NAMESPACE_ID::int32 minor_version() const;
  void set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_minor_version() const;
  void _internal_set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 build_number = 30;
  bool has_build_number() const;
  private:
  bool _internal_has_build_number() const;
  public:
  void clear_build_number();
  ::PROTOBUF_NAMESPACE_ID::int32 build_number() const;
  void set_build_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_build_number() const;
  void _internal_set_build_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Brake)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double brake_pedal_position_;
  bool is_brake_pedal_pressed_;
  bool is_brake_force_exist_;
  bool is_brake_over_heat_;
  bool is_hand_brake_on_;
  bool is_brake_valid_;
  bool boo_input_;
  bool boo_cmd_;
  bool boo_output_;
  double brake_input_;
  double brake_cmd_;
  double brake_output_;
  ::PROTOBUF_NAMESPACE_ID::int32 watchdog_source_;
  bool watchdog_applying_brakes_;
  bool brake_enabled_;
  bool driver_override_;
  bool driver_activity_;
  bool watchdog_fault_;
  bool channel_1_fault_;
  bool channel_2_fault_;
  bool boo_fault_;
  bool connector_fault_;
  double brake_torque_req_;
  double brake_torque_act_;
  int hsa_status_;
  int hsa_mode_;
  double wheel_torque_act_;
  ::PROTOBUF_NAMESPACE_ID::int32 major_version_;
  ::PROTOBUF_NAMESPACE_ID::int32 minor_version_;
  ::PROTOBUF_NAMESPACE_ID::int32 build_number_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Epb :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Epb) */ {
 public:
  Epb();
  virtual ~Epb();

  Epb(const Epb& from);
  Epb(Epb&& from) noexcept
    : Epb() {
    *this = ::std::move(from);
  }

  inline Epb& operator=(const Epb& from) {
    CopyFrom(from);
    return *this;
  }
  inline Epb& operator=(Epb&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Epb& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Epb* internal_default_instance() {
    return reinterpret_cast<const Epb*>(
               &_Epb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Epb& a, Epb& b) {
    a.Swap(&b);
  }
  inline void Swap(Epb* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Epb* New() const final {
    return CreateMaybeMessage<Epb>(nullptr);
  }

  Epb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Epb>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Epb& from);
  void MergeFrom(const Epb& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Epb* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Epb";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Epb_PBrakeType PBrakeType;
  static constexpr PBrakeType PBRAKE_OFF =
    Epb_PBrakeType_PBRAKE_OFF;
  static constexpr PBrakeType PBRAKE_TRANSITION =
    Epb_PBrakeType_PBRAKE_TRANSITION;
  static constexpr PBrakeType PBRAKE_ON =
    Epb_PBrakeType_PBRAKE_ON;
  static constexpr PBrakeType PBRAKE_FAULT =
    Epb_PBrakeType_PBRAKE_FAULT;
  static inline bool PBrakeType_IsValid(int value) {
    return Epb_PBrakeType_IsValid(value);
  }
  static constexpr PBrakeType PBrakeType_MIN =
    Epb_PBrakeType_PBrakeType_MIN;
  static constexpr PBrakeType PBrakeType_MAX =
    Epb_PBrakeType_PBrakeType_MAX;
  static constexpr int PBrakeType_ARRAYSIZE =
    Epb_PBrakeType_PBrakeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PBrakeType_descriptor() {
    return Epb_PBrakeType_descriptor();
  }
  template<typename T>
  static inline const std::string& PBrakeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PBrakeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PBrakeType_Name.");
    return Epb_PBrakeType_Name(enum_t_value);
  }
  static inline bool PBrakeType_Parse(const std::string& name,
      PBrakeType* value) {
    return Epb_PBrakeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIsEpbErrorFieldNumber = 1,
    kIsEpbReleasedFieldNumber = 2,
    kEpbStatusFieldNumber = 3,
    kParkingBrakeStatusFieldNumber = 4,
  };
  // optional bool is_epb_error = 1;
  bool has_is_epb_error() const;
  private:
  bool _internal_has_is_epb_error() const;
  public:
  void clear_is_epb_error();
  bool is_epb_error() const;
  void set_is_epb_error(bool value);
  private:
  bool _internal_is_epb_error() const;
  void _internal_set_is_epb_error(bool value);
  public:

  // optional bool is_epb_released = 2;
  bool has_is_epb_released() const;
  private:
  bool _internal_has_is_epb_released() const;
  public:
  void clear_is_epb_released();
  bool is_epb_released() const;
  void set_is_epb_released(bool value);
  private:
  bool _internal_is_epb_released() const;
  void _internal_set_is_epb_released(bool value);
  public:

  // optional int32 epb_status = 3;
  bool has_epb_status() const;
  private:
  bool _internal_has_epb_status() const;
  public:
  void clear_epb_status();
  ::PROTOBUF_NAMESPACE_ID::int32 epb_status() const;
  void set_epb_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_epb_status() const;
  void _internal_set_epb_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .apollo.canbus.Epb.PBrakeType parking_brake_status = 4;
  bool has_parking_brake_status() const;
  private:
  bool _internal_has_parking_brake_status() const;
  public:
  void clear_parking_brake_status();
  ::apollo::canbus::Epb_PBrakeType parking_brake_status() const;
  void set_parking_brake_status(::apollo::canbus::Epb_PBrakeType value);
  private:
  ::apollo::canbus::Epb_PBrakeType _internal_parking_brake_status() const;
  void _internal_set_parking_brake_status(::apollo::canbus::Epb_PBrakeType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Epb)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool is_epb_error_;
  bool is_epb_released_;
  ::PROTOBUF_NAMESPACE_ID::int32 epb_status_;
  int parking_brake_status_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Gas :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Gas) */ {
 public:
  Gas();
  virtual ~Gas();

  Gas(const Gas& from);
  Gas(Gas&& from) noexcept
    : Gas() {
    *this = ::std::move(from);
  }

  inline Gas& operator=(const Gas& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gas& operator=(Gas&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Gas& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Gas* internal_default_instance() {
    return reinterpret_cast<const Gas*>(
               &_Gas_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Gas& a, Gas& b) {
    a.Swap(&b);
  }
  inline void Swap(Gas* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Gas* New() const final {
    return CreateMaybeMessage<Gas>(nullptr);
  }

  Gas* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Gas>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Gas& from);
  void MergeFrom(const Gas& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gas* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Gas";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGasPedalPositionFieldNumber = 3,
    kIsGasPedalErrorFieldNumber = 1,
    kIsGasPedalPressedMoreFieldNumber = 2,
    kIsGasValidFieldNumber = 4,
    kThrottleEnabledFieldNumber = 9,
    kWatchdogSourceFieldNumber = 8,
    kThrottleInputFieldNumber = 5,
    kThrottleCmdFieldNumber = 6,
    kThrottleOutputFieldNumber = 7,
    kDriverOverrideFieldNumber = 10,
    kDriverActivityFieldNumber = 11,
    kWatchdogFaultFieldNumber = 12,
    kChannel1FaultFieldNumber = 13,
    kChannel2FaultFieldNumber = 14,
    kConnectorFaultFieldNumber = 15,
    kAcceleratorPedalFieldNumber = 16,
    kAcceleratorPedalRateFieldNumber = 17,
    kMajorVersionFieldNumber = 18,
    kMinorVersionFieldNumber = 19,
    kBuildNumberFieldNumber = 20,
  };
  // optional double gas_pedal_position = 3 [default = 0];
  bool has_gas_pedal_position() const;
  private:
  bool _internal_has_gas_pedal_position() const;
  public:
  void clear_gas_pedal_position();
  double gas_pedal_position() const;
  void set_gas_pedal_position(double value);
  private:
  double _internal_gas_pedal_position() const;
  void _internal_set_gas_pedal_position(double value);
  public:

  // optional bool is_gas_pedal_error = 1;
  bool has_is_gas_pedal_error() const;
  private:
  bool _internal_has_is_gas_pedal_error() const;
  public:
  void clear_is_gas_pedal_error();
  bool is_gas_pedal_error() const;
  void set_is_gas_pedal_error(bool value);
  private:
  bool _internal_is_gas_pedal_error() const;
  void _internal_set_is_gas_pedal_error(bool value);
  public:

  // optional bool is_gas_pedal_pressed_more = 2;
  bool has_is_gas_pedal_pressed_more() const;
  private:
  bool _internal_has_is_gas_pedal_pressed_more() const;
  public:
  void clear_is_gas_pedal_pressed_more();
  bool is_gas_pedal_pressed_more() const;
  void set_is_gas_pedal_pressed_more(bool value);
  private:
  bool _internal_is_gas_pedal_pressed_more() const;
  void _internal_set_is_gas_pedal_pressed_more(bool value);
  public:

  // optional bool is_gas_valid = 4 [default = false];
  bool has_is_gas_valid() const;
  private:
  bool _internal_has_is_gas_valid() const;
  public:
  void clear_is_gas_valid();
  bool is_gas_valid() const;
  void set_is_gas_valid(bool value);
  private:
  bool _internal_is_gas_valid() const;
  void _internal_set_is_gas_valid(bool value);
  public:

  // optional bool throttle_enabled = 9;
  bool has_throttle_enabled() const;
  private:
  bool _internal_has_throttle_enabled() const;
  public:
  void clear_throttle_enabled();
  bool throttle_enabled() const;
  void set_throttle_enabled(bool value);
  private:
  bool _internal_throttle_enabled() const;
  void _internal_set_throttle_enabled(bool value);
  public:

  // optional int32 watchdog_source = 8;
  bool has_watchdog_source() const;
  private:
  bool _internal_has_watchdog_source() const;
  public:
  void clear_watchdog_source();
  ::PROTOBUF_NAMESPACE_ID::int32 watchdog_source() const;
  void set_watchdog_source(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_watchdog_source() const;
  void _internal_set_watchdog_source(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double throttle_input = 5;
  bool has_throttle_input() const;
  private:
  bool _internal_has_throttle_input() const;
  public:
  void clear_throttle_input();
  double throttle_input() const;
  void set_throttle_input(double value);
  private:
  double _internal_throttle_input() const;
  void _internal_set_throttle_input(double value);
  public:

  // optional double throttle_cmd = 6;
  bool has_throttle_cmd() const;
  private:
  bool _internal_has_throttle_cmd() const;
  public:
  void clear_throttle_cmd();
  double throttle_cmd() const;
  void set_throttle_cmd(double value);
  private:
  double _internal_throttle_cmd() const;
  void _internal_set_throttle_cmd(double value);
  public:

  // optional double throttle_output = 7;
  bool has_throttle_output() const;
  private:
  bool _internal_has_throttle_output() const;
  public:
  void clear_throttle_output();
  double throttle_output() const;
  void set_throttle_output(double value);
  private:
  double _internal_throttle_output() const;
  void _internal_set_throttle_output(double value);
  public:

  // optional bool driver_override = 10;
  bool has_driver_override() const;
  private:
  bool _internal_has_driver_override() const;
  public:
  void clear_driver_override();
  bool driver_override() const;
  void set_driver_override(bool value);
  private:
  bool _internal_driver_override() const;
  void _internal_set_driver_override(bool value);
  public:

  // optional bool driver_activity = 11;
  bool has_driver_activity() const;
  private:
  bool _internal_has_driver_activity() const;
  public:
  void clear_driver_activity();
  bool driver_activity() const;
  void set_driver_activity(bool value);
  private:
  bool _internal_driver_activity() const;
  void _internal_set_driver_activity(bool value);
  public:

  // optional bool watchdog_fault = 12;
  bool has_watchdog_fault() const;
  private:
  bool _internal_has_watchdog_fault() const;
  public:
  void clear_watchdog_fault();
  bool watchdog_fault() const;
  void set_watchdog_fault(bool value);
  private:
  bool _internal_watchdog_fault() const;
  void _internal_set_watchdog_fault(bool value);
  public:

  // optional bool channel_1_fault = 13;
  bool has_channel_1_fault() const;
  private:
  bool _internal_has_channel_1_fault() const;
  public:
  void clear_channel_1_fault();
  bool channel_1_fault() const;
  void set_channel_1_fault(bool value);
  private:
  bool _internal_channel_1_fault() const;
  void _internal_set_channel_1_fault(bool value);
  public:

  // optional bool channel_2_fault = 14;
  bool has_channel_2_fault() const;
  private:
  bool _internal_has_channel_2_fault() const;
  public:
  void clear_channel_2_fault();
  bool channel_2_fault() const;
  void set_channel_2_fault(bool value);
  private:
  bool _internal_channel_2_fault() const;
  void _internal_set_channel_2_fault(bool value);
  public:

  // optional bool connector_fault = 15;
  bool has_connector_fault() const;
  private:
  bool _internal_has_connector_fault() const;
  public:
  void clear_connector_fault();
  bool connector_fault() const;
  void set_connector_fault(bool value);
  private:
  bool _internal_connector_fault() const;
  void _internal_set_connector_fault(bool value);
  public:

  // optional double accelerator_pedal = 16;
  bool has_accelerator_pedal() const;
  private:
  bool _internal_has_accelerator_pedal() const;
  public:
  void clear_accelerator_pedal();
  double accelerator_pedal() const;
  void set_accelerator_pedal(double value);
  private:
  double _internal_accelerator_pedal() const;
  void _internal_set_accelerator_pedal(double value);
  public:

  // optional double accelerator_pedal_rate = 17;
  bool has_accelerator_pedal_rate() const;
  private:
  bool _internal_has_accelerator_pedal_rate() const;
  public:
  void clear_accelerator_pedal_rate();
  double accelerator_pedal_rate() const;
  void set_accelerator_pedal_rate(double value);
  private:
  double _internal_accelerator_pedal_rate() const;
  void _internal_set_accelerator_pedal_rate(double value);
  public:

  // optional int32 major_version = 18;
  bool has_major_version() const;
  private:
  bool _internal_has_major_version() const;
  public:
  void clear_major_version();
  ::PROTOBUF_NAMESPACE_ID::int32 major_version() const;
  void set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_major_version() const;
  void _internal_set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 minor_version = 19;
  bool has_minor_version() const;
  private:
  bool _internal_has_minor_version() const;
  public:
  void clear_minor_version();
  ::PROTOBUF_NAMESPACE_ID::int32 minor_version() const;
  void set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_minor_version() const;
  void _internal_set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 build_number = 20;
  bool has_build_number() const;
  private:
  bool _internal_has_build_number() const;
  public:
  void clear_build_number();
  ::PROTOBUF_NAMESPACE_ID::int32 build_number() const;
  void set_build_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_build_number() const;
  void _internal_set_build_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Gas)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double gas_pedal_position_;
  bool is_gas_pedal_error_;
  bool is_gas_pedal_pressed_more_;
  bool is_gas_valid_;
  bool throttle_enabled_;
  ::PROTOBUF_NAMESPACE_ID::int32 watchdog_source_;
  double throttle_input_;
  double throttle_cmd_;
  double throttle_output_;
  bool driver_override_;
  bool driver_activity_;
  bool watchdog_fault_;
  bool channel_1_fault_;
  bool channel_2_fault_;
  bool connector_fault_;
  double accelerator_pedal_;
  double accelerator_pedal_rate_;
  ::PROTOBUF_NAMESPACE_ID::int32 major_version_;
  ::PROTOBUF_NAMESPACE_ID::int32 minor_version_;
  ::PROTOBUF_NAMESPACE_ID::int32 build_number_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Esp :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Esp) */ {
 public:
  Esp();
  virtual ~Esp();

  Esp(const Esp& from);
  Esp(Esp&& from) noexcept
    : Esp() {
    *this = ::std::move(from);
  }

  inline Esp& operator=(const Esp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Esp& operator=(Esp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Esp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Esp* internal_default_instance() {
    return reinterpret_cast<const Esp*>(
               &_Esp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Esp& a, Esp& b) {
    a.Swap(&b);
  }
  inline void Swap(Esp* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Esp* New() const final {
    return CreateMaybeMessage<Esp>(nullptr);
  }

  Esp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Esp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Esp& from);
  void MergeFrom(const Esp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Esp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Esp";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsEspAccErrorFieldNumber = 1,
    kIsEspOnFieldNumber = 2,
    kIsEspActiveFieldNumber = 3,
    kIsAbsErrorFieldNumber = 4,
    kIsAbsActiveFieldNumber = 5,
    kIsTcsvdcFailFieldNumber = 6,
    kIsAbsEnabledFieldNumber = 7,
    kIsStabActiveFieldNumber = 8,
    kIsStabEnabledFieldNumber = 9,
    kIsTracActiveFieldNumber = 10,
    kIsTracEnabledFieldNumber = 11,
  };
  // optional bool is_esp_acc_error = 1;
  bool has_is_esp_acc_error() const;
  private:
  bool _internal_has_is_esp_acc_error() const;
  public:
  void clear_is_esp_acc_error();
  bool is_esp_acc_error() const;
  void set_is_esp_acc_error(bool value);
  private:
  bool _internal_is_esp_acc_error() const;
  void _internal_set_is_esp_acc_error(bool value);
  public:

  // optional bool is_esp_on = 2;
  bool has_is_esp_on() const;
  private:
  bool _internal_has_is_esp_on() const;
  public:
  void clear_is_esp_on();
  bool is_esp_on() const;
  void set_is_esp_on(bool value);
  private:
  bool _internal_is_esp_on() const;
  void _internal_set_is_esp_on(bool value);
  public:

  // optional bool is_esp_active = 3;
  bool has_is_esp_active() const;
  private:
  bool _internal_has_is_esp_active() const;
  public:
  void clear_is_esp_active();
  bool is_esp_active() const;
  void set_is_esp_active(bool value);
  private:
  bool _internal_is_esp_active() const;
  void _internal_set_is_esp_active(bool value);
  public:

  // optional bool is_abs_error = 4;
  bool has_is_abs_error() const;
  private:
  bool _internal_has_is_abs_error() const;
  public:
  void clear_is_abs_error();
  bool is_abs_error() const;
  void set_is_abs_error(bool value);
  private:
  bool _internal_is_abs_error() const;
  void _internal_set_is_abs_error(bool value);
  public:

  // optional bool is_abs_active = 5;
  bool has_is_abs_active() const;
  private:
  bool _internal_has_is_abs_active() const;
  public:
  void clear_is_abs_active();
  bool is_abs_active() const;
  void set_is_abs_active(bool value);
  private:
  bool _internal_is_abs_active() const;
  void _internal_set_is_abs_active(bool value);
  public:

  // optional bool is_tcsvdc_fail = 6;
  bool has_is_tcsvdc_fail() const;
  private:
  bool _internal_has_is_tcsvdc_fail() const;
  public:
  void clear_is_tcsvdc_fail();
  bool is_tcsvdc_fail() const;
  void set_is_tcsvdc_fail(bool value);
  private:
  bool _internal_is_tcsvdc_fail() const;
  void _internal_set_is_tcsvdc_fail(bool value);
  public:

  // optional bool is_abs_enabled = 7;
  bool has_is_abs_enabled() const;
  private:
  bool _internal_has_is_abs_enabled() const;
  public:
  void clear_is_abs_enabled();
  bool is_abs_enabled() const;
  void set_is_abs_enabled(bool value);
  private:
  bool _internal_is_abs_enabled() const;
  void _internal_set_is_abs_enabled(bool value);
  public:

  // optional bool is_stab_active = 8;
  bool has_is_stab_active() const;
  private:
  bool _internal_has_is_stab_active() const;
  public:
  void clear_is_stab_active();
  bool is_stab_active() const;
  void set_is_stab_active(bool value);
  private:
  bool _internal_is_stab_active() const;
  void _internal_set_is_stab_active(bool value);
  public:

  // optional bool is_stab_enabled = 9;
  bool has_is_stab_enabled() const;
  private:
  bool _internal_has_is_stab_enabled() const;
  public:
  void clear_is_stab_enabled();
  bool is_stab_enabled() const;
  void set_is_stab_enabled(bool value);
  private:
  bool _internal_is_stab_enabled() const;
  void _internal_set_is_stab_enabled(bool value);
  public:

  // optional bool is_trac_active = 10;
  bool has_is_trac_active() const;
  private:
  bool _internal_has_is_trac_active() const;
  public:
  void clear_is_trac_active();
  bool is_trac_active() const;
  void set_is_trac_active(bool value);
  private:
  bool _internal_is_trac_active() const;
  void _internal_set_is_trac_active(bool value);
  public:

  // optional bool is_trac_enabled = 11;
  bool has_is_trac_enabled() const;
  private:
  bool _internal_has_is_trac_enabled() const;
  public:
  void clear_is_trac_enabled();
  bool is_trac_enabled() const;
  void set_is_trac_enabled(bool value);
  private:
  bool _internal_is_trac_enabled() const;
  void _internal_set_is_trac_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Esp)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool is_esp_acc_error_;
  bool is_esp_on_;
  bool is_esp_active_;
  bool is_abs_error_;
  bool is_abs_active_;
  bool is_tcsvdc_fail_;
  bool is_abs_enabled_;
  bool is_stab_active_;
  bool is_stab_enabled_;
  bool is_trac_active_;
  bool is_trac_enabled_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Ems :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Ems) */ {
 public:
  Ems();
  virtual ~Ems();

  Ems(const Ems& from);
  Ems(Ems&& from) noexcept
    : Ems() {
    *this = ::std::move(from);
  }

  inline Ems& operator=(const Ems& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ems& operator=(Ems&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Ems& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ems* internal_default_instance() {
    return reinterpret_cast<const Ems*>(
               &_Ems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Ems& a, Ems& b) {
    a.Swap(&b);
  }
  inline void Swap(Ems* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ems* New() const final {
    return CreateMaybeMessage<Ems>(nullptr);
  }

  Ems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ems>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ems& from);
  void MergeFrom(const Ems& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ems* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Ems";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Ems_Type Type;
  static constexpr Type STOP =
    Ems_Type_STOP;
  static constexpr Type CRANK =
    Ems_Type_CRANK;
  static constexpr Type RUNNING =
    Ems_Type_RUNNING;
  static constexpr Type INVALID =
    Ems_Type_INVALID;
  static inline bool Type_IsValid(int value) {
    return Ems_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Ems_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Ems_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Ems_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Ems_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Ems_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return Ems_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMaxEngineTorqPercentFieldNumber = 4,
    kEngineStateFieldNumber = 3,
    kIsEngineAccAvailableFieldNumber = 1,
    kIsEngineAccErrorFieldNumber = 2,
    kIsEngineSpeedErrorFieldNumber = 7,
    kIsOverEngineTorqueFieldNumber = 10,
    kMinEngineTorqPercentFieldNumber = 5,
    kBaseEngineTorqConstantFieldNumber = 6,
    kEngineTorqueFieldNumber = 9,
    kEngineSpeedFieldNumber = 8,
    kEngineRpmFieldNumber = 11,
  };
  // optional double max_engine_torq_percent = 4;
  bool has_max_engine_torq_percent() const;
  private:
  bool _internal_has_max_engine_torq_percent() const;
  public:
  void clear_max_engine_torq_percent();
  double max_engine_torq_percent() const;
  void set_max_engine_torq_percent(double value);
  private:
  double _internal_max_engine_torq_percent() const;
  void _internal_set_max_engine_torq_percent(double value);
  public:

  // optional .apollo.canbus.Ems.Type engine_state = 3;
  bool has_engine_state() const;
  private:
  bool _internal_has_engine_state() const;
  public:
  void clear_engine_state();
  ::apollo::canbus::Ems_Type engine_state() const;
  void set_engine_state(::apollo::canbus::Ems_Type value);
  private:
  ::apollo::canbus::Ems_Type _internal_engine_state() const;
  void _internal_set_engine_state(::apollo::canbus::Ems_Type value);
  public:

  // optional bool is_engine_acc_available = 1;
  bool has_is_engine_acc_available() const;
  private:
  bool _internal_has_is_engine_acc_available() const;
  public:
  void clear_is_engine_acc_available();
  bool is_engine_acc_available() const;
  void set_is_engine_acc_available(bool value);
  private:
  bool _internal_is_engine_acc_available() const;
  void _internal_set_is_engine_acc_available(bool value);
  public:

  // optional bool is_engine_acc_error = 2;
  bool has_is_engine_acc_error() const;
  private:
  bool _internal_has_is_engine_acc_error() const;
  public:
  void clear_is_engine_acc_error();
  bool is_engine_acc_error() const;
  void set_is_engine_acc_error(bool value);
  private:
  bool _internal_is_engine_acc_error() const;
  void _internal_set_is_engine_acc_error(bool value);
  public:

  // optional bool is_engine_speed_error = 7;
  bool has_is_engine_speed_error() const;
  private:
  bool _internal_has_is_engine_speed_error() const;
  public:
  void clear_is_engine_speed_error();
  bool is_engine_speed_error() const;
  void set_is_engine_speed_error(bool value);
  private:
  bool _internal_is_engine_speed_error() const;
  void _internal_set_is_engine_speed_error(bool value);
  public:

  // optional bool is_over_engine_torque = 10;
  bool has_is_over_engine_torque() const;
  private:
  bool _internal_has_is_over_engine_torque() const;
  public:
  void clear_is_over_engine_torque();
  bool is_over_engine_torque() const;
  void set_is_over_engine_torque(bool value);
  private:
  bool _internal_is_over_engine_torque() const;
  void _internal_set_is_over_engine_torque(bool value);
  public:

  // optional double min_engine_torq_percent = 5;
  bool has_min_engine_torq_percent() const;
  private:
  bool _internal_has_min_engine_torq_percent() const;
  public:
  void clear_min_engine_torq_percent();
  double min_engine_torq_percent() const;
  void set_min_engine_torq_percent(double value);
  private:
  double _internal_min_engine_torq_percent() const;
  void _internal_set_min_engine_torq_percent(double value);
  public:

  // optional int32 base_engine_torq_constant = 6;
  bool has_base_engine_torq_constant() const;
  private:
  bool _internal_has_base_engine_torq_constant() const;
  public:
  void clear_base_engine_torq_constant();
  ::PROTOBUF_NAMESPACE_ID::int32 base_engine_torq_constant() const;
  void set_base_engine_torq_constant(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_base_engine_torq_constant() const;
  void _internal_set_base_engine_torq_constant(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 engine_torque = 9;
  bool has_engine_torque() const;
  private:
  bool _internal_has_engine_torque() const;
  public:
  void clear_engine_torque();
  ::PROTOBUF_NAMESPACE_ID::int32 engine_torque() const;
  void set_engine_torque(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_engine_torque() const;
  void _internal_set_engine_torque(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double engine_speed = 8;
  bool has_engine_speed() const;
  private:
  bool _internal_has_engine_speed() const;
  public:
  void clear_engine_speed();
  double engine_speed() const;
  void set_engine_speed(double value);
  private:
  double _internal_engine_speed() const;
  void _internal_set_engine_speed(double value);
  public:

  // optional double engine_rpm = 11;
  bool has_engine_rpm() const;
  private:
  bool _internal_has_engine_rpm() const;
  public:
  void clear_engine_rpm();
  double engine_rpm() const;
  void set_engine_rpm(double value);
  private:
  double _internal_engine_rpm() const;
  void _internal_set_engine_rpm(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Ems)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double max_engine_torq_percent_;
  int engine_state_;
  bool is_engine_acc_available_;
  bool is_engine_acc_error_;
  bool is_engine_speed_error_;
  bool is_over_engine_torque_;
  double min_engine_torq_percent_;
  ::PROTOBUF_NAMESPACE_ID::int32 base_engine_torq_constant_;
  ::PROTOBUF_NAMESPACE_ID::int32 engine_torque_;
  double engine_speed_;
  double engine_rpm_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Gear :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Gear) */ {
 public:
  Gear();
  virtual ~Gear();

  Gear(const Gear& from);
  Gear(Gear&& from) noexcept
    : Gear() {
    *this = ::std::move(from);
  }

  inline Gear& operator=(const Gear& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gear& operator=(Gear&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Gear& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Gear* internal_default_instance() {
    return reinterpret_cast<const Gear*>(
               &_Gear_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Gear& a, Gear& b) {
    a.Swap(&b);
  }
  inline void Swap(Gear* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Gear* New() const final {
    return CreateMaybeMessage<Gear>(nullptr);
  }

  Gear* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Gear>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Gear& from);
  void MergeFrom(const Gear& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gear* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Gear";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGearStateFieldNumber = 2,
    kIsShiftPositionValidFieldNumber = 1,
    kDriverOverrideFieldNumber = 3,
    kCanbusFaultFieldNumber = 5,
    kGearCmdFieldNumber = 4,
  };
  // optional .apollo.canbus.Chassis.GearPosition gear_state = 2;
  bool has_gear_state() const;
  private:
  bool _internal_has_gear_state() const;
  public:
  void clear_gear_state();
  ::apollo::canbus::Chassis_GearPosition gear_state() const;
  void set_gear_state(::apollo::canbus::Chassis_GearPosition value);
  private:
  ::apollo::canbus::Chassis_GearPosition _internal_gear_state() const;
  void _internal_set_gear_state(::apollo::canbus::Chassis_GearPosition value);
  public:

  // optional bool is_shift_position_valid = 1;
  bool has_is_shift_position_valid() const;
  private:
  bool _internal_has_is_shift_position_valid() const;
  public:
  void clear_is_shift_position_valid();
  bool is_shift_position_valid() const;
  void set_is_shift_position_valid(bool value);
  private:
  bool _internal_is_shift_position_valid() const;
  void _internal_set_is_shift_position_valid(bool value);
  public:

  // optional bool driver_override = 3;
  bool has_driver_override() const;
  private:
  bool _internal_has_driver_override() const;
  public:
  void clear_driver_override();
  bool driver_override() const;
  void set_driver_override(bool value);
  private:
  bool _internal_driver_override() const;
  void _internal_set_driver_override(bool value);
  public:

  // optional bool canbus_fault = 5;
  bool has_canbus_fault() const;
  private:
  bool _internal_has_canbus_fault() const;
  public:
  void clear_canbus_fault();
  bool canbus_fault() const;
  void set_canbus_fault(bool value);
  private:
  bool _internal_canbus_fault() const;
  void _internal_set_canbus_fault(bool value);
  public:

  // optional .apollo.canbus.Chassis.GearPosition gear_cmd = 4;
  bool has_gear_cmd() const;
  private:
  bool _internal_has_gear_cmd() const;
  public:
  void clear_gear_cmd();
  ::apollo::canbus::Chassis_GearPosition gear_cmd() const;
  void set_gear_cmd(::apollo::canbus::Chassis_GearPosition value);
  private:
  ::apollo::canbus::Chassis_GearPosition _internal_gear_cmd() const;
  void _internal_set_gear_cmd(::apollo::canbus::Chassis_GearPosition value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Gear)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int gear_state_;
  bool is_shift_position_valid_;
  bool driver_override_;
  bool canbus_fault_;
  int gear_cmd_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Safety :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Safety) */ {
 public:
  Safety();
  virtual ~Safety();

  Safety(const Safety& from);
  Safety(Safety&& from) noexcept
    : Safety() {
    *this = ::std::move(from);
  }

  inline Safety& operator=(const Safety& from) {
    CopyFrom(from);
    return *this;
  }
  inline Safety& operator=(Safety&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Safety& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Safety* internal_default_instance() {
    return reinterpret_cast<const Safety*>(
               &_Safety_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Safety& a, Safety& b) {
    a.Swap(&b);
  }
  inline void Swap(Safety* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Safety* New() const final {
    return CreateMaybeMessage<Safety>(nullptr);
  }

  Safety* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Safety>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Safety& from);
  void MergeFrom(const Safety& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Safety* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Safety";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmergencyButtonFieldNumber = 3,
    kIsDriverCarDoorCloseFieldNumber = 1,
    kIsDriverBuckledFieldNumber = 2,
    kHasErrorFieldNumber = 4,
    kIsMotorInvertorFaultFieldNumber = 5,
    kIsSystemFaultFieldNumber = 6,
    kIsPowerBatteryFaultFieldNumber = 7,
    kIsMotorInvertorOverTemperatureFieldNumber = 8,
    kIsSmallBatteryChargeDischargeFaultFieldNumber = 9,
    kDrivingModeFieldNumber = 10,
    kIsPassengerDoorOpenFieldNumber = 11,
    kIsRearleftDoorOpenFieldNumber = 12,
    kIsRearrightDoorOpenFieldNumber = 13,
    kIsHoodOpenFieldNumber = 14,
    kIsTrunkOpenFieldNumber = 15,
    kIsPassengerDetectedFieldNumber = 16,
    kIsPassengerAirbagEnabledFieldNumber = 17,
    kIsPassengerBuckledFieldNumber = 18,
    kFrontLeftTirePressFieldNumber = 19,
    kFrontRightTirePressFieldNumber = 20,
    kRearLeftTirePressFieldNumber = 21,
    kRearRightTirePressFieldNumber = 22,
    kCarDrivingModeFieldNumber = 23,
  };
  // optional int32 emergency_button = 3;
  bool has_emergency_button() const;
  private:
  bool _internal_has_emergency_button() const;
  public:
  void clear_emergency_button();
  ::PROTOBUF_NAMESPACE_ID::int32 emergency_button() const;
  void set_emergency_button(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_emergency_button() const;
  void _internal_set_emergency_button(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool is_driver_car_door_close = 1;
  bool has_is_driver_car_door_close() const;
  private:
  bool _internal_has_is_driver_car_door_close() const;
  public:
  void clear_is_driver_car_door_close();
  bool is_driver_car_door_close() const;
  void set_is_driver_car_door_close(bool value);
  private:
  bool _internal_is_driver_car_door_close() const;
  void _internal_set_is_driver_car_door_close(bool value);
  public:

  // optional bool is_driver_buckled = 2;
  bool has_is_driver_buckled() const;
  private:
  bool _internal_has_is_driver_buckled() const;
  public:
  void clear_is_driver_buckled();
  bool is_driver_buckled() const;
  void set_is_driver_buckled(bool value);
  private:
  bool _internal_is_driver_buckled() const;
  void _internal_set_is_driver_buckled(bool value);
  public:

  // optional bool has_error = 4 [default = false];
  bool has_has_error() const;
  private:
  bool _internal_has_has_error() const;
  public:
  void clear_has_error();
  bool has_error() const;
  void set_has_error(bool value);
  private:
  bool _internal_has_error() const;
  void _internal_set_has_error(bool value);
  public:

  // optional bool is_motor_invertor_fault = 5;
  bool has_is_motor_invertor_fault() const;
  private:
  bool _internal_has_is_motor_invertor_fault() const;
  public:
  void clear_is_motor_invertor_fault();
  bool is_motor_invertor_fault() const;
  void set_is_motor_invertor_fault(bool value);
  private:
  bool _internal_is_motor_invertor_fault() const;
  void _internal_set_is_motor_invertor_fault(bool value);
  public:

  // optional bool is_system_fault = 6;
  bool has_is_system_fault() const;
  private:
  bool _internal_has_is_system_fault() const;
  public:
  void clear_is_system_fault();
  bool is_system_fault() const;
  void set_is_system_fault(bool value);
  private:
  bool _internal_is_system_fault() const;
  void _internal_set_is_system_fault(bool value);
  public:

  // optional bool is_power_battery_fault = 7;
  bool has_is_power_battery_fault() const;
  private:
  bool _internal_has_is_power_battery_fault() const;
  public:
  void clear_is_power_battery_fault();
  bool is_power_battery_fault() const;
  void set_is_power_battery_fault(bool value);
  private:
  bool _internal_is_power_battery_fault() const;
  void _internal_set_is_power_battery_fault(bool value);
  public:

  // optional bool is_motor_invertor_over_temperature = 8;
  bool has_is_motor_invertor_over_temperature() const;
  private:
  bool _internal_has_is_motor_invertor_over_temperature() const;
  public:
  void clear_is_motor_invertor_over_temperature();
  bool is_motor_invertor_over_temperature() const;
  void set_is_motor_invertor_over_temperature(bool value);
  private:
  bool _internal_is_motor_invertor_over_temperature() const;
  void _internal_set_is_motor_invertor_over_temperature(bool value);
  public:

  // optional bool is_small_battery_charge_discharge_fault = 9;
  bool has_is_small_battery_charge_discharge_fault() const;
  private:
  bool _internal_has_is_small_battery_charge_discharge_fault() const;
  public:
  void clear_is_small_battery_charge_discharge_fault();
  bool is_small_battery_charge_discharge_fault() const;
  void set_is_small_battery_charge_discharge_fault(bool value);
  private:
  bool _internal_is_small_battery_charge_discharge_fault() const;
  void _internal_set_is_small_battery_charge_discharge_fault(bool value);
  public:

  // optional int32 driving_mode = 10;
  bool has_driving_mode() const;
  private:
  bool _internal_has_driving_mode() const;
  public:
  void clear_driving_mode();
  ::PROTOBUF_NAMESPACE_ID::int32 driving_mode() const;
  void set_driving_mode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_driving_mode() const;
  void _internal_set_driving_mode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool is_passenger_door_open = 11;
  bool has_is_passenger_door_open() const;
  private:
  bool _internal_has_is_passenger_door_open() const;
  public:
  void clear_is_passenger_door_open();
  bool is_passenger_door_open() const;
  void set_is_passenger_door_open(bool value);
  private:
  bool _internal_is_passenger_door_open() const;
  void _internal_set_is_passenger_door_open(bool value);
  public:

  // optional bool is_rearleft_door_open = 12;
  bool has_is_rearleft_door_open() const;
  private:
  bool _internal_has_is_rearleft_door_open() const;
  public:
  void clear_is_rearleft_door_open();
  bool is_rearleft_door_open() const;
  void set_is_rearleft_door_open(bool value);
  private:
  bool _internal_is_rearleft_door_open() const;
  void _internal_set_is_rearleft_door_open(bool value);
  public:

  // optional bool is_rearright_door_open = 13;
  bool has_is_rearright_door_open() const;
  private:
  bool _internal_has_is_rearright_door_open() const;
  public:
  void clear_is_rearright_door_open();
  bool is_rearright_door_open() const;
  void set_is_rearright_door_open(bool value);
  private:
  bool _internal_is_rearright_door_open() const;
  void _internal_set_is_rearright_door_open(bool value);
  public:

  // optional bool is_hood_open = 14;
  bool has_is_hood_open() const;
  private:
  bool _internal_has_is_hood_open() const;
  public:
  void clear_is_hood_open();
  bool is_hood_open() const;
  void set_is_hood_open(bool value);
  private:
  bool _internal_is_hood_open() const;
  void _internal_set_is_hood_open(bool value);
  public:

  // optional bool is_trunk_open = 15;
  bool has_is_trunk_open() const;
  private:
  bool _internal_has_is_trunk_open() const;
  public:
  void clear_is_trunk_open();
  bool is_trunk_open() const;
  void set_is_trunk_open(bool value);
  private:
  bool _internal_is_trunk_open() const;
  void _internal_set_is_trunk_open(bool value);
  public:

  // optional bool is_passenger_detected = 16;
  bool has_is_passenger_detected() const;
  private:
  bool _internal_has_is_passenger_detected() const;
  public:
  void clear_is_passenger_detected();
  bool is_passenger_detected() const;
  void set_is_passenger_detected(bool value);
  private:
  bool _internal_is_passenger_detected() const;
  void _internal_set_is_passenger_detected(bool value);
  public:

  // optional bool is_passenger_airbag_enabled = 17;
  bool has_is_passenger_airbag_enabled() const;
  private:
  bool _internal_has_is_passenger_airbag_enabled() const;
  public:
  void clear_is_passenger_airbag_enabled();
  bool is_passenger_airbag_enabled() const;
  void set_is_passenger_airbag_enabled(bool value);
  private:
  bool _internal_is_passenger_airbag_enabled() const;
  void _internal_set_is_passenger_airbag_enabled(bool value);
  public:

  // optional bool is_passenger_buckled = 18;
  bool has_is_passenger_buckled() const;
  private:
  bool _internal_has_is_passenger_buckled() const;
  public:
  void clear_is_passenger_buckled();
  bool is_passenger_buckled() const;
  void set_is_passenger_buckled(bool value);
  private:
  bool _internal_is_passenger_buckled() const;
  void _internal_set_is_passenger_buckled(bool value);
  public:

  // optional int32 front_left_tire_press = 19;
  bool has_front_left_tire_press() const;
  private:
  bool _internal_has_front_left_tire_press() const;
  public:
  void clear_front_left_tire_press();
  ::PROTOBUF_NAMESPACE_ID::int32 front_left_tire_press() const;
  void set_front_left_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_front_left_tire_press() const;
  void _internal_set_front_left_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 front_right_tire_press = 20;
  bool has_front_right_tire_press() const;
  private:
  bool _internal_has_front_right_tire_press() const;
  public:
  void clear_front_right_tire_press();
  ::PROTOBUF_NAMESPACE_ID::int32 front_right_tire_press() const;
  void set_front_right_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_front_right_tire_press() const;
  void _internal_set_front_right_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 rear_left_tire_press = 21;
  bool has_rear_left_tire_press() const;
  private:
  bool _internal_has_rear_left_tire_press() const;
  public:
  void clear_rear_left_tire_press();
  ::PROTOBUF_NAMESPACE_ID::int32 rear_left_tire_press() const;
  void set_rear_left_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rear_left_tire_press() const;
  void _internal_set_rear_left_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 rear_right_tire_press = 22;
  bool has_rear_right_tire_press() const;
  private:
  bool _internal_has_rear_right_tire_press() const;
  public:
  void clear_rear_right_tire_press();
  ::PROTOBUF_NAMESPACE_ID::int32 rear_right_tire_press() const;
  void set_rear_right_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rear_right_tire_press() const;
  void _internal_set_rear_right_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .apollo.canbus.Chassis.DrivingMode car_driving_mode = 23;
  bool has_car_driving_mode() const;
  private:
  bool _internal_has_car_driving_mode() const;
  public:
  void clear_car_driving_mode();
  ::apollo::canbus::Chassis_DrivingMode car_driving_mode() const;
  void set_car_driving_mode(::apollo::canbus::Chassis_DrivingMode value);
  private:
  ::apollo::canbus::Chassis_DrivingMode _internal_car_driving_mode() const;
  void _internal_set_car_driving_mode(::apollo::canbus::Chassis_DrivingMode value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Safety)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 emergency_button_;
  bool is_driver_car_door_close_;
  bool is_driver_buckled_;
  bool has_error_;
  bool is_motor_invertor_fault_;
  bool is_system_fault_;
  bool is_power_battery_fault_;
  bool is_motor_invertor_over_temperature_;
  bool is_small_battery_charge_discharge_fault_;
  ::PROTOBUF_NAMESPACE_ID::int32 driving_mode_;
  bool is_passenger_door_open_;
  bool is_rearleft_door_open_;
  bool is_rearright_door_open_;
  bool is_hood_open_;
  bool is_trunk_open_;
  bool is_passenger_detected_;
  bool is_passenger_airbag_enabled_;
  bool is_passenger_buckled_;
  ::PROTOBUF_NAMESPACE_ID::int32 front_left_tire_press_;
  ::PROTOBUF_NAMESPACE_ID::int32 front_right_tire_press_;
  ::PROTOBUF_NAMESPACE_ID::int32 rear_left_tire_press_;
  ::PROTOBUF_NAMESPACE_ID::int32 rear_right_tire_press_;
  int car_driving_mode_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class BasicInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.BasicInfo) */ {
 public:
  BasicInfo();
  virtual ~BasicInfo();

  BasicInfo(const BasicInfo& from);
  BasicInfo(BasicInfo&& from) noexcept
    : BasicInfo() {
    *this = ::std::move(from);
  }

  inline BasicInfo& operator=(const BasicInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasicInfo& operator=(BasicInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BasicInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BasicInfo* internal_default_instance() {
    return reinterpret_cast<const BasicInfo*>(
               &_BasicInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BasicInfo& a, BasicInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BasicInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BasicInfo* New() const final {
    return CreateMaybeMessage<BasicInfo>(nullptr);
  }

  BasicInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BasicInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BasicInfo& from);
  void MergeFrom(const BasicInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.BasicInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BasicInfo_Type Type;
  static constexpr Type OFF =
    BasicInfo_Type_OFF;
  static constexpr Type ACC =
    BasicInfo_Type_ACC;
  static constexpr Type ON =
    BasicInfo_Type_ON;
  static constexpr Type START =
    BasicInfo_Type_START;
  static constexpr Type INVALID =
    BasicInfo_Type_INVALID;
  static inline bool Type_IsValid(int value) {
    return BasicInfo_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    BasicInfo_Type_Type_MIN;
  static constexpr Type Type_MAX =
    BasicInfo_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    BasicInfo_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return BasicInfo_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return BasicInfo_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return BasicInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPowerStateFieldNumber = 2,
    kIsAutoModeFieldNumber = 1,
    kIsAirBagDeployedFieldNumber = 3,
    kIsSystemErrorFieldNumber = 6,
    kIsHumanInterruptFieldNumber = 7,
    kOdoMeterFieldNumber = 4,
    kDriveRangeFieldNumber = 5,
    kAccOnButtonFieldNumber = 8,
    kAccOffButtonFieldNumber = 9,
    kAccResButtonFieldNumber = 10,
    kAccCancelButtonFieldNumber = 11,
    kAccOnOffButtonFieldNumber = 12,
    kAccResCancelButtonFieldNumber = 13,
    kAccIncSpdButtonFieldNumber = 14,
    kAccDecSpdButtonFieldNumber = 15,
    kAccIncGapButtonFieldNumber = 16,
    kAccDecGapButtonFieldNumber = 17,
    kLkaButtonFieldNumber = 18,
    kCanbusFaultFieldNumber = 19,
    kYearFieldNumber = 23,
    kLatitudeFieldNumber = 20,
    kLongitudeFieldNumber = 21,
    kMonthFieldNumber = 24,
    kDayFieldNumber = 25,
    kHoursFieldNumber = 26,
    kMinutesFieldNumber = 27,
    kSecondsFieldNumber = 28,
    kGpsValidFieldNumber = 22,
    kIsGpsFaultFieldNumber = 31,
    kIsInferredFieldNumber = 32,
    kCompassDirectionFieldNumber = 29,
    kPdopFieldNumber = 30,
    kAltitudeFieldNumber = 33,
    kHeadingFieldNumber = 34,
    kHdopFieldNumber = 35,
    kVdopFieldNumber = 36,
    kQualityFieldNumber = 37,
    kNumSatellitesFieldNumber = 38,
    kGpsSpeedFieldNumber = 39,
  };
  // optional .apollo.canbus.BasicInfo.Type power_state = 2;
  bool has_power_state() const;
  private:
  bool _internal_has_power_state() const;
  public:
  void clear_power_state();
  ::apollo::canbus::BasicInfo_Type power_state() const;
  void set_power_state(::apollo::canbus::BasicInfo_Type value);
  private:
  ::apollo::canbus::BasicInfo_Type _internal_power_state() const;
  void _internal_set_power_state(::apollo::canbus::BasicInfo_Type value);
  public:

  // optional bool is_auto_mode = 1;
  bool has_is_auto_mode() const;
  private:
  bool _internal_has_is_auto_mode() const;
  public:
  void clear_is_auto_mode();
  bool is_auto_mode() const;
  void set_is_auto_mode(bool value);
  private:
  bool _internal_is_auto_mode() const;
  void _internal_set_is_auto_mode(bool value);
  public:

  // optional bool is_air_bag_deployed = 3;
  bool has_is_air_bag_deployed() const;
  private:
  bool _internal_has_is_air_bag_deployed() const;
  public:
  void clear_is_air_bag_deployed();
  bool is_air_bag_deployed() const;
  void set_is_air_bag_deployed(bool value);
  private:
  bool _internal_is_air_bag_deployed() const;
  void _internal_set_is_air_bag_deployed(bool value);
  public:

  // optional bool is_system_error = 6;
  bool has_is_system_error() const;
  private:
  bool _internal_has_is_system_error() const;
  public:
  void clear_is_system_error();
  bool is_system_error() const;
  void set_is_system_error(bool value);
  private:
  bool _internal_is_system_error() const;
  void _internal_set_is_system_error(bool value);
  public:

  // optional bool is_human_interrupt = 7;
  bool has_is_human_interrupt() const;
  private:
  bool _internal_has_is_human_interrupt() const;
  public:
  void clear_is_human_interrupt();
  bool is_human_interrupt() const;
  void set_is_human_interrupt(bool value);
  private:
  bool _internal_is_human_interrupt() const;
  void _internal_set_is_human_interrupt(bool value);
  public:

  // optional double odo_meter = 4;
  bool has_odo_meter() const;
  private:
  bool _internal_has_odo_meter() const;
  public:
  void clear_odo_meter();
  double odo_meter() const;
  void set_odo_meter(double value);
  private:
  double _internal_odo_meter() const;
  void _internal_set_odo_meter(double value);
  public:

  // optional double drive_range = 5;
  bool has_drive_range() const;
  private:
  bool _internal_has_drive_range() const;
  public:
  void clear_drive_range();
  double drive_range() const;
  void set_drive_range(double value);
  private:
  double _internal_drive_range() const;
  void _internal_set_drive_range(double value);
  public:

  // optional bool acc_on_button = 8;
  bool has_acc_on_button() const;
  private:
  bool _internal_has_acc_on_button() const;
  public:
  void clear_acc_on_button();
  bool acc_on_button() const;
  void set_acc_on_button(bool value);
  private:
  bool _internal_acc_on_button() const;
  void _internal_set_acc_on_button(bool value);
  public:

  // optional bool acc_off_button = 9;
  bool has_acc_off_button() const;
  private:
  bool _internal_has_acc_off_button() const;
  public:
  void clear_acc_off_button();
  bool acc_off_button() const;
  void set_acc_off_button(bool value);
  private:
  bool _internal_acc_off_button() const;
  void _internal_set_acc_off_button(bool value);
  public:

  // optional bool acc_res_button = 10;
  bool has_acc_res_button() const;
  private:
  bool _internal_has_acc_res_button() const;
  public:
  void clear_acc_res_button();
  bool acc_res_button() const;
  void set_acc_res_button(bool value);
  private:
  bool _internal_acc_res_button() const;
  void _internal_set_acc_res_button(bool value);
  public:

  // optional bool acc_cancel_button = 11;
  bool has_acc_cancel_button() const;
  private:
  bool _internal_has_acc_cancel_button() const;
  public:
  void clear_acc_cancel_button();
  bool acc_cancel_button() const;
  void set_acc_cancel_button(bool value);
  private:
  bool _internal_acc_cancel_button() const;
  void _internal_set_acc_cancel_button(bool value);
  public:

  // optional bool acc_on_off_button = 12;
  bool has_acc_on_off_button() const;
  private:
  bool _internal_has_acc_on_off_button() const;
  public:
  void clear_acc_on_off_button();
  bool acc_on_off_button() const;
  void set_acc_on_off_button(bool value);
  private:
  bool _internal_acc_on_off_button() const;
  void _internal_set_acc_on_off_button(bool value);
  public:

  // optional bool acc_res_cancel_button = 13;
  bool has_acc_res_cancel_button() const;
  private:
  bool _internal_has_acc_res_cancel_button() const;
  public:
  void clear_acc_res_cancel_button();
  bool acc_res_cancel_button() const;
  void set_acc_res_cancel_button(bool value);
  private:
  bool _internal_acc_res_cancel_button() const;
  void _internal_set_acc_res_cancel_button(bool value);
  public:

  // optional bool acc_inc_spd_button = 14;
  bool has_acc_inc_spd_button() const;
  private:
  bool _internal_has_acc_inc_spd_button() const;
  public:
  void clear_acc_inc_spd_button();
  bool acc_inc_spd_button() const;
  void set_acc_inc_spd_button(bool value);
  private:
  bool _internal_acc_inc_spd_button() const;
  void _internal_set_acc_inc_spd_button(bool value);
  public:

  // optional bool acc_dec_spd_button = 15;
  bool has_acc_dec_spd_button() const;
  private:
  bool _internal_has_acc_dec_spd_button() const;
  public:
  void clear_acc_dec_spd_button();
  bool acc_dec_spd_button() const;
  void set_acc_dec_spd_button(bool value);
  private:
  bool _internal_acc_dec_spd_button() const;
  void _internal_set_acc_dec_spd_button(bool value);
  public:

  // optional bool acc_inc_gap_button = 16;
  bool has_acc_inc_gap_button() const;
  private:
  bool _internal_has_acc_inc_gap_button() const;
  public:
  void clear_acc_inc_gap_button();
  bool acc_inc_gap_button() const;
  void set_acc_inc_gap_button(bool value);
  private:
  bool _internal_acc_inc_gap_button() const;
  void _internal_set_acc_inc_gap_button(bool value);
  public:

  // optional bool acc_dec_gap_button = 17;
  bool has_acc_dec_gap_button() const;
  private:
  bool _internal_has_acc_dec_gap_button() const;
  public:
  void clear_acc_dec_gap_button();
  bool acc_dec_gap_button() const;
  void set_acc_dec_gap_button(bool value);
  private:
  bool _internal_acc_dec_gap_button() const;
  void _internal_set_acc_dec_gap_button(bool value);
  public:

  // optional bool lka_button = 18;
  bool has_lka_button() const;
  private:
  bool _internal_has_lka_button() const;
  public:
  void clear_lka_button();
  bool lka_button() const;
  void set_lka_button(bool value);
  private:
  bool _internal_lka_button() const;
  void _internal_set_lka_button(bool value);
  public:

  // optional bool canbus_fault = 19;
  bool has_canbus_fault() const;
  private:
  bool _internal_has_canbus_fault() const;
  public:
  void clear_canbus_fault();
  bool canbus_fault() const;
  void set_canbus_fault(bool value);
  private:
  bool _internal_canbus_fault() const;
  void _internal_set_canbus_fault(bool value);
  public:

  // optional int32 year = 23;
  bool has_year() const;
  private:
  bool _internal_has_year() const;
  public:
  void clear_year();
  ::PROTOBUF_NAMESPACE_ID::int32 year() const;
  void set_year(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_year() const;
  void _internal_set_year(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double latitude = 20;
  bool has_latitude() const;
  private:
  bool _internal_has_latitude() const;
  public:
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // optional double longitude = 21;
  bool has_longitude() const;
  private:
  bool _internal_has_longitude() const;
  public:
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // optional int32 month = 24;
  bool has_month() const;
  private:
  bool _internal_has_month() const;
  public:
  void clear_month();
  ::PROTOBUF_NAMESPACE_ID::int32 month() const;
  void set_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_month() const;
  void _internal_set_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 day = 25;
  bool has_day() const;
  private:
  bool _internal_has_day() const;
  public:
  void clear_day();
  ::PROTOBUF_NAMESPACE_ID::int32 day() const;
  void set_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_day() const;
  void _internal_set_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 hours = 26;
  bool has_hours() const;
  private:
  bool _internal_has_hours() const;
  public:
  void clear_hours();
  ::PROTOBUF_NAMESPACE_ID::int32 hours() const;
  void set_hours(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hours() const;
  void _internal_set_hours(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 minutes = 27;
  bool has_minutes() const;
  private:
  bool _internal_has_minutes() const;
  public:
  void clear_minutes();
  ::PROTOBUF_NAMESPACE_ID::int32 minutes() const;
  void set_minutes(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_minutes() const;
  void _internal_set_minutes(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 seconds = 28;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  ::PROTOBUF_NAMESPACE_ID::int32 seconds() const;
  void set_seconds(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_seconds() const;
  void _internal_set_seconds(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool gps_valid = 22;
  bool has_gps_valid() const;
  private:
  bool _internal_has_gps_valid() const;
  public:
  void clear_gps_valid();
  bool gps_valid() const;
  void set_gps_valid(bool value);
  private:
  bool _internal_gps_valid() const;
  void _internal_set_gps_valid(bool value);
  public:

  // optional bool is_gps_fault = 31;
  bool has_is_gps_fault() const;
  private:
  bool _internal_has_is_gps_fault() const;
  public:
  void clear_is_gps_fault();
  bool is_gps_fault() const;
  void set_is_gps_fault(bool value);
  private:
  bool _internal_is_gps_fault() const;
  void _internal_set_is_gps_fault(bool value);
  public:

  // optional bool is_inferred = 32;
  bool has_is_inferred() const;
  private:
  bool _internal_has_is_inferred() const;
  public:
  void clear_is_inferred();
  bool is_inferred() const;
  void set_is_inferred(bool value);
  private:
  bool _internal_is_inferred() const;
  void _internal_set_is_inferred(bool value);
  public:

  // optional double compass_direction = 29;
  bool has_compass_direction() const;
  private:
  bool _internal_has_compass_direction() const;
  public:
  void clear_compass_direction();
  double compass_direction() const;
  void set_compass_direction(double value);
  private:
  double _internal_compass_direction() const;
  void _internal_set_compass_direction(double value);
  public:

  // optional double pdop = 30;
  bool has_pdop() const;
  private:
  bool _internal_has_pdop() const;
  public:
  void clear_pdop();
  double pdop() const;
  void set_pdop(double value);
  private:
  double _internal_pdop() const;
  void _internal_set_pdop(double value);
  public:

  // optional double altitude = 33;
  bool has_altitude() const;
  private:
  bool _internal_has_altitude() const;
  public:
  void clear_altitude();
  double altitude() const;
  void set_altitude(double value);
  private:
  double _internal_altitude() const;
  void _internal_set_altitude(double value);
  public:

  // optional double heading = 34;
  bool has_heading() const;
  private:
  bool _internal_has_heading() const;
  public:
  void clear_heading();
  double heading() const;
  void set_heading(double value);
  private:
  double _internal_heading() const;
  void _internal_set_heading(double value);
  public:

  // optional double hdop = 35;
  bool has_hdop() const;
  private:
  bool _internal_has_hdop() const;
  public:
  void clear_hdop();
  double hdop() const;
  void set_hdop(double value);
  private:
  double _internal_hdop() const;
  void _internal_set_hdop(double value);
  public:

  // optional double vdop = 36;
  bool has_vdop() const;
  private:
  bool _internal_has_vdop() const;
  public:
  void clear_vdop();
  double vdop() const;
  void set_vdop(double value);
  private:
  double _internal_vdop() const;
  void _internal_set_vdop(double value);
  public:

  // optional .apollo.canbus.GpsQuality quality = 37;
  bool has_quality() const;
  private:
  bool _internal_has_quality() const;
  public:
  void clear_quality();
  ::apollo::canbus::GpsQuality quality() const;
  void set_quality(::apollo::canbus::GpsQuality value);
  private:
  ::apollo::canbus::GpsQuality _internal_quality() const;
  void _internal_set_quality(::apollo::canbus::GpsQuality value);
  public:

  // optional int32 num_satellites = 38;
  bool has_num_satellites() const;
  private:
  bool _internal_has_num_satellites() const;
  public:
  void clear_num_satellites();
  ::PROTOBUF_NAMESPACE_ID::int32 num_satellites() const;
  void set_num_satellites(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_satellites() const;
  void _internal_set_num_satellites(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double gps_speed = 39;
  bool has_gps_speed() const;
  private:
  bool _internal_has_gps_speed() const;
  public:
  void clear_gps_speed();
  double gps_speed() const;
  void set_gps_speed(double value);
  private:
  double _internal_gps_speed() const;
  void _internal_set_gps_speed(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.BasicInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int power_state_;
  bool is_auto_mode_;
  bool is_air_bag_deployed_;
  bool is_system_error_;
  bool is_human_interrupt_;
  double odo_meter_;
  double drive_range_;
  bool acc_on_button_;
  bool acc_off_button_;
  bool acc_res_button_;
  bool acc_cancel_button_;
  bool acc_on_off_button_;
  bool acc_res_cancel_button_;
  bool acc_inc_spd_button_;
  bool acc_dec_spd_button_;
  bool acc_inc_gap_button_;
  bool acc_dec_gap_button_;
  bool lka_button_;
  bool canbus_fault_;
  ::PROTOBUF_NAMESPACE_ID::int32 year_;
  double latitude_;
  double longitude_;
  ::PROTOBUF_NAMESPACE_ID::int32 month_;
  ::PROTOBUF_NAMESPACE_ID::int32 day_;
  ::PROTOBUF_NAMESPACE_ID::int32 hours_;
  ::PROTOBUF_NAMESPACE_ID::int32 minutes_;
  ::PROTOBUF_NAMESPACE_ID::int32 seconds_;
  bool gps_valid_;
  bool is_gps_fault_;
  bool is_inferred_;
  double compass_direction_;
  double pdop_;
  double altitude_;
  double heading_;
  double hdop_;
  double vdop_;
  int quality_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_satellites_;
  double gps_speed_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Global_rpt_6a :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Global_rpt_6a) */ {
 public:
  Global_rpt_6a();
  virtual ~Global_rpt_6a();

  Global_rpt_6a(const Global_rpt_6a& from);
  Global_rpt_6a(Global_rpt_6a&& from) noexcept
    : Global_rpt_6a() {
    *this = ::std::move(from);
  }

  inline Global_rpt_6a& operator=(const Global_rpt_6a& from) {
    CopyFrom(from);
    return *this;
  }
  inline Global_rpt_6a& operator=(Global_rpt_6a&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Global_rpt_6a& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Global_rpt_6a* internal_default_instance() {
    return reinterpret_cast<const Global_rpt_6a*>(
               &_Global_rpt_6a_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Global_rpt_6a& a, Global_rpt_6a& b) {
    a.Swap(&b);
  }
  inline void Swap(Global_rpt_6a* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Global_rpt_6a* New() const final {
    return CreateMaybeMessage<Global_rpt_6a>(nullptr);
  }

  Global_rpt_6a* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Global_rpt_6a>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Global_rpt_6a& from);
  void MergeFrom(const Global_rpt_6a& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Global_rpt_6a* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Global_rpt_6a";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Global_rpt_6a_Pacmod_statusType Pacmod_statusType;
  static constexpr Pacmod_statusType PACMOD_STATUS_CONTROL_DISABLED =
    Global_rpt_6a_Pacmod_statusType_PACMOD_STATUS_CONTROL_DISABLED;
  static constexpr Pacmod_statusType PACMOD_STATUS_CONTROL_ENABLED =
    Global_rpt_6a_Pacmod_statusType_PACMOD_STATUS_CONTROL_ENABLED;
  static inline bool Pacmod_statusType_IsValid(int value) {
    return Global_rpt_6a_Pacmod_statusType_IsValid(value);
  }
  static constexpr Pacmod_statusType Pacmod_statusType_MIN =
    Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_MIN;
  static constexpr Pacmod_statusType Pacmod_statusType_MAX =
    Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_MAX;
  static constexpr int Pacmod_statusType_ARRAYSIZE =
    Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Pacmod_statusType_descriptor() {
    return Global_rpt_6a_Pacmod_statusType_descriptor();
  }
  template<typename T>
  static inline const std::string& Pacmod_statusType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Pacmod_statusType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Pacmod_statusType_Name.");
    return Global_rpt_6a_Pacmod_statusType_Name(enum_t_value);
  }
  static inline bool Pacmod_statusType_Parse(const std::string& name,
      Pacmod_statusType* value) {
    return Global_rpt_6a_Pacmod_statusType_Parse(name, value);
  }

  typedef Global_rpt_6a_Override_statusType Override_statusType;
  static constexpr Override_statusType OVERRIDE_STATUS_NOT_OVERRIDDEN =
    Global_rpt_6a_Override_statusType_OVERRIDE_STATUS_NOT_OVERRIDDEN;
  static constexpr Override_statusType OVERRIDE_STATUS_OVERRIDDEN =
    Global_rpt_6a_Override_statusType_OVERRIDE_STATUS_OVERRIDDEN;
  static inline bool Override_statusType_IsValid(int value) {
    return Global_rpt_6a_Override_statusType_IsValid(value);
  }
  static constexpr Override_statusType Override_statusType_MIN =
    Global_rpt_6a_Override_statusType_Override_statusType_MIN;
  static constexpr Override_statusType Override_statusType_MAX =
    Global_rpt_6a_Override_statusType_Override_statusType_MAX;
  static constexpr int Override_statusType_ARRAYSIZE =
    Global_rpt_6a_Override_statusType_Override_statusType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Override_statusType_descriptor() {
    return Global_rpt_6a_Override_statusType_descriptor();
  }
  template<typename T>
  static inline const std::string& Override_statusType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Override_statusType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Override_statusType_Name.");
    return Global_rpt_6a_Override_statusType_Name(enum_t_value);
  }
  static inline bool Override_statusType_Parse(const std::string& name,
      Override_statusType* value) {
    return Global_rpt_6a_Override_statusType_Parse(name, value);
  }

  typedef Global_rpt_6a_Brk_can_timeoutType Brk_can_timeoutType;
  static constexpr Brk_can_timeoutType BRK_CAN_TIMEOUT_NO_ACTIVE_CAN_TIMEOUT =
    Global_rpt_6a_Brk_can_timeoutType_BRK_CAN_TIMEOUT_NO_ACTIVE_CAN_TIMEOUT;
  static constexpr Brk_can_timeoutType BRK_CAN_TIMEOUT_ACTIVE_CAN_TIMEOUT =
    Global_rpt_6a_Brk_can_timeoutType_BRK_CAN_TIMEOUT_ACTIVE_CAN_TIMEOUT;
  static inline bool Brk_can_timeoutType_IsValid(int value) {
    return Global_rpt_6a_Brk_can_timeoutType_IsValid(value);
  }
  static constexpr Brk_can_timeoutType Brk_can_timeoutType_MIN =
    Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_MIN;
  static constexpr Brk_can_timeoutType Brk_can_timeoutType_MAX =
    Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_MAX;
  static constexpr int Brk_can_timeoutType_ARRAYSIZE =
    Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Brk_can_timeoutType_descriptor() {
    return Global_rpt_6a_Brk_can_timeoutType_descriptor();
  }
  template<typename T>
  static inline const std::string& Brk_can_timeoutType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Brk_can_timeoutType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Brk_can_timeoutType_Name.");
    return Global_rpt_6a_Brk_can_timeoutType_Name(enum_t_value);
  }
  static inline bool Brk_can_timeoutType_Parse(const std::string& name,
      Brk_can_timeoutType* value) {
    return Global_rpt_6a_Brk_can_timeoutType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPacmodStatusFieldNumber = 1,
    kOverrideStatusFieldNumber = 2,
    kVehCanTimeoutFieldNumber = 3,
    kStrCanTimeoutFieldNumber = 4,
    kUsrCanTimeoutFieldNumber = 6,
    kBrkCanTimeoutFieldNumber = 5,
    kUsrCanReadErrorsFieldNumber = 7,
  };
  // optional .apollo.canbus.Global_rpt_6a.Pacmod_statusType pacmod_status = 1;
  bool has_pacmod_status() const;
  private:
  bool _internal_has_pacmod_status() const;
  public:
  void clear_pacmod_status();
  ::apollo::canbus::Global_rpt_6a_Pacmod_statusType pacmod_status() const;
  void set_pacmod_status(::apollo::canbus::Global_rpt_6a_Pacmod_statusType value);
  private:
  ::apollo::canbus::Global_rpt_6a_Pacmod_statusType _internal_pacmod_status() const;
  void _internal_set_pacmod_status(::apollo::canbus::Global_rpt_6a_Pacmod_statusType value);
  public:

  // optional .apollo.canbus.Global_rpt_6a.Override_statusType override_status = 2;
  bool has_override_status() const;
  private:
  bool _internal_has_override_status() const;
  public:
  void clear_override_status();
  ::apollo::canbus::Global_rpt_6a_Override_statusType override_status() const;
  void set_override_status(::apollo::canbus::Global_rpt_6a_Override_statusType value);
  private:
  ::apollo::canbus::Global_rpt_6a_Override_statusType _internal_override_status() const;
  void _internal_set_override_status(::apollo::canbus::Global_rpt_6a_Override_statusType value);
  public:

  // optional bool veh_can_timeout = 3;
  bool has_veh_can_timeout() const;
  private:
  bool _internal_has_veh_can_timeout() const;
  public:
  void clear_veh_can_timeout();
  bool veh_can_timeout() const;
  void set_veh_can_timeout(bool value);
  private:
  bool _internal_veh_can_timeout() const;
  void _internal_set_veh_can_timeout(bool value);
  public:

  // optional bool str_can_timeout = 4;
  bool has_str_can_timeout() const;
  private:
  bool _internal_has_str_can_timeout() const;
  public:
  void clear_str_can_timeout();
  bool str_can_timeout() const;
  void set_str_can_timeout(bool value);
  private:
  bool _internal_str_can_timeout() const;
  void _internal_set_str_can_timeout(bool value);
  public:

  // optional bool usr_can_timeout = 6;
  bool has_usr_can_timeout() const;
  private:
  bool _internal_has_usr_can_timeout() const;
  public:
  void clear_usr_can_timeout();
  bool usr_can_timeout() const;
  void set_usr_can_timeout(bool value);
  private:
  bool _internal_usr_can_timeout() const;
  void _internal_set_usr_can_timeout(bool value);
  public:

  // optional .apollo.canbus.Global_rpt_6a.Brk_can_timeoutType brk_can_timeout = 5;
  bool has_brk_can_timeout() const;
  private:
  bool _internal_has_brk_can_timeout() const;
  public:
  void clear_brk_can_timeout();
  ::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType brk_can_timeout() const;
  void set_brk_can_timeout(::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType value);
  private:
  ::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType _internal_brk_can_timeout() const;
  void _internal_set_brk_can_timeout(::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType value);
  public:

  // optional int32 usr_can_read_errors = 7;
  bool has_usr_can_read_errors() const;
  private:
  bool _internal_has_usr_can_read_errors() const;
  public:
  void clear_usr_can_read_errors();
  ::PROTOBUF_NAMESPACE_ID::int32 usr_can_read_errors() const;
  void set_usr_can_read_errors(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_usr_can_read_errors() const;
  void _internal_set_usr_can_read_errors(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Global_rpt_6a)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int pacmod_status_;
  int override_status_;
  bool veh_can_timeout_;
  bool str_can_timeout_;
  bool usr_can_timeout_;
  int brk_can_timeout_;
  ::PROTOBUF_NAMESPACE_ID::int32 usr_can_read_errors_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Brake_cmd_6b :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Brake_cmd_6b) */ {
 public:
  Brake_cmd_6b();
  virtual ~Brake_cmd_6b();

  Brake_cmd_6b(const Brake_cmd_6b& from);
  Brake_cmd_6b(Brake_cmd_6b&& from) noexcept
    : Brake_cmd_6b() {
    *this = ::std::move(from);
  }

  inline Brake_cmd_6b& operator=(const Brake_cmd_6b& from) {
    CopyFrom(from);
    return *this;
  }
  inline Brake_cmd_6b& operator=(Brake_cmd_6b&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Brake_cmd_6b& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Brake_cmd_6b* internal_default_instance() {
    return reinterpret_cast<const Brake_cmd_6b*>(
               &_Brake_cmd_6b_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Brake_cmd_6b& a, Brake_cmd_6b& b) {
    a.Swap(&b);
  }
  inline void Swap(Brake_cmd_6b* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Brake_cmd_6b* New() const final {
    return CreateMaybeMessage<Brake_cmd_6b>(nullptr);
  }

  Brake_cmd_6b* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Brake_cmd_6b>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Brake_cmd_6b& from);
  void MergeFrom(const Brake_cmd_6b& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Brake_cmd_6b* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Brake_cmd_6b";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBrakeCmdFieldNumber = 1,
  };
  // optional double brake_cmd = 1;
  bool has_brake_cmd() const;
  private:
  bool _internal_has_brake_cmd() const;
  public:
  void clear_brake_cmd();
  double brake_cmd() const;
  void set_brake_cmd(double value);
  private:
  double _internal_brake_cmd() const;
  void _internal_set_brake_cmd(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Brake_cmd_6b)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double brake_cmd_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Brake_rpt_6c :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Brake_rpt_6c) */ {
 public:
  Brake_rpt_6c();
  virtual ~Brake_rpt_6c();

  Brake_rpt_6c(const Brake_rpt_6c& from);
  Brake_rpt_6c(Brake_rpt_6c&& from) noexcept
    : Brake_rpt_6c() {
    *this = ::std::move(from);
  }

  inline Brake_rpt_6c& operator=(const Brake_rpt_6c& from) {
    CopyFrom(from);
    return *this;
  }
  inline Brake_rpt_6c& operator=(Brake_rpt_6c&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Brake_rpt_6c& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Brake_rpt_6c* internal_default_instance() {
    return reinterpret_cast<const Brake_rpt_6c*>(
               &_Brake_rpt_6c_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Brake_rpt_6c& a, Brake_rpt_6c& b) {
    a.Swap(&b);
  }
  inline void Swap(Brake_rpt_6c* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Brake_rpt_6c* New() const final {
    return CreateMaybeMessage<Brake_rpt_6c>(nullptr);
  }

  Brake_rpt_6c* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Brake_rpt_6c>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Brake_rpt_6c& from);
  void MergeFrom(const Brake_rpt_6c& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Brake_rpt_6c* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Brake_rpt_6c";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Brake_rpt_6c_Brake_on_offType Brake_on_offType;
  static constexpr Brake_on_offType BRAKE_ON_OFF_OFF =
    Brake_rpt_6c_Brake_on_offType_BRAKE_ON_OFF_OFF;
  static constexpr Brake_on_offType BRAKE_ON_OFF_ON =
    Brake_rpt_6c_Brake_on_offType_BRAKE_ON_OFF_ON;
  static inline bool Brake_on_offType_IsValid(int value) {
    return Brake_rpt_6c_Brake_on_offType_IsValid(value);
  }
  static constexpr Brake_on_offType Brake_on_offType_MIN =
    Brake_rpt_6c_Brake_on_offType_Brake_on_offType_MIN;
  static constexpr Brake_on_offType Brake_on_offType_MAX =
    Brake_rpt_6c_Brake_on_offType_Brake_on_offType_MAX;
  static constexpr int Brake_on_offType_ARRAYSIZE =
    Brake_rpt_6c_Brake_on_offType_Brake_on_offType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Brake_on_offType_descriptor() {
    return Brake_rpt_6c_Brake_on_offType_descriptor();
  }
  template<typename T>
  static inline const std::string& Brake_on_offType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Brake_on_offType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Brake_on_offType_Name.");
    return Brake_rpt_6c_Brake_on_offType_Name(enum_t_value);
  }
  static inline bool Brake_on_offType_Parse(const std::string& name,
      Brake_on_offType* value) {
    return Brake_rpt_6c_Brake_on_offType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kManualInputFieldNumber = 1,
    kCommandedValueFieldNumber = 2,
    kOutputValueFieldNumber = 3,
    kBrakeOnOffFieldNumber = 4,
  };
  // optional double manual_input = 1;
  bool has_manual_input() const;
  private:
  bool _internal_has_manual_input() const;
  public:
  void clear_manual_input();
  double manual_input() const;
  void set_manual_input(double value);
  private:
  double _internal_manual_input() const;
  void _internal_set_manual_input(double value);
  public:

  // optional double commanded_value = 2;
  bool has_commanded_value() const;
  private:
  bool _internal_has_commanded_value() const;
  public:
  void clear_commanded_value();
  double commanded_value() const;
  void set_commanded_value(double value);
  private:
  double _internal_commanded_value() const;
  void _internal_set_commanded_value(double value);
  public:

  // optional double output_value = 3;
  bool has_output_value() const;
  private:
  bool _internal_has_output_value() const;
  public:
  void clear_output_value();
  double output_value() const;
  void set_output_value(double value);
  private:
  double _internal_output_value() const;
  void _internal_set_output_value(double value);
  public:

  // optional .apollo.canbus.Brake_rpt_6c.Brake_on_offType brake_on_off = 4;
  bool has_brake_on_off() const;
  private:
  bool _internal_has_brake_on_off() const;
  public:
  void clear_brake_on_off();
  ::apollo::canbus::Brake_rpt_6c_Brake_on_offType brake_on_off() const;
  void set_brake_on_off(::apollo::canbus::Brake_rpt_6c_Brake_on_offType value);
  private:
  ::apollo::canbus::Brake_rpt_6c_Brake_on_offType _internal_brake_on_off() const;
  void _internal_set_brake_on_off(::apollo::canbus::Brake_rpt_6c_Brake_on_offType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Brake_rpt_6c)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double manual_input_;
  double commanded_value_;
  double output_value_;
  int brake_on_off_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Steering_cmd_6d :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Steering_cmd_6d) */ {
 public:
  Steering_cmd_6d();
  virtual ~Steering_cmd_6d();

  Steering_cmd_6d(const Steering_cmd_6d& from);
  Steering_cmd_6d(Steering_cmd_6d&& from) noexcept
    : Steering_cmd_6d() {
    *this = ::std::move(from);
  }

  inline Steering_cmd_6d& operator=(const Steering_cmd_6d& from) {
    CopyFrom(from);
    return *this;
  }
  inline Steering_cmd_6d& operator=(Steering_cmd_6d&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Steering_cmd_6d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Steering_cmd_6d* internal_default_instance() {
    return reinterpret_cast<const Steering_cmd_6d*>(
               &_Steering_cmd_6d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Steering_cmd_6d& a, Steering_cmd_6d& b) {
    a.Swap(&b);
  }
  inline void Swap(Steering_cmd_6d* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Steering_cmd_6d* New() const final {
    return CreateMaybeMessage<Steering_cmd_6d>(nullptr);
  }

  Steering_cmd_6d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Steering_cmd_6d>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Steering_cmd_6d& from);
  void MergeFrom(const Steering_cmd_6d& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Steering_cmd_6d* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Steering_cmd_6d";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionValueFieldNumber = 1,
    kSpeedLimitFieldNumber = 2,
  };
  // optional double position_value = 1;
  bool has_position_value() const;
  private:
  bool _internal_has_position_value() const;
  public:
  void clear_position_value();
  double position_value() const;
  void set_position_value(double value);
  private:
  double _internal_position_value() const;
  void _internal_set_position_value(double value);
  public:

  // optional double speed_limit = 2;
  bool has_speed_limit() const;
  private:
  bool _internal_has_speed_limit() const;
  public:
  void clear_speed_limit();
  double speed_limit() const;
  void set_speed_limit(double value);
  private:
  double _internal_speed_limit() const;
  void _internal_set_speed_limit(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Steering_cmd_6d)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double position_value_;
  double speed_limit_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Steering_rpt_1_6e :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Steering_rpt_1_6e) */ {
 public:
  Steering_rpt_1_6e();
  virtual ~Steering_rpt_1_6e();

  Steering_rpt_1_6e(const Steering_rpt_1_6e& from);
  Steering_rpt_1_6e(Steering_rpt_1_6e&& from) noexcept
    : Steering_rpt_1_6e() {
    *this = ::std::move(from);
  }

  inline Steering_rpt_1_6e& operator=(const Steering_rpt_1_6e& from) {
    CopyFrom(from);
    return *this;
  }
  inline Steering_rpt_1_6e& operator=(Steering_rpt_1_6e&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Steering_rpt_1_6e& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Steering_rpt_1_6e* internal_default_instance() {
    return reinterpret_cast<const Steering_rpt_1_6e*>(
               &_Steering_rpt_1_6e_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Steering_rpt_1_6e& a, Steering_rpt_1_6e& b) {
    a.Swap(&b);
  }
  inline void Swap(Steering_rpt_1_6e* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Steering_rpt_1_6e* New() const final {
    return CreateMaybeMessage<Steering_rpt_1_6e>(nullptr);
  }

  Steering_rpt_1_6e* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Steering_rpt_1_6e>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Steering_rpt_1_6e& from);
  void MergeFrom(const Steering_rpt_1_6e& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Steering_rpt_1_6e* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Steering_rpt_1_6e";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManualInputFieldNumber = 1,
    kCommandedValueFieldNumber = 2,
    kOutputValueFieldNumber = 3,
  };
  // optional double manual_input = 1;
  bool has_manual_input() const;
  private:
  bool _internal_has_manual_input() const;
  public:
  void clear_manual_input();
  double manual_input() const;
  void set_manual_input(double value);
  private:
  double _internal_manual_input() const;
  void _internal_set_manual_input(double value);
  public:

  // optional double commanded_value = 2;
  bool has_commanded_value() const;
  private:
  bool _internal_has_commanded_value() const;
  public:
  void clear_commanded_value();
  double commanded_value() const;
  void set_commanded_value(double value);
  private:
  double _internal_commanded_value() const;
  void _internal_set_commanded_value(double value);
  public:

  // optional double output_value = 3;
  bool has_output_value() const;
  private:
  bool _internal_has_output_value() const;
  public:
  void clear_output_value();
  double output_value() const;
  void set_output_value(double value);
  private:
  double _internal_output_value() const;
  void _internal_set_output_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Steering_rpt_1_6e)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double manual_input_;
  double commanded_value_;
  double output_value_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Wheel_speed_rpt_7a :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Wheel_speed_rpt_7a) */ {
 public:
  Wheel_speed_rpt_7a();
  virtual ~Wheel_speed_rpt_7a();

  Wheel_speed_rpt_7a(const Wheel_speed_rpt_7a& from);
  Wheel_speed_rpt_7a(Wheel_speed_rpt_7a&& from) noexcept
    : Wheel_speed_rpt_7a() {
    *this = ::std::move(from);
  }

  inline Wheel_speed_rpt_7a& operator=(const Wheel_speed_rpt_7a& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wheel_speed_rpt_7a& operator=(Wheel_speed_rpt_7a&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Wheel_speed_rpt_7a& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Wheel_speed_rpt_7a* internal_default_instance() {
    return reinterpret_cast<const Wheel_speed_rpt_7a*>(
               &_Wheel_speed_rpt_7a_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Wheel_speed_rpt_7a& a, Wheel_speed_rpt_7a& b) {
    a.Swap(&b);
  }
  inline void Swap(Wheel_speed_rpt_7a* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Wheel_speed_rpt_7a* New() const final {
    return CreateMaybeMessage<Wheel_speed_rpt_7a>(nullptr);
  }

  Wheel_speed_rpt_7a* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Wheel_speed_rpt_7a>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Wheel_speed_rpt_7a& from);
  void MergeFrom(const Wheel_speed_rpt_7a& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wheel_speed_rpt_7a* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Wheel_speed_rpt_7a";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWheelSpdRearRightFieldNumber = 1,
    kWheelSpdRearLeftFieldNumber = 2,
    kWheelSpdFrontRightFieldNumber = 3,
    kWheelSpdFrontLeftFieldNumber = 4,
  };
  // optional int32 wheel_spd_rear_right = 1;
  bool has_wheel_spd_rear_right() const;
  private:
  bool _internal_has_wheel_spd_rear_right() const;
  public:
  void clear_wheel_spd_rear_right();
  ::PROTOBUF_NAMESPACE_ID::int32 wheel_spd_rear_right() const;
  void set_wheel_spd_rear_right(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wheel_spd_rear_right() const;
  void _internal_set_wheel_spd_rear_right(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 wheel_spd_rear_left = 2;
  bool has_wheel_spd_rear_left() const;
  private:
  bool _internal_has_wheel_spd_rear_left() const;
  public:
  void clear_wheel_spd_rear_left();
  ::PROTOBUF_NAMESPACE_ID::int32 wheel_spd_rear_left() const;
  void set_wheel_spd_rear_left(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wheel_spd_rear_left() const;
  void _internal_set_wheel_spd_rear_left(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 wheel_spd_front_right = 3;
  bool has_wheel_spd_front_right() const;
  private:
  bool _internal_has_wheel_spd_front_right() const;
  public:
  void clear_wheel_spd_front_right();
  ::PROTOBUF_NAMESPACE_ID::int32 wheel_spd_front_right() const;
  void set_wheel_spd_front_right(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wheel_spd_front_right() const;
  void _internal_set_wheel_spd_front_right(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 wheel_spd_front_left = 4;
  bool has_wheel_spd_front_left() const;
  private:
  bool _internal_has_wheel_spd_front_left() const;
  public:
  void clear_wheel_spd_front_left();
  ::PROTOBUF_NAMESPACE_ID::int32 wheel_spd_front_left() const;
  void set_wheel_spd_front_left(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wheel_spd_front_left() const;
  void _internal_set_wheel_spd_front_left(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Wheel_speed_rpt_7a)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 wheel_spd_rear_right_;
  ::PROTOBUF_NAMESPACE_ID::int32 wheel_spd_rear_left_;
  ::PROTOBUF_NAMESPACE_ID::int32 wheel_spd_front_right_;
  ::PROTOBUF_NAMESPACE_ID::int32 wheel_spd_front_left_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Date_time_rpt_83 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Date_time_rpt_83) */ {
 public:
  Date_time_rpt_83();
  virtual ~Date_time_rpt_83();

  Date_time_rpt_83(const Date_time_rpt_83& from);
  Date_time_rpt_83(Date_time_rpt_83&& from) noexcept
    : Date_time_rpt_83() {
    *this = ::std::move(from);
  }

  inline Date_time_rpt_83& operator=(const Date_time_rpt_83& from) {
    CopyFrom(from);
    return *this;
  }
  inline Date_time_rpt_83& operator=(Date_time_rpt_83&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Date_time_rpt_83& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Date_time_rpt_83* internal_default_instance() {
    return reinterpret_cast<const Date_time_rpt_83*>(
               &_Date_time_rpt_83_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Date_time_rpt_83& a, Date_time_rpt_83& b) {
    a.Swap(&b);
  }
  inline void Swap(Date_time_rpt_83* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Date_time_rpt_83* New() const final {
    return CreateMaybeMessage<Date_time_rpt_83>(nullptr);
  }

  Date_time_rpt_83* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Date_time_rpt_83>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Date_time_rpt_83& from);
  void MergeFrom(const Date_time_rpt_83& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Date_time_rpt_83* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Date_time_rpt_83";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeSecondFieldNumber = 1,
    kTimeMinuteFieldNumber = 2,
    kTimeHourFieldNumber = 3,
    kDateDayFieldNumber = 4,
    kDateMonthFieldNumber = 5,
    kDateYearFieldNumber = 6,
  };
  // optional int32 time_second = 1;
  bool has_time_second() const;
  private:
  bool _internal_has_time_second() const;
  public:
  void clear_time_second();
  ::PROTOBUF_NAMESPACE_ID::int32 time_second() const;
  void set_time_second(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_time_second() const;
  void _internal_set_time_second(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 time_minute = 2;
  bool has_time_minute() const;
  private:
  bool _internal_has_time_minute() const;
  public:
  void clear_time_minute();
  ::PROTOBUF_NAMESPACE_ID::int32 time_minute() const;
  void set_time_minute(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_time_minute() const;
  void _internal_set_time_minute(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 time_hour = 3;
  bool has_time_hour() const;
  private:
  bool _internal_has_time_hour() const;
  public:
  void clear_time_hour();
  ::PROTOBUF_NAMESPACE_ID::int32 time_hour() const;
  void set_time_hour(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_time_hour() const;
  void _internal_set_time_hour(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 date_day = 4;
  bool has_date_day() const;
  private:
  bool _internal_has_date_day() const;
  public:
  void clear_date_day();
  ::PROTOBUF_NAMESPACE_ID::int32 date_day() const;
  void set_date_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_date_day() const;
  void _internal_set_date_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 date_month = 5;
  bool has_date_month() const;
  private:
  bool _internal_has_date_month() const;
  public:
  void clear_date_month();
  ::PROTOBUF_NAMESPACE_ID::int32 date_month() const;
  void set_date_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_date_month() const;
  void _internal_set_date_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 date_year = 6;
  bool has_date_year() const;
  private:
  bool _internal_has_date_year() const;
  public:
  void clear_date_year();
  ::PROTOBUF_NAMESPACE_ID::int32 date_year() const;
  void set_date_year(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_date_year() const;
  void _internal_set_date_year(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Date_time_rpt_83)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_second_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_minute_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_hour_;
  ::PROTOBUF_NAMESPACE_ID::int32 date_day_;
  ::PROTOBUF_NAMESPACE_ID::int32 date_month_;
  ::PROTOBUF_NAMESPACE_ID::int32 date_year_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Brake_motor_rpt_1_70 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Brake_motor_rpt_1_70) */ {
 public:
  Brake_motor_rpt_1_70();
  virtual ~Brake_motor_rpt_1_70();

  Brake_motor_rpt_1_70(const Brake_motor_rpt_1_70& from);
  Brake_motor_rpt_1_70(Brake_motor_rpt_1_70&& from) noexcept
    : Brake_motor_rpt_1_70() {
    *this = ::std::move(from);
  }

  inline Brake_motor_rpt_1_70& operator=(const Brake_motor_rpt_1_70& from) {
    CopyFrom(from);
    return *this;
  }
  inline Brake_motor_rpt_1_70& operator=(Brake_motor_rpt_1_70&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Brake_motor_rpt_1_70& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Brake_motor_rpt_1_70* internal_default_instance() {
    return reinterpret_cast<const Brake_motor_rpt_1_70*>(
               &_Brake_motor_rpt_1_70_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Brake_motor_rpt_1_70& a, Brake_motor_rpt_1_70& b) {
    a.Swap(&b);
  }
  inline void Swap(Brake_motor_rpt_1_70* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Brake_motor_rpt_1_70* New() const final {
    return CreateMaybeMessage<Brake_motor_rpt_1_70>(nullptr);
  }

  Brake_motor_rpt_1_70* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Brake_motor_rpt_1_70>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Brake_motor_rpt_1_70& from);
  void MergeFrom(const Brake_motor_rpt_1_70& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Brake_motor_rpt_1_70* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Brake_motor_rpt_1_70";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotorCurrentFieldNumber = 1,
    kShaftPositionFieldNumber = 2,
  };
  // optional double motor_current = 1;
  bool has_motor_current() const;
  private:
  bool _internal_has_motor_current() const;
  public:
  void clear_motor_current();
  double motor_current() const;
  void set_motor_current(double value);
  private:
  double _internal_motor_current() const;
  void _internal_set_motor_current(double value);
  public:

  // optional double shaft_position = 2;
  bool has_shaft_position() const;
  private:
  bool _internal_has_shaft_position() const;
  public:
  void clear_shaft_position();
  double shaft_position() const;
  void set_shaft_position(double value);
  private:
  double _internal_shaft_position() const;
  void _internal_set_shaft_position(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Brake_motor_rpt_1_70)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double motor_current_;
  double shaft_position_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Headlight_rpt_77 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Headlight_rpt_77) */ {
 public:
  Headlight_rpt_77();
  virtual ~Headlight_rpt_77();

  Headlight_rpt_77(const Headlight_rpt_77& from);
  Headlight_rpt_77(Headlight_rpt_77&& from) noexcept
    : Headlight_rpt_77() {
    *this = ::std::move(from);
  }

  inline Headlight_rpt_77& operator=(const Headlight_rpt_77& from) {
    CopyFrom(from);
    return *this;
  }
  inline Headlight_rpt_77& operator=(Headlight_rpt_77&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Headlight_rpt_77& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Headlight_rpt_77* internal_default_instance() {
    return reinterpret_cast<const Headlight_rpt_77*>(
               &_Headlight_rpt_77_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Headlight_rpt_77& a, Headlight_rpt_77& b) {
    a.Swap(&b);
  }
  inline void Swap(Headlight_rpt_77* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Headlight_rpt_77* New() const final {
    return CreateMaybeMessage<Headlight_rpt_77>(nullptr);
  }

  Headlight_rpt_77* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Headlight_rpt_77>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Headlight_rpt_77& from);
  void MergeFrom(const Headlight_rpt_77& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Headlight_rpt_77* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Headlight_rpt_77";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Headlight_rpt_77_Output_valueType Output_valueType;
  static constexpr Output_valueType OUTPUT_VALUE_HEADLIGHTS_OFF =
    Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_HEADLIGHTS_OFF;
  static constexpr Output_valueType OUTPUT_VALUE_LOW_BEAMS =
    Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_LOW_BEAMS;
  static constexpr Output_valueType OUTPUT_VALUE_HIGH_BEAMS =
    Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_HIGH_BEAMS;
  static inline bool Output_valueType_IsValid(int value) {
    return Headlight_rpt_77_Output_valueType_IsValid(value);
  }
  static constexpr Output_valueType Output_valueType_MIN =
    Headlight_rpt_77_Output_valueType_Output_valueType_MIN;
  static constexpr Output_valueType Output_valueType_MAX =
    Headlight_rpt_77_Output_valueType_Output_valueType_MAX;
  static constexpr int Output_valueType_ARRAYSIZE =
    Headlight_rpt_77_Output_valueType_Output_valueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Output_valueType_descriptor() {
    return Headlight_rpt_77_Output_valueType_descriptor();
  }
  template<typename T>
  static inline const std::string& Output_valueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Output_valueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Output_valueType_Name.");
    return Headlight_rpt_77_Output_valueType_Name(enum_t_value);
  }
  static inline bool Output_valueType_Parse(const std::string& name,
      Output_valueType* value) {
    return Headlight_rpt_77_Output_valueType_Parse(name, value);
  }

  typedef Headlight_rpt_77_Manual_inputType Manual_inputType;
  static constexpr Manual_inputType MANUAL_INPUT_HEADLIGHTS_OFF =
    Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_HEADLIGHTS_OFF;
  static constexpr Manual_inputType MANUAL_INPUT_LOW_BEAMS =
    Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_LOW_BEAMS;
  static constexpr Manual_inputType MANUAL_INPUT_HIGH_BEAMS =
    Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_HIGH_BEAMS;
  static inline bool Manual_inputType_IsValid(int value) {
    return Headlight_rpt_77_Manual_inputType_IsValid(value);
  }
  static constexpr Manual_inputType Manual_inputType_MIN =
    Headlight_rpt_77_Manual_inputType_Manual_inputType_MIN;
  static constexpr Manual_inputType Manual_inputType_MAX =
    Headlight_rpt_77_Manual_inputType_Manual_inputType_MAX;
  static constexpr int Manual_inputType_ARRAYSIZE =
    Headlight_rpt_77_Manual_inputType_Manual_inputType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Manual_inputType_descriptor() {
    return Headlight_rpt_77_Manual_inputType_descriptor();
  }
  template<typename T>
  static inline const std::string& Manual_inputType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Manual_inputType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Manual_inputType_Name.");
    return Headlight_rpt_77_Manual_inputType_Name(enum_t_value);
  }
  static inline bool Manual_inputType_Parse(const std::string& name,
      Manual_inputType* value) {
    return Headlight_rpt_77_Manual_inputType_Parse(name, value);
  }

  typedef Headlight_rpt_77_Commanded_valueType Commanded_valueType;
  static constexpr Commanded_valueType COMMANDED_VALUE_HEADLIGHTS_OFF =
    Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_HEADLIGHTS_OFF;
  static constexpr Commanded_valueType COMMANDED_VALUE_LOW_BEAMS =
    Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_LOW_BEAMS;
  static constexpr Commanded_valueType COMMANDED_VALUE_HIGH_BEAMS =
    Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_HIGH_BEAMS;
  static inline bool Commanded_valueType_IsValid(int value) {
    return Headlight_rpt_77_Commanded_valueType_IsValid(value);
  }
  static constexpr Commanded_valueType Commanded_valueType_MIN =
    Headlight_rpt_77_Commanded_valueType_Commanded_valueType_MIN;
  static constexpr Commanded_valueType Commanded_valueType_MAX =
    Headlight_rpt_77_Commanded_valueType_Commanded_valueType_MAX;
  static constexpr int Commanded_valueType_ARRAYSIZE =
    Headlight_rpt_77_Commanded_valueType_Commanded_valueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Commanded_valueType_descriptor() {
    return Headlight_rpt_77_Commanded_valueType_descriptor();
  }
  template<typename T>
  static inline const std::string& Commanded_valueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Commanded_valueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Commanded_valueType_Name.");
    return Headlight_rpt_77_Commanded_valueType_Name(enum_t_value);
  }
  static inline bool Commanded_valueType_Parse(const std::string& name,
      Commanded_valueType* value) {
    return Headlight_rpt_77_Commanded_valueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOutputValueFieldNumber = 1,
    kManualInputFieldNumber = 2,
    kCommandedValueFieldNumber = 3,
  };
  // optional .apollo.canbus.Headlight_rpt_77.Output_valueType output_value = 1;
  bool has_output_value() const;
  private:
  bool _internal_has_output_value() const;
  public:
  void clear_output_value();
  ::apollo::canbus::Headlight_rpt_77_Output_valueType output_value() const;
  void set_output_value(::apollo::canbus::Headlight_rpt_77_Output_valueType value);
  private:
  ::apollo::canbus::Headlight_rpt_77_Output_valueType _internal_output_value() const;
  void _internal_set_output_value(::apollo::canbus::Headlight_rpt_77_Output_valueType value);
  public:

  // optional .apollo.canbus.Headlight_rpt_77.Manual_inputType manual_input = 2;
  bool has_manual_input() const;
  private:
  bool _internal_has_manual_input() const;
  public:
  void clear_manual_input();
  ::apollo::canbus::Headlight_rpt_77_Manual_inputType manual_input() const;
  void set_manual_input(::apollo::canbus::Headlight_rpt_77_Manual_inputType value);
  private:
  ::apollo::canbus::Headlight_rpt_77_Manual_inputType _internal_manual_input() const;
  void _internal_set_manual_input(::apollo::canbus::Headlight_rpt_77_Manual_inputType value);
  public:

  // optional .apollo.canbus.Headlight_rpt_77.Commanded_valueType commanded_value = 3;
  bool has_commanded_value() const;
  private:
  bool _internal_has_commanded_value() const;
  public:
  void clear_commanded_value();
  ::apollo::canbus::Headlight_rpt_77_Commanded_valueType commanded_value() const;
  void set_commanded_value(::apollo::canbus::Headlight_rpt_77_Commanded_valueType value);
  private:
  ::apollo::canbus::Headlight_rpt_77_Commanded_valueType _internal_commanded_value() const;
  void _internal_set_commanded_value(::apollo::canbus::Headlight_rpt_77_Commanded_valueType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Headlight_rpt_77)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int output_value_;
  int manual_input_;
  int commanded_value_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Accel_rpt_68 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Accel_rpt_68) */ {
 public:
  Accel_rpt_68();
  virtual ~Accel_rpt_68();

  Accel_rpt_68(const Accel_rpt_68& from);
  Accel_rpt_68(Accel_rpt_68&& from) noexcept
    : Accel_rpt_68() {
    *this = ::std::move(from);
  }

  inline Accel_rpt_68& operator=(const Accel_rpt_68& from) {
    CopyFrom(from);
    return *this;
  }
  inline Accel_rpt_68& operator=(Accel_rpt_68&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Accel_rpt_68& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Accel_rpt_68* internal_default_instance() {
    return reinterpret_cast<const Accel_rpt_68*>(
               &_Accel_rpt_68_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Accel_rpt_68& a, Accel_rpt_68& b) {
    a.Swap(&b);
  }
  inline void Swap(Accel_rpt_68* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Accel_rpt_68* New() const final {
    return CreateMaybeMessage<Accel_rpt_68>(nullptr);
  }

  Accel_rpt_68* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Accel_rpt_68>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Accel_rpt_68& from);
  void MergeFrom(const Accel_rpt_68& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Accel_rpt_68* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Accel_rpt_68";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManualInputFieldNumber = 1,
    kCommandedValueFieldNumber = 2,
    kOutputValueFieldNumber = 3,
  };
  // optional double manual_input = 1;
  bool has_manual_input() const;
  private:
  bool _internal_has_manual_input() const;
  public:
  void clear_manual_input();
  double manual_input() const;
  void set_manual_input(double value);
  private:
  double _internal_manual_input() const;
  void _internal_set_manual_input(double value);
  public:

  // optional double commanded_value = 2;
  bool has_commanded_value() const;
  private:
  bool _internal_has_commanded_value() const;
  public:
  void clear_commanded_value();
  double commanded_value() const;
  void set_commanded_value(double value);
  private:
  double _internal_commanded_value() const;
  void _internal_set_commanded_value(double value);
  public:

  // optional double output_value = 3;
  bool has_output_value() const;
  private:
  bool _internal_has_output_value() const;
  public:
  void clear_output_value();
  double output_value() const;
  void set_output_value(double value);
  private:
  double _internal_output_value() const;
  void _internal_set_output_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Accel_rpt_68)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double manual_input_;
  double commanded_value_;
  double output_value_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Steering_motor_rpt_3_75 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Steering_motor_rpt_3_75) */ {
 public:
  Steering_motor_rpt_3_75();
  virtual ~Steering_motor_rpt_3_75();

  Steering_motor_rpt_3_75(const Steering_motor_rpt_3_75& from);
  Steering_motor_rpt_3_75(Steering_motor_rpt_3_75&& from) noexcept
    : Steering_motor_rpt_3_75() {
    *this = ::std::move(from);
  }

  inline Steering_motor_rpt_3_75& operator=(const Steering_motor_rpt_3_75& from) {
    CopyFrom(from);
    return *this;
  }
  inline Steering_motor_rpt_3_75& operator=(Steering_motor_rpt_3_75&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Steering_motor_rpt_3_75& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Steering_motor_rpt_3_75* internal_default_instance() {
    return reinterpret_cast<const Steering_motor_rpt_3_75*>(
               &_Steering_motor_rpt_3_75_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Steering_motor_rpt_3_75& a, Steering_motor_rpt_3_75& b) {
    a.Swap(&b);
  }
  inline void Swap(Steering_motor_rpt_3_75* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Steering_motor_rpt_3_75* New() const final {
    return CreateMaybeMessage<Steering_motor_rpt_3_75>(nullptr);
  }

  Steering_motor_rpt_3_75* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Steering_motor_rpt_3_75>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Steering_motor_rpt_3_75& from);
  void MergeFrom(const Steering_motor_rpt_3_75& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Steering_motor_rpt_3_75* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Steering_motor_rpt_3_75";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTorqueOutputFieldNumber = 1,
    kTorqueInputFieldNumber = 2,
  };
  // optional double torque_output = 1;
  bool has_torque_output() const;
  private:
  bool _internal_has_torque_output() const;
  public:
  void clear_torque_output();
  double torque_output() const;
  void set_torque_output(double value);
  private:
  double _internal_torque_output() const;
  void _internal_set_torque_output(double value);
  public:

  // optional double torque_input = 2;
  bool has_torque_input() const;
  private:
  bool _internal_has_torque_input() const;
  public:
  void clear_torque_input();
  double torque_input() const;
  void set_torque_input(double value);
  private:
  double _internal_torque_input() const;
  void _internal_set_torque_input(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Steering_motor_rpt_3_75)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double torque_output_;
  double torque_input_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Turn_cmd_63 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Turn_cmd_63) */ {
 public:
  Turn_cmd_63();
  virtual ~Turn_cmd_63();

  Turn_cmd_63(const Turn_cmd_63& from);
  Turn_cmd_63(Turn_cmd_63&& from) noexcept
    : Turn_cmd_63() {
    *this = ::std::move(from);
  }

  inline Turn_cmd_63& operator=(const Turn_cmd_63& from) {
    CopyFrom(from);
    return *this;
  }
  inline Turn_cmd_63& operator=(Turn_cmd_63&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Turn_cmd_63& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Turn_cmd_63* internal_default_instance() {
    return reinterpret_cast<const Turn_cmd_63*>(
               &_Turn_cmd_63_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Turn_cmd_63& a, Turn_cmd_63& b) {
    a.Swap(&b);
  }
  inline void Swap(Turn_cmd_63* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Turn_cmd_63* New() const final {
    return CreateMaybeMessage<Turn_cmd_63>(nullptr);
  }

  Turn_cmd_63* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Turn_cmd_63>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Turn_cmd_63& from);
  void MergeFrom(const Turn_cmd_63& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Turn_cmd_63* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Turn_cmd_63";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Turn_cmd_63_Turn_signal_cmdType Turn_signal_cmdType;
  static constexpr Turn_signal_cmdType TURN_SIGNAL_CMD_RIGHT =
    Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_RIGHT;
  static constexpr Turn_signal_cmdType TURN_SIGNAL_CMD_NONE =
    Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_NONE;
  static constexpr Turn_signal_cmdType TURN_SIGNAL_CMD_LEFT =
    Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_LEFT;
  static constexpr Turn_signal_cmdType TURN_SIGNAL_CMD_HAZARD =
    Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_HAZARD;
  static inline bool Turn_signal_cmdType_IsValid(int value) {
    return Turn_cmd_63_Turn_signal_cmdType_IsValid(value);
  }
  static constexpr Turn_signal_cmdType Turn_signal_cmdType_MIN =
    Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_MIN;
  static constexpr Turn_signal_cmdType Turn_signal_cmdType_MAX =
    Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_MAX;
  static constexpr int Turn_signal_cmdType_ARRAYSIZE =
    Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Turn_signal_cmdType_descriptor() {
    return Turn_cmd_63_Turn_signal_cmdType_descriptor();
  }
  template<typename T>
  static inline const std::string& Turn_signal_cmdType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Turn_signal_cmdType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Turn_signal_cmdType_Name.");
    return Turn_cmd_63_Turn_signal_cmdType_Name(enum_t_value);
  }
  static inline bool Turn_signal_cmdType_Parse(const std::string& name,
      Turn_signal_cmdType* value) {
    return Turn_cmd_63_Turn_signal_cmdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTurnSignalCmdFieldNumber = 1,
  };
  // optional .apollo.canbus.Turn_cmd_63.Turn_signal_cmdType turn_signal_cmd = 1;
  bool has_turn_signal_cmd() const;
  private:
  bool _internal_has_turn_signal_cmd() const;
  public:
  void clear_turn_signal_cmd();
  ::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType turn_signal_cmd() const;
  void set_turn_signal_cmd(::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType value);
  private:
  ::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType _internal_turn_signal_cmd() const;
  void _internal_set_turn_signal_cmd(::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Turn_cmd_63)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int turn_signal_cmd_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Turn_rpt_64 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Turn_rpt_64) */ {
 public:
  Turn_rpt_64();
  virtual ~Turn_rpt_64();

  Turn_rpt_64(const Turn_rpt_64& from);
  Turn_rpt_64(Turn_rpt_64&& from) noexcept
    : Turn_rpt_64() {
    *this = ::std::move(from);
  }

  inline Turn_rpt_64& operator=(const Turn_rpt_64& from) {
    CopyFrom(from);
    return *this;
  }
  inline Turn_rpt_64& operator=(Turn_rpt_64&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Turn_rpt_64& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Turn_rpt_64* internal_default_instance() {
    return reinterpret_cast<const Turn_rpt_64*>(
               &_Turn_rpt_64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Turn_rpt_64& a, Turn_rpt_64& b) {
    a.Swap(&b);
  }
  inline void Swap(Turn_rpt_64* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Turn_rpt_64* New() const final {
    return CreateMaybeMessage<Turn_rpt_64>(nullptr);
  }

  Turn_rpt_64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Turn_rpt_64>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Turn_rpt_64& from);
  void MergeFrom(const Turn_rpt_64& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Turn_rpt_64* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Turn_rpt_64";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Turn_rpt_64_Manual_inputType Manual_inputType;
  static constexpr Manual_inputType MANUAL_INPUT_RIGHT =
    Turn_rpt_64_Manual_inputType_MANUAL_INPUT_RIGHT;
  static constexpr Manual_inputType MANUAL_INPUT_NONE =
    Turn_rpt_64_Manual_inputType_MANUAL_INPUT_NONE;
  static constexpr Manual_inputType MANUAL_INPUT_LEFT =
    Turn_rpt_64_Manual_inputType_MANUAL_INPUT_LEFT;
  static constexpr Manual_inputType MANUAL_INPUT_HAZARD =
    Turn_rpt_64_Manual_inputType_MANUAL_INPUT_HAZARD;
  static inline bool Manual_inputType_IsValid(int value) {
    return Turn_rpt_64_Manual_inputType_IsValid(value);
  }
  static constexpr Manual_inputType Manual_inputType_MIN =
    Turn_rpt_64_Manual_inputType_Manual_inputType_MIN;
  static constexpr Manual_inputType Manual_inputType_MAX =
    Turn_rpt_64_Manual_inputType_Manual_inputType_MAX;
  static constexpr int Manual_inputType_ARRAYSIZE =
    Turn_rpt_64_Manual_inputType_Manual_inputType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Manual_inputType_descriptor() {
    return Turn_rpt_64_Manual_inputType_descriptor();
  }
  template<typename T>
  static inline const std::string& Manual_inputType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Manual_inputType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Manual_inputType_Name.");
    return Turn_rpt_64_Manual_inputType_Name(enum_t_value);
  }
  static inline bool Manual_inputType_Parse(const std::string& name,
      Manual_inputType* value) {
    return Turn_rpt_64_Manual_inputType_Parse(name, value);
  }

  typedef Turn_rpt_64_Commanded_valueType Commanded_valueType;
  static constexpr Commanded_valueType COMMANDED_VALUE_RIGHT =
    Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_RIGHT;
  static constexpr Commanded_valueType COMMANDED_VALUE_NONE =
    Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_NONE;
  static constexpr Commanded_valueType COMMANDED_VALUE_LEFT =
    Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_LEFT;
  static constexpr Commanded_valueType COMMANDED_VALUE_HAZARD =
    Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_HAZARD;
  static inline bool Commanded_valueType_IsValid(int value) {
    return Turn_rpt_64_Commanded_valueType_IsValid(value);
  }
  static constexpr Commanded_valueType Commanded_valueType_MIN =
    Turn_rpt_64_Commanded_valueType_Commanded_valueType_MIN;
  static constexpr Commanded_valueType Commanded_valueType_MAX =
    Turn_rpt_64_Commanded_valueType_Commanded_valueType_MAX;
  static constexpr int Commanded_valueType_ARRAYSIZE =
    Turn_rpt_64_Commanded_valueType_Commanded_valueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Commanded_valueType_descriptor() {
    return Turn_rpt_64_Commanded_valueType_descriptor();
  }
  template<typename T>
  static inline const std::string& Commanded_valueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Commanded_valueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Commanded_valueType_Name.");
    return Turn_rpt_64_Commanded_valueType_Name(enum_t_value);
  }
  static inline bool Commanded_valueType_Parse(const std::string& name,
      Commanded_valueType* value) {
    return Turn_rpt_64_Commanded_valueType_Parse(name, value);
  }

  typedef Turn_rpt_64_Output_valueType Output_valueType;
  static constexpr Output_valueType OUTPUT_VALUE_RIGHT =
    Turn_rpt_64_Output_valueType_OUTPUT_VALUE_RIGHT;
  static constexpr Output_valueType OUTPUT_VALUE_NONE =
    Turn_rpt_64_Output_valueType_OUTPUT_VALUE_NONE;
  static constexpr Output_valueType OUTPUT_VALUE_LEFT =
    Turn_rpt_64_Output_valueType_OUTPUT_VALUE_LEFT;
  static constexpr Output_valueType OUTPUT_VALUE_HAZARD =
    Turn_rpt_64_Output_valueType_OUTPUT_VALUE_HAZARD;
  static inline bool Output_valueType_IsValid(int value) {
    return Turn_rpt_64_Output_valueType_IsValid(value);
  }
  static constexpr Output_valueType Output_valueType_MIN =
    Turn_rpt_64_Output_valueType_Output_valueType_MIN;
  static constexpr Output_valueType Output_valueType_MAX =
    Turn_rpt_64_Output_valueType_Output_valueType_MAX;
  static constexpr int Output_valueType_ARRAYSIZE =
    Turn_rpt_64_Output_valueType_Output_valueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Output_valueType_descriptor() {
    return Turn_rpt_64_Output_valueType_descriptor();
  }
  template<typename T>
  static inline const std::string& Output_valueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Output_valueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Output_valueType_Name.");
    return Turn_rpt_64_Output_valueType_Name(enum_t_value);
  }
  static inline bool Output_valueType_Parse(const std::string& name,
      Output_valueType* value) {
    return Turn_rpt_64_Output_valueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kManualInputFieldNumber = 1,
    kCommandedValueFieldNumber = 2,
    kOutputValueFieldNumber = 3,
  };
  // optional .apollo.canbus.Turn_rpt_64.Manual_inputType manual_input = 1;
  bool has_manual_input() const;
  private:
  bool _internal_has_manual_input() const;
  public:
  void clear_manual_input();
  ::apollo::canbus::Turn_rpt_64_Manual_inputType manual_input() const;
  void set_manual_input(::apollo::canbus::Turn_rpt_64_Manual_inputType value);
  private:
  ::apollo::canbus::Turn_rpt_64_Manual_inputType _internal_manual_input() const;
  void _internal_set_manual_input(::apollo::canbus::Turn_rpt_64_Manual_inputType value);
  public:

  // optional .apollo.canbus.Turn_rpt_64.Commanded_valueType commanded_value = 2;
  bool has_commanded_value() const;
  private:
  bool _internal_has_commanded_value() const;
  public:
  void clear_commanded_value();
  ::apollo::canbus::Turn_rpt_64_Commanded_valueType commanded_value() const;
  void set_commanded_value(::apollo::canbus::Turn_rpt_64_Commanded_valueType value);
  private:
  ::apollo::canbus::Turn_rpt_64_Commanded_valueType _internal_commanded_value() const;
  void _internal_set_commanded_value(::apollo::canbus::Turn_rpt_64_Commanded_valueType value);
  public:

  // optional .apollo.canbus.Turn_rpt_64.Output_valueType output_value = 3;
  bool has_output_value() const;
  private:
  bool _internal_has_output_value() const;
  public:
  void clear_output_value();
  ::apollo::canbus::Turn_rpt_64_Output_valueType output_value() const;
  void set_output_value(::apollo::canbus::Turn_rpt_64_Output_valueType value);
  private:
  ::apollo::canbus::Turn_rpt_64_Output_valueType _internal_output_value() const;
  void _internal_set_output_value(::apollo::canbus::Turn_rpt_64_Output_valueType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Turn_rpt_64)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int manual_input_;
  int commanded_value_;
  int output_value_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Shift_cmd_65 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Shift_cmd_65) */ {
 public:
  Shift_cmd_65();
  virtual ~Shift_cmd_65();

  Shift_cmd_65(const Shift_cmd_65& from);
  Shift_cmd_65(Shift_cmd_65&& from) noexcept
    : Shift_cmd_65() {
    *this = ::std::move(from);
  }

  inline Shift_cmd_65& operator=(const Shift_cmd_65& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shift_cmd_65& operator=(Shift_cmd_65&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Shift_cmd_65& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Shift_cmd_65* internal_default_instance() {
    return reinterpret_cast<const Shift_cmd_65*>(
               &_Shift_cmd_65_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Shift_cmd_65& a, Shift_cmd_65& b) {
    a.Swap(&b);
  }
  inline void Swap(Shift_cmd_65* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Shift_cmd_65* New() const final {
    return CreateMaybeMessage<Shift_cmd_65>(nullptr);
  }

  Shift_cmd_65* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Shift_cmd_65>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Shift_cmd_65& from);
  void MergeFrom(const Shift_cmd_65& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shift_cmd_65* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Shift_cmd_65";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Shift_cmd_65_Shift_cmdType Shift_cmdType;
  static constexpr Shift_cmdType SHIFT_CMD_PARK =
    Shift_cmd_65_Shift_cmdType_SHIFT_CMD_PARK;
  static constexpr Shift_cmdType SHIFT_CMD_REVERSE =
    Shift_cmd_65_Shift_cmdType_SHIFT_CMD_REVERSE;
  static constexpr Shift_cmdType SHIFT_CMD_NEUTRAL =
    Shift_cmd_65_Shift_cmdType_SHIFT_CMD_NEUTRAL;
  static constexpr Shift_cmdType SHIFT_CMD_FORWARD =
    Shift_cmd_65_Shift_cmdType_SHIFT_CMD_FORWARD;
  static constexpr Shift_cmdType SHIFT_CMD_LOW =
    Shift_cmd_65_Shift_cmdType_SHIFT_CMD_LOW;
  static inline bool Shift_cmdType_IsValid(int value) {
    return Shift_cmd_65_Shift_cmdType_IsValid(value);
  }
  static constexpr Shift_cmdType Shift_cmdType_MIN =
    Shift_cmd_65_Shift_cmdType_Shift_cmdType_MIN;
  static constexpr Shift_cmdType Shift_cmdType_MAX =
    Shift_cmd_65_Shift_cmdType_Shift_cmdType_MAX;
  static constexpr int Shift_cmdType_ARRAYSIZE =
    Shift_cmd_65_Shift_cmdType_Shift_cmdType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Shift_cmdType_descriptor() {
    return Shift_cmd_65_Shift_cmdType_descriptor();
  }
  template<typename T>
  static inline const std::string& Shift_cmdType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Shift_cmdType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Shift_cmdType_Name.");
    return Shift_cmd_65_Shift_cmdType_Name(enum_t_value);
  }
  static inline bool Shift_cmdType_Parse(const std::string& name,
      Shift_cmdType* value) {
    return Shift_cmd_65_Shift_cmdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kShiftCmdFieldNumber = 1,
  };
  // optional .apollo.canbus.Shift_cmd_65.Shift_cmdType shift_cmd = 1;
  bool has_shift_cmd() const;
  private:
  bool _internal_has_shift_cmd() const;
  public:
  void clear_shift_cmd();
  ::apollo::canbus::Shift_cmd_65_Shift_cmdType shift_cmd() const;
  void set_shift_cmd(::apollo::canbus::Shift_cmd_65_Shift_cmdType value);
  private:
  ::apollo::canbus::Shift_cmd_65_Shift_cmdType _internal_shift_cmd() const;
  void _internal_set_shift_cmd(::apollo::canbus::Shift_cmd_65_Shift_cmdType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Shift_cmd_65)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int shift_cmd_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Shift_rpt_66 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Shift_rpt_66) */ {
 public:
  Shift_rpt_66();
  virtual ~Shift_rpt_66();

  Shift_rpt_66(const Shift_rpt_66& from);
  Shift_rpt_66(Shift_rpt_66&& from) noexcept
    : Shift_rpt_66() {
    *this = ::std::move(from);
  }

  inline Shift_rpt_66& operator=(const Shift_rpt_66& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shift_rpt_66& operator=(Shift_rpt_66&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Shift_rpt_66& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Shift_rpt_66* internal_default_instance() {
    return reinterpret_cast<const Shift_rpt_66*>(
               &_Shift_rpt_66_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Shift_rpt_66& a, Shift_rpt_66& b) {
    a.Swap(&b);
  }
  inline void Swap(Shift_rpt_66* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Shift_rpt_66* New() const final {
    return CreateMaybeMessage<Shift_rpt_66>(nullptr);
  }

  Shift_rpt_66* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Shift_rpt_66>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Shift_rpt_66& from);
  void MergeFrom(const Shift_rpt_66& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shift_rpt_66* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Shift_rpt_66";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Shift_rpt_66_Manual_inputType Manual_inputType;
  static constexpr Manual_inputType MANUAL_INPUT_PARK =
    Shift_rpt_66_Manual_inputType_MANUAL_INPUT_PARK;
  static constexpr Manual_inputType MANUAL_INPUT_REVERSE =
    Shift_rpt_66_Manual_inputType_MANUAL_INPUT_REVERSE;
  static constexpr Manual_inputType MANUAL_INPUT_NEUTRAL =
    Shift_rpt_66_Manual_inputType_MANUAL_INPUT_NEUTRAL;
  static constexpr Manual_inputType MANUAL_INPUT_FORWARD =
    Shift_rpt_66_Manual_inputType_MANUAL_INPUT_FORWARD;
  static constexpr Manual_inputType MANUAL_INPUT_HIGH =
    Shift_rpt_66_Manual_inputType_MANUAL_INPUT_HIGH;
  static inline bool Manual_inputType_IsValid(int value) {
    return Shift_rpt_66_Manual_inputType_IsValid(value);
  }
  static constexpr Manual_inputType Manual_inputType_MIN =
    Shift_rpt_66_Manual_inputType_Manual_inputType_MIN;
  static constexpr Manual_inputType Manual_inputType_MAX =
    Shift_rpt_66_Manual_inputType_Manual_inputType_MAX;
  static constexpr int Manual_inputType_ARRAYSIZE =
    Shift_rpt_66_Manual_inputType_Manual_inputType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Manual_inputType_descriptor() {
    return Shift_rpt_66_Manual_inputType_descriptor();
  }
  template<typename T>
  static inline const std::string& Manual_inputType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Manual_inputType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Manual_inputType_Name.");
    return Shift_rpt_66_Manual_inputType_Name(enum_t_value);
  }
  static inline bool Manual_inputType_Parse(const std::string& name,
      Manual_inputType* value) {
    return Shift_rpt_66_Manual_inputType_Parse(name, value);
  }

  typedef Shift_rpt_66_Commanded_valueType Commanded_valueType;
  static constexpr Commanded_valueType COMMANDED_VALUE_PARK =
    Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_PARK;
  static constexpr Commanded_valueType COMMANDED_VALUE_REVERSE =
    Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_REVERSE;
  static constexpr Commanded_valueType COMMANDED_VALUE_NEUTRAL =
    Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_NEUTRAL;
  static constexpr Commanded_valueType COMMANDED_VALUE_FORWARD =
    Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_FORWARD;
  static constexpr Commanded_valueType COMMANDED_VALUE_HIGH =
    Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_HIGH;
  static inline bool Commanded_valueType_IsValid(int value) {
    return Shift_rpt_66_Commanded_valueType_IsValid(value);
  }
  static constexpr Commanded_valueType Commanded_valueType_MIN =
    Shift_rpt_66_Commanded_valueType_Commanded_valueType_MIN;
  static constexpr Commanded_valueType Commanded_valueType_MAX =
    Shift_rpt_66_Commanded_valueType_Commanded_valueType_MAX;
  static constexpr int Commanded_valueType_ARRAYSIZE =
    Shift_rpt_66_Commanded_valueType_Commanded_valueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Commanded_valueType_descriptor() {
    return Shift_rpt_66_Commanded_valueType_descriptor();
  }
  template<typename T>
  static inline const std::string& Commanded_valueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Commanded_valueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Commanded_valueType_Name.");
    return Shift_rpt_66_Commanded_valueType_Name(enum_t_value);
  }
  static inline bool Commanded_valueType_Parse(const std::string& name,
      Commanded_valueType* value) {
    return Shift_rpt_66_Commanded_valueType_Parse(name, value);
  }

  typedef Shift_rpt_66_Output_valueType Output_valueType;
  static constexpr Output_valueType OUTPUT_VALUE_PARK =
    Shift_rpt_66_Output_valueType_OUTPUT_VALUE_PARK;
  static constexpr Output_valueType OUTPUT_VALUE_REVERSE =
    Shift_rpt_66_Output_valueType_OUTPUT_VALUE_REVERSE;
  static constexpr Output_valueType OUTPUT_VALUE_NEUTRAL =
    Shift_rpt_66_Output_valueType_OUTPUT_VALUE_NEUTRAL;
  static constexpr Output_valueType OUTPUT_VALUE_FORWARD =
    Shift_rpt_66_Output_valueType_OUTPUT_VALUE_FORWARD;
  static constexpr Output_valueType OUTPUT_VALUE_HIGH =
    Shift_rpt_66_Output_valueType_OUTPUT_VALUE_HIGH;
  static inline bool Output_valueType_IsValid(int value) {
    return Shift_rpt_66_Output_valueType_IsValid(value);
  }
  static constexpr Output_valueType Output_valueType_MIN =
    Shift_rpt_66_Output_valueType_Output_valueType_MIN;
  static constexpr Output_valueType Output_valueType_MAX =
    Shift_rpt_66_Output_valueType_Output_valueType_MAX;
  static constexpr int Output_valueType_ARRAYSIZE =
    Shift_rpt_66_Output_valueType_Output_valueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Output_valueType_descriptor() {
    return Shift_rpt_66_Output_valueType_descriptor();
  }
  template<typename T>
  static inline const std::string& Output_valueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Output_valueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Output_valueType_Name.");
    return Shift_rpt_66_Output_valueType_Name(enum_t_value);
  }
  static inline bool Output_valueType_Parse(const std::string& name,
      Output_valueType* value) {
    return Shift_rpt_66_Output_valueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kManualInputFieldNumber = 1,
    kCommandedValueFieldNumber = 2,
    kOutputValueFieldNumber = 3,
  };
  // optional .apollo.canbus.Shift_rpt_66.Manual_inputType manual_input = 1;
  bool has_manual_input() const;
  private:
  bool _internal_has_manual_input() const;
  public:
  void clear_manual_input();
  ::apollo::canbus::Shift_rpt_66_Manual_inputType manual_input() const;
  void set_manual_input(::apollo::canbus::Shift_rpt_66_Manual_inputType value);
  private:
  ::apollo::canbus::Shift_rpt_66_Manual_inputType _internal_manual_input() const;
  void _internal_set_manual_input(::apollo::canbus::Shift_rpt_66_Manual_inputType value);
  public:

  // optional .apollo.canbus.Shift_rpt_66.Commanded_valueType commanded_value = 2;
  bool has_commanded_value() const;
  private:
  bool _internal_has_commanded_value() const;
  public:
  void clear_commanded_value();
  ::apollo::canbus::Shift_rpt_66_Commanded_valueType commanded_value() const;
  void set_commanded_value(::apollo::canbus::Shift_rpt_66_Commanded_valueType value);
  private:
  ::apollo::canbus::Shift_rpt_66_Commanded_valueType _internal_commanded_value() const;
  void _internal_set_commanded_value(::apollo::canbus::Shift_rpt_66_Commanded_valueType value);
  public:

  // optional .apollo.canbus.Shift_rpt_66.Output_valueType output_value = 3;
  bool has_output_value() const;
  private:
  bool _internal_has_output_value() const;
  public:
  void clear_output_value();
  ::apollo::canbus::Shift_rpt_66_Output_valueType output_value() const;
  void set_output_value(::apollo::canbus::Shift_rpt_66_Output_valueType value);
  private:
  ::apollo::canbus::Shift_rpt_66_Output_valueType _internal_output_value() const;
  void _internal_set_output_value(::apollo::canbus::Shift_rpt_66_Output_valueType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Shift_rpt_66)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int manual_input_;
  int commanded_value_;
  int output_value_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Accel_cmd_67 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Accel_cmd_67) */ {
 public:
  Accel_cmd_67();
  virtual ~Accel_cmd_67();

  Accel_cmd_67(const Accel_cmd_67& from);
  Accel_cmd_67(Accel_cmd_67&& from) noexcept
    : Accel_cmd_67() {
    *this = ::std::move(from);
  }

  inline Accel_cmd_67& operator=(const Accel_cmd_67& from) {
    CopyFrom(from);
    return *this;
  }
  inline Accel_cmd_67& operator=(Accel_cmd_67&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Accel_cmd_67& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Accel_cmd_67* internal_default_instance() {
    return reinterpret_cast<const Accel_cmd_67*>(
               &_Accel_cmd_67_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Accel_cmd_67& a, Accel_cmd_67& b) {
    a.Swap(&b);
  }
  inline void Swap(Accel_cmd_67* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Accel_cmd_67* New() const final {
    return CreateMaybeMessage<Accel_cmd_67>(nullptr);
  }

  Accel_cmd_67* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Accel_cmd_67>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Accel_cmd_67& from);
  void MergeFrom(const Accel_cmd_67& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Accel_cmd_67* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Accel_cmd_67";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccelCmdFieldNumber = 1,
  };
  // optional double accel_cmd = 1;
  bool has_accel_cmd() const;
  private:
  bool _internal_has_accel_cmd() const;
  public:
  void clear_accel_cmd();
  double accel_cmd() const;
  void set_accel_cmd(double value);
  private:
  double _internal_accel_cmd() const;
  void _internal_set_accel_cmd(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Accel_cmd_67)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double accel_cmd_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Lat_lon_heading_rpt_82 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Lat_lon_heading_rpt_82) */ {
 public:
  Lat_lon_heading_rpt_82();
  virtual ~Lat_lon_heading_rpt_82();

  Lat_lon_heading_rpt_82(const Lat_lon_heading_rpt_82& from);
  Lat_lon_heading_rpt_82(Lat_lon_heading_rpt_82&& from) noexcept
    : Lat_lon_heading_rpt_82() {
    *this = ::std::move(from);
  }

  inline Lat_lon_heading_rpt_82& operator=(const Lat_lon_heading_rpt_82& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lat_lon_heading_rpt_82& operator=(Lat_lon_heading_rpt_82&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Lat_lon_heading_rpt_82& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lat_lon_heading_rpt_82* internal_default_instance() {
    return reinterpret_cast<const Lat_lon_heading_rpt_82*>(
               &_Lat_lon_heading_rpt_82_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Lat_lon_heading_rpt_82& a, Lat_lon_heading_rpt_82& b) {
    a.Swap(&b);
  }
  inline void Swap(Lat_lon_heading_rpt_82* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lat_lon_heading_rpt_82* New() const final {
    return CreateMaybeMessage<Lat_lon_heading_rpt_82>(nullptr);
  }

  Lat_lon_heading_rpt_82* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lat_lon_heading_rpt_82>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Lat_lon_heading_rpt_82& from);
  void MergeFrom(const Lat_lon_heading_rpt_82& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lat_lon_heading_rpt_82* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Lat_lon_heading_rpt_82";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadingFieldNumber = 1,
    kLongitudeSecondsFieldNumber = 2,
    kLongitudeMinutesFieldNumber = 3,
    kLongitudeDegreesFieldNumber = 4,
    kLatitudeSecondsFieldNumber = 5,
    kLatitudeMinutesFieldNumber = 6,
    kLatitudeDegreesFieldNumber = 7,
  };
  // optional double heading = 1;
  bool has_heading() const;
  private:
  bool _internal_has_heading() const;
  public:
  void clear_heading();
  double heading() const;
  void set_heading(double value);
  private:
  double _internal_heading() const;
  void _internal_set_heading(double value);
  public:

  // optional int32 longitude_seconds = 2;
  bool has_longitude_seconds() const;
  private:
  bool _internal_has_longitude_seconds() const;
  public:
  void clear_longitude_seconds();
  ::PROTOBUF_NAMESPACE_ID::int32 longitude_seconds() const;
  void set_longitude_seconds(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_longitude_seconds() const;
  void _internal_set_longitude_seconds(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 longitude_minutes = 3;
  bool has_longitude_minutes() const;
  private:
  bool _internal_has_longitude_minutes() const;
  public:
  void clear_longitude_minutes();
  ::PROTOBUF_NAMESPACE_ID::int32 longitude_minutes() const;
  void set_longitude_minutes(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_longitude_minutes() const;
  void _internal_set_longitude_minutes(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 longitude_degrees = 4;
  bool has_longitude_degrees() const;
  private:
  bool _internal_has_longitude_degrees() const;
  public:
  void clear_longitude_degrees();
  ::PROTOBUF_NAMESPACE_ID::int32 longitude_degrees() const;
  void set_longitude_degrees(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_longitude_degrees() const;
  void _internal_set_longitude_degrees(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 latitude_seconds = 5;
  bool has_latitude_seconds() const;
  private:
  bool _internal_has_latitude_seconds() const;
  public:
  void clear_latitude_seconds();
  ::PROTOBUF_NAMESPACE_ID::int32 latitude_seconds() const;
  void set_latitude_seconds(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_latitude_seconds() const;
  void _internal_set_latitude_seconds(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 latitude_minutes = 6;
  bool has_latitude_minutes() const;
  private:
  bool _internal_has_latitude_minutes() const;
  public:
  void clear_latitude_minutes();
  ::PROTOBUF_NAMESPACE_ID::int32 latitude_minutes() const;
  void set_latitude_minutes(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_latitude_minutes() const;
  void _internal_set_latitude_minutes(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 latitude_degrees = 7;
  bool has_latitude_degrees() const;
  private:
  bool _internal_has_latitude_degrees() const;
  public:
  void clear_latitude_degrees();
  ::PROTOBUF_NAMESPACE_ID::int32 latitude_degrees() const;
  void set_latitude_degrees(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_latitude_degrees() const;
  void _internal_set_latitude_degrees(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Lat_lon_heading_rpt_82)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double heading_;
  ::PROTOBUF_NAMESPACE_ID::int32 longitude_seconds_;
  ::PROTOBUF_NAMESPACE_ID::int32 longitude_minutes_;
  ::PROTOBUF_NAMESPACE_ID::int32 longitude_degrees_;
  ::PROTOBUF_NAMESPACE_ID::int32 latitude_seconds_;
  ::PROTOBUF_NAMESPACE_ID::int32 latitude_minutes_;
  ::PROTOBUF_NAMESPACE_ID::int32 latitude_degrees_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Global_cmd_69 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Global_cmd_69) */ {
 public:
  Global_cmd_69();
  virtual ~Global_cmd_69();

  Global_cmd_69(const Global_cmd_69& from);
  Global_cmd_69(Global_cmd_69&& from) noexcept
    : Global_cmd_69() {
    *this = ::std::move(from);
  }

  inline Global_cmd_69& operator=(const Global_cmd_69& from) {
    CopyFrom(from);
    return *this;
  }
  inline Global_cmd_69& operator=(Global_cmd_69&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Global_cmd_69& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Global_cmd_69* internal_default_instance() {
    return reinterpret_cast<const Global_cmd_69*>(
               &_Global_cmd_69_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Global_cmd_69& a, Global_cmd_69& b) {
    a.Swap(&b);
  }
  inline void Swap(Global_cmd_69* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Global_cmd_69* New() const final {
    return CreateMaybeMessage<Global_cmd_69>(nullptr);
  }

  Global_cmd_69* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Global_cmd_69>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Global_cmd_69& from);
  void MergeFrom(const Global_cmd_69& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Global_cmd_69* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Global_cmd_69";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Global_cmd_69_Pacmod_enableType Pacmod_enableType;
  static constexpr Pacmod_enableType PACMOD_ENABLE_CONTROL_DISABLED =
    Global_cmd_69_Pacmod_enableType_PACMOD_ENABLE_CONTROL_DISABLED;
  static constexpr Pacmod_enableType PACMOD_ENABLE_CONTROL_ENABLED =
    Global_cmd_69_Pacmod_enableType_PACMOD_ENABLE_CONTROL_ENABLED;
  static inline bool Pacmod_enableType_IsValid(int value) {
    return Global_cmd_69_Pacmod_enableType_IsValid(value);
  }
  static constexpr Pacmod_enableType Pacmod_enableType_MIN =
    Global_cmd_69_Pacmod_enableType_Pacmod_enableType_MIN;
  static constexpr Pacmod_enableType Pacmod_enableType_MAX =
    Global_cmd_69_Pacmod_enableType_Pacmod_enableType_MAX;
  static constexpr int Pacmod_enableType_ARRAYSIZE =
    Global_cmd_69_Pacmod_enableType_Pacmod_enableType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Pacmod_enableType_descriptor() {
    return Global_cmd_69_Pacmod_enableType_descriptor();
  }
  template<typename T>
  static inline const std::string& Pacmod_enableType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Pacmod_enableType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Pacmod_enableType_Name.");
    return Global_cmd_69_Pacmod_enableType_Name(enum_t_value);
  }
  static inline bool Pacmod_enableType_Parse(const std::string& name,
      Pacmod_enableType* value) {
    return Global_cmd_69_Pacmod_enableType_Parse(name, value);
  }

  typedef Global_cmd_69_Clear_overrideType Clear_overrideType;
  static constexpr Clear_overrideType CLEAR_OVERRIDE_DON_T_CLEAR_ACTIVE_OVERRIDES =
    Global_cmd_69_Clear_overrideType_CLEAR_OVERRIDE_DON_T_CLEAR_ACTIVE_OVERRIDES;
  static constexpr Clear_overrideType CLEAR_OVERRIDE_CLEAR_ACTIVE_OVERRIDES =
    Global_cmd_69_Clear_overrideType_CLEAR_OVERRIDE_CLEAR_ACTIVE_OVERRIDES;
  static inline bool Clear_overrideType_IsValid(int value) {
    return Global_cmd_69_Clear_overrideType_IsValid(value);
  }
  static constexpr Clear_overrideType Clear_overrideType_MIN =
    Global_cmd_69_Clear_overrideType_Clear_overrideType_MIN;
  static constexpr Clear_overrideType Clear_overrideType_MAX =
    Global_cmd_69_Clear_overrideType_Clear_overrideType_MAX;
  static constexpr int Clear_overrideType_ARRAYSIZE =
    Global_cmd_69_Clear_overrideType_Clear_overrideType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Clear_overrideType_descriptor() {
    return Global_cmd_69_Clear_overrideType_descriptor();
  }
  template<typename T>
  static inline const std::string& Clear_overrideType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Clear_overrideType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Clear_overrideType_Name.");
    return Global_cmd_69_Clear_overrideType_Name(enum_t_value);
  }
  static inline bool Clear_overrideType_Parse(const std::string& name,
      Clear_overrideType* value) {
    return Global_cmd_69_Clear_overrideType_Parse(name, value);
  }

  typedef Global_cmd_69_Ignore_overrideType Ignore_overrideType;
  static constexpr Ignore_overrideType IGNORE_OVERRIDE_DON_T_IGNORE_USER_OVERRIDES =
    Global_cmd_69_Ignore_overrideType_IGNORE_OVERRIDE_DON_T_IGNORE_USER_OVERRIDES;
  static constexpr Ignore_overrideType IGNORE_OVERRIDE_IGNORE_USER_OVERRIDES =
    Global_cmd_69_Ignore_overrideType_IGNORE_OVERRIDE_IGNORE_USER_OVERRIDES;
  static inline bool Ignore_overrideType_IsValid(int value) {
    return Global_cmd_69_Ignore_overrideType_IsValid(value);
  }
  static constexpr Ignore_overrideType Ignore_overrideType_MIN =
    Global_cmd_69_Ignore_overrideType_Ignore_overrideType_MIN;
  static constexpr Ignore_overrideType Ignore_overrideType_MAX =
    Global_cmd_69_Ignore_overrideType_Ignore_overrideType_MAX;
  static constexpr int Ignore_overrideType_ARRAYSIZE =
    Global_cmd_69_Ignore_overrideType_Ignore_overrideType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Ignore_overrideType_descriptor() {
    return Global_cmd_69_Ignore_overrideType_descriptor();
  }
  template<typename T>
  static inline const std::string& Ignore_overrideType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Ignore_overrideType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Ignore_overrideType_Name.");
    return Global_cmd_69_Ignore_overrideType_Name(enum_t_value);
  }
  static inline bool Ignore_overrideType_Parse(const std::string& name,
      Ignore_overrideType* value) {
    return Global_cmd_69_Ignore_overrideType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPacmodEnableFieldNumber = 1,
    kClearOverrideFieldNumber = 2,
    kIgnoreOverrideFieldNumber = 3,
  };
  // optional .apollo.canbus.Global_cmd_69.Pacmod_enableType pacmod_enable = 1;
  bool has_pacmod_enable() const;
  private:
  bool _internal_has_pacmod_enable() const;
  public:
  void clear_pacmod_enable();
  ::apollo::canbus::Global_cmd_69_Pacmod_enableType pacmod_enable() const;
  void set_pacmod_enable(::apollo::canbus::Global_cmd_69_Pacmod_enableType value);
  private:
  ::apollo::canbus::Global_cmd_69_Pacmod_enableType _internal_pacmod_enable() const;
  void _internal_set_pacmod_enable(::apollo::canbus::Global_cmd_69_Pacmod_enableType value);
  public:

  // optional .apollo.canbus.Global_cmd_69.Clear_overrideType clear_override = 2;
  bool has_clear_override() const;
  private:
  bool _internal_has_clear_override() const;
  public:
  void clear_clear_override();
  ::apollo::canbus::Global_cmd_69_Clear_overrideType clear_override() const;
  void set_clear_override(::apollo::canbus::Global_cmd_69_Clear_overrideType value);
  private:
  ::apollo::canbus::Global_cmd_69_Clear_overrideType _internal_clear_override() const;
  void _internal_set_clear_override(::apollo::canbus::Global_cmd_69_Clear_overrideType value);
  public:

  // optional .apollo.canbus.Global_cmd_69.Ignore_overrideType ignore_override = 3;
  bool has_ignore_override() const;
  private:
  bool _internal_has_ignore_override() const;
  public:
  void clear_ignore_override();
  ::apollo::canbus::Global_cmd_69_Ignore_overrideType ignore_override() const;
  void set_ignore_override(::apollo::canbus::Global_cmd_69_Ignore_overrideType value);
  private:
  ::apollo::canbus::Global_cmd_69_Ignore_overrideType _internal_ignore_override() const;
  void _internal_set_ignore_override(::apollo::canbus::Global_cmd_69_Ignore_overrideType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Global_cmd_69)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int pacmod_enable_;
  int clear_override_;
  int ignore_override_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Parking_brake_status_rpt_80 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Parking_brake_status_rpt_80) */ {
 public:
  Parking_brake_status_rpt_80();
  virtual ~Parking_brake_status_rpt_80();

  Parking_brake_status_rpt_80(const Parking_brake_status_rpt_80& from);
  Parking_brake_status_rpt_80(Parking_brake_status_rpt_80&& from) noexcept
    : Parking_brake_status_rpt_80() {
    *this = ::std::move(from);
  }

  inline Parking_brake_status_rpt_80& operator=(const Parking_brake_status_rpt_80& from) {
    CopyFrom(from);
    return *this;
  }
  inline Parking_brake_status_rpt_80& operator=(Parking_brake_status_rpt_80&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Parking_brake_status_rpt_80& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Parking_brake_status_rpt_80* internal_default_instance() {
    return reinterpret_cast<const Parking_brake_status_rpt_80*>(
               &_Parking_brake_status_rpt_80_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Parking_brake_status_rpt_80& a, Parking_brake_status_rpt_80& b) {
    a.Swap(&b);
  }
  inline void Swap(Parking_brake_status_rpt_80* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Parking_brake_status_rpt_80* New() const final {
    return CreateMaybeMessage<Parking_brake_status_rpt_80>(nullptr);
  }

  Parking_brake_status_rpt_80* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Parking_brake_status_rpt_80>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Parking_brake_status_rpt_80& from);
  void MergeFrom(const Parking_brake_status_rpt_80& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Parking_brake_status_rpt_80* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Parking_brake_status_rpt_80";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Parking_brake_status_rpt_80_Parking_brake_enabledType Parking_brake_enabledType;
  static constexpr Parking_brake_enabledType PARKING_BRAKE_ENABLED_OFF =
    Parking_brake_status_rpt_80_Parking_brake_enabledType_PARKING_BRAKE_ENABLED_OFF;
  static constexpr Parking_brake_enabledType PARKING_BRAKE_ENABLED_ON =
    Parking_brake_status_rpt_80_Parking_brake_enabledType_PARKING_BRAKE_ENABLED_ON;
  static inline bool Parking_brake_enabledType_IsValid(int value) {
    return Parking_brake_status_rpt_80_Parking_brake_enabledType_IsValid(value);
  }
  static constexpr Parking_brake_enabledType Parking_brake_enabledType_MIN =
    Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_MIN;
  static constexpr Parking_brake_enabledType Parking_brake_enabledType_MAX =
    Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_MAX;
  static constexpr int Parking_brake_enabledType_ARRAYSIZE =
    Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Parking_brake_enabledType_descriptor() {
    return Parking_brake_status_rpt_80_Parking_brake_enabledType_descriptor();
  }
  template<typename T>
  static inline const std::string& Parking_brake_enabledType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Parking_brake_enabledType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Parking_brake_enabledType_Name.");
    return Parking_brake_status_rpt_80_Parking_brake_enabledType_Name(enum_t_value);
  }
  static inline bool Parking_brake_enabledType_Parse(const std::string& name,
      Parking_brake_enabledType* value) {
    return Parking_brake_status_rpt_80_Parking_brake_enabledType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParkingBrakeEnabledFieldNumber = 1,
  };
  // optional .apollo.canbus.Parking_brake_status_rpt_80.Parking_brake_enabledType parking_brake_enabled = 1;
  bool has_parking_brake_enabled() const;
  private:
  bool _internal_has_parking_brake_enabled() const;
  public:
  void clear_parking_brake_enabled();
  ::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType parking_brake_enabled() const;
  void set_parking_brake_enabled(::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType value);
  private:
  ::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType _internal_parking_brake_enabled() const;
  void _internal_set_parking_brake_enabled(::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Parking_brake_status_rpt_80)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int parking_brake_enabled_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Yaw_rate_rpt_81 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Yaw_rate_rpt_81) */ {
 public:
  Yaw_rate_rpt_81();
  virtual ~Yaw_rate_rpt_81();

  Yaw_rate_rpt_81(const Yaw_rate_rpt_81& from);
  Yaw_rate_rpt_81(Yaw_rate_rpt_81&& from) noexcept
    : Yaw_rate_rpt_81() {
    *this = ::std::move(from);
  }

  inline Yaw_rate_rpt_81& operator=(const Yaw_rate_rpt_81& from) {
    CopyFrom(from);
    return *this;
  }
  inline Yaw_rate_rpt_81& operator=(Yaw_rate_rpt_81&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Yaw_rate_rpt_81& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Yaw_rate_rpt_81* internal_default_instance() {
    return reinterpret_cast<const Yaw_rate_rpt_81*>(
               &_Yaw_rate_rpt_81_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Yaw_rate_rpt_81& a, Yaw_rate_rpt_81& b) {
    a.Swap(&b);
  }
  inline void Swap(Yaw_rate_rpt_81* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Yaw_rate_rpt_81* New() const final {
    return CreateMaybeMessage<Yaw_rate_rpt_81>(nullptr);
  }

  Yaw_rate_rpt_81* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Yaw_rate_rpt_81>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Yaw_rate_rpt_81& from);
  void MergeFrom(const Yaw_rate_rpt_81& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Yaw_rate_rpt_81* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Yaw_rate_rpt_81";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYawRateFieldNumber = 1,
  };
  // optional double yaw_rate = 1;
  bool has_yaw_rate() const;
  private:
  bool _internal_has_yaw_rate() const;
  public:
  void clear_yaw_rate();
  double yaw_rate() const;
  void set_yaw_rate(double value);
  private:
  double _internal_yaw_rate() const;
  void _internal_set_yaw_rate(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Yaw_rate_rpt_81)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double yaw_rate_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Horn_rpt_79 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Horn_rpt_79) */ {
 public:
  Horn_rpt_79();
  virtual ~Horn_rpt_79();

  Horn_rpt_79(const Horn_rpt_79& from);
  Horn_rpt_79(Horn_rpt_79&& from) noexcept
    : Horn_rpt_79() {
    *this = ::std::move(from);
  }

  inline Horn_rpt_79& operator=(const Horn_rpt_79& from) {
    CopyFrom(from);
    return *this;
  }
  inline Horn_rpt_79& operator=(Horn_rpt_79&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Horn_rpt_79& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Horn_rpt_79* internal_default_instance() {
    return reinterpret_cast<const Horn_rpt_79*>(
               &_Horn_rpt_79_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Horn_rpt_79& a, Horn_rpt_79& b) {
    a.Swap(&b);
  }
  inline void Swap(Horn_rpt_79* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Horn_rpt_79* New() const final {
    return CreateMaybeMessage<Horn_rpt_79>(nullptr);
  }

  Horn_rpt_79* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Horn_rpt_79>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Horn_rpt_79& from);
  void MergeFrom(const Horn_rpt_79& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Horn_rpt_79* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Horn_rpt_79";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Horn_rpt_79_Output_valueType Output_valueType;
  static constexpr Output_valueType OUTPUT_VALUE_OFF =
    Horn_rpt_79_Output_valueType_OUTPUT_VALUE_OFF;
  static constexpr Output_valueType OUTPUT_VALUE_ON =
    Horn_rpt_79_Output_valueType_OUTPUT_VALUE_ON;
  static inline bool Output_valueType_IsValid(int value) {
    return Horn_rpt_79_Output_valueType_IsValid(value);
  }
  static constexpr Output_valueType Output_valueType_MIN =
    Horn_rpt_79_Output_valueType_Output_valueType_MIN;
  static constexpr Output_valueType Output_valueType_MAX =
    Horn_rpt_79_Output_valueType_Output_valueType_MAX;
  static constexpr int Output_valueType_ARRAYSIZE =
    Horn_rpt_79_Output_valueType_Output_valueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Output_valueType_descriptor() {
    return Horn_rpt_79_Output_valueType_descriptor();
  }
  template<typename T>
  static inline const std::string& Output_valueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Output_valueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Output_valueType_Name.");
    return Horn_rpt_79_Output_valueType_Name(enum_t_value);
  }
  static inline bool Output_valueType_Parse(const std::string& name,
      Output_valueType* value) {
    return Horn_rpt_79_Output_valueType_Parse(name, value);
  }

  typedef Horn_rpt_79_Commanded_valueType Commanded_valueType;
  static constexpr Commanded_valueType COMMANDED_VALUE_OFF =
    Horn_rpt_79_Commanded_valueType_COMMANDED_VALUE_OFF;
  static constexpr Commanded_valueType COMMANDED_VALUE_ON =
    Horn_rpt_79_Commanded_valueType_COMMANDED_VALUE_ON;
  static inline bool Commanded_valueType_IsValid(int value) {
    return Horn_rpt_79_Commanded_valueType_IsValid(value);
  }
  static constexpr Commanded_valueType Commanded_valueType_MIN =
    Horn_rpt_79_Commanded_valueType_Commanded_valueType_MIN;
  static constexpr Commanded_valueType Commanded_valueType_MAX =
    Horn_rpt_79_Commanded_valueType_Commanded_valueType_MAX;
  static constexpr int Commanded_valueType_ARRAYSIZE =
    Horn_rpt_79_Commanded_valueType_Commanded_valueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Commanded_valueType_descriptor() {
    return Horn_rpt_79_Commanded_valueType_descriptor();
  }
  template<typename T>
  static inline const std::string& Commanded_valueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Commanded_valueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Commanded_valueType_Name.");
    return Horn_rpt_79_Commanded_valueType_Name(enum_t_value);
  }
  static inline bool Commanded_valueType_Parse(const std::string& name,
      Commanded_valueType* value) {
    return Horn_rpt_79_Commanded_valueType_Parse(name, value);
  }

  typedef Horn_rpt_79_Manual_inputType Manual_inputType;
  static constexpr Manual_inputType MANUAL_INPUT_OFF =
    Horn_rpt_79_Manual_inputType_MANUAL_INPUT_OFF;
  static constexpr Manual_inputType MANUAL_INPUT_ON =
    Horn_rpt_79_Manual_inputType_MANUAL_INPUT_ON;
  static inline bool Manual_inputType_IsValid(int value) {
    return Horn_rpt_79_Manual_inputType_IsValid(value);
  }
  static constexpr Manual_inputType Manual_inputType_MIN =
    Horn_rpt_79_Manual_inputType_Manual_inputType_MIN;
  static constexpr Manual_inputType Manual_inputType_MAX =
    Horn_rpt_79_Manual_inputType_Manual_inputType_MAX;
  static constexpr int Manual_inputType_ARRAYSIZE =
    Horn_rpt_79_Manual_inputType_Manual_inputType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Manual_inputType_descriptor() {
    return Horn_rpt_79_Manual_inputType_descriptor();
  }
  template<typename T>
  static inline const std::string& Manual_inputType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Manual_inputType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Manual_inputType_Name.");
    return Horn_rpt_79_Manual_inputType_Name(enum_t_value);
  }
  static inline bool Manual_inputType_Parse(const std::string& name,
      Manual_inputType* value) {
    return Horn_rpt_79_Manual_inputType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOutputValueFieldNumber = 1,
    kCommandedValueFieldNumber = 2,
    kManualInputFieldNumber = 3,
  };
  // optional .apollo.canbus.Horn_rpt_79.Output_valueType output_value = 1;
  bool has_output_value() const;
  private:
  bool _internal_has_output_value() const;
  public:
  void clear_output_value();
  ::apollo::canbus::Horn_rpt_79_Output_valueType output_value() const;
  void set_output_value(::apollo::canbus::Horn_rpt_79_Output_valueType value);
  private:
  ::apollo::canbus::Horn_rpt_79_Output_valueType _internal_output_value() const;
  void _internal_set_output_value(::apollo::canbus::Horn_rpt_79_Output_valueType value);
  public:

  // optional .apollo.canbus.Horn_rpt_79.Commanded_valueType commanded_value = 2;
  bool has_commanded_value() const;
  private:
  bool _internal_has_commanded_value() const;
  public:
  void clear_commanded_value();
  ::apollo::canbus::Horn_rpt_79_Commanded_valueType commanded_value() const;
  void set_commanded_value(::apollo::canbus::Horn_rpt_79_Commanded_valueType value);
  private:
  ::apollo::canbus::Horn_rpt_79_Commanded_valueType _internal_commanded_value() const;
  void _internal_set_commanded_value(::apollo::canbus::Horn_rpt_79_Commanded_valueType value);
  public:

  // optional .apollo.canbus.Horn_rpt_79.Manual_inputType manual_input = 3;
  bool has_manual_input() const;
  private:
  bool _internal_has_manual_input() const;
  public:
  void clear_manual_input();
  ::apollo::canbus::Horn_rpt_79_Manual_inputType manual_input() const;
  void set_manual_input(::apollo::canbus::Horn_rpt_79_Manual_inputType value);
  private:
  ::apollo::canbus::Horn_rpt_79_Manual_inputType _internal_manual_input() const;
  void _internal_set_manual_input(::apollo::canbus::Horn_rpt_79_Manual_inputType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Horn_rpt_79)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int output_value_;
  int commanded_value_;
  int manual_input_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Horn_cmd_78 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Horn_cmd_78) */ {
 public:
  Horn_cmd_78();
  virtual ~Horn_cmd_78();

  Horn_cmd_78(const Horn_cmd_78& from);
  Horn_cmd_78(Horn_cmd_78&& from) noexcept
    : Horn_cmd_78() {
    *this = ::std::move(from);
  }

  inline Horn_cmd_78& operator=(const Horn_cmd_78& from) {
    CopyFrom(from);
    return *this;
  }
  inline Horn_cmd_78& operator=(Horn_cmd_78&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Horn_cmd_78& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Horn_cmd_78* internal_default_instance() {
    return reinterpret_cast<const Horn_cmd_78*>(
               &_Horn_cmd_78_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Horn_cmd_78& a, Horn_cmd_78& b) {
    a.Swap(&b);
  }
  inline void Swap(Horn_cmd_78* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Horn_cmd_78* New() const final {
    return CreateMaybeMessage<Horn_cmd_78>(nullptr);
  }

  Horn_cmd_78* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Horn_cmd_78>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Horn_cmd_78& from);
  void MergeFrom(const Horn_cmd_78& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Horn_cmd_78* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Horn_cmd_78";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Horn_cmd_78_Horn_cmdType Horn_cmdType;
  static constexpr Horn_cmdType HORN_CMD_OFF =
    Horn_cmd_78_Horn_cmdType_HORN_CMD_OFF;
  static constexpr Horn_cmdType HORN_CMD_ON =
    Horn_cmd_78_Horn_cmdType_HORN_CMD_ON;
  static inline bool Horn_cmdType_IsValid(int value) {
    return Horn_cmd_78_Horn_cmdType_IsValid(value);
  }
  static constexpr Horn_cmdType Horn_cmdType_MIN =
    Horn_cmd_78_Horn_cmdType_Horn_cmdType_MIN;
  static constexpr Horn_cmdType Horn_cmdType_MAX =
    Horn_cmd_78_Horn_cmdType_Horn_cmdType_MAX;
  static constexpr int Horn_cmdType_ARRAYSIZE =
    Horn_cmd_78_Horn_cmdType_Horn_cmdType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Horn_cmdType_descriptor() {
    return Horn_cmd_78_Horn_cmdType_descriptor();
  }
  template<typename T>
  static inline const std::string& Horn_cmdType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Horn_cmdType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Horn_cmdType_Name.");
    return Horn_cmd_78_Horn_cmdType_Name(enum_t_value);
  }
  static inline bool Horn_cmdType_Parse(const std::string& name,
      Horn_cmdType* value) {
    return Horn_cmd_78_Horn_cmdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHornCmdFieldNumber = 1,
  };
  // optional .apollo.canbus.Horn_cmd_78.Horn_cmdType horn_cmd = 1;
  bool has_horn_cmd() const;
  private:
  bool _internal_has_horn_cmd() const;
  public:
  void clear_horn_cmd();
  ::apollo::canbus::Horn_cmd_78_Horn_cmdType horn_cmd() const;
  void set_horn_cmd(::apollo::canbus::Horn_cmd_78_Horn_cmdType value);
  private:
  ::apollo::canbus::Horn_cmd_78_Horn_cmdType _internal_horn_cmd() const;
  void _internal_set_horn_cmd(::apollo::canbus::Horn_cmd_78_Horn_cmdType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Horn_cmd_78)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int horn_cmd_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Wiper_rpt_91 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Wiper_rpt_91) */ {
 public:
  Wiper_rpt_91();
  virtual ~Wiper_rpt_91();

  Wiper_rpt_91(const Wiper_rpt_91& from);
  Wiper_rpt_91(Wiper_rpt_91&& from) noexcept
    : Wiper_rpt_91() {
    *this = ::std::move(from);
  }

  inline Wiper_rpt_91& operator=(const Wiper_rpt_91& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wiper_rpt_91& operator=(Wiper_rpt_91&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Wiper_rpt_91& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Wiper_rpt_91* internal_default_instance() {
    return reinterpret_cast<const Wiper_rpt_91*>(
               &_Wiper_rpt_91_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Wiper_rpt_91& a, Wiper_rpt_91& b) {
    a.Swap(&b);
  }
  inline void Swap(Wiper_rpt_91* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Wiper_rpt_91* New() const final {
    return CreateMaybeMessage<Wiper_rpt_91>(nullptr);
  }

  Wiper_rpt_91* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Wiper_rpt_91>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Wiper_rpt_91& from);
  void MergeFrom(const Wiper_rpt_91& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wiper_rpt_91* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Wiper_rpt_91";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Wiper_rpt_91_Output_valueType Output_valueType;
  static constexpr Output_valueType OUTPUT_VALUE_WIPERS_OFF =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_WIPERS_OFF;
  static constexpr Output_valueType OUTPUT_VALUE_INTERMITTENT_1 =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_1;
  static constexpr Output_valueType OUTPUT_VALUE_INTERMITTENT_2 =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_2;
  static constexpr Output_valueType OUTPUT_VALUE_INTERMITTENT_3 =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_3;
  static constexpr Output_valueType OUTPUT_VALUE_INTERMITTENT_4 =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_4;
  static constexpr Output_valueType OUTPUT_VALUE_INTERMITTENT_5 =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_5;
  static constexpr Output_valueType OUTPUT_VALUE_LOW =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_LOW;
  static constexpr Output_valueType OUTPUT_VALUE_HIGH =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_HIGH;
  static inline bool Output_valueType_IsValid(int value) {
    return Wiper_rpt_91_Output_valueType_IsValid(value);
  }
  static constexpr Output_valueType Output_valueType_MIN =
    Wiper_rpt_91_Output_valueType_Output_valueType_MIN;
  static constexpr Output_valueType Output_valueType_MAX =
    Wiper_rpt_91_Output_valueType_Output_valueType_MAX;
  static constexpr int Output_valueType_ARRAYSIZE =
    Wiper_rpt_91_Output_valueType_Output_valueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Output_valueType_descriptor() {
    return Wiper_rpt_91_Output_valueType_descriptor();
  }
  template<typename T>
  static inline const std::string& Output_valueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Output_valueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Output_valueType_Name.");
    return Wiper_rpt_91_Output_valueType_Name(enum_t_value);
  }
  static inline bool Output_valueType_Parse(const std::string& name,
      Output_valueType* value) {
    return Wiper_rpt_91_Output_valueType_Parse(name, value);
  }

  typedef Wiper_rpt_91_Commanded_valueType Commanded_valueType;
  static constexpr Commanded_valueType COMMANDED_VALUE_WIPERS_OFF =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_WIPERS_OFF;
  static constexpr Commanded_valueType COMMANDED_VALUE_INTERMITTENT_1 =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_1;
  static constexpr Commanded_valueType COMMANDED_VALUE_INTERMITTENT_2 =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_2;
  static constexpr Commanded_valueType COMMANDED_VALUE_INTERMITTENT_3 =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_3;
  static constexpr Commanded_valueType COMMANDED_VALUE_INTERMITTENT_4 =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_4;
  static constexpr Commanded_valueType COMMANDED_VALUE_INTERMITTENT_5 =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_5;
  static constexpr Commanded_valueType COMMANDED_VALUE_LOW =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_LOW;
  static constexpr Commanded_valueType COMMANDED_VALUE_HIGH =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_HIGH;
  static inline bool Commanded_valueType_IsValid(int value) {
    return Wiper_rpt_91_Commanded_valueType_IsValid(value);
  }
  static constexpr Commanded_valueType Commanded_valueType_MIN =
    Wiper_rpt_91_Commanded_valueType_Commanded_valueType_MIN;
  static constexpr Commanded_valueType Commanded_valueType_MAX =
    Wiper_rpt_91_Commanded_valueType_Commanded_valueType_MAX;
  static constexpr int Commanded_valueType_ARRAYSIZE =
    Wiper_rpt_91_Commanded_valueType_Commanded_valueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Commanded_valueType_descriptor() {
    return Wiper_rpt_91_Commanded_valueType_descriptor();
  }
  template<typename T>
  static inline const std::string& Commanded_valueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Commanded_valueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Commanded_valueType_Name.");
    return Wiper_rpt_91_Commanded_valueType_Name(enum_t_value);
  }
  static inline bool Commanded_valueType_Parse(const std::string& name,
      Commanded_valueType* value) {
    return Wiper_rpt_91_Commanded_valueType_Parse(name, value);
  }

  typedef Wiper_rpt_91_Manual_inputType Manual_inputType;
  static constexpr Manual_inputType MANUAL_INPUT_WIPERS_OFF =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_WIPERS_OFF;
  static constexpr Manual_inputType MANUAL_INPUT_INTERMITTENT_1 =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_1;
  static constexpr Manual_inputType MANUAL_INPUT_INTERMITTENT_2 =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_2;
  static constexpr Manual_inputType MANUAL_INPUT_INTERMITTENT_3 =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_3;
  static constexpr Manual_inputType MANUAL_INPUT_INTERMITTENT_4 =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_4;
  static constexpr Manual_inputType MANUAL_INPUT_INTERMITTENT_5 =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_5;
  static constexpr Manual_inputType MANUAL_INPUT_LOW =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_LOW;
  static constexpr Manual_inputType MANUAL_INPUT_HIGH =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_HIGH;
  static inline bool Manual_inputType_IsValid(int value) {
    return Wiper_rpt_91_Manual_inputType_IsValid(value);
  }
  static constexpr Manual_inputType Manual_inputType_MIN =
    Wiper_rpt_91_Manual_inputType_Manual_inputType_MIN;
  static constexpr Manual_inputType Manual_inputType_MAX =
    Wiper_rpt_91_Manual_inputType_Manual_inputType_MAX;
  static constexpr int Manual_inputType_ARRAYSIZE =
    Wiper_rpt_91_Manual_inputType_Manual_inputType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Manual_inputType_descriptor() {
    return Wiper_rpt_91_Manual_inputType_descriptor();
  }
  template<typename T>
  static inline const std::string& Manual_inputType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Manual_inputType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Manual_inputType_Name.");
    return Wiper_rpt_91_Manual_inputType_Name(enum_t_value);
  }
  static inline bool Manual_inputType_Parse(const std::string& name,
      Manual_inputType* value) {
    return Wiper_rpt_91_Manual_inputType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOutputValueFieldNumber = 1,
    kCommandedValueFieldNumber = 2,
    kManualInputFieldNumber = 3,
  };
  // optional .apollo.canbus.Wiper_rpt_91.Output_valueType output_value = 1;
  bool has_output_value() const;
  private:
  bool _internal_has_output_value() const;
  public:
  void clear_output_value();
  ::apollo::canbus::Wiper_rpt_91_Output_valueType output_value() const;
  void set_output_value(::apollo::canbus::Wiper_rpt_91_Output_valueType value);
  private:
  ::apollo::canbus::Wiper_rpt_91_Output_valueType _internal_output_value() const;
  void _internal_set_output_value(::apollo::canbus::Wiper_rpt_91_Output_valueType value);
  public:

  // optional .apollo.canbus.Wiper_rpt_91.Commanded_valueType commanded_value = 2;
  bool has_commanded_value() const;
  private:
  bool _internal_has_commanded_value() const;
  public:
  void clear_commanded_value();
  ::apollo::canbus::Wiper_rpt_91_Commanded_valueType commanded_value() const;
  void set_commanded_value(::apollo::canbus::Wiper_rpt_91_Commanded_valueType value);
  private:
  ::apollo::canbus::Wiper_rpt_91_Commanded_valueType _internal_commanded_value() const;
  void _internal_set_commanded_value(::apollo::canbus::Wiper_rpt_91_Commanded_valueType value);
  public:

  // optional .apollo.canbus.Wiper_rpt_91.Manual_inputType manual_input = 3;
  bool has_manual_input() const;
  private:
  bool _internal_has_manual_input() const;
  public:
  void clear_manual_input();
  ::apollo::canbus::Wiper_rpt_91_Manual_inputType manual_input() const;
  void set_manual_input(::apollo::canbus::Wiper_rpt_91_Manual_inputType value);
  private:
  ::apollo::canbus::Wiper_rpt_91_Manual_inputType _internal_manual_input() const;
  void _internal_set_manual_input(::apollo::canbus::Wiper_rpt_91_Manual_inputType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Wiper_rpt_91)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int output_value_;
  int commanded_value_;
  int manual_input_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Vehicle_speed_rpt_6f :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Vehicle_speed_rpt_6f) */ {
 public:
  Vehicle_speed_rpt_6f();
  virtual ~Vehicle_speed_rpt_6f();

  Vehicle_speed_rpt_6f(const Vehicle_speed_rpt_6f& from);
  Vehicle_speed_rpt_6f(Vehicle_speed_rpt_6f&& from) noexcept
    : Vehicle_speed_rpt_6f() {
    *this = ::std::move(from);
  }

  inline Vehicle_speed_rpt_6f& operator=(const Vehicle_speed_rpt_6f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle_speed_rpt_6f& operator=(Vehicle_speed_rpt_6f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vehicle_speed_rpt_6f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle_speed_rpt_6f* internal_default_instance() {
    return reinterpret_cast<const Vehicle_speed_rpt_6f*>(
               &_Vehicle_speed_rpt_6f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Vehicle_speed_rpt_6f& a, Vehicle_speed_rpt_6f& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle_speed_rpt_6f* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vehicle_speed_rpt_6f* New() const final {
    return CreateMaybeMessage<Vehicle_speed_rpt_6f>(nullptr);
  }

  Vehicle_speed_rpt_6f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle_speed_rpt_6f>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vehicle_speed_rpt_6f& from);
  void MergeFrom(const Vehicle_speed_rpt_6f& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_speed_rpt_6f* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Vehicle_speed_rpt_6f";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Vehicle_speed_rpt_6f_Vehicle_speed_validType Vehicle_speed_validType;
  static constexpr Vehicle_speed_validType VEHICLE_SPEED_VALID_INVALID =
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_VEHICLE_SPEED_VALID_INVALID;
  static constexpr Vehicle_speed_validType VEHICLE_SPEED_VALID_VALID =
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_VEHICLE_SPEED_VALID_VALID;
  static inline bool Vehicle_speed_validType_IsValid(int value) {
    return Vehicle_speed_rpt_6f_Vehicle_speed_validType_IsValid(value);
  }
  static constexpr Vehicle_speed_validType Vehicle_speed_validType_MIN =
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_MIN;
  static constexpr Vehicle_speed_validType Vehicle_speed_validType_MAX =
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_MAX;
  static constexpr int Vehicle_speed_validType_ARRAYSIZE =
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Vehicle_speed_validType_descriptor() {
    return Vehicle_speed_rpt_6f_Vehicle_speed_validType_descriptor();
  }
  template<typename T>
  static inline const std::string& Vehicle_speed_validType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Vehicle_speed_validType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Vehicle_speed_validType_Name.");
    return Vehicle_speed_rpt_6f_Vehicle_speed_validType_Name(enum_t_value);
  }
  static inline bool Vehicle_speed_validType_Parse(const std::string& name,
      Vehicle_speed_validType* value) {
    return Vehicle_speed_rpt_6f_Vehicle_speed_validType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleSpeedFieldNumber = 1,
    kVehicleSpeedValidFieldNumber = 2,
  };
  // optional double vehicle_speed = 1;
  bool has_vehicle_speed() const;
  private:
  bool _internal_has_vehicle_speed() const;
  public:
  void clear_vehicle_speed();
  double vehicle_speed() const;
  void set_vehicle_speed(double value);
  private:
  double _internal_vehicle_speed() const;
  void _internal_set_vehicle_speed(double value);
  public:

  // optional .apollo.canbus.Vehicle_speed_rpt_6f.Vehicle_speed_validType vehicle_speed_valid = 2;
  bool has_vehicle_speed_valid() const;
  private:
  bool _internal_has_vehicle_speed_valid() const;
  public:
  void clear_vehicle_speed_valid();
  ::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType vehicle_speed_valid() const;
  void set_vehicle_speed_valid(::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType value);
  private:
  ::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType _internal_vehicle_speed_valid() const;
  void _internal_set_vehicle_speed_valid(::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Vehicle_speed_rpt_6f)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double vehicle_speed_;
  int vehicle_speed_valid_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Headlight_cmd_76 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Headlight_cmd_76) */ {
 public:
  Headlight_cmd_76();
  virtual ~Headlight_cmd_76();

  Headlight_cmd_76(const Headlight_cmd_76& from);
  Headlight_cmd_76(Headlight_cmd_76&& from) noexcept
    : Headlight_cmd_76() {
    *this = ::std::move(from);
  }

  inline Headlight_cmd_76& operator=(const Headlight_cmd_76& from) {
    CopyFrom(from);
    return *this;
  }
  inline Headlight_cmd_76& operator=(Headlight_cmd_76&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Headlight_cmd_76& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Headlight_cmd_76* internal_default_instance() {
    return reinterpret_cast<const Headlight_cmd_76*>(
               &_Headlight_cmd_76_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Headlight_cmd_76& a, Headlight_cmd_76& b) {
    a.Swap(&b);
  }
  inline void Swap(Headlight_cmd_76* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Headlight_cmd_76* New() const final {
    return CreateMaybeMessage<Headlight_cmd_76>(nullptr);
  }

  Headlight_cmd_76* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Headlight_cmd_76>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Headlight_cmd_76& from);
  void MergeFrom(const Headlight_cmd_76& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Headlight_cmd_76* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Headlight_cmd_76";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Headlight_cmd_76_Headlight_cmdType Headlight_cmdType;
  static constexpr Headlight_cmdType HEADLIGHT_CMD_HEADLIGHTS_OFF =
    Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_HEADLIGHTS_OFF;
  static constexpr Headlight_cmdType HEADLIGHT_CMD_LOW_BEAMS =
    Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_LOW_BEAMS;
  static constexpr Headlight_cmdType HEADLIGHT_CMD_HIGH_BEAMS =
    Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_HIGH_BEAMS;
  static inline bool Headlight_cmdType_IsValid(int value) {
    return Headlight_cmd_76_Headlight_cmdType_IsValid(value);
  }
  static constexpr Headlight_cmdType Headlight_cmdType_MIN =
    Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_MIN;
  static constexpr Headlight_cmdType Headlight_cmdType_MAX =
    Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_MAX;
  static constexpr int Headlight_cmdType_ARRAYSIZE =
    Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Headlight_cmdType_descriptor() {
    return Headlight_cmd_76_Headlight_cmdType_descriptor();
  }
  template<typename T>
  static inline const std::string& Headlight_cmdType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Headlight_cmdType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Headlight_cmdType_Name.");
    return Headlight_cmd_76_Headlight_cmdType_Name(enum_t_value);
  }
  static inline bool Headlight_cmdType_Parse(const std::string& name,
      Headlight_cmdType* value) {
    return Headlight_cmd_76_Headlight_cmdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeadlightCmdFieldNumber = 1,
  };
  // optional .apollo.canbus.Headlight_cmd_76.Headlight_cmdType headlight_cmd = 1;
  bool has_headlight_cmd() const;
  private:
  bool _internal_has_headlight_cmd() const;
  public:
  void clear_headlight_cmd();
  ::apollo::canbus::Headlight_cmd_76_Headlight_cmdType headlight_cmd() const;
  void set_headlight_cmd(::apollo::canbus::Headlight_cmd_76_Headlight_cmdType value);
  private:
  ::apollo::canbus::Headlight_cmd_76_Headlight_cmdType _internal_headlight_cmd() const;
  void _internal_set_headlight_cmd(::apollo::canbus::Headlight_cmd_76_Headlight_cmdType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Headlight_cmd_76)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int headlight_cmd_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Steering_motor_rpt_2_74 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Steering_motor_rpt_2_74) */ {
 public:
  Steering_motor_rpt_2_74();
  virtual ~Steering_motor_rpt_2_74();

  Steering_motor_rpt_2_74(const Steering_motor_rpt_2_74& from);
  Steering_motor_rpt_2_74(Steering_motor_rpt_2_74&& from) noexcept
    : Steering_motor_rpt_2_74() {
    *this = ::std::move(from);
  }

  inline Steering_motor_rpt_2_74& operator=(const Steering_motor_rpt_2_74& from) {
    CopyFrom(from);
    return *this;
  }
  inline Steering_motor_rpt_2_74& operator=(Steering_motor_rpt_2_74&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Steering_motor_rpt_2_74& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Steering_motor_rpt_2_74* internal_default_instance() {
    return reinterpret_cast<const Steering_motor_rpt_2_74*>(
               &_Steering_motor_rpt_2_74_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(Steering_motor_rpt_2_74& a, Steering_motor_rpt_2_74& b) {
    a.Swap(&b);
  }
  inline void Swap(Steering_motor_rpt_2_74* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Steering_motor_rpt_2_74* New() const final {
    return CreateMaybeMessage<Steering_motor_rpt_2_74>(nullptr);
  }

  Steering_motor_rpt_2_74* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Steering_motor_rpt_2_74>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Steering_motor_rpt_2_74& from);
  void MergeFrom(const Steering_motor_rpt_2_74& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Steering_motor_rpt_2_74* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Steering_motor_rpt_2_74";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncoderTemperatureFieldNumber = 1,
    kMotorTemperatureFieldNumber = 2,
    kAngularSpeedFieldNumber = 3,
  };
  // optional int32 encoder_temperature = 1;
  bool has_encoder_temperature() const;
  private:
  bool _internal_has_encoder_temperature() const;
  public:
  void clear_encoder_temperature();
  ::PROTOBUF_NAMESPACE_ID::int32 encoder_temperature() const;
  void set_encoder_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_encoder_temperature() const;
  void _internal_set_encoder_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 motor_temperature = 2;
  bool has_motor_temperature() const;
  private:
  bool _internal_has_motor_temperature() const;
  public:
  void clear_motor_temperature();
  ::PROTOBUF_NAMESPACE_ID::int32 motor_temperature() const;
  void set_motor_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_motor_temperature() const;
  void _internal_set_motor_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double angular_speed = 3;
  bool has_angular_speed() const;
  private:
  bool _internal_has_angular_speed() const;
  public:
  void clear_angular_speed();
  double angular_speed() const;
  void set_angular_speed(double value);
  private:
  double _internal_angular_speed() const;
  void _internal_set_angular_speed(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Steering_motor_rpt_2_74)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 encoder_temperature_;
  ::PROTOBUF_NAMESPACE_ID::int32 motor_temperature_;
  double angular_speed_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Brake_motor_rpt_2_71 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Brake_motor_rpt_2_71) */ {
 public:
  Brake_motor_rpt_2_71();
  virtual ~Brake_motor_rpt_2_71();

  Brake_motor_rpt_2_71(const Brake_motor_rpt_2_71& from);
  Brake_motor_rpt_2_71(Brake_motor_rpt_2_71&& from) noexcept
    : Brake_motor_rpt_2_71() {
    *this = ::std::move(from);
  }

  inline Brake_motor_rpt_2_71& operator=(const Brake_motor_rpt_2_71& from) {
    CopyFrom(from);
    return *this;
  }
  inline Brake_motor_rpt_2_71& operator=(Brake_motor_rpt_2_71&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Brake_motor_rpt_2_71& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Brake_motor_rpt_2_71* internal_default_instance() {
    return reinterpret_cast<const Brake_motor_rpt_2_71*>(
               &_Brake_motor_rpt_2_71_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(Brake_motor_rpt_2_71& a, Brake_motor_rpt_2_71& b) {
    a.Swap(&b);
  }
  inline void Swap(Brake_motor_rpt_2_71* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Brake_motor_rpt_2_71* New() const final {
    return CreateMaybeMessage<Brake_motor_rpt_2_71>(nullptr);
  }

  Brake_motor_rpt_2_71* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Brake_motor_rpt_2_71>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Brake_motor_rpt_2_71& from);
  void MergeFrom(const Brake_motor_rpt_2_71& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Brake_motor_rpt_2_71* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Brake_motor_rpt_2_71";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncoderTemperatureFieldNumber = 1,
    kMotorTemperatureFieldNumber = 2,
    kAngularSpeedFieldNumber = 3,
  };
  // optional int32 encoder_temperature = 1;
  bool has_encoder_temperature() const;
  private:
  bool _internal_has_encoder_temperature() const;
  public:
  void clear_encoder_temperature();
  ::PROTOBUF_NAMESPACE_ID::int32 encoder_temperature() const;
  void set_encoder_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_encoder_temperature() const;
  void _internal_set_encoder_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 motor_temperature = 2;
  bool has_motor_temperature() const;
  private:
  bool _internal_has_motor_temperature() const;
  public:
  void clear_motor_temperature();
  ::PROTOBUF_NAMESPACE_ID::int32 motor_temperature() const;
  void set_motor_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_motor_temperature() const;
  void _internal_set_motor_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double angular_speed = 3;
  bool has_angular_speed() const;
  private:
  bool _internal_has_angular_speed() const;
  public:
  void clear_angular_speed();
  double angular_speed() const;
  void set_angular_speed(double value);
  private:
  double _internal_angular_speed() const;
  void _internal_set_angular_speed(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Brake_motor_rpt_2_71)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 encoder_temperature_;
  ::PROTOBUF_NAMESPACE_ID::int32 motor_temperature_;
  double angular_speed_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Steering_motor_rpt_1_73 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Steering_motor_rpt_1_73) */ {
 public:
  Steering_motor_rpt_1_73();
  virtual ~Steering_motor_rpt_1_73();

  Steering_motor_rpt_1_73(const Steering_motor_rpt_1_73& from);
  Steering_motor_rpt_1_73(Steering_motor_rpt_1_73&& from) noexcept
    : Steering_motor_rpt_1_73() {
    *this = ::std::move(from);
  }

  inline Steering_motor_rpt_1_73& operator=(const Steering_motor_rpt_1_73& from) {
    CopyFrom(from);
    return *this;
  }
  inline Steering_motor_rpt_1_73& operator=(Steering_motor_rpt_1_73&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Steering_motor_rpt_1_73& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Steering_motor_rpt_1_73* internal_default_instance() {
    return reinterpret_cast<const Steering_motor_rpt_1_73*>(
               &_Steering_motor_rpt_1_73_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(Steering_motor_rpt_1_73& a, Steering_motor_rpt_1_73& b) {
    a.Swap(&b);
  }
  inline void Swap(Steering_motor_rpt_1_73* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Steering_motor_rpt_1_73* New() const final {
    return CreateMaybeMessage<Steering_motor_rpt_1_73>(nullptr);
  }

  Steering_motor_rpt_1_73* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Steering_motor_rpt_1_73>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Steering_motor_rpt_1_73& from);
  void MergeFrom(const Steering_motor_rpt_1_73& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Steering_motor_rpt_1_73* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Steering_motor_rpt_1_73";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotorCurrentFieldNumber = 1,
    kShaftPositionFieldNumber = 2,
  };
  // optional double motor_current = 1;
  bool has_motor_current() const;
  private:
  bool _internal_has_motor_current() const;
  public:
  void clear_motor_current();
  double motor_current() const;
  void set_motor_current(double value);
  private:
  double _internal_motor_current() const;
  void _internal_set_motor_current(double value);
  public:

  // optional double shaft_position = 2;
  bool has_shaft_position() const;
  private:
  bool _internal_has_shaft_position() const;
  public:
  void clear_shaft_position();
  double shaft_position() const;
  void set_shaft_position(double value);
  private:
  double _internal_shaft_position() const;
  void _internal_set_shaft_position(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Steering_motor_rpt_1_73)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double motor_current_;
  double shaft_position_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Wiper_cmd_90 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Wiper_cmd_90) */ {
 public:
  Wiper_cmd_90();
  virtual ~Wiper_cmd_90();

  Wiper_cmd_90(const Wiper_cmd_90& from);
  Wiper_cmd_90(Wiper_cmd_90&& from) noexcept
    : Wiper_cmd_90() {
    *this = ::std::move(from);
  }

  inline Wiper_cmd_90& operator=(const Wiper_cmd_90& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wiper_cmd_90& operator=(Wiper_cmd_90&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Wiper_cmd_90& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Wiper_cmd_90* internal_default_instance() {
    return reinterpret_cast<const Wiper_cmd_90*>(
               &_Wiper_cmd_90_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(Wiper_cmd_90& a, Wiper_cmd_90& b) {
    a.Swap(&b);
  }
  inline void Swap(Wiper_cmd_90* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Wiper_cmd_90* New() const final {
    return CreateMaybeMessage<Wiper_cmd_90>(nullptr);
  }

  Wiper_cmd_90* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Wiper_cmd_90>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Wiper_cmd_90& from);
  void MergeFrom(const Wiper_cmd_90& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wiper_cmd_90* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Wiper_cmd_90";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Wiper_cmd_90_Wiper_cmdType Wiper_cmdType;
  static constexpr Wiper_cmdType WIPER_CMD_WIPERS_OFF =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_WIPERS_OFF;
  static constexpr Wiper_cmdType WIPER_CMD_INTERMITTENT_1 =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_1;
  static constexpr Wiper_cmdType WIPER_CMD_INTERMITTENT_2 =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_2;
  static constexpr Wiper_cmdType WIPER_CMD_INTERMITTENT_3 =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_3;
  static constexpr Wiper_cmdType WIPER_CMD_INTERMITTENT_4 =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_4;
  static constexpr Wiper_cmdType WIPER_CMD_INTERMITTENT_5 =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_5;
  static constexpr Wiper_cmdType WIPER_CMD_LOW =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_LOW;
  static constexpr Wiper_cmdType WIPER_CMD_HIGH =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_HIGH;
  static inline bool Wiper_cmdType_IsValid(int value) {
    return Wiper_cmd_90_Wiper_cmdType_IsValid(value);
  }
  static constexpr Wiper_cmdType Wiper_cmdType_MIN =
    Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_MIN;
  static constexpr Wiper_cmdType Wiper_cmdType_MAX =
    Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_MAX;
  static constexpr int Wiper_cmdType_ARRAYSIZE =
    Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Wiper_cmdType_descriptor() {
    return Wiper_cmd_90_Wiper_cmdType_descriptor();
  }
  template<typename T>
  static inline const std::string& Wiper_cmdType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Wiper_cmdType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Wiper_cmdType_Name.");
    return Wiper_cmd_90_Wiper_cmdType_Name(enum_t_value);
  }
  static inline bool Wiper_cmdType_Parse(const std::string& name,
      Wiper_cmdType* value) {
    return Wiper_cmd_90_Wiper_cmdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWiperCmdFieldNumber = 1,
  };
  // optional .apollo.canbus.Wiper_cmd_90.Wiper_cmdType wiper_cmd = 1;
  bool has_wiper_cmd() const;
  private:
  bool _internal_has_wiper_cmd() const;
  public:
  void clear_wiper_cmd();
  ::apollo::canbus::Wiper_cmd_90_Wiper_cmdType wiper_cmd() const;
  void set_wiper_cmd(::apollo::canbus::Wiper_cmd_90_Wiper_cmdType value);
  private:
  ::apollo::canbus::Wiper_cmd_90_Wiper_cmdType _internal_wiper_cmd() const;
  void _internal_set_wiper_cmd(::apollo::canbus::Wiper_cmd_90_Wiper_cmdType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Wiper_cmd_90)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int wiper_cmd_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Brake_motor_rpt_3_72 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Brake_motor_rpt_3_72) */ {
 public:
  Brake_motor_rpt_3_72();
  virtual ~Brake_motor_rpt_3_72();

  Brake_motor_rpt_3_72(const Brake_motor_rpt_3_72& from);
  Brake_motor_rpt_3_72(Brake_motor_rpt_3_72&& from) noexcept
    : Brake_motor_rpt_3_72() {
    *this = ::std::move(from);
  }

  inline Brake_motor_rpt_3_72& operator=(const Brake_motor_rpt_3_72& from) {
    CopyFrom(from);
    return *this;
  }
  inline Brake_motor_rpt_3_72& operator=(Brake_motor_rpt_3_72&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Brake_motor_rpt_3_72& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Brake_motor_rpt_3_72* internal_default_instance() {
    return reinterpret_cast<const Brake_motor_rpt_3_72*>(
               &_Brake_motor_rpt_3_72_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(Brake_motor_rpt_3_72& a, Brake_motor_rpt_3_72& b) {
    a.Swap(&b);
  }
  inline void Swap(Brake_motor_rpt_3_72* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Brake_motor_rpt_3_72* New() const final {
    return CreateMaybeMessage<Brake_motor_rpt_3_72>(nullptr);
  }

  Brake_motor_rpt_3_72* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Brake_motor_rpt_3_72>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Brake_motor_rpt_3_72& from);
  void MergeFrom(const Brake_motor_rpt_3_72& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Brake_motor_rpt_3_72* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Brake_motor_rpt_3_72";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTorqueOutputFieldNumber = 1,
    kTorqueInputFieldNumber = 2,
  };
  // optional double torque_output = 1;
  bool has_torque_output() const;
  private:
  bool _internal_has_torque_output() const;
  public:
  void clear_torque_output();
  double torque_output() const;
  void set_torque_output(double value);
  private:
  double _internal_torque_output() const;
  void _internal_set_torque_output(double value);
  public:

  // optional double torque_input = 2;
  bool has_torque_input() const;
  private:
  bool _internal_has_torque_input() const;
  public:
  void clear_torque_input();
  double torque_input() const;
  void set_torque_input(double value);
  private:
  double _internal_torque_input() const;
  void _internal_set_torque_input(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Brake_motor_rpt_3_72)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double torque_output_;
  double torque_input_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// -------------------------------------------------------------------

class Gem :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Gem) */ {
 public:
  Gem();
  virtual ~Gem();

  Gem(const Gem& from);
  Gem(Gem&& from) noexcept
    : Gem() {
    *this = ::std::move(from);
  }

  inline Gem& operator=(const Gem& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gem& operator=(Gem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Gem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Gem* internal_default_instance() {
    return reinterpret_cast<const Gem*>(
               &_Gem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Gem& a, Gem& b) {
    a.Swap(&b);
  }
  inline void Swap(Gem* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Gem* New() const final {
    return CreateMaybeMessage<Gem>(nullptr);
  }

  Gem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Gem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Gem& from);
  void MergeFrom(const Gem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.canbus.Gem";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto);
    return ::descriptor_table_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGlobalRpt6AFieldNumber = 1,
    kBrakeCmd6BFieldNumber = 2,
    kBrakeRpt6CFieldNumber = 3,
    kSteeringCmd6DFieldNumber = 4,
    kSteeringRpt16EFieldNumber = 5,
    kWheelSpeedRpt7AFieldNumber = 6,
    kDateTimeRpt83FieldNumber = 7,
    kBrakeMotorRpt170FieldNumber = 8,
    kHeadlightRpt77FieldNumber = 9,
    kAccelRpt68FieldNumber = 10,
    kSteeringMotorRpt375FieldNumber = 11,
    kTurnCmd63FieldNumber = 12,
    kTurnRpt64FieldNumber = 13,
    kShiftCmd65FieldNumber = 14,
    kShiftRpt66FieldNumber = 15,
    kAccelCmd67FieldNumber = 16,
    kLatLonHeadingRpt82FieldNumber = 17,
    kGlobalCmd69FieldNumber = 18,
    kParkingBrakeStatusRpt80FieldNumber = 19,
    kYawRateRpt81FieldNumber = 20,
    kHornRpt79FieldNumber = 21,
    kHornCmd78FieldNumber = 22,
    kWiperRpt91FieldNumber = 23,
    kVehicleSpeedRpt6FFieldNumber = 24,
    kHeadlightCmd76FieldNumber = 25,
    kSteeringMotorRpt274FieldNumber = 26,
    kBrakeMotorRpt271FieldNumber = 27,
    kSteeringMotorRpt173FieldNumber = 28,
    kWiperCmd90FieldNumber = 29,
    kBrakeMotorRpt372FieldNumber = 30,
  };
  // optional .apollo.canbus.Global_rpt_6a global_rpt_6a = 1;
  bool has_global_rpt_6a() const;
  private:
  bool _internal_has_global_rpt_6a() const;
  public:
  void clear_global_rpt_6a();
  const ::apollo::canbus::Global_rpt_6a& global_rpt_6a() const;
  ::apollo::canbus::Global_rpt_6a* release_global_rpt_6a();
  ::apollo::canbus::Global_rpt_6a* mutable_global_rpt_6a();
  void set_allocated_global_rpt_6a(::apollo::canbus::Global_rpt_6a* global_rpt_6a);
  private:
  const ::apollo::canbus::Global_rpt_6a& _internal_global_rpt_6a() const;
  ::apollo::canbus::Global_rpt_6a* _internal_mutable_global_rpt_6a();
  public:

  // optional .apollo.canbus.Brake_cmd_6b brake_cmd_6b = 2;
  bool has_brake_cmd_6b() const;
  private:
  bool _internal_has_brake_cmd_6b() const;
  public:
  void clear_brake_cmd_6b();
  const ::apollo::canbus::Brake_cmd_6b& brake_cmd_6b() const;
  ::apollo::canbus::Brake_cmd_6b* release_brake_cmd_6b();
  ::apollo::canbus::Brake_cmd_6b* mutable_brake_cmd_6b();
  void set_allocated_brake_cmd_6b(::apollo::canbus::Brake_cmd_6b* brake_cmd_6b);
  private:
  const ::apollo::canbus::Brake_cmd_6b& _internal_brake_cmd_6b() const;
  ::apollo::canbus::Brake_cmd_6b* _internal_mutable_brake_cmd_6b();
  public:

  // optional .apollo.canbus.Brake_rpt_6c brake_rpt_6c = 3;
  bool has_brake_rpt_6c() const;
  private:
  bool _internal_has_brake_rpt_6c() const;
  public:
  void clear_brake_rpt_6c();
  const ::apollo::canbus::Brake_rpt_6c& brake_rpt_6c() const;
  ::apollo::canbus::Brake_rpt_6c* release_brake_rpt_6c();
  ::apollo::canbus::Brake_rpt_6c* mutable_brake_rpt_6c();
  void set_allocated_brake_rpt_6c(::apollo::canbus::Brake_rpt_6c* brake_rpt_6c);
  private:
  const ::apollo::canbus::Brake_rpt_6c& _internal_brake_rpt_6c() const;
  ::apollo::canbus::Brake_rpt_6c* _internal_mutable_brake_rpt_6c();
  public:

  // optional .apollo.canbus.Steering_cmd_6d steering_cmd_6d = 4;
  bool has_steering_cmd_6d() const;
  private:
  bool _internal_has_steering_cmd_6d() const;
  public:
  void clear_steering_cmd_6d();
  const ::apollo::canbus::Steering_cmd_6d& steering_cmd_6d() const;
  ::apollo::canbus::Steering_cmd_6d* release_steering_cmd_6d();
  ::apollo::canbus::Steering_cmd_6d* mutable_steering_cmd_6d();
  void set_allocated_steering_cmd_6d(::apollo::canbus::Steering_cmd_6d* steering_cmd_6d);
  private:
  const ::apollo::canbus::Steering_cmd_6d& _internal_steering_cmd_6d() const;
  ::apollo::canbus::Steering_cmd_6d* _internal_mutable_steering_cmd_6d();
  public:

  // optional .apollo.canbus.Steering_rpt_1_6e steering_rpt_1_6e = 5;
  bool has_steering_rpt_1_6e() const;
  private:
  bool _internal_has_steering_rpt_1_6e() const;
  public:
  void clear_steering_rpt_1_6e();
  const ::apollo::canbus::Steering_rpt_1_6e& steering_rpt_1_6e() const;
  ::apollo::canbus::Steering_rpt_1_6e* release_steering_rpt_1_6e();
  ::apollo::canbus::Steering_rpt_1_6e* mutable_steering_rpt_1_6e();
  void set_allocated_steering_rpt_1_6e(::apollo::canbus::Steering_rpt_1_6e* steering_rpt_1_6e);
  private:
  const ::apollo::canbus::Steering_rpt_1_6e& _internal_steering_rpt_1_6e() const;
  ::apollo::canbus::Steering_rpt_1_6e* _internal_mutable_steering_rpt_1_6e();
  public:

  // optional .apollo.canbus.Wheel_speed_rpt_7a wheel_speed_rpt_7a = 6;
  bool has_wheel_speed_rpt_7a() const;
  private:
  bool _internal_has_wheel_speed_rpt_7a() const;
  public:
  void clear_wheel_speed_rpt_7a();
  const ::apollo::canbus::Wheel_speed_rpt_7a& wheel_speed_rpt_7a() const;
  ::apollo::canbus::Wheel_speed_rpt_7a* release_wheel_speed_rpt_7a();
  ::apollo::canbus::Wheel_speed_rpt_7a* mutable_wheel_speed_rpt_7a();
  void set_allocated_wheel_speed_rpt_7a(::apollo::canbus::Wheel_speed_rpt_7a* wheel_speed_rpt_7a);
  private:
  const ::apollo::canbus::Wheel_speed_rpt_7a& _internal_wheel_speed_rpt_7a() const;
  ::apollo::canbus::Wheel_speed_rpt_7a* _internal_mutable_wheel_speed_rpt_7a();
  public:

  // optional .apollo.canbus.Date_time_rpt_83 date_time_rpt_83 = 7;
  bool has_date_time_rpt_83() const;
  private:
  bool _internal_has_date_time_rpt_83() const;
  public:
  void clear_date_time_rpt_83();
  const ::apollo::canbus::Date_time_rpt_83& date_time_rpt_83() const;
  ::apollo::canbus::Date_time_rpt_83* release_date_time_rpt_83();
  ::apollo::canbus::Date_time_rpt_83* mutable_date_time_rpt_83();
  void set_allocated_date_time_rpt_83(::apollo::canbus::Date_time_rpt_83* date_time_rpt_83);
  private:
  const ::apollo::canbus::Date_time_rpt_83& _internal_date_time_rpt_83() const;
  ::apollo::canbus::Date_time_rpt_83* _internal_mutable_date_time_rpt_83();
  public:

  // optional .apollo.canbus.Brake_motor_rpt_1_70 brake_motor_rpt_1_70 = 8;
  bool has_brake_motor_rpt_1_70() const;
  private:
  bool _internal_has_brake_motor_rpt_1_70() const;
  public:
  void clear_brake_motor_rpt_1_70();
  const ::apollo::canbus::Brake_motor_rpt_1_70& brake_motor_rpt_1_70() const;
  ::apollo::canbus::Brake_motor_rpt_1_70* release_brake_motor_rpt_1_70();
  ::apollo::canbus::Brake_motor_rpt_1_70* mutable_brake_motor_rpt_1_70();
  void set_allocated_brake_motor_rpt_1_70(::apollo::canbus::Brake_motor_rpt_1_70* brake_motor_rpt_1_70);
  private:
  const ::apollo::canbus::Brake_motor_rpt_1_70& _internal_brake_motor_rpt_1_70() const;
  ::apollo::canbus::Brake_motor_rpt_1_70* _internal_mutable_brake_motor_rpt_1_70();
  public:

  // optional .apollo.canbus.Headlight_rpt_77 headlight_rpt_77 = 9;
  bool has_headlight_rpt_77() const;
  private:
  bool _internal_has_headlight_rpt_77() const;
  public:
  void clear_headlight_rpt_77();
  const ::apollo::canbus::Headlight_rpt_77& headlight_rpt_77() const;
  ::apollo::canbus::Headlight_rpt_77* release_headlight_rpt_77();
  ::apollo::canbus::Headlight_rpt_77* mutable_headlight_rpt_77();
  void set_allocated_headlight_rpt_77(::apollo::canbus::Headlight_rpt_77* headlight_rpt_77);
  private:
  const ::apollo::canbus::Headlight_rpt_77& _internal_headlight_rpt_77() const;
  ::apollo::canbus::Headlight_rpt_77* _internal_mutable_headlight_rpt_77();
  public:

  // optional .apollo.canbus.Accel_rpt_68 accel_rpt_68 = 10;
  bool has_accel_rpt_68() const;
  private:
  bool _internal_has_accel_rpt_68() const;
  public:
  void clear_accel_rpt_68();
  const ::apollo::canbus::Accel_rpt_68& accel_rpt_68() const;
  ::apollo::canbus::Accel_rpt_68* release_accel_rpt_68();
  ::apollo::canbus::Accel_rpt_68* mutable_accel_rpt_68();
  void set_allocated_accel_rpt_68(::apollo::canbus::Accel_rpt_68* accel_rpt_68);
  private:
  const ::apollo::canbus::Accel_rpt_68& _internal_accel_rpt_68() const;
  ::apollo::canbus::Accel_rpt_68* _internal_mutable_accel_rpt_68();
  public:

  // optional .apollo.canbus.Steering_motor_rpt_3_75 steering_motor_rpt_3_75 = 11;
  bool has_steering_motor_rpt_3_75() const;
  private:
  bool _internal_has_steering_motor_rpt_3_75() const;
  public:
  void clear_steering_motor_rpt_3_75();
  const ::apollo::canbus::Steering_motor_rpt_3_75& steering_motor_rpt_3_75() const;
  ::apollo::canbus::Steering_motor_rpt_3_75* release_steering_motor_rpt_3_75();
  ::apollo::canbus::Steering_motor_rpt_3_75* mutable_steering_motor_rpt_3_75();
  void set_allocated_steering_motor_rpt_3_75(::apollo::canbus::Steering_motor_rpt_3_75* steering_motor_rpt_3_75);
  private:
  const ::apollo::canbus::Steering_motor_rpt_3_75& _internal_steering_motor_rpt_3_75() const;
  ::apollo::canbus::Steering_motor_rpt_3_75* _internal_mutable_steering_motor_rpt_3_75();
  public:

  // optional .apollo.canbus.Turn_cmd_63 turn_cmd_63 = 12;
  bool has_turn_cmd_63() const;
  private:
  bool _internal_has_turn_cmd_63() const;
  public:
  void clear_turn_cmd_63();
  const ::apollo::canbus::Turn_cmd_63& turn_cmd_63() const;
  ::apollo::canbus::Turn_cmd_63* release_turn_cmd_63();
  ::apollo::canbus::Turn_cmd_63* mutable_turn_cmd_63();
  void set_allocated_turn_cmd_63(::apollo::canbus::Turn_cmd_63* turn_cmd_63);
  private:
  const ::apollo::canbus::Turn_cmd_63& _internal_turn_cmd_63() const;
  ::apollo::canbus::Turn_cmd_63* _internal_mutable_turn_cmd_63();
  public:

  // optional .apollo.canbus.Turn_rpt_64 turn_rpt_64 = 13;
  bool has_turn_rpt_64() const;
  private:
  bool _internal_has_turn_rpt_64() const;
  public:
  void clear_turn_rpt_64();
  const ::apollo::canbus::Turn_rpt_64& turn_rpt_64() const;
  ::apollo::canbus::Turn_rpt_64* release_turn_rpt_64();
  ::apollo::canbus::Turn_rpt_64* mutable_turn_rpt_64();
  void set_allocated_turn_rpt_64(::apollo::canbus::Turn_rpt_64* turn_rpt_64);
  private:
  const ::apollo::canbus::Turn_rpt_64& _internal_turn_rpt_64() const;
  ::apollo::canbus::Turn_rpt_64* _internal_mutable_turn_rpt_64();
  public:

  // optional .apollo.canbus.Shift_cmd_65 shift_cmd_65 = 14;
  bool has_shift_cmd_65() const;
  private:
  bool _internal_has_shift_cmd_65() const;
  public:
  void clear_shift_cmd_65();
  const ::apollo::canbus::Shift_cmd_65& shift_cmd_65() const;
  ::apollo::canbus::Shift_cmd_65* release_shift_cmd_65();
  ::apollo::canbus::Shift_cmd_65* mutable_shift_cmd_65();
  void set_allocated_shift_cmd_65(::apollo::canbus::Shift_cmd_65* shift_cmd_65);
  private:
  const ::apollo::canbus::Shift_cmd_65& _internal_shift_cmd_65() const;
  ::apollo::canbus::Shift_cmd_65* _internal_mutable_shift_cmd_65();
  public:

  // optional .apollo.canbus.Shift_rpt_66 shift_rpt_66 = 15;
  bool has_shift_rpt_66() const;
  private:
  bool _internal_has_shift_rpt_66() const;
  public:
  void clear_shift_rpt_66();
  const ::apollo::canbus::Shift_rpt_66& shift_rpt_66() const;
  ::apollo::canbus::Shift_rpt_66* release_shift_rpt_66();
  ::apollo::canbus::Shift_rpt_66* mutable_shift_rpt_66();
  void set_allocated_shift_rpt_66(::apollo::canbus::Shift_rpt_66* shift_rpt_66);
  private:
  const ::apollo::canbus::Shift_rpt_66& _internal_shift_rpt_66() const;
  ::apollo::canbus::Shift_rpt_66* _internal_mutable_shift_rpt_66();
  public:

  // optional .apollo.canbus.Accel_cmd_67 accel_cmd_67 = 16;
  bool has_accel_cmd_67() const;
  private:
  bool _internal_has_accel_cmd_67() const;
  public:
  void clear_accel_cmd_67();
  const ::apollo::canbus::Accel_cmd_67& accel_cmd_67() const;
  ::apollo::canbus::Accel_cmd_67* release_accel_cmd_67();
  ::apollo::canbus::Accel_cmd_67* mutable_accel_cmd_67();
  void set_allocated_accel_cmd_67(::apollo::canbus::Accel_cmd_67* accel_cmd_67);
  private:
  const ::apollo::canbus::Accel_cmd_67& _internal_accel_cmd_67() const;
  ::apollo::canbus::Accel_cmd_67* _internal_mutable_accel_cmd_67();
  public:

  // optional .apollo.canbus.Lat_lon_heading_rpt_82 lat_lon_heading_rpt_82 = 17;
  bool has_lat_lon_heading_rpt_82() const;
  private:
  bool _internal_has_lat_lon_heading_rpt_82() const;
  public:
  void clear_lat_lon_heading_rpt_82();
  const ::apollo::canbus::Lat_lon_heading_rpt_82& lat_lon_heading_rpt_82() const;
  ::apollo::canbus::Lat_lon_heading_rpt_82* release_lat_lon_heading_rpt_82();
  ::apollo::canbus::Lat_lon_heading_rpt_82* mutable_lat_lon_heading_rpt_82();
  void set_allocated_lat_lon_heading_rpt_82(::apollo::canbus::Lat_lon_heading_rpt_82* lat_lon_heading_rpt_82);
  private:
  const ::apollo::canbus::Lat_lon_heading_rpt_82& _internal_lat_lon_heading_rpt_82() const;
  ::apollo::canbus::Lat_lon_heading_rpt_82* _internal_mutable_lat_lon_heading_rpt_82();
  public:

  // optional .apollo.canbus.Global_cmd_69 global_cmd_69 = 18;
  bool has_global_cmd_69() const;
  private:
  bool _internal_has_global_cmd_69() const;
  public:
  void clear_global_cmd_69();
  const ::apollo::canbus::Global_cmd_69& global_cmd_69() const;
  ::apollo::canbus::Global_cmd_69* release_global_cmd_69();
  ::apollo::canbus::Global_cmd_69* mutable_global_cmd_69();
  void set_allocated_global_cmd_69(::apollo::canbus::Global_cmd_69* global_cmd_69);
  private:
  const ::apollo::canbus::Global_cmd_69& _internal_global_cmd_69() const;
  ::apollo::canbus::Global_cmd_69* _internal_mutable_global_cmd_69();
  public:

  // optional .apollo.canbus.Parking_brake_status_rpt_80 parking_brake_status_rpt_80 = 19;
  bool has_parking_brake_status_rpt_80() const;
  private:
  bool _internal_has_parking_brake_status_rpt_80() const;
  public:
  void clear_parking_brake_status_rpt_80();
  const ::apollo::canbus::Parking_brake_status_rpt_80& parking_brake_status_rpt_80() const;
  ::apollo::canbus::Parking_brake_status_rpt_80* release_parking_brake_status_rpt_80();
  ::apollo::canbus::Parking_brake_status_rpt_80* mutable_parking_brake_status_rpt_80();
  void set_allocated_parking_brake_status_rpt_80(::apollo::canbus::Parking_brake_status_rpt_80* parking_brake_status_rpt_80);
  private:
  const ::apollo::canbus::Parking_brake_status_rpt_80& _internal_parking_brake_status_rpt_80() const;
  ::apollo::canbus::Parking_brake_status_rpt_80* _internal_mutable_parking_brake_status_rpt_80();
  public:

  // optional .apollo.canbus.Yaw_rate_rpt_81 yaw_rate_rpt_81 = 20;
  bool has_yaw_rate_rpt_81() const;
  private:
  bool _internal_has_yaw_rate_rpt_81() const;
  public:
  void clear_yaw_rate_rpt_81();
  const ::apollo::canbus::Yaw_rate_rpt_81& yaw_rate_rpt_81() const;
  ::apollo::canbus::Yaw_rate_rpt_81* release_yaw_rate_rpt_81();
  ::apollo::canbus::Yaw_rate_rpt_81* mutable_yaw_rate_rpt_81();
  void set_allocated_yaw_rate_rpt_81(::apollo::canbus::Yaw_rate_rpt_81* yaw_rate_rpt_81);
  private:
  const ::apollo::canbus::Yaw_rate_rpt_81& _internal_yaw_rate_rpt_81() const;
  ::apollo::canbus::Yaw_rate_rpt_81* _internal_mutable_yaw_rate_rpt_81();
  public:

  // optional .apollo.canbus.Horn_rpt_79 horn_rpt_79 = 21;
  bool has_horn_rpt_79() const;
  private:
  bool _internal_has_horn_rpt_79() const;
  public:
  void clear_horn_rpt_79();
  const ::apollo::canbus::Horn_rpt_79& horn_rpt_79() const;
  ::apollo::canbus::Horn_rpt_79* release_horn_rpt_79();
  ::apollo::canbus::Horn_rpt_79* mutable_horn_rpt_79();
  void set_allocated_horn_rpt_79(::apollo::canbus::Horn_rpt_79* horn_rpt_79);
  private:
  const ::apollo::canbus::Horn_rpt_79& _internal_horn_rpt_79() const;
  ::apollo::canbus::Horn_rpt_79* _internal_mutable_horn_rpt_79();
  public:

  // optional .apollo.canbus.Horn_cmd_78 horn_cmd_78 = 22;
  bool has_horn_cmd_78() const;
  private:
  bool _internal_has_horn_cmd_78() const;
  public:
  void clear_horn_cmd_78();
  const ::apollo::canbus::Horn_cmd_78& horn_cmd_78() const;
  ::apollo::canbus::Horn_cmd_78* release_horn_cmd_78();
  ::apollo::canbus::Horn_cmd_78* mutable_horn_cmd_78();
  void set_allocated_horn_cmd_78(::apollo::canbus::Horn_cmd_78* horn_cmd_78);
  private:
  const ::apollo::canbus::Horn_cmd_78& _internal_horn_cmd_78() const;
  ::apollo::canbus::Horn_cmd_78* _internal_mutable_horn_cmd_78();
  public:

  // optional .apollo.canbus.Wiper_rpt_91 wiper_rpt_91 = 23;
  bool has_wiper_rpt_91() const;
  private:
  bool _internal_has_wiper_rpt_91() const;
  public:
  void clear_wiper_rpt_91();
  const ::apollo::canbus::Wiper_rpt_91& wiper_rpt_91() const;
  ::apollo::canbus::Wiper_rpt_91* release_wiper_rpt_91();
  ::apollo::canbus::Wiper_rpt_91* mutable_wiper_rpt_91();
  void set_allocated_wiper_rpt_91(::apollo::canbus::Wiper_rpt_91* wiper_rpt_91);
  private:
  const ::apollo::canbus::Wiper_rpt_91& _internal_wiper_rpt_91() const;
  ::apollo::canbus::Wiper_rpt_91* _internal_mutable_wiper_rpt_91();
  public:

  // optional .apollo.canbus.Vehicle_speed_rpt_6f vehicle_speed_rpt_6f = 24;
  bool has_vehicle_speed_rpt_6f() const;
  private:
  bool _internal_has_vehicle_speed_rpt_6f() const;
  public:
  void clear_vehicle_speed_rpt_6f();
  const ::apollo::canbus::Vehicle_speed_rpt_6f& vehicle_speed_rpt_6f() const;
  ::apollo::canbus::Vehicle_speed_rpt_6f* release_vehicle_speed_rpt_6f();
  ::apollo::canbus::Vehicle_speed_rpt_6f* mutable_vehicle_speed_rpt_6f();
  void set_allocated_vehicle_speed_rpt_6f(::apollo::canbus::Vehicle_speed_rpt_6f* vehicle_speed_rpt_6f);
  private:
  const ::apollo::canbus::Vehicle_speed_rpt_6f& _internal_vehicle_speed_rpt_6f() const;
  ::apollo::canbus::Vehicle_speed_rpt_6f* _internal_mutable_vehicle_speed_rpt_6f();
  public:

  // optional .apollo.canbus.Headlight_cmd_76 headlight_cmd_76 = 25;
  bool has_headlight_cmd_76() const;
  private:
  bool _internal_has_headlight_cmd_76() const;
  public:
  void clear_headlight_cmd_76();
  const ::apollo::canbus::Headlight_cmd_76& headlight_cmd_76() const;
  ::apollo::canbus::Headlight_cmd_76* release_headlight_cmd_76();
  ::apollo::canbus::Headlight_cmd_76* mutable_headlight_cmd_76();
  void set_allocated_headlight_cmd_76(::apollo::canbus::Headlight_cmd_76* headlight_cmd_76);
  private:
  const ::apollo::canbus::Headlight_cmd_76& _internal_headlight_cmd_76() const;
  ::apollo::canbus::Headlight_cmd_76* _internal_mutable_headlight_cmd_76();
  public:

  // optional .apollo.canbus.Steering_motor_rpt_2_74 steering_motor_rpt_2_74 = 26;
  bool has_steering_motor_rpt_2_74() const;
  private:
  bool _internal_has_steering_motor_rpt_2_74() const;
  public:
  void clear_steering_motor_rpt_2_74();
  const ::apollo::canbus::Steering_motor_rpt_2_74& steering_motor_rpt_2_74() const;
  ::apollo::canbus::Steering_motor_rpt_2_74* release_steering_motor_rpt_2_74();
  ::apollo::canbus::Steering_motor_rpt_2_74* mutable_steering_motor_rpt_2_74();
  void set_allocated_steering_motor_rpt_2_74(::apollo::canbus::Steering_motor_rpt_2_74* steering_motor_rpt_2_74);
  private:
  const ::apollo::canbus::Steering_motor_rpt_2_74& _internal_steering_motor_rpt_2_74() const;
  ::apollo::canbus::Steering_motor_rpt_2_74* _internal_mutable_steering_motor_rpt_2_74();
  public:

  // optional .apollo.canbus.Brake_motor_rpt_2_71 brake_motor_rpt_2_71 = 27;
  bool has_brake_motor_rpt_2_71() const;
  private:
  bool _internal_has_brake_motor_rpt_2_71() const;
  public:
  void clear_brake_motor_rpt_2_71();
  const ::apollo::canbus::Brake_motor_rpt_2_71& brake_motor_rpt_2_71() const;
  ::apollo::canbus::Brake_motor_rpt_2_71* release_brake_motor_rpt_2_71();
  ::apollo::canbus::Brake_motor_rpt_2_71* mutable_brake_motor_rpt_2_71();
  void set_allocated_brake_motor_rpt_2_71(::apollo::canbus::Brake_motor_rpt_2_71* brake_motor_rpt_2_71);
  private:
  const ::apollo::canbus::Brake_motor_rpt_2_71& _internal_brake_motor_rpt_2_71() const;
  ::apollo::canbus::Brake_motor_rpt_2_71* _internal_mutable_brake_motor_rpt_2_71();
  public:

  // optional .apollo.canbus.Steering_motor_rpt_1_73 steering_motor_rpt_1_73 = 28;
  bool has_steering_motor_rpt_1_73() const;
  private:
  bool _internal_has_steering_motor_rpt_1_73() const;
  public:
  void clear_steering_motor_rpt_1_73();
  const ::apollo::canbus::Steering_motor_rpt_1_73& steering_motor_rpt_1_73() const;
  ::apollo::canbus::Steering_motor_rpt_1_73* release_steering_motor_rpt_1_73();
  ::apollo::canbus::Steering_motor_rpt_1_73* mutable_steering_motor_rpt_1_73();
  void set_allocated_steering_motor_rpt_1_73(::apollo::canbus::Steering_motor_rpt_1_73* steering_motor_rpt_1_73);
  private:
  const ::apollo::canbus::Steering_motor_rpt_1_73& _internal_steering_motor_rpt_1_73() const;
  ::apollo::canbus::Steering_motor_rpt_1_73* _internal_mutable_steering_motor_rpt_1_73();
  public:

  // optional .apollo.canbus.Wiper_cmd_90 wiper_cmd_90 = 29;
  bool has_wiper_cmd_90() const;
  private:
  bool _internal_has_wiper_cmd_90() const;
  public:
  void clear_wiper_cmd_90();
  const ::apollo::canbus::Wiper_cmd_90& wiper_cmd_90() const;
  ::apollo::canbus::Wiper_cmd_90* release_wiper_cmd_90();
  ::apollo::canbus::Wiper_cmd_90* mutable_wiper_cmd_90();
  void set_allocated_wiper_cmd_90(::apollo::canbus::Wiper_cmd_90* wiper_cmd_90);
  private:
  const ::apollo::canbus::Wiper_cmd_90& _internal_wiper_cmd_90() const;
  ::apollo::canbus::Wiper_cmd_90* _internal_mutable_wiper_cmd_90();
  public:

  // optional .apollo.canbus.Brake_motor_rpt_3_72 brake_motor_rpt_3_72 = 30;
  bool has_brake_motor_rpt_3_72() const;
  private:
  bool _internal_has_brake_motor_rpt_3_72() const;
  public:
  void clear_brake_motor_rpt_3_72();
  const ::apollo::canbus::Brake_motor_rpt_3_72& brake_motor_rpt_3_72() const;
  ::apollo::canbus::Brake_motor_rpt_3_72* release_brake_motor_rpt_3_72();
  ::apollo::canbus::Brake_motor_rpt_3_72* mutable_brake_motor_rpt_3_72();
  void set_allocated_brake_motor_rpt_3_72(::apollo::canbus::Brake_motor_rpt_3_72* brake_motor_rpt_3_72);
  private:
  const ::apollo::canbus::Brake_motor_rpt_3_72& _internal_brake_motor_rpt_3_72() const;
  ::apollo::canbus::Brake_motor_rpt_3_72* _internal_mutable_brake_motor_rpt_3_72();
  public:

  // @@protoc_insertion_point(class_scope:apollo.canbus.Gem)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::canbus::Global_rpt_6a* global_rpt_6a_;
  ::apollo::canbus::Brake_cmd_6b* brake_cmd_6b_;
  ::apollo::canbus::Brake_rpt_6c* brake_rpt_6c_;
  ::apollo::canbus::Steering_cmd_6d* steering_cmd_6d_;
  ::apollo::canbus::Steering_rpt_1_6e* steering_rpt_1_6e_;
  ::apollo::canbus::Wheel_speed_rpt_7a* wheel_speed_rpt_7a_;
  ::apollo::canbus::Date_time_rpt_83* date_time_rpt_83_;
  ::apollo::canbus::Brake_motor_rpt_1_70* brake_motor_rpt_1_70_;
  ::apollo::canbus::Headlight_rpt_77* headlight_rpt_77_;
  ::apollo::canbus::Accel_rpt_68* accel_rpt_68_;
  ::apollo::canbus::Steering_motor_rpt_3_75* steering_motor_rpt_3_75_;
  ::apollo::canbus::Turn_cmd_63* turn_cmd_63_;
  ::apollo::canbus::Turn_rpt_64* turn_rpt_64_;
  ::apollo::canbus::Shift_cmd_65* shift_cmd_65_;
  ::apollo::canbus::Shift_rpt_66* shift_rpt_66_;
  ::apollo::canbus::Accel_cmd_67* accel_cmd_67_;
  ::apollo::canbus::Lat_lon_heading_rpt_82* lat_lon_heading_rpt_82_;
  ::apollo::canbus::Global_cmd_69* global_cmd_69_;
  ::apollo::canbus::Parking_brake_status_rpt_80* parking_brake_status_rpt_80_;
  ::apollo::canbus::Yaw_rate_rpt_81* yaw_rate_rpt_81_;
  ::apollo::canbus::Horn_rpt_79* horn_rpt_79_;
  ::apollo::canbus::Horn_cmd_78* horn_cmd_78_;
  ::apollo::canbus::Wiper_rpt_91* wiper_rpt_91_;
  ::apollo::canbus::Vehicle_speed_rpt_6f* vehicle_speed_rpt_6f_;
  ::apollo::canbus::Headlight_cmd_76* headlight_cmd_76_;
  ::apollo::canbus::Steering_motor_rpt_2_74* steering_motor_rpt_2_74_;
  ::apollo::canbus::Brake_motor_rpt_2_71* brake_motor_rpt_2_71_;
  ::apollo::canbus::Steering_motor_rpt_1_73* steering_motor_rpt_1_73_;
  ::apollo::canbus::Wiper_cmd_90* wiper_cmd_90_;
  ::apollo::canbus::Brake_motor_rpt_3_72* brake_motor_rpt_3_72_;
  friend struct ::TableStruct_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ChassisDetail

// optional .apollo.canbus.ChassisDetail.Type car_type = 1;
inline bool ChassisDetail::_internal_has_car_type() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool ChassisDetail::has_car_type() const {
  return _internal_has_car_type();
}
inline void ChassisDetail::clear_car_type() {
  car_type_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::apollo::canbus::ChassisDetail_Type ChassisDetail::_internal_car_type() const {
  return static_cast< ::apollo::canbus::ChassisDetail_Type >(car_type_);
}
inline ::apollo::canbus::ChassisDetail_Type ChassisDetail::car_type() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.car_type)
  return _internal_car_type();
}
inline void ChassisDetail::_internal_set_car_type(::apollo::canbus::ChassisDetail_Type value) {
  assert(::apollo::canbus::ChassisDetail_Type_IsValid(value));
  _has_bits_[0] |= 0x01000000u;
  car_type_ = value;
}
inline void ChassisDetail::set_car_type(::apollo::canbus::ChassisDetail_Type value) {
  _internal_set_car_type(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.ChassisDetail.car_type)
}

// optional .apollo.canbus.BasicInfo basic = 2;
inline bool ChassisDetail::_internal_has_basic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || basic_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_basic() const {
  return _internal_has_basic();
}
inline void ChassisDetail::clear_basic() {
  if (basic_ != nullptr) basic_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::canbus::BasicInfo& ChassisDetail::_internal_basic() const {
  const ::apollo::canbus::BasicInfo* p = basic_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::BasicInfo*>(
      &::apollo::canbus::_BasicInfo_default_instance_);
}
inline const ::apollo::canbus::BasicInfo& ChassisDetail::basic() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.basic)
  return _internal_basic();
}
inline ::apollo::canbus::BasicInfo* ChassisDetail::release_basic() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.basic)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::canbus::BasicInfo* temp = basic_;
  basic_ = nullptr;
  return temp;
}
inline ::apollo::canbus::BasicInfo* ChassisDetail::_internal_mutable_basic() {
  _has_bits_[0] |= 0x00000001u;
  if (basic_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::BasicInfo>(GetArenaNoVirtual());
    basic_ = p;
  }
  return basic_;
}
inline ::apollo::canbus::BasicInfo* ChassisDetail::mutable_basic() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.basic)
  return _internal_mutable_basic();
}
inline void ChassisDetail::set_allocated_basic(::apollo::canbus::BasicInfo* basic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete basic_;
  }
  if (basic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      basic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basic, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  basic_ = basic;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.basic)
}

// optional .apollo.canbus.Safety safety = 3;
inline bool ChassisDetail::_internal_has_safety() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || safety_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_safety() const {
  return _internal_has_safety();
}
inline void ChassisDetail::clear_safety() {
  if (safety_ != nullptr) safety_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::canbus::Safety& ChassisDetail::_internal_safety() const {
  const ::apollo::canbus::Safety* p = safety_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Safety*>(
      &::apollo::canbus::_Safety_default_instance_);
}
inline const ::apollo::canbus::Safety& ChassisDetail::safety() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.safety)
  return _internal_safety();
}
inline ::apollo::canbus::Safety* ChassisDetail::release_safety() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.safety)
  _has_bits_[0] &= ~0x00000002u;
  ::apollo::canbus::Safety* temp = safety_;
  safety_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Safety* ChassisDetail::_internal_mutable_safety() {
  _has_bits_[0] |= 0x00000002u;
  if (safety_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Safety>(GetArenaNoVirtual());
    safety_ = p;
  }
  return safety_;
}
inline ::apollo::canbus::Safety* ChassisDetail::mutable_safety() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.safety)
  return _internal_mutable_safety();
}
inline void ChassisDetail::set_allocated_safety(::apollo::canbus::Safety* safety) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete safety_;
  }
  if (safety) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      safety = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, safety, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  safety_ = safety;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.safety)
}

// optional .apollo.canbus.Gear gear = 4;
inline bool ChassisDetail::_internal_has_gear() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || gear_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_gear() const {
  return _internal_has_gear();
}
inline void ChassisDetail::clear_gear() {
  if (gear_ != nullptr) gear_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::canbus::Gear& ChassisDetail::_internal_gear() const {
  const ::apollo::canbus::Gear* p = gear_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Gear*>(
      &::apollo::canbus::_Gear_default_instance_);
}
inline const ::apollo::canbus::Gear& ChassisDetail::gear() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.gear)
  return _internal_gear();
}
inline ::apollo::canbus::Gear* ChassisDetail::release_gear() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.gear)
  _has_bits_[0] &= ~0x00000004u;
  ::apollo::canbus::Gear* temp = gear_;
  gear_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Gear* ChassisDetail::_internal_mutable_gear() {
  _has_bits_[0] |= 0x00000004u;
  if (gear_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Gear>(GetArenaNoVirtual());
    gear_ = p;
  }
  return gear_;
}
inline ::apollo::canbus::Gear* ChassisDetail::mutable_gear() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.gear)
  return _internal_mutable_gear();
}
inline void ChassisDetail::set_allocated_gear(::apollo::canbus::Gear* gear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gear_;
  }
  if (gear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gear, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  gear_ = gear;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.gear)
}

// optional .apollo.canbus.Ems ems = 5;
inline bool ChassisDetail::_internal_has_ems() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || ems_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_ems() const {
  return _internal_has_ems();
}
inline void ChassisDetail::clear_ems() {
  if (ems_ != nullptr) ems_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::canbus::Ems& ChassisDetail::_internal_ems() const {
  const ::apollo::canbus::Ems* p = ems_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Ems*>(
      &::apollo::canbus::_Ems_default_instance_);
}
inline const ::apollo::canbus::Ems& ChassisDetail::ems() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.ems)
  return _internal_ems();
}
inline ::apollo::canbus::Ems* ChassisDetail::release_ems() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.ems)
  _has_bits_[0] &= ~0x00000008u;
  ::apollo::canbus::Ems* temp = ems_;
  ems_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Ems* ChassisDetail::_internal_mutable_ems() {
  _has_bits_[0] |= 0x00000008u;
  if (ems_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Ems>(GetArenaNoVirtual());
    ems_ = p;
  }
  return ems_;
}
inline ::apollo::canbus::Ems* ChassisDetail::mutable_ems() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.ems)
  return _internal_mutable_ems();
}
inline void ChassisDetail::set_allocated_ems(::apollo::canbus::Ems* ems) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ems_;
  }
  if (ems) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ems = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ems, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ems_ = ems;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.ems)
}

// optional .apollo.canbus.Esp esp = 6;
inline bool ChassisDetail::_internal_has_esp() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || esp_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_esp() const {
  return _internal_has_esp();
}
inline void ChassisDetail::clear_esp() {
  if (esp_ != nullptr) esp_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::apollo::canbus::Esp& ChassisDetail::_internal_esp() const {
  const ::apollo::canbus::Esp* p = esp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Esp*>(
      &::apollo::canbus::_Esp_default_instance_);
}
inline const ::apollo::canbus::Esp& ChassisDetail::esp() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.esp)
  return _internal_esp();
}
inline ::apollo::canbus::Esp* ChassisDetail::release_esp() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.esp)
  _has_bits_[0] &= ~0x00000010u;
  ::apollo::canbus::Esp* temp = esp_;
  esp_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Esp* ChassisDetail::_internal_mutable_esp() {
  _has_bits_[0] |= 0x00000010u;
  if (esp_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Esp>(GetArenaNoVirtual());
    esp_ = p;
  }
  return esp_;
}
inline ::apollo::canbus::Esp* ChassisDetail::mutable_esp() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.esp)
  return _internal_mutable_esp();
}
inline void ChassisDetail::set_allocated_esp(::apollo::canbus::Esp* esp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete esp_;
  }
  if (esp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      esp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  esp_ = esp;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.esp)
}

// optional .apollo.canbus.Gas gas = 7;
inline bool ChassisDetail::_internal_has_gas() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || gas_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_gas() const {
  return _internal_has_gas();
}
inline void ChassisDetail::clear_gas() {
  if (gas_ != nullptr) gas_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::apollo::canbus::Gas& ChassisDetail::_internal_gas() const {
  const ::apollo::canbus::Gas* p = gas_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Gas*>(
      &::apollo::canbus::_Gas_default_instance_);
}
inline const ::apollo::canbus::Gas& ChassisDetail::gas() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.gas)
  return _internal_gas();
}
inline ::apollo::canbus::Gas* ChassisDetail::release_gas() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.gas)
  _has_bits_[0] &= ~0x00000020u;
  ::apollo::canbus::Gas* temp = gas_;
  gas_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Gas* ChassisDetail::_internal_mutable_gas() {
  _has_bits_[0] |= 0x00000020u;
  if (gas_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Gas>(GetArenaNoVirtual());
    gas_ = p;
  }
  return gas_;
}
inline ::apollo::canbus::Gas* ChassisDetail::mutable_gas() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.gas)
  return _internal_mutable_gas();
}
inline void ChassisDetail::set_allocated_gas(::apollo::canbus::Gas* gas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gas_;
  }
  if (gas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gas, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  gas_ = gas;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.gas)
}

// optional .apollo.canbus.Epb epb = 8;
inline bool ChassisDetail::_internal_has_epb() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || epb_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_epb() const {
  return _internal_has_epb();
}
inline void ChassisDetail::clear_epb() {
  if (epb_ != nullptr) epb_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::apollo::canbus::Epb& ChassisDetail::_internal_epb() const {
  const ::apollo::canbus::Epb* p = epb_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Epb*>(
      &::apollo::canbus::_Epb_default_instance_);
}
inline const ::apollo::canbus::Epb& ChassisDetail::epb() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.epb)
  return _internal_epb();
}
inline ::apollo::canbus::Epb* ChassisDetail::release_epb() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.epb)
  _has_bits_[0] &= ~0x00000040u;
  ::apollo::canbus::Epb* temp = epb_;
  epb_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Epb* ChassisDetail::_internal_mutable_epb() {
  _has_bits_[0] |= 0x00000040u;
  if (epb_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Epb>(GetArenaNoVirtual());
    epb_ = p;
  }
  return epb_;
}
inline ::apollo::canbus::Epb* ChassisDetail::mutable_epb() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.epb)
  return _internal_mutable_epb();
}
inline void ChassisDetail::set_allocated_epb(::apollo::canbus::Epb* epb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete epb_;
  }
  if (epb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      epb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, epb, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  epb_ = epb;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.epb)
}

// optional .apollo.canbus.Brake brake = 9;
inline bool ChassisDetail::_internal_has_brake() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || brake_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_brake() const {
  return _internal_has_brake();
}
inline void ChassisDetail::clear_brake() {
  if (brake_ != nullptr) brake_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::apollo::canbus::Brake& ChassisDetail::_internal_brake() const {
  const ::apollo::canbus::Brake* p = brake_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Brake*>(
      &::apollo::canbus::_Brake_default_instance_);
}
inline const ::apollo::canbus::Brake& ChassisDetail::brake() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.brake)
  return _internal_brake();
}
inline ::apollo::canbus::Brake* ChassisDetail::release_brake() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.brake)
  _has_bits_[0] &= ~0x00000080u;
  ::apollo::canbus::Brake* temp = brake_;
  brake_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Brake* ChassisDetail::_internal_mutable_brake() {
  _has_bits_[0] |= 0x00000080u;
  if (brake_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Brake>(GetArenaNoVirtual());
    brake_ = p;
  }
  return brake_;
}
inline ::apollo::canbus::Brake* ChassisDetail::mutable_brake() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.brake)
  return _internal_mutable_brake();
}
inline void ChassisDetail::set_allocated_brake(::apollo::canbus::Brake* brake) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete brake_;
  }
  if (brake) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      brake = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brake, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  brake_ = brake;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.brake)
}

// optional .apollo.canbus.Deceleration deceleration = 10;
inline bool ChassisDetail::_internal_has_deceleration() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || deceleration_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_deceleration() const {
  return _internal_has_deceleration();
}
inline void ChassisDetail::clear_deceleration() {
  if (deceleration_ != nullptr) deceleration_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::apollo::canbus::Deceleration& ChassisDetail::_internal_deceleration() const {
  const ::apollo::canbus::Deceleration* p = deceleration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Deceleration*>(
      &::apollo::canbus::_Deceleration_default_instance_);
}
inline const ::apollo::canbus::Deceleration& ChassisDetail::deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.deceleration)
  return _internal_deceleration();
}
inline ::apollo::canbus::Deceleration* ChassisDetail::release_deceleration() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.deceleration)
  _has_bits_[0] &= ~0x00000100u;
  ::apollo::canbus::Deceleration* temp = deceleration_;
  deceleration_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Deceleration* ChassisDetail::_internal_mutable_deceleration() {
  _has_bits_[0] |= 0x00000100u;
  if (deceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Deceleration>(GetArenaNoVirtual());
    deceleration_ = p;
  }
  return deceleration_;
}
inline ::apollo::canbus::Deceleration* ChassisDetail::mutable_deceleration() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.deceleration)
  return _internal_mutable_deceleration();
}
inline void ChassisDetail::set_allocated_deceleration(::apollo::canbus::Deceleration* deceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete deceleration_;
  }
  if (deceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      deceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deceleration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  deceleration_ = deceleration;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.deceleration)
}

// optional .apollo.canbus.VehicleSpd vehicle_spd = 11;
inline bool ChassisDetail::_internal_has_vehicle_spd() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || vehicle_spd_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_vehicle_spd() const {
  return _internal_has_vehicle_spd();
}
inline void ChassisDetail::clear_vehicle_spd() {
  if (vehicle_spd_ != nullptr) vehicle_spd_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::apollo::canbus::VehicleSpd& ChassisDetail::_internal_vehicle_spd() const {
  const ::apollo::canbus::VehicleSpd* p = vehicle_spd_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::VehicleSpd*>(
      &::apollo::canbus::_VehicleSpd_default_instance_);
}
inline const ::apollo::canbus::VehicleSpd& ChassisDetail::vehicle_spd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.vehicle_spd)
  return _internal_vehicle_spd();
}
inline ::apollo::canbus::VehicleSpd* ChassisDetail::release_vehicle_spd() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.vehicle_spd)
  _has_bits_[0] &= ~0x00000200u;
  ::apollo::canbus::VehicleSpd* temp = vehicle_spd_;
  vehicle_spd_ = nullptr;
  return temp;
}
inline ::apollo::canbus::VehicleSpd* ChassisDetail::_internal_mutable_vehicle_spd() {
  _has_bits_[0] |= 0x00000200u;
  if (vehicle_spd_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::VehicleSpd>(GetArenaNoVirtual());
    vehicle_spd_ = p;
  }
  return vehicle_spd_;
}
inline ::apollo::canbus::VehicleSpd* ChassisDetail::mutable_vehicle_spd() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.vehicle_spd)
  return _internal_mutable_vehicle_spd();
}
inline void ChassisDetail::set_allocated_vehicle_spd(::apollo::canbus::VehicleSpd* vehicle_spd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vehicle_spd_;
  }
  if (vehicle_spd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vehicle_spd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle_spd, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  vehicle_spd_ = vehicle_spd;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.vehicle_spd)
}

// optional .apollo.canbus.Eps eps = 12;
inline bool ChassisDetail::_internal_has_eps() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || eps_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_eps() const {
  return _internal_has_eps();
}
inline void ChassisDetail::clear_eps() {
  if (eps_ != nullptr) eps_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::apollo::canbus::Eps& ChassisDetail::_internal_eps() const {
  const ::apollo::canbus::Eps* p = eps_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Eps*>(
      &::apollo::canbus::_Eps_default_instance_);
}
inline const ::apollo::canbus::Eps& ChassisDetail::eps() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.eps)
  return _internal_eps();
}
inline ::apollo::canbus::Eps* ChassisDetail::release_eps() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.eps)
  _has_bits_[0] &= ~0x00000400u;
  ::apollo::canbus::Eps* temp = eps_;
  eps_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Eps* ChassisDetail::_internal_mutable_eps() {
  _has_bits_[0] |= 0x00000400u;
  if (eps_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Eps>(GetArenaNoVirtual());
    eps_ = p;
  }
  return eps_;
}
inline ::apollo::canbus::Eps* ChassisDetail::mutable_eps() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.eps)
  return _internal_mutable_eps();
}
inline void ChassisDetail::set_allocated_eps(::apollo::canbus::Eps* eps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete eps_;
  }
  if (eps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eps, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  eps_ = eps;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.eps)
}

// optional .apollo.canbus.Light light = 13;
inline bool ChassisDetail::_internal_has_light() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || light_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_light() const {
  return _internal_has_light();
}
inline void ChassisDetail::clear_light() {
  if (light_ != nullptr) light_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::apollo::canbus::Light& ChassisDetail::_internal_light() const {
  const ::apollo::canbus::Light* p = light_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Light*>(
      &::apollo::canbus::_Light_default_instance_);
}
inline const ::apollo::canbus::Light& ChassisDetail::light() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.light)
  return _internal_light();
}
inline ::apollo::canbus::Light* ChassisDetail::release_light() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.light)
  _has_bits_[0] &= ~0x00000800u;
  ::apollo::canbus::Light* temp = light_;
  light_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Light* ChassisDetail::_internal_mutable_light() {
  _has_bits_[0] |= 0x00000800u;
  if (light_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Light>(GetArenaNoVirtual());
    light_ = p;
  }
  return light_;
}
inline ::apollo::canbus::Light* ChassisDetail::mutable_light() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.light)
  return _internal_mutable_light();
}
inline void ChassisDetail::set_allocated_light(::apollo::canbus::Light* light) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete light_;
  }
  if (light) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      light = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, light, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  light_ = light;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.light)
}

// optional .apollo.canbus.Battery battery = 14;
inline bool ChassisDetail::_internal_has_battery() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || battery_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_battery() const {
  return _internal_has_battery();
}
inline void ChassisDetail::clear_battery() {
  if (battery_ != nullptr) battery_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::apollo::canbus::Battery& ChassisDetail::_internal_battery() const {
  const ::apollo::canbus::Battery* p = battery_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Battery*>(
      &::apollo::canbus::_Battery_default_instance_);
}
inline const ::apollo::canbus::Battery& ChassisDetail::battery() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.battery)
  return _internal_battery();
}
inline ::apollo::canbus::Battery* ChassisDetail::release_battery() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.battery)
  _has_bits_[0] &= ~0x00001000u;
  ::apollo::canbus::Battery* temp = battery_;
  battery_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Battery* ChassisDetail::_internal_mutable_battery() {
  _has_bits_[0] |= 0x00001000u;
  if (battery_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Battery>(GetArenaNoVirtual());
    battery_ = p;
  }
  return battery_;
}
inline ::apollo::canbus::Battery* ChassisDetail::mutable_battery() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.battery)
  return _internal_mutable_battery();
}
inline void ChassisDetail::set_allocated_battery(::apollo::canbus::Battery* battery) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete battery_;
  }
  if (battery) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      battery = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, battery, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  battery_ = battery;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.battery)
}

// optional .apollo.canbus.CheckResponseSignal check_response = 15;
inline bool ChassisDetail::_internal_has_check_response() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || check_response_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_check_response() const {
  return _internal_has_check_response();
}
inline void ChassisDetail::clear_check_response() {
  if (check_response_ != nullptr) check_response_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::apollo::canbus::CheckResponseSignal& ChassisDetail::_internal_check_response() const {
  const ::apollo::canbus::CheckResponseSignal* p = check_response_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::CheckResponseSignal*>(
      &::apollo::canbus::_CheckResponseSignal_default_instance_);
}
inline const ::apollo::canbus::CheckResponseSignal& ChassisDetail::check_response() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.check_response)
  return _internal_check_response();
}
inline ::apollo::canbus::CheckResponseSignal* ChassisDetail::release_check_response() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.check_response)
  _has_bits_[0] &= ~0x00002000u;
  ::apollo::canbus::CheckResponseSignal* temp = check_response_;
  check_response_ = nullptr;
  return temp;
}
inline ::apollo::canbus::CheckResponseSignal* ChassisDetail::_internal_mutable_check_response() {
  _has_bits_[0] |= 0x00002000u;
  if (check_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::CheckResponseSignal>(GetArenaNoVirtual());
    check_response_ = p;
  }
  return check_response_;
}
inline ::apollo::canbus::CheckResponseSignal* ChassisDetail::mutable_check_response() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.check_response)
  return _internal_mutable_check_response();
}
inline void ChassisDetail::set_allocated_check_response(::apollo::canbus::CheckResponseSignal* check_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete check_response_;
  }
  if (check_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      check_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_response, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  check_response_ = check_response;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.check_response)
}

// optional .apollo.canbus.License license = 16 [deprecated = true];
inline bool ChassisDetail::_internal_has_license() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || license_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_license() const {
  return _internal_has_license();
}
inline const ::apollo::canbus::License& ChassisDetail::_internal_license() const {
  const ::apollo::canbus::License* p = license_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::License*>(
      &::apollo::canbus::_License_default_instance_);
}
inline const ::apollo::canbus::License& ChassisDetail::license() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.license)
  return _internal_license();
}
inline ::apollo::canbus::License* ChassisDetail::release_license() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.license)
  _has_bits_[0] &= ~0x00004000u;
  ::apollo::canbus::License* temp = license_;
  license_ = nullptr;
  return temp;
}
inline ::apollo::canbus::License* ChassisDetail::_internal_mutable_license() {
  _has_bits_[0] |= 0x00004000u;
  if (license_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::License>(GetArenaNoVirtual());
    license_ = p;
  }
  return license_;
}
inline ::apollo::canbus::License* ChassisDetail::mutable_license() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.license)
  return _internal_mutable_license();
}
inline void ChassisDetail::set_allocated_license(::apollo::canbus::License* license) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(license_);
  }
  if (license) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      license = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, license, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  license_ = license;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.license)
}

// optional .apollo.canbus.Surround surround = 17;
inline bool ChassisDetail::_internal_has_surround() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || surround_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_surround() const {
  return _internal_has_surround();
}
inline const ::apollo::canbus::Surround& ChassisDetail::_internal_surround() const {
  const ::apollo::canbus::Surround* p = surround_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Surround*>(
      &::apollo::canbus::_Surround_default_instance_);
}
inline const ::apollo::canbus::Surround& ChassisDetail::surround() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.surround)
  return _internal_surround();
}
inline ::apollo::canbus::Surround* ChassisDetail::release_surround() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.surround)
  _has_bits_[0] &= ~0x00008000u;
  ::apollo::canbus::Surround* temp = surround_;
  surround_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Surround* ChassisDetail::_internal_mutable_surround() {
  _has_bits_[0] |= 0x00008000u;
  if (surround_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Surround>(GetArenaNoVirtual());
    surround_ = p;
  }
  return surround_;
}
inline ::apollo::canbus::Surround* ChassisDetail::mutable_surround() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.surround)
  return _internal_mutable_surround();
}
inline void ChassisDetail::set_allocated_surround(::apollo::canbus::Surround* surround) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(surround_);
  }
  if (surround) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      surround = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, surround, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  surround_ = surround;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.surround)
}

// optional .apollo.canbus.Gem gem = 18;
inline bool ChassisDetail::_internal_has_gem() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || gem_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_gem() const {
  return _internal_has_gem();
}
inline void ChassisDetail::clear_gem() {
  if (gem_ != nullptr) gem_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::apollo::canbus::Gem& ChassisDetail::_internal_gem() const {
  const ::apollo::canbus::Gem* p = gem_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Gem*>(
      &::apollo::canbus::_Gem_default_instance_);
}
inline const ::apollo::canbus::Gem& ChassisDetail::gem() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.gem)
  return _internal_gem();
}
inline ::apollo::canbus::Gem* ChassisDetail::release_gem() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.gem)
  _has_bits_[0] &= ~0x00010000u;
  ::apollo::canbus::Gem* temp = gem_;
  gem_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Gem* ChassisDetail::_internal_mutable_gem() {
  _has_bits_[0] |= 0x00010000u;
  if (gem_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Gem>(GetArenaNoVirtual());
    gem_ = p;
  }
  return gem_;
}
inline ::apollo::canbus::Gem* ChassisDetail::mutable_gem() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.gem)
  return _internal_mutable_gem();
}
inline void ChassisDetail::set_allocated_gem(::apollo::canbus::Gem* gem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gem_;
  }
  if (gem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gem, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  gem_ = gem;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.gem)
}

// optional .apollo.canbus.Lexus lexus = 19;
inline bool ChassisDetail::_internal_has_lexus() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || lexus_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_lexus() const {
  return _internal_has_lexus();
}
inline const ::apollo::canbus::Lexus& ChassisDetail::_internal_lexus() const {
  const ::apollo::canbus::Lexus* p = lexus_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Lexus*>(
      &::apollo::canbus::_Lexus_default_instance_);
}
inline const ::apollo::canbus::Lexus& ChassisDetail::lexus() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.lexus)
  return _internal_lexus();
}
inline ::apollo::canbus::Lexus* ChassisDetail::release_lexus() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.lexus)
  _has_bits_[0] &= ~0x00020000u;
  ::apollo::canbus::Lexus* temp = lexus_;
  lexus_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Lexus* ChassisDetail::_internal_mutable_lexus() {
  _has_bits_[0] |= 0x00020000u;
  if (lexus_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Lexus>(GetArenaNoVirtual());
    lexus_ = p;
  }
  return lexus_;
}
inline ::apollo::canbus::Lexus* ChassisDetail::mutable_lexus() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.lexus)
  return _internal_mutable_lexus();
}
inline void ChassisDetail::set_allocated_lexus(::apollo::canbus::Lexus* lexus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lexus_);
  }
  if (lexus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lexus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lexus, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  lexus_ = lexus;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.lexus)
}

// optional .apollo.canbus.Transit transit = 20;
inline bool ChassisDetail::_internal_has_transit() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || transit_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_transit() const {
  return _internal_has_transit();
}
inline const ::apollo::canbus::Transit& ChassisDetail::_internal_transit() const {
  const ::apollo::canbus::Transit* p = transit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Transit*>(
      &::apollo::canbus::_Transit_default_instance_);
}
inline const ::apollo::canbus::Transit& ChassisDetail::transit() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.transit)
  return _internal_transit();
}
inline ::apollo::canbus::Transit* ChassisDetail::release_transit() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.transit)
  _has_bits_[0] &= ~0x00040000u;
  ::apollo::canbus::Transit* temp = transit_;
  transit_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Transit* ChassisDetail::_internal_mutable_transit() {
  _has_bits_[0] |= 0x00040000u;
  if (transit_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Transit>(GetArenaNoVirtual());
    transit_ = p;
  }
  return transit_;
}
inline ::apollo::canbus::Transit* ChassisDetail::mutable_transit() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.transit)
  return _internal_mutable_transit();
}
inline void ChassisDetail::set_allocated_transit(::apollo::canbus::Transit* transit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_);
  }
  if (transit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transit, submessage_arena);
    }
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  transit_ = transit;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.transit)
}

// optional .apollo.canbus.Ge3 ge3 = 21;
inline bool ChassisDetail::_internal_has_ge3() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || ge3_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_ge3() const {
  return _internal_has_ge3();
}
inline const ::apollo::canbus::Ge3& ChassisDetail::_internal_ge3() const {
  const ::apollo::canbus::Ge3* p = ge3_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Ge3*>(
      &::apollo::canbus::_Ge3_default_instance_);
}
inline const ::apollo::canbus::Ge3& ChassisDetail::ge3() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.ge3)
  return _internal_ge3();
}
inline ::apollo::canbus::Ge3* ChassisDetail::release_ge3() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.ge3)
  _has_bits_[0] &= ~0x00080000u;
  ::apollo::canbus::Ge3* temp = ge3_;
  ge3_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Ge3* ChassisDetail::_internal_mutable_ge3() {
  _has_bits_[0] |= 0x00080000u;
  if (ge3_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Ge3>(GetArenaNoVirtual());
    ge3_ = p;
  }
  return ge3_;
}
inline ::apollo::canbus::Ge3* ChassisDetail::mutable_ge3() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.ge3)
  return _internal_mutable_ge3();
}
inline void ChassisDetail::set_allocated_ge3(::apollo::canbus::Ge3* ge3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ge3_);
  }
  if (ge3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ge3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ge3, submessage_arena);
    }
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  ge3_ = ge3;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.ge3)
}

// optional .apollo.canbus.Wey wey = 22;
inline bool ChassisDetail::_internal_has_wey() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || wey_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_wey() const {
  return _internal_has_wey();
}
inline const ::apollo::canbus::Wey& ChassisDetail::_internal_wey() const {
  const ::apollo::canbus::Wey* p = wey_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Wey*>(
      &::apollo::canbus::_Wey_default_instance_);
}
inline const ::apollo::canbus::Wey& ChassisDetail::wey() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.wey)
  return _internal_wey();
}
inline ::apollo::canbus::Wey* ChassisDetail::release_wey() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.wey)
  _has_bits_[0] &= ~0x00100000u;
  ::apollo::canbus::Wey* temp = wey_;
  wey_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Wey* ChassisDetail::_internal_mutable_wey() {
  _has_bits_[0] |= 0x00100000u;
  if (wey_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Wey>(GetArenaNoVirtual());
    wey_ = p;
  }
  return wey_;
}
inline ::apollo::canbus::Wey* ChassisDetail::mutable_wey() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.wey)
  return _internal_mutable_wey();
}
inline void ChassisDetail::set_allocated_wey(::apollo::canbus::Wey* wey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(wey_);
  }
  if (wey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      wey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wey, submessage_arena);
    }
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  wey_ = wey;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.wey)
}

// optional .apollo.canbus.Zhongyun zhongyun = 23;
inline bool ChassisDetail::_internal_has_zhongyun() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || zhongyun_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_zhongyun() const {
  return _internal_has_zhongyun();
}
inline const ::apollo::canbus::Zhongyun& ChassisDetail::_internal_zhongyun() const {
  const ::apollo::canbus::Zhongyun* p = zhongyun_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Zhongyun*>(
      &::apollo::canbus::_Zhongyun_default_instance_);
}
inline const ::apollo::canbus::Zhongyun& ChassisDetail::zhongyun() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.zhongyun)
  return _internal_zhongyun();
}
inline ::apollo::canbus::Zhongyun* ChassisDetail::release_zhongyun() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.zhongyun)
  _has_bits_[0] &= ~0x00200000u;
  ::apollo::canbus::Zhongyun* temp = zhongyun_;
  zhongyun_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Zhongyun* ChassisDetail::_internal_mutable_zhongyun() {
  _has_bits_[0] |= 0x00200000u;
  if (zhongyun_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Zhongyun>(GetArenaNoVirtual());
    zhongyun_ = p;
  }
  return zhongyun_;
}
inline ::apollo::canbus::Zhongyun* ChassisDetail::mutable_zhongyun() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.zhongyun)
  return _internal_mutable_zhongyun();
}
inline void ChassisDetail::set_allocated_zhongyun(::apollo::canbus::Zhongyun* zhongyun) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(zhongyun_);
  }
  if (zhongyun) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      zhongyun = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zhongyun, submessage_arena);
    }
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  zhongyun_ = zhongyun;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.zhongyun)
}

// optional .apollo.canbus.Ch ch = 24;
inline bool ChassisDetail::_internal_has_ch() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || ch_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_ch() const {
  return _internal_has_ch();
}
inline const ::apollo::canbus::Ch& ChassisDetail::_internal_ch() const {
  const ::apollo::canbus::Ch* p = ch_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Ch*>(
      &::apollo::canbus::_Ch_default_instance_);
}
inline const ::apollo::canbus::Ch& ChassisDetail::ch() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.ch)
  return _internal_ch();
}
inline ::apollo::canbus::Ch* ChassisDetail::release_ch() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.ch)
  _has_bits_[0] &= ~0x00400000u;
  ::apollo::canbus::Ch* temp = ch_;
  ch_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Ch* ChassisDetail::_internal_mutable_ch() {
  _has_bits_[0] |= 0x00400000u;
  if (ch_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Ch>(GetArenaNoVirtual());
    ch_ = p;
  }
  return ch_;
}
inline ::apollo::canbus::Ch* ChassisDetail::mutable_ch() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.ch)
  return _internal_mutable_ch();
}
inline void ChassisDetail::set_allocated_ch(::apollo::canbus::Ch* ch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ch_);
  }
  if (ch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ch, submessage_arena);
    }
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  ch_ = ch;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.ch)
}

// optional .apollo.common.VehicleID vehicle_id = 101;
inline bool ChassisDetail::_internal_has_vehicle_id() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || vehicle_id_ != nullptr);
  return value;
}
inline bool ChassisDetail::has_vehicle_id() const {
  return _internal_has_vehicle_id();
}
inline const ::apollo::common::VehicleID& ChassisDetail::_internal_vehicle_id() const {
  const ::apollo::common::VehicleID* p = vehicle_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::common::VehicleID*>(
      &::apollo::common::_VehicleID_default_instance_);
}
inline const ::apollo::common::VehicleID& ChassisDetail::vehicle_id() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.vehicle_id)
  return _internal_vehicle_id();
}
inline ::apollo::common::VehicleID* ChassisDetail::release_vehicle_id() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.vehicle_id)
  _has_bits_[0] &= ~0x00800000u;
  ::apollo::common::VehicleID* temp = vehicle_id_;
  vehicle_id_ = nullptr;
  return temp;
}
inline ::apollo::common::VehicleID* ChassisDetail::_internal_mutable_vehicle_id() {
  _has_bits_[0] |= 0x00800000u;
  if (vehicle_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::VehicleID>(GetArenaNoVirtual());
    vehicle_id_ = p;
  }
  return vehicle_id_;
}
inline ::apollo::common::VehicleID* ChassisDetail::mutable_vehicle_id() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.vehicle_id)
  return _internal_mutable_vehicle_id();
}
inline void ChassisDetail::set_allocated_vehicle_id(::apollo::common::VehicleID* vehicle_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehicle_id_);
  }
  if (vehicle_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vehicle_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  vehicle_id_ = vehicle_id;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.vehicle_id)
}

// -------------------------------------------------------------------

// CheckResponseSignal

// optional bool is_eps_online = 1 [default = false];
inline bool CheckResponseSignal::_internal_has_is_eps_online() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CheckResponseSignal::has_is_eps_online() const {
  return _internal_has_is_eps_online();
}
inline void CheckResponseSignal::clear_is_eps_online() {
  is_eps_online_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CheckResponseSignal::_internal_is_eps_online() const {
  return is_eps_online_;
}
inline bool CheckResponseSignal::is_eps_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_eps_online)
  return _internal_is_eps_online();
}
inline void CheckResponseSignal::_internal_set_is_eps_online(bool value) {
  _has_bits_[0] |= 0x00000001u;
  is_eps_online_ = value;
}
inline void CheckResponseSignal::set_is_eps_online(bool value) {
  _internal_set_is_eps_online(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_eps_online)
}

// optional bool is_epb_online = 2 [default = false];
inline bool CheckResponseSignal::_internal_has_is_epb_online() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CheckResponseSignal::has_is_epb_online() const {
  return _internal_has_is_epb_online();
}
inline void CheckResponseSignal::clear_is_epb_online() {
  is_epb_online_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CheckResponseSignal::_internal_is_epb_online() const {
  return is_epb_online_;
}
inline bool CheckResponseSignal::is_epb_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_epb_online)
  return _internal_is_epb_online();
}
inline void CheckResponseSignal::_internal_set_is_epb_online(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_epb_online_ = value;
}
inline void CheckResponseSignal::set_is_epb_online(bool value) {
  _internal_set_is_epb_online(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_epb_online)
}

// optional bool is_esp_online = 3 [default = false];
inline bool CheckResponseSignal::_internal_has_is_esp_online() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CheckResponseSignal::has_is_esp_online() const {
  return _internal_has_is_esp_online();
}
inline void CheckResponseSignal::clear_is_esp_online() {
  is_esp_online_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CheckResponseSignal::_internal_is_esp_online() const {
  return is_esp_online_;
}
inline bool CheckResponseSignal::is_esp_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_esp_online)
  return _internal_is_esp_online();
}
inline void CheckResponseSignal::_internal_set_is_esp_online(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_esp_online_ = value;
}
inline void CheckResponseSignal::set_is_esp_online(bool value) {
  _internal_set_is_esp_online(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_esp_online)
}

// optional bool is_vtog_online = 4 [default = false];
inline bool CheckResponseSignal::_internal_has_is_vtog_online() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CheckResponseSignal::has_is_vtog_online() const {
  return _internal_has_is_vtog_online();
}
inline void CheckResponseSignal::clear_is_vtog_online() {
  is_vtog_online_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CheckResponseSignal::_internal_is_vtog_online() const {
  return is_vtog_online_;
}
inline bool CheckResponseSignal::is_vtog_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_vtog_online)
  return _internal_is_vtog_online();
}
inline void CheckResponseSignal::_internal_set_is_vtog_online(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_vtog_online_ = value;
}
inline void CheckResponseSignal::set_is_vtog_online(bool value) {
  _internal_set_is_vtog_online(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_vtog_online)
}

// optional bool is_scu_online = 5 [default = false];
inline bool CheckResponseSignal::_internal_has_is_scu_online() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CheckResponseSignal::has_is_scu_online() const {
  return _internal_has_is_scu_online();
}
inline void CheckResponseSignal::clear_is_scu_online() {
  is_scu_online_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CheckResponseSignal::_internal_is_scu_online() const {
  return is_scu_online_;
}
inline bool CheckResponseSignal::is_scu_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_scu_online)
  return _internal_is_scu_online();
}
inline void CheckResponseSignal::_internal_set_is_scu_online(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_scu_online_ = value;
}
inline void CheckResponseSignal::set_is_scu_online(bool value) {
  _internal_set_is_scu_online(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_scu_online)
}

// optional bool is_switch_online = 6 [default = false];
inline bool CheckResponseSignal::_internal_has_is_switch_online() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CheckResponseSignal::has_is_switch_online() const {
  return _internal_has_is_switch_online();
}
inline void CheckResponseSignal::clear_is_switch_online() {
  is_switch_online_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CheckResponseSignal::_internal_is_switch_online() const {
  return is_switch_online_;
}
inline bool CheckResponseSignal::is_switch_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_switch_online)
  return _internal_is_switch_online();
}
inline void CheckResponseSignal::_internal_set_is_switch_online(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_switch_online_ = value;
}
inline void CheckResponseSignal::set_is_switch_online(bool value) {
  _internal_set_is_switch_online(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_switch_online)
}

// optional bool is_vcu_online = 7 [default = false];
inline bool CheckResponseSignal::_internal_has_is_vcu_online() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CheckResponseSignal::has_is_vcu_online() const {
  return _internal_has_is_vcu_online();
}
inline void CheckResponseSignal::clear_is_vcu_online() {
  is_vcu_online_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CheckResponseSignal::_internal_is_vcu_online() const {
  return is_vcu_online_;
}
inline bool CheckResponseSignal::is_vcu_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_vcu_online)
  return _internal_is_vcu_online();
}
inline void CheckResponseSignal::_internal_set_is_vcu_online(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_vcu_online_ = value;
}
inline void CheckResponseSignal::set_is_vcu_online(bool value) {
  _internal_set_is_vcu_online(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_vcu_online)
}

// -------------------------------------------------------------------

// Battery

// optional double battery_percent = 1;
inline bool Battery::_internal_has_battery_percent() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Battery::has_battery_percent() const {
  return _internal_has_battery_percent();
}
inline void Battery::clear_battery_percent() {
  battery_percent_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Battery::_internal_battery_percent() const {
  return battery_percent_;
}
inline double Battery::battery_percent() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Battery.battery_percent)
  return _internal_battery_percent();
}
inline void Battery::_internal_set_battery_percent(double value) {
  _has_bits_[0] |= 0x00000001u;
  battery_percent_ = value;
}
inline void Battery::set_battery_percent(double value) {
  _internal_set_battery_percent(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Battery.battery_percent)
}

// optional double fuel_level = 2;
inline bool Battery::_internal_has_fuel_level() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Battery::has_fuel_level() const {
  return _internal_has_fuel_level();
}
inline void Battery::clear_fuel_level() {
  fuel_level_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Battery::_internal_fuel_level() const {
  return fuel_level_;
}
inline double Battery::fuel_level() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Battery.fuel_level)
  return _internal_fuel_level();
}
inline void Battery::_internal_set_fuel_level(double value) {
  _has_bits_[0] |= 0x00000002u;
  fuel_level_ = value;
}
inline void Battery::set_fuel_level(double value) {
  _internal_set_fuel_level(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Battery.fuel_level)
}

// -------------------------------------------------------------------

// Light

// optional .apollo.canbus.Light.TurnLightType turn_light_type = 1;
inline bool Light::_internal_has_turn_light_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Light::has_turn_light_type() const {
  return _internal_has_turn_light_type();
}
inline void Light::clear_turn_light_type() {
  turn_light_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Light_TurnLightType Light::_internal_turn_light_type() const {
  return static_cast< ::apollo::canbus::Light_TurnLightType >(turn_light_type_);
}
inline ::apollo::canbus::Light_TurnLightType Light::turn_light_type() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.turn_light_type)
  return _internal_turn_light_type();
}
inline void Light::_internal_set_turn_light_type(::apollo::canbus::Light_TurnLightType value) {
  assert(::apollo::canbus::Light_TurnLightType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  turn_light_type_ = value;
}
inline void Light::set_turn_light_type(::apollo::canbus::Light_TurnLightType value) {
  _internal_set_turn_light_type(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.turn_light_type)
}

// optional .apollo.canbus.Light.BeamLampType beam_lamp_type = 2;
inline bool Light::_internal_has_beam_lamp_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Light::has_beam_lamp_type() const {
  return _internal_has_beam_lamp_type();
}
inline void Light::clear_beam_lamp_type() {
  beam_lamp_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Light_BeamLampType Light::_internal_beam_lamp_type() const {
  return static_cast< ::apollo::canbus::Light_BeamLampType >(beam_lamp_type_);
}
inline ::apollo::canbus::Light_BeamLampType Light::beam_lamp_type() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.beam_lamp_type)
  return _internal_beam_lamp_type();
}
inline void Light::_internal_set_beam_lamp_type(::apollo::canbus::Light_BeamLampType value) {
  assert(::apollo::canbus::Light_BeamLampType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  beam_lamp_type_ = value;
}
inline void Light::set_beam_lamp_type(::apollo::canbus::Light_BeamLampType value) {
  _internal_set_beam_lamp_type(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.beam_lamp_type)
}

// optional bool is_brake_lamp_on = 3;
inline bool Light::_internal_has_is_brake_lamp_on() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Light::has_is_brake_lamp_on() const {
  return _internal_has_is_brake_lamp_on();
}
inline void Light::clear_is_brake_lamp_on() {
  is_brake_lamp_on_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Light::_internal_is_brake_lamp_on() const {
  return is_brake_lamp_on_;
}
inline bool Light::is_brake_lamp_on() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.is_brake_lamp_on)
  return _internal_is_brake_lamp_on();
}
inline void Light::_internal_set_is_brake_lamp_on(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_brake_lamp_on_ = value;
}
inline void Light::set_is_brake_lamp_on(bool value) {
  _internal_set_is_brake_lamp_on(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.is_brake_lamp_on)
}

// optional bool is_auto_light = 4;
inline bool Light::_internal_has_is_auto_light() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Light::has_is_auto_light() const {
  return _internal_has_is_auto_light();
}
inline void Light::clear_is_auto_light() {
  is_auto_light_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Light::_internal_is_auto_light() const {
  return is_auto_light_;
}
inline bool Light::is_auto_light() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.is_auto_light)
  return _internal_is_auto_light();
}
inline void Light::_internal_set_is_auto_light(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_auto_light_ = value;
}
inline void Light::set_is_auto_light(bool value) {
  _internal_set_is_auto_light(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.is_auto_light)
}

// optional int32 wiper_gear = 5;
inline bool Light::_internal_has_wiper_gear() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Light::has_wiper_gear() const {
  return _internal_has_wiper_gear();
}
inline void Light::clear_wiper_gear() {
  wiper_gear_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Light::_internal_wiper_gear() const {
  return wiper_gear_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Light::wiper_gear() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.wiper_gear)
  return _internal_wiper_gear();
}
inline void Light::_internal_set_wiper_gear(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  wiper_gear_ = value;
}
inline void Light::set_wiper_gear(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wiper_gear(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.wiper_gear)
}

// optional int32 lotion_gear = 6;
inline bool Light::_internal_has_lotion_gear() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Light::has_lotion_gear() const {
  return _internal_has_lotion_gear();
}
inline void Light::clear_lotion_gear() {
  lotion_gear_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Light::_internal_lotion_gear() const {
  return lotion_gear_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Light::lotion_gear() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.lotion_gear)
  return _internal_lotion_gear();
}
inline void Light::_internal_set_lotion_gear(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  lotion_gear_ = value;
}
inline void Light::set_lotion_gear(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lotion_gear(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.lotion_gear)
}

// optional bool is_horn_on = 7;
inline bool Light::_internal_has_is_horn_on() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Light::has_is_horn_on() const {
  return _internal_has_is_horn_on();
}
inline void Light::clear_is_horn_on() {
  is_horn_on_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Light::_internal_is_horn_on() const {
  return is_horn_on_;
}
inline bool Light::is_horn_on() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.is_horn_on)
  return _internal_is_horn_on();
}
inline void Light::_internal_set_is_horn_on(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_horn_on_ = value;
}
inline void Light::set_is_horn_on(bool value) {
  _internal_set_is_horn_on(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.is_horn_on)
}

// optional .apollo.canbus.Light.LincolnLampType lincoln_lamp_type = 8;
inline bool Light::_internal_has_lincoln_lamp_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Light::has_lincoln_lamp_type() const {
  return _internal_has_lincoln_lamp_type();
}
inline void Light::clear_lincoln_lamp_type() {
  lincoln_lamp_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::apollo::canbus::Light_LincolnLampType Light::_internal_lincoln_lamp_type() const {
  return static_cast< ::apollo::canbus::Light_LincolnLampType >(lincoln_lamp_type_);
}
inline ::apollo::canbus::Light_LincolnLampType Light::lincoln_lamp_type() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.lincoln_lamp_type)
  return _internal_lincoln_lamp_type();
}
inline void Light::_internal_set_lincoln_lamp_type(::apollo::canbus::Light_LincolnLampType value) {
  assert(::apollo::canbus::Light_LincolnLampType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  lincoln_lamp_type_ = value;
}
inline void Light::set_lincoln_lamp_type(::apollo::canbus::Light_LincolnLampType value) {
  _internal_set_lincoln_lamp_type(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.lincoln_lamp_type)
}

// optional .apollo.canbus.Light.LincolnWiperType lincoln_wiper = 9;
inline bool Light::_internal_has_lincoln_wiper() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Light::has_lincoln_wiper() const {
  return _internal_has_lincoln_wiper();
}
inline void Light::clear_lincoln_wiper() {
  lincoln_wiper_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::apollo::canbus::Light_LincolnWiperType Light::_internal_lincoln_wiper() const {
  return static_cast< ::apollo::canbus::Light_LincolnWiperType >(lincoln_wiper_);
}
inline ::apollo::canbus::Light_LincolnWiperType Light::lincoln_wiper() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.lincoln_wiper)
  return _internal_lincoln_wiper();
}
inline void Light::_internal_set_lincoln_wiper(::apollo::canbus::Light_LincolnWiperType value) {
  assert(::apollo::canbus::Light_LincolnWiperType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  lincoln_wiper_ = value;
}
inline void Light::set_lincoln_wiper(::apollo::canbus::Light_LincolnWiperType value) {
  _internal_set_lincoln_wiper(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.lincoln_wiper)
}

// optional .apollo.canbus.Light.LincolnAmbientType lincoln_ambient = 10;
inline bool Light::_internal_has_lincoln_ambient() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Light::has_lincoln_ambient() const {
  return _internal_has_lincoln_ambient();
}
inline void Light::clear_lincoln_ambient() {
  lincoln_ambient_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::apollo::canbus::Light_LincolnAmbientType Light::_internal_lincoln_ambient() const {
  return static_cast< ::apollo::canbus::Light_LincolnAmbientType >(lincoln_ambient_);
}
inline ::apollo::canbus::Light_LincolnAmbientType Light::lincoln_ambient() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.lincoln_ambient)
  return _internal_lincoln_ambient();
}
inline void Light::_internal_set_lincoln_ambient(::apollo::canbus::Light_LincolnAmbientType value) {
  assert(::apollo::canbus::Light_LincolnAmbientType_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  lincoln_ambient_ = value;
}
inline void Light::set_lincoln_ambient(::apollo::canbus::Light_LincolnAmbientType value) {
  _internal_set_lincoln_ambient(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.lincoln_ambient)
}

// -------------------------------------------------------------------

// Eps

// optional bool is_eps_fail = 1;
inline bool Eps::_internal_has_is_eps_fail() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Eps::has_is_eps_fail() const {
  return _internal_has_is_eps_fail();
}
inline void Eps::clear_is_eps_fail() {
  is_eps_fail_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Eps::_internal_is_eps_fail() const {
  return is_eps_fail_;
}
inline bool Eps::is_eps_fail() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.is_eps_fail)
  return _internal_is_eps_fail();
}
inline void Eps::_internal_set_is_eps_fail(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_eps_fail_ = value;
}
inline void Eps::set_is_eps_fail(bool value) {
  _internal_set_is_eps_fail(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.is_eps_fail)
}

// optional .apollo.canbus.Eps.Type eps_control_state = 2;
inline bool Eps::_internal_has_eps_control_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Eps::has_eps_control_state() const {
  return _internal_has_eps_control_state();
}
inline void Eps::clear_eps_control_state() {
  eps_control_state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Eps_Type Eps::_internal_eps_control_state() const {
  return static_cast< ::apollo::canbus::Eps_Type >(eps_control_state_);
}
inline ::apollo::canbus::Eps_Type Eps::eps_control_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.eps_control_state)
  return _internal_eps_control_state();
}
inline void Eps::_internal_set_eps_control_state(::apollo::canbus::Eps_Type value) {
  assert(::apollo::canbus::Eps_Type_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  eps_control_state_ = value;
}
inline void Eps::set_eps_control_state(::apollo::canbus::Eps_Type value) {
  _internal_set_eps_control_state(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.eps_control_state)
}

// optional double eps_driver_hand_torq = 3;
inline bool Eps::_internal_has_eps_driver_hand_torq() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Eps::has_eps_driver_hand_torq() const {
  return _internal_has_eps_driver_hand_torq();
}
inline void Eps::clear_eps_driver_hand_torq() {
  eps_driver_hand_torq_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Eps::_internal_eps_driver_hand_torq() const {
  return eps_driver_hand_torq_;
}
inline double Eps::eps_driver_hand_torq() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.eps_driver_hand_torq)
  return _internal_eps_driver_hand_torq();
}
inline void Eps::_internal_set_eps_driver_hand_torq(double value) {
  _has_bits_[0] |= 0x00000001u;
  eps_driver_hand_torq_ = value;
}
inline void Eps::set_eps_driver_hand_torq(double value) {
  _internal_set_eps_driver_hand_torq(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.eps_driver_hand_torq)
}

// optional bool is_steering_angle_valid = 4;
inline bool Eps::_internal_has_is_steering_angle_valid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Eps::has_is_steering_angle_valid() const {
  return _internal_has_is_steering_angle_valid();
}
inline void Eps::clear_is_steering_angle_valid() {
  is_steering_angle_valid_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Eps::_internal_is_steering_angle_valid() const {
  return is_steering_angle_valid_;
}
inline bool Eps::is_steering_angle_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.is_steering_angle_valid)
  return _internal_is_steering_angle_valid();
}
inline void Eps::_internal_set_is_steering_angle_valid(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_steering_angle_valid_ = value;
}
inline void Eps::set_is_steering_angle_valid(bool value) {
  _internal_set_is_steering_angle_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.is_steering_angle_valid)
}

// optional double steering_angle = 5;
inline bool Eps::_internal_has_steering_angle() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Eps::has_steering_angle() const {
  return _internal_has_steering_angle();
}
inline void Eps::clear_steering_angle() {
  steering_angle_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double Eps::_internal_steering_angle() const {
  return steering_angle_;
}
inline double Eps::steering_angle() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.steering_angle)
  return _internal_steering_angle();
}
inline void Eps::_internal_set_steering_angle(double value) {
  _has_bits_[0] |= 0x00000040u;
  steering_angle_ = value;
}
inline void Eps::set_steering_angle(double value) {
  _internal_set_steering_angle(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.steering_angle)
}

// optional double steering_angle_spd = 6;
inline bool Eps::_internal_has_steering_angle_spd() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Eps::has_steering_angle_spd() const {
  return _internal_has_steering_angle_spd();
}
inline void Eps::clear_steering_angle_spd() {
  steering_angle_spd_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double Eps::_internal_steering_angle_spd() const {
  return steering_angle_spd_;
}
inline double Eps::steering_angle_spd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.steering_angle_spd)
  return _internal_steering_angle_spd();
}
inline void Eps::_internal_set_steering_angle_spd(double value) {
  _has_bits_[0] |= 0x00000080u;
  steering_angle_spd_ = value;
}
inline void Eps::set_steering_angle_spd(double value) {
  _internal_set_steering_angle_spd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.steering_angle_spd)
}

// optional bool is_trimming_status = 7;
inline bool Eps::_internal_has_is_trimming_status() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Eps::has_is_trimming_status() const {
  return _internal_has_is_trimming_status();
}
inline void Eps::clear_is_trimming_status() {
  is_trimming_status_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Eps::_internal_is_trimming_status() const {
  return is_trimming_status_;
}
inline bool Eps::is_trimming_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.is_trimming_status)
  return _internal_is_trimming_status();
}
inline void Eps::_internal_set_is_trimming_status(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_trimming_status_ = value;
}
inline void Eps::set_is_trimming_status(bool value) {
  _internal_set_is_trimming_status(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.is_trimming_status)
}

// optional bool is_calibration_status = 8;
inline bool Eps::_internal_has_is_calibration_status() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Eps::has_is_calibration_status() const {
  return _internal_has_is_calibration_status();
}
inline void Eps::clear_is_calibration_status() {
  is_calibration_status_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Eps::_internal_is_calibration_status() const {
  return is_calibration_status_;
}
inline bool Eps::is_calibration_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.is_calibration_status)
  return _internal_is_calibration_status();
}
inline void Eps::_internal_set_is_calibration_status(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_calibration_status_ = value;
}
inline void Eps::set_is_calibration_status(bool value) {
  _internal_set_is_calibration_status(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.is_calibration_status)
}

// optional bool is_failure_status = 9;
inline bool Eps::_internal_has_is_failure_status() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Eps::has_is_failure_status() const {
  return _internal_has_is_failure_status();
}
inline void Eps::clear_is_failure_status() {
  is_failure_status_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool Eps::_internal_is_failure_status() const {
  return is_failure_status_;
}
inline bool Eps::is_failure_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.is_failure_status)
  return _internal_is_failure_status();
}
inline void Eps::_internal_set_is_failure_status(bool value) {
  _has_bits_[0] |= 0x00002000u;
  is_failure_status_ = value;
}
inline void Eps::set_is_failure_status(bool value) {
  _internal_set_is_failure_status(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.is_failure_status)
}

// optional int32 allow_enter_autonomous_mode = 10;
inline bool Eps::_internal_has_allow_enter_autonomous_mode() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Eps::has_allow_enter_autonomous_mode() const {
  return _internal_has_allow_enter_autonomous_mode();
}
inline void Eps::clear_allow_enter_autonomous_mode() {
  allow_enter_autonomous_mode_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Eps::_internal_allow_enter_autonomous_mode() const {
  return allow_enter_autonomous_mode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Eps::allow_enter_autonomous_mode() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.allow_enter_autonomous_mode)
  return _internal_allow_enter_autonomous_mode();
}
inline void Eps::_internal_set_allow_enter_autonomous_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  allow_enter_autonomous_mode_ = value;
}
inline void Eps::set_allow_enter_autonomous_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_allow_enter_autonomous_mode(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.allow_enter_autonomous_mode)
}

// optional int32 current_driving_mode = 11;
inline bool Eps::_internal_has_current_driving_mode() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Eps::has_current_driving_mode() const {
  return _internal_has_current_driving_mode();
}
inline void Eps::clear_current_driving_mode() {
  current_driving_mode_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Eps::_internal_current_driving_mode() const {
  return current_driving_mode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Eps::current_driving_mode() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.current_driving_mode)
  return _internal_current_driving_mode();
}
inline void Eps::_internal_set_current_driving_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  current_driving_mode_ = value;
}
inline void Eps::set_current_driving_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_current_driving_mode(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.current_driving_mode)
}

// optional double steering_angle_cmd = 12;
inline bool Eps::_internal_has_steering_angle_cmd() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Eps::has_steering_angle_cmd() const {
  return _internal_has_steering_angle_cmd();
}
inline void Eps::clear_steering_angle_cmd() {
  steering_angle_cmd_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline double Eps::_internal_steering_angle_cmd() const {
  return steering_angle_cmd_;
}
inline double Eps::steering_angle_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.steering_angle_cmd)
  return _internal_steering_angle_cmd();
}
inline void Eps::_internal_set_steering_angle_cmd(double value) {
  _has_bits_[0] |= 0x00000400u;
  steering_angle_cmd_ = value;
}
inline void Eps::set_steering_angle_cmd(double value) {
  _internal_set_steering_angle_cmd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.steering_angle_cmd)
}

// optional double vehicle_speed = 13;
inline bool Eps::_internal_has_vehicle_speed() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Eps::has_vehicle_speed() const {
  return _internal_has_vehicle_speed();
}
inline void Eps::clear_vehicle_speed() {
  vehicle_speed_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline double Eps::_internal_vehicle_speed() const {
  return vehicle_speed_;
}
inline double Eps::vehicle_speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.vehicle_speed)
  return _internal_vehicle_speed();
}
inline void Eps::_internal_set_vehicle_speed(double value) {
  _has_bits_[0] |= 0x00000800u;
  vehicle_speed_ = value;
}
inline void Eps::set_vehicle_speed(double value) {
  _internal_set_vehicle_speed(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.vehicle_speed)
}

// optional double epas_torque = 14;
inline bool Eps::_internal_has_epas_torque() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Eps::has_epas_torque() const {
  return _internal_has_epas_torque();
}
inline void Eps::clear_epas_torque() {
  epas_torque_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline double Eps::_internal_epas_torque() const {
  return epas_torque_;
}
inline double Eps::epas_torque() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.epas_torque)
  return _internal_epas_torque();
}
inline void Eps::_internal_set_epas_torque(double value) {
  _has_bits_[0] |= 0x00001000u;
  epas_torque_ = value;
}
inline void Eps::set_epas_torque(double value) {
  _internal_set_epas_torque(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.epas_torque)
}

// optional bool steering_enabled = 15;
inline bool Eps::_internal_has_steering_enabled() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Eps::has_steering_enabled() const {
  return _internal_has_steering_enabled();
}
inline void Eps::clear_steering_enabled() {
  steering_enabled_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool Eps::_internal_steering_enabled() const {
  return steering_enabled_;
}
inline bool Eps::steering_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.steering_enabled)
  return _internal_steering_enabled();
}
inline void Eps::_internal_set_steering_enabled(bool value) {
  _has_bits_[0] |= 0x00004000u;
  steering_enabled_ = value;
}
inline void Eps::set_steering_enabled(bool value) {
  _internal_set_steering_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.steering_enabled)
}

// optional bool driver_override = 16;
inline bool Eps::_internal_has_driver_override() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Eps::has_driver_override() const {
  return _internal_has_driver_override();
}
inline void Eps::clear_driver_override() {
  driver_override_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool Eps::_internal_driver_override() const {
  return driver_override_;
}
inline bool Eps::driver_override() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.driver_override)
  return _internal_driver_override();
}
inline void Eps::_internal_set_driver_override(bool value) {
  _has_bits_[0] |= 0x00008000u;
  driver_override_ = value;
}
inline void Eps::set_driver_override(bool value) {
  _internal_set_driver_override(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.driver_override)
}

// optional bool driver_activity = 17;
inline bool Eps::_internal_has_driver_activity() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Eps::has_driver_activity() const {
  return _internal_has_driver_activity();
}
inline void Eps::clear_driver_activity() {
  driver_activity_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool Eps::_internal_driver_activity() const {
  return driver_activity_;
}
inline bool Eps::driver_activity() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.driver_activity)
  return _internal_driver_activity();
}
inline void Eps::_internal_set_driver_activity(bool value) {
  _has_bits_[0] |= 0x00010000u;
  driver_activity_ = value;
}
inline void Eps::set_driver_activity(bool value) {
  _internal_set_driver_activity(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.driver_activity)
}

// optional bool watchdog_fault = 18;
inline bool Eps::_internal_has_watchdog_fault() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Eps::has_watchdog_fault() const {
  return _internal_has_watchdog_fault();
}
inline void Eps::clear_watchdog_fault() {
  watchdog_fault_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool Eps::_internal_watchdog_fault() const {
  return watchdog_fault_;
}
inline bool Eps::watchdog_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.watchdog_fault)
  return _internal_watchdog_fault();
}
inline void Eps::_internal_set_watchdog_fault(bool value) {
  _has_bits_[0] |= 0x00020000u;
  watchdog_fault_ = value;
}
inline void Eps::set_watchdog_fault(bool value) {
  _internal_set_watchdog_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.watchdog_fault)
}

// optional bool channel_1_fault = 19;
inline bool Eps::_internal_has_channel_1_fault() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Eps::has_channel_1_fault() const {
  return _internal_has_channel_1_fault();
}
inline void Eps::clear_channel_1_fault() {
  channel_1_fault_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool Eps::_internal_channel_1_fault() const {
  return channel_1_fault_;
}
inline bool Eps::channel_1_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.channel_1_fault)
  return _internal_channel_1_fault();
}
inline void Eps::_internal_set_channel_1_fault(bool value) {
  _has_bits_[0] |= 0x00040000u;
  channel_1_fault_ = value;
}
inline void Eps::set_channel_1_fault(bool value) {
  _internal_set_channel_1_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.channel_1_fault)
}

// optional bool channel_2_fault = 20;
inline bool Eps::_internal_has_channel_2_fault() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Eps::has_channel_2_fault() const {
  return _internal_has_channel_2_fault();
}
inline void Eps::clear_channel_2_fault() {
  channel_2_fault_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool Eps::_internal_channel_2_fault() const {
  return channel_2_fault_;
}
inline bool Eps::channel_2_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.channel_2_fault)
  return _internal_channel_2_fault();
}
inline void Eps::_internal_set_channel_2_fault(bool value) {
  _has_bits_[0] |= 0x00080000u;
  channel_2_fault_ = value;
}
inline void Eps::set_channel_2_fault(bool value) {
  _internal_set_channel_2_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.channel_2_fault)
}

// optional bool calibration_fault = 21;
inline bool Eps::_internal_has_calibration_fault() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Eps::has_calibration_fault() const {
  return _internal_has_calibration_fault();
}
inline void Eps::clear_calibration_fault() {
  calibration_fault_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool Eps::_internal_calibration_fault() const {
  return calibration_fault_;
}
inline bool Eps::calibration_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.calibration_fault)
  return _internal_calibration_fault();
}
inline void Eps::_internal_set_calibration_fault(bool value) {
  _has_bits_[0] |= 0x00100000u;
  calibration_fault_ = value;
}
inline void Eps::set_calibration_fault(bool value) {
  _internal_set_calibration_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.calibration_fault)
}

// optional bool connector_fault = 22;
inline bool Eps::_internal_has_connector_fault() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Eps::has_connector_fault() const {
  return _internal_has_connector_fault();
}
inline void Eps::clear_connector_fault() {
  connector_fault_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool Eps::_internal_connector_fault() const {
  return connector_fault_;
}
inline bool Eps::connector_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.connector_fault)
  return _internal_connector_fault();
}
inline void Eps::_internal_set_connector_fault(bool value) {
  _has_bits_[0] |= 0x00400000u;
  connector_fault_ = value;
}
inline void Eps::set_connector_fault(bool value) {
  _internal_set_connector_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.connector_fault)
}

// optional double timestamp_65 = 23;
inline bool Eps::_internal_has_timestamp_65() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Eps::has_timestamp_65() const {
  return _internal_has_timestamp_65();
}
inline void Eps::clear_timestamp_65() {
  timestamp_65_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline double Eps::_internal_timestamp_65() const {
  return timestamp_65_;
}
inline double Eps::timestamp_65() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.timestamp_65)
  return _internal_timestamp_65();
}
inline void Eps::_internal_set_timestamp_65(double value) {
  _has_bits_[0] |= 0x00200000u;
  timestamp_65_ = value;
}
inline void Eps::set_timestamp_65(double value) {
  _internal_set_timestamp_65(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.timestamp_65)
}

// optional int32 major_version = 24;
inline bool Eps::_internal_has_major_version() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Eps::has_major_version() const {
  return _internal_has_major_version();
}
inline void Eps::clear_major_version() {
  major_version_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Eps::_internal_major_version() const {
  return major_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Eps::major_version() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.major_version)
  return _internal_major_version();
}
inline void Eps::_internal_set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00800000u;
  major_version_ = value;
}
inline void Eps::set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_major_version(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.major_version)
}

// optional int32 minor_version = 25;
inline bool Eps::_internal_has_minor_version() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool Eps::has_minor_version() const {
  return _internal_has_minor_version();
}
inline void Eps::clear_minor_version() {
  minor_version_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Eps::_internal_minor_version() const {
  return minor_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Eps::minor_version() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.minor_version)
  return _internal_minor_version();
}
inline void Eps::_internal_set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x01000000u;
  minor_version_ = value;
}
inline void Eps::set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_minor_version(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.minor_version)
}

// optional int32 build_number = 26;
inline bool Eps::_internal_has_build_number() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool Eps::has_build_number() const {
  return _internal_has_build_number();
}
inline void Eps::clear_build_number() {
  build_number_ = 0;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Eps::_internal_build_number() const {
  return build_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Eps::build_number() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.build_number)
  return _internal_build_number();
}
inline void Eps::_internal_set_build_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x02000000u;
  build_number_ = value;
}
inline void Eps::set_build_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_build_number(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.build_number)
}

// -------------------------------------------------------------------

// VehicleSpd

// optional bool is_vehicle_standstill = 1;
inline bool VehicleSpd::_internal_has_is_vehicle_standstill() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VehicleSpd::has_is_vehicle_standstill() const {
  return _internal_has_is_vehicle_standstill();
}
inline void VehicleSpd::clear_is_vehicle_standstill() {
  is_vehicle_standstill_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool VehicleSpd::_internal_is_vehicle_standstill() const {
  return is_vehicle_standstill_;
}
inline bool VehicleSpd::is_vehicle_standstill() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_vehicle_standstill)
  return _internal_is_vehicle_standstill();
}
inline void VehicleSpd::_internal_set_is_vehicle_standstill(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_vehicle_standstill_ = value;
}
inline void VehicleSpd::set_is_vehicle_standstill(bool value) {
  _internal_set_is_vehicle_standstill(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_vehicle_standstill)
}

// optional bool is_vehicle_spd_valid = 2;
inline bool VehicleSpd::_internal_has_is_vehicle_spd_valid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VehicleSpd::has_is_vehicle_spd_valid() const {
  return _internal_has_is_vehicle_spd_valid();
}
inline void VehicleSpd::clear_is_vehicle_spd_valid() {
  is_vehicle_spd_valid_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool VehicleSpd::_internal_is_vehicle_spd_valid() const {
  return is_vehicle_spd_valid_;
}
inline bool VehicleSpd::is_vehicle_spd_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_vehicle_spd_valid)
  return _internal_is_vehicle_spd_valid();
}
inline void VehicleSpd::_internal_set_is_vehicle_spd_valid(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_vehicle_spd_valid_ = value;
}
inline void VehicleSpd::set_is_vehicle_spd_valid(bool value) {
  _internal_set_is_vehicle_spd_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_vehicle_spd_valid)
}

// optional double vehicle_spd = 3 [default = 0];
inline bool VehicleSpd::_internal_has_vehicle_spd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VehicleSpd::has_vehicle_spd() const {
  return _internal_has_vehicle_spd();
}
inline void VehicleSpd::clear_vehicle_spd() {
  vehicle_spd_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double VehicleSpd::_internal_vehicle_spd() const {
  return vehicle_spd_;
}
inline double VehicleSpd::vehicle_spd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.vehicle_spd)
  return _internal_vehicle_spd();
}
inline void VehicleSpd::_internal_set_vehicle_spd(double value) {
  _has_bits_[0] |= 0x00000001u;
  vehicle_spd_ = value;
}
inline void VehicleSpd::set_vehicle_spd(double value) {
  _internal_set_vehicle_spd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.vehicle_spd)
}

// optional bool is_wheel_spd_rr_valid = 4;
inline bool VehicleSpd::_internal_has_is_wheel_spd_rr_valid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VehicleSpd::has_is_wheel_spd_rr_valid() const {
  return _internal_has_is_wheel_spd_rr_valid();
}
inline void VehicleSpd::clear_is_wheel_spd_rr_valid() {
  is_wheel_spd_rr_valid_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool VehicleSpd::_internal_is_wheel_spd_rr_valid() const {
  return is_wheel_spd_rr_valid_;
}
inline bool VehicleSpd::is_wheel_spd_rr_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_wheel_spd_rr_valid)
  return _internal_is_wheel_spd_rr_valid();
}
inline void VehicleSpd::_internal_set_is_wheel_spd_rr_valid(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_wheel_spd_rr_valid_ = value;
}
inline void VehicleSpd::set_is_wheel_spd_rr_valid(bool value) {
  _internal_set_is_wheel_spd_rr_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_wheel_spd_rr_valid)
}

// optional .apollo.canbus.WheelSpeed.WheelSpeedType wheel_direction_rr = 5;
inline bool VehicleSpd::_internal_has_wheel_direction_rr() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool VehicleSpd::has_wheel_direction_rr() const {
  return _internal_has_wheel_direction_rr();
}
inline void VehicleSpd::clear_wheel_direction_rr() {
  wheel_direction_rr_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::apollo::canbus::WheelSpeed_WheelSpeedType VehicleSpd::_internal_wheel_direction_rr() const {
  return static_cast< ::apollo::canbus::WheelSpeed_WheelSpeedType >(wheel_direction_rr_);
}
inline ::apollo::canbus::WheelSpeed_WheelSpeedType VehicleSpd::wheel_direction_rr() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_direction_rr)
  return _internal_wheel_direction_rr();
}
inline void VehicleSpd::_internal_set_wheel_direction_rr(::apollo::canbus::WheelSpeed_WheelSpeedType value) {
  assert(::apollo::canbus::WheelSpeed_WheelSpeedType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  wheel_direction_rr_ = value;
}
inline void VehicleSpd::set_wheel_direction_rr(::apollo::canbus::WheelSpeed_WheelSpeedType value) {
  _internal_set_wheel_direction_rr(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_direction_rr)
}

// optional double wheel_spd_rr = 6;
inline bool VehicleSpd::_internal_has_wheel_spd_rr() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool VehicleSpd::has_wheel_spd_rr() const {
  return _internal_has_wheel_spd_rr();
}
inline void VehicleSpd::clear_wheel_spd_rr() {
  wheel_spd_rr_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double VehicleSpd::_internal_wheel_spd_rr() const {
  return wheel_spd_rr_;
}
inline double VehicleSpd::wheel_spd_rr() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_spd_rr)
  return _internal_wheel_spd_rr();
}
inline void VehicleSpd::_internal_set_wheel_spd_rr(double value) {
  _has_bits_[0] |= 0x00000040u;
  wheel_spd_rr_ = value;
}
inline void VehicleSpd::set_wheel_spd_rr(double value) {
  _internal_set_wheel_spd_rr(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_spd_rr)
}

// optional bool is_wheel_spd_rl_valid = 7;
inline bool VehicleSpd::_internal_has_is_wheel_spd_rl_valid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VehicleSpd::has_is_wheel_spd_rl_valid() const {
  return _internal_has_is_wheel_spd_rl_valid();
}
inline void VehicleSpd::clear_is_wheel_spd_rl_valid() {
  is_wheel_spd_rl_valid_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool VehicleSpd::_internal_is_wheel_spd_rl_valid() const {
  return is_wheel_spd_rl_valid_;
}
inline bool VehicleSpd::is_wheel_spd_rl_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_wheel_spd_rl_valid)
  return _internal_is_wheel_spd_rl_valid();
}
inline void VehicleSpd::_internal_set_is_wheel_spd_rl_valid(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_wheel_spd_rl_valid_ = value;
}
inline void VehicleSpd::set_is_wheel_spd_rl_valid(bool value) {
  _internal_set_is_wheel_spd_rl_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_wheel_spd_rl_valid)
}

// optional .apollo.canbus.WheelSpeed.WheelSpeedType wheel_direction_rl = 8;
inline bool VehicleSpd::_internal_has_wheel_direction_rl() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool VehicleSpd::has_wheel_direction_rl() const {
  return _internal_has_wheel_direction_rl();
}
inline void VehicleSpd::clear_wheel_direction_rl() {
  wheel_direction_rl_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::apollo::canbus::WheelSpeed_WheelSpeedType VehicleSpd::_internal_wheel_direction_rl() const {
  return static_cast< ::apollo::canbus::WheelSpeed_WheelSpeedType >(wheel_direction_rl_);
}
inline ::apollo::canbus::WheelSpeed_WheelSpeedType VehicleSpd::wheel_direction_rl() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_direction_rl)
  return _internal_wheel_direction_rl();
}
inline void VehicleSpd::_internal_set_wheel_direction_rl(::apollo::canbus::WheelSpeed_WheelSpeedType value) {
  assert(::apollo::canbus::WheelSpeed_WheelSpeedType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  wheel_direction_rl_ = value;
}
inline void VehicleSpd::set_wheel_direction_rl(::apollo::canbus::WheelSpeed_WheelSpeedType value) {
  _internal_set_wheel_direction_rl(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_direction_rl)
}

// optional double wheel_spd_rl = 9;
inline bool VehicleSpd::_internal_has_wheel_spd_rl() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool VehicleSpd::has_wheel_spd_rl() const {
  return _internal_has_wheel_spd_rl();
}
inline void VehicleSpd::clear_wheel_spd_rl() {
  wheel_spd_rl_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double VehicleSpd::_internal_wheel_spd_rl() const {
  return wheel_spd_rl_;
}
inline double VehicleSpd::wheel_spd_rl() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_spd_rl)
  return _internal_wheel_spd_rl();
}
inline void VehicleSpd::_internal_set_wheel_spd_rl(double value) {
  _has_bits_[0] |= 0x00000080u;
  wheel_spd_rl_ = value;
}
inline void VehicleSpd::set_wheel_spd_rl(double value) {
  _internal_set_wheel_spd_rl(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_spd_rl)
}

// optional bool is_wheel_spd_fr_valid = 10;
inline bool VehicleSpd::_internal_has_is_wheel_spd_fr_valid() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool VehicleSpd::has_is_wheel_spd_fr_valid() const {
  return _internal_has_is_wheel_spd_fr_valid();
}
inline void VehicleSpd::clear_is_wheel_spd_fr_valid() {
  is_wheel_spd_fr_valid_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool VehicleSpd::_internal_is_wheel_spd_fr_valid() const {
  return is_wheel_spd_fr_valid_;
}
inline bool VehicleSpd::is_wheel_spd_fr_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_wheel_spd_fr_valid)
  return _internal_is_wheel_spd_fr_valid();
}
inline void VehicleSpd::_internal_set_is_wheel_spd_fr_valid(bool value) {
  _has_bits_[0] |= 0x00001000u;
  is_wheel_spd_fr_valid_ = value;
}
inline void VehicleSpd::set_is_wheel_spd_fr_valid(bool value) {
  _internal_set_is_wheel_spd_fr_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_wheel_spd_fr_valid)
}

// optional .apollo.canbus.WheelSpeed.WheelSpeedType wheel_direction_fr = 11;
inline bool VehicleSpd::_internal_has_wheel_direction_fr() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool VehicleSpd::has_wheel_direction_fr() const {
  return _internal_has_wheel_direction_fr();
}
inline void VehicleSpd::clear_wheel_direction_fr() {
  wheel_direction_fr_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::apollo::canbus::WheelSpeed_WheelSpeedType VehicleSpd::_internal_wheel_direction_fr() const {
  return static_cast< ::apollo::canbus::WheelSpeed_WheelSpeedType >(wheel_direction_fr_);
}
inline ::apollo::canbus::WheelSpeed_WheelSpeedType VehicleSpd::wheel_direction_fr() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_direction_fr)
  return _internal_wheel_direction_fr();
}
inline void VehicleSpd::_internal_set_wheel_direction_fr(::apollo::canbus::WheelSpeed_WheelSpeedType value) {
  assert(::apollo::canbus::WheelSpeed_WheelSpeedType_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  wheel_direction_fr_ = value;
}
inline void VehicleSpd::set_wheel_direction_fr(::apollo::canbus::WheelSpeed_WheelSpeedType value) {
  _internal_set_wheel_direction_fr(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_direction_fr)
}

// optional double wheel_spd_fr = 12;
inline bool VehicleSpd::_internal_has_wheel_spd_fr() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool VehicleSpd::has_wheel_spd_fr() const {
  return _internal_has_wheel_spd_fr();
}
inline void VehicleSpd::clear_wheel_spd_fr() {
  wheel_spd_fr_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline double VehicleSpd::_internal_wheel_spd_fr() const {
  return wheel_spd_fr_;
}
inline double VehicleSpd::wheel_spd_fr() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_spd_fr)
  return _internal_wheel_spd_fr();
}
inline void VehicleSpd::_internal_set_wheel_spd_fr(double value) {
  _has_bits_[0] |= 0x00000400u;
  wheel_spd_fr_ = value;
}
inline void VehicleSpd::set_wheel_spd_fr(double value) {
  _internal_set_wheel_spd_fr(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_spd_fr)
}

// optional bool is_wheel_spd_fl_valid = 13;
inline bool VehicleSpd::_internal_has_is_wheel_spd_fl_valid() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool VehicleSpd::has_is_wheel_spd_fl_valid() const {
  return _internal_has_is_wheel_spd_fl_valid();
}
inline void VehicleSpd::clear_is_wheel_spd_fl_valid() {
  is_wheel_spd_fl_valid_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool VehicleSpd::_internal_is_wheel_spd_fl_valid() const {
  return is_wheel_spd_fl_valid_;
}
inline bool VehicleSpd::is_wheel_spd_fl_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_wheel_spd_fl_valid)
  return _internal_is_wheel_spd_fl_valid();
}
inline void VehicleSpd::_internal_set_is_wheel_spd_fl_valid(bool value) {
  _has_bits_[0] |= 0x00002000u;
  is_wheel_spd_fl_valid_ = value;
}
inline void VehicleSpd::set_is_wheel_spd_fl_valid(bool value) {
  _internal_set_is_wheel_spd_fl_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_wheel_spd_fl_valid)
}

// optional .apollo.canbus.WheelSpeed.WheelSpeedType wheel_direction_fl = 14;
inline bool VehicleSpd::_internal_has_wheel_direction_fl() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool VehicleSpd::has_wheel_direction_fl() const {
  return _internal_has_wheel_direction_fl();
}
inline void VehicleSpd::clear_wheel_direction_fl() {
  wheel_direction_fl_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::apollo::canbus::WheelSpeed_WheelSpeedType VehicleSpd::_internal_wheel_direction_fl() const {
  return static_cast< ::apollo::canbus::WheelSpeed_WheelSpeedType >(wheel_direction_fl_);
}
inline ::apollo::canbus::WheelSpeed_WheelSpeedType VehicleSpd::wheel_direction_fl() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_direction_fl)
  return _internal_wheel_direction_fl();
}
inline void VehicleSpd::_internal_set_wheel_direction_fl(::apollo::canbus::WheelSpeed_WheelSpeedType value) {
  assert(::apollo::canbus::WheelSpeed_WheelSpeedType_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  wheel_direction_fl_ = value;
}
inline void VehicleSpd::set_wheel_direction_fl(::apollo::canbus::WheelSpeed_WheelSpeedType value) {
  _internal_set_wheel_direction_fl(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_direction_fl)
}

// optional double wheel_spd_fl = 15;
inline bool VehicleSpd::_internal_has_wheel_spd_fl() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool VehicleSpd::has_wheel_spd_fl() const {
  return _internal_has_wheel_spd_fl();
}
inline void VehicleSpd::clear_wheel_spd_fl() {
  wheel_spd_fl_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline double VehicleSpd::_internal_wheel_spd_fl() const {
  return wheel_spd_fl_;
}
inline double VehicleSpd::wheel_spd_fl() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_spd_fl)
  return _internal_wheel_spd_fl();
}
inline void VehicleSpd::_internal_set_wheel_spd_fl(double value) {
  _has_bits_[0] |= 0x00010000u;
  wheel_spd_fl_ = value;
}
inline void VehicleSpd::set_wheel_spd_fl(double value) {
  _internal_set_wheel_spd_fl(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_spd_fl)
}

// optional bool is_yaw_rate_valid = 16;
inline bool VehicleSpd::_internal_has_is_yaw_rate_valid() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool VehicleSpd::has_is_yaw_rate_valid() const {
  return _internal_has_is_yaw_rate_valid();
}
inline void VehicleSpd::clear_is_yaw_rate_valid() {
  is_yaw_rate_valid_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool VehicleSpd::_internal_is_yaw_rate_valid() const {
  return is_yaw_rate_valid_;
}
inline bool VehicleSpd::is_yaw_rate_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_yaw_rate_valid)
  return _internal_is_yaw_rate_valid();
}
inline void VehicleSpd::_internal_set_is_yaw_rate_valid(bool value) {
  _has_bits_[0] |= 0x00004000u;
  is_yaw_rate_valid_ = value;
}
inline void VehicleSpd::set_is_yaw_rate_valid(bool value) {
  _internal_set_is_yaw_rate_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_yaw_rate_valid)
}

// optional double yaw_rate = 17;
inline bool VehicleSpd::_internal_has_yaw_rate() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool VehicleSpd::has_yaw_rate() const {
  return _internal_has_yaw_rate();
}
inline void VehicleSpd::clear_yaw_rate() {
  yaw_rate_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline double VehicleSpd::_internal_yaw_rate() const {
  return yaw_rate_;
}
inline double VehicleSpd::yaw_rate() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.yaw_rate)
  return _internal_yaw_rate();
}
inline void VehicleSpd::_internal_set_yaw_rate(double value) {
  _has_bits_[0] |= 0x00020000u;
  yaw_rate_ = value;
}
inline void VehicleSpd::set_yaw_rate(double value) {
  _internal_set_yaw_rate(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.yaw_rate)
}

// optional double yaw_rate_offset = 18;
inline bool VehicleSpd::_internal_has_yaw_rate_offset() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool VehicleSpd::has_yaw_rate_offset() const {
  return _internal_has_yaw_rate_offset();
}
inline void VehicleSpd::clear_yaw_rate_offset() {
  yaw_rate_offset_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline double VehicleSpd::_internal_yaw_rate_offset() const {
  return yaw_rate_offset_;
}
inline double VehicleSpd::yaw_rate_offset() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.yaw_rate_offset)
  return _internal_yaw_rate_offset();
}
inline void VehicleSpd::_internal_set_yaw_rate_offset(double value) {
  _has_bits_[0] |= 0x00040000u;
  yaw_rate_offset_ = value;
}
inline void VehicleSpd::set_yaw_rate_offset(double value) {
  _internal_set_yaw_rate_offset(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.yaw_rate_offset)
}

// optional bool is_ax_valid = 19;
inline bool VehicleSpd::_internal_has_is_ax_valid() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool VehicleSpd::has_is_ax_valid() const {
  return _internal_has_is_ax_valid();
}
inline void VehicleSpd::clear_is_ax_valid() {
  is_ax_valid_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool VehicleSpd::_internal_is_ax_valid() const {
  return is_ax_valid_;
}
inline bool VehicleSpd::is_ax_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_ax_valid)
  return _internal_is_ax_valid();
}
inline void VehicleSpd::_internal_set_is_ax_valid(bool value) {
  _has_bits_[0] |= 0x00008000u;
  is_ax_valid_ = value;
}
inline void VehicleSpd::set_is_ax_valid(bool value) {
  _internal_set_is_ax_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_ax_valid)
}

// optional double ax = 20;
inline bool VehicleSpd::_internal_has_ax() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool VehicleSpd::has_ax() const {
  return _internal_has_ax();
}
inline void VehicleSpd::clear_ax() {
  ax_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline double VehicleSpd::_internal_ax() const {
  return ax_;
}
inline double VehicleSpd::ax() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.ax)
  return _internal_ax();
}
inline void VehicleSpd::_internal_set_ax(double value) {
  _has_bits_[0] |= 0x00080000u;
  ax_ = value;
}
inline void VehicleSpd::set_ax(double value) {
  _internal_set_ax(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.ax)
}

// optional double ax_offset = 21;
inline bool VehicleSpd::_internal_has_ax_offset() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool VehicleSpd::has_ax_offset() const {
  return _internal_has_ax_offset();
}
inline void VehicleSpd::clear_ax_offset() {
  ax_offset_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline double VehicleSpd::_internal_ax_offset() const {
  return ax_offset_;
}
inline double VehicleSpd::ax_offset() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.ax_offset)
  return _internal_ax_offset();
}
inline void VehicleSpd::_internal_set_ax_offset(double value) {
  _has_bits_[0] |= 0x00100000u;
  ax_offset_ = value;
}
inline void VehicleSpd::set_ax_offset(double value) {
  _internal_set_ax_offset(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.ax_offset)
}

// optional bool is_ay_valid = 22;
inline bool VehicleSpd::_internal_has_is_ay_valid() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool VehicleSpd::has_is_ay_valid() const {
  return _internal_has_is_ay_valid();
}
inline void VehicleSpd::clear_is_ay_valid() {
  is_ay_valid_ = false;
  _has_bits_[0] &= ~0x20000000u;
}
inline bool VehicleSpd::_internal_is_ay_valid() const {
  return is_ay_valid_;
}
inline bool VehicleSpd::is_ay_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_ay_valid)
  return _internal_is_ay_valid();
}
inline void VehicleSpd::_internal_set_is_ay_valid(bool value) {
  _has_bits_[0] |= 0x20000000u;
  is_ay_valid_ = value;
}
inline void VehicleSpd::set_is_ay_valid(bool value) {
  _internal_set_is_ay_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_ay_valid)
}

// optional double ay = 23;
inline bool VehicleSpd::_internal_has_ay() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool VehicleSpd::has_ay() const {
  return _internal_has_ay();
}
inline void VehicleSpd::clear_ay() {
  ay_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline double VehicleSpd::_internal_ay() const {
  return ay_;
}
inline double VehicleSpd::ay() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.ay)
  return _internal_ay();
}
inline void VehicleSpd::_internal_set_ay(double value) {
  _has_bits_[0] |= 0x00200000u;
  ay_ = value;
}
inline void VehicleSpd::set_ay(double value) {
  _internal_set_ay(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.ay)
}

// optional double ay_offset = 24;
inline bool VehicleSpd::_internal_has_ay_offset() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool VehicleSpd::has_ay_offset() const {
  return _internal_has_ay_offset();
}
inline void VehicleSpd::clear_ay_offset() {
  ay_offset_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline double VehicleSpd::_internal_ay_offset() const {
  return ay_offset_;
}
inline double VehicleSpd::ay_offset() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.ay_offset)
  return _internal_ay_offset();
}
inline void VehicleSpd::_internal_set_ay_offset(double value) {
  _has_bits_[0] |= 0x00400000u;
  ay_offset_ = value;
}
inline void VehicleSpd::set_ay_offset(double value) {
  _internal_set_ay_offset(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.ay_offset)
}

// optional double lat_acc = 25;
inline bool VehicleSpd::_internal_has_lat_acc() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool VehicleSpd::has_lat_acc() const {
  return _internal_has_lat_acc();
}
inline void VehicleSpd::clear_lat_acc() {
  lat_acc_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline double VehicleSpd::_internal_lat_acc() const {
  return lat_acc_;
}
inline double VehicleSpd::lat_acc() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.lat_acc)
  return _internal_lat_acc();
}
inline void VehicleSpd::_internal_set_lat_acc(double value) {
  _has_bits_[0] |= 0x00800000u;
  lat_acc_ = value;
}
inline void VehicleSpd::set_lat_acc(double value) {
  _internal_set_lat_acc(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.lat_acc)
}

// optional double long_acc = 26;
inline bool VehicleSpd::_internal_has_long_acc() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool VehicleSpd::has_long_acc() const {
  return _internal_has_long_acc();
}
inline void VehicleSpd::clear_long_acc() {
  long_acc_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline double VehicleSpd::_internal_long_acc() const {
  return long_acc_;
}
inline double VehicleSpd::long_acc() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.long_acc)
  return _internal_long_acc();
}
inline void VehicleSpd::_internal_set_long_acc(double value) {
  _has_bits_[0] |= 0x01000000u;
  long_acc_ = value;
}
inline void VehicleSpd::set_long_acc(double value) {
  _internal_set_long_acc(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.long_acc)
}

// optional double vert_acc = 27;
inline bool VehicleSpd::_internal_has_vert_acc() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool VehicleSpd::has_vert_acc() const {
  return _internal_has_vert_acc();
}
inline void VehicleSpd::clear_vert_acc() {
  vert_acc_ = 0;
  _has_bits_[0] &= ~0x02000000u;
}
inline double VehicleSpd::_internal_vert_acc() const {
  return vert_acc_;
}
inline double VehicleSpd::vert_acc() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.vert_acc)
  return _internal_vert_acc();
}
inline void VehicleSpd::_internal_set_vert_acc(double value) {
  _has_bits_[0] |= 0x02000000u;
  vert_acc_ = value;
}
inline void VehicleSpd::set_vert_acc(double value) {
  _internal_set_vert_acc(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.vert_acc)
}

// optional double roll_rate = 28;
inline bool VehicleSpd::_internal_has_roll_rate() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool VehicleSpd::has_roll_rate() const {
  return _internal_has_roll_rate();
}
inline void VehicleSpd::clear_roll_rate() {
  roll_rate_ = 0;
  _has_bits_[0] &= ~0x04000000u;
}
inline double VehicleSpd::_internal_roll_rate() const {
  return roll_rate_;
}
inline double VehicleSpd::roll_rate() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.roll_rate)
  return _internal_roll_rate();
}
inline void VehicleSpd::_internal_set_roll_rate(double value) {
  _has_bits_[0] |= 0x04000000u;
  roll_rate_ = value;
}
inline void VehicleSpd::set_roll_rate(double value) {
  _internal_set_roll_rate(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.roll_rate)
}

// optional double acc_est = 29;
inline bool VehicleSpd::_internal_has_acc_est() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool VehicleSpd::has_acc_est() const {
  return _internal_has_acc_est();
}
inline void VehicleSpd::clear_acc_est() {
  acc_est_ = 0;
  _has_bits_[0] &= ~0x08000000u;
}
inline double VehicleSpd::_internal_acc_est() const {
  return acc_est_;
}
inline double VehicleSpd::acc_est() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.acc_est)
  return _internal_acc_est();
}
inline void VehicleSpd::_internal_set_acc_est(double value) {
  _has_bits_[0] |= 0x08000000u;
  acc_est_ = value;
}
inline void VehicleSpd::set_acc_est(double value) {
  _internal_set_acc_est(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.acc_est)
}

// optional double timestamp_sec = 30;
inline bool VehicleSpd::_internal_has_timestamp_sec() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool VehicleSpd::has_timestamp_sec() const {
  return _internal_has_timestamp_sec();
}
inline void VehicleSpd::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  _has_bits_[0] &= ~0x10000000u;
}
inline double VehicleSpd::_internal_timestamp_sec() const {
  return timestamp_sec_;
}
inline double VehicleSpd::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.timestamp_sec)
  return _internal_timestamp_sec();
}
inline void VehicleSpd::_internal_set_timestamp_sec(double value) {
  _has_bits_[0] |= 0x10000000u;
  timestamp_sec_ = value;
}
inline void VehicleSpd::set_timestamp_sec(double value) {
  _internal_set_timestamp_sec(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.timestamp_sec)
}

// -------------------------------------------------------------------

// Deceleration

// optional bool is_deceleration_available = 1;
inline bool Deceleration::_internal_has_is_deceleration_available() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Deceleration::has_is_deceleration_available() const {
  return _internal_has_is_deceleration_available();
}
inline void Deceleration::clear_is_deceleration_available() {
  is_deceleration_available_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Deceleration::_internal_is_deceleration_available() const {
  return is_deceleration_available_;
}
inline bool Deceleration::is_deceleration_available() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.is_deceleration_available)
  return _internal_is_deceleration_available();
}
inline void Deceleration::_internal_set_is_deceleration_available(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_deceleration_available_ = value;
}
inline void Deceleration::set_is_deceleration_available(bool value) {
  _internal_set_is_deceleration_available(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.is_deceleration_available)
}

// optional bool is_deceleration_active = 2;
inline bool Deceleration::_internal_has_is_deceleration_active() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Deceleration::has_is_deceleration_active() const {
  return _internal_has_is_deceleration_active();
}
inline void Deceleration::clear_is_deceleration_active() {
  is_deceleration_active_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Deceleration::_internal_is_deceleration_active() const {
  return is_deceleration_active_;
}
inline bool Deceleration::is_deceleration_active() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.is_deceleration_active)
  return _internal_is_deceleration_active();
}
inline void Deceleration::_internal_set_is_deceleration_active(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_deceleration_active_ = value;
}
inline void Deceleration::set_is_deceleration_active(bool value) {
  _internal_set_is_deceleration_active(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.is_deceleration_active)
}

// optional double deceleration = 3 [default = 0];
inline bool Deceleration::_internal_has_deceleration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Deceleration::has_deceleration() const {
  return _internal_has_deceleration();
}
inline void Deceleration::clear_deceleration() {
  deceleration_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Deceleration::_internal_deceleration() const {
  return deceleration_;
}
inline double Deceleration::deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.deceleration)
  return _internal_deceleration();
}
inline void Deceleration::_internal_set_deceleration(double value) {
  _has_bits_[0] |= 0x00000001u;
  deceleration_ = value;
}
inline void Deceleration::set_deceleration(double value) {
  _internal_set_deceleration(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.deceleration)
}

// optional double is_evb_fail = 4;
inline bool Deceleration::_internal_has_is_evb_fail() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Deceleration::has_is_evb_fail() const {
  return _internal_has_is_evb_fail();
}
inline void Deceleration::clear_is_evb_fail() {
  is_evb_fail_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Deceleration::_internal_is_evb_fail() const {
  return is_evb_fail_;
}
inline double Deceleration::is_evb_fail() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.is_evb_fail)
  return _internal_is_evb_fail();
}
inline void Deceleration::_internal_set_is_evb_fail(double value) {
  _has_bits_[0] |= 0x00000002u;
  is_evb_fail_ = value;
}
inline void Deceleration::set_is_evb_fail(double value) {
  _internal_set_is_evb_fail(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.is_evb_fail)
}

// optional double evb_pressure = 5 [default = 0];
inline bool Deceleration::_internal_has_evb_pressure() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Deceleration::has_evb_pressure() const {
  return _internal_has_evb_pressure();
}
inline void Deceleration::clear_evb_pressure() {
  evb_pressure_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Deceleration::_internal_evb_pressure() const {
  return evb_pressure_;
}
inline double Deceleration::evb_pressure() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.evb_pressure)
  return _internal_evb_pressure();
}
inline void Deceleration::_internal_set_evb_pressure(double value) {
  _has_bits_[0] |= 0x00000004u;
  evb_pressure_ = value;
}
inline void Deceleration::set_evb_pressure(double value) {
  _internal_set_evb_pressure(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.evb_pressure)
}

// optional double brake_pressure = 6 [default = 0];
inline bool Deceleration::_internal_has_brake_pressure() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Deceleration::has_brake_pressure() const {
  return _internal_has_brake_pressure();
}
inline void Deceleration::clear_brake_pressure() {
  brake_pressure_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double Deceleration::_internal_brake_pressure() const {
  return brake_pressure_;
}
inline double Deceleration::brake_pressure() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.brake_pressure)
  return _internal_brake_pressure();
}
inline void Deceleration::_internal_set_brake_pressure(double value) {
  _has_bits_[0] |= 0x00000008u;
  brake_pressure_ = value;
}
inline void Deceleration::set_brake_pressure(double value) {
  _internal_set_brake_pressure(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.brake_pressure)
}

// optional double brake_pressure_spd = 7 [default = 0];
inline bool Deceleration::_internal_has_brake_pressure_spd() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Deceleration::has_brake_pressure_spd() const {
  return _internal_has_brake_pressure_spd();
}
inline void Deceleration::clear_brake_pressure_spd() {
  brake_pressure_spd_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double Deceleration::_internal_brake_pressure_spd() const {
  return brake_pressure_spd_;
}
inline double Deceleration::brake_pressure_spd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.brake_pressure_spd)
  return _internal_brake_pressure_spd();
}
inline void Deceleration::_internal_set_brake_pressure_spd(double value) {
  _has_bits_[0] |= 0x00000010u;
  brake_pressure_spd_ = value;
}
inline void Deceleration::set_brake_pressure_spd(double value) {
  _internal_set_brake_pressure_spd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.brake_pressure_spd)
}

// -------------------------------------------------------------------

// Brake

// optional bool is_brake_pedal_pressed = 1 [default = false];
inline bool Brake::_internal_has_is_brake_pedal_pressed() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Brake::has_is_brake_pedal_pressed() const {
  return _internal_has_is_brake_pedal_pressed();
}
inline void Brake::clear_is_brake_pedal_pressed() {
  is_brake_pedal_pressed_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Brake::_internal_is_brake_pedal_pressed() const {
  return is_brake_pedal_pressed_;
}
inline bool Brake::is_brake_pedal_pressed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.is_brake_pedal_pressed)
  return _internal_is_brake_pedal_pressed();
}
inline void Brake::_internal_set_is_brake_pedal_pressed(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_brake_pedal_pressed_ = value;
}
inline void Brake::set_is_brake_pedal_pressed(bool value) {
  _internal_set_is_brake_pedal_pressed(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.is_brake_pedal_pressed)
}

// optional bool is_brake_force_exist = 2;
inline bool Brake::_internal_has_is_brake_force_exist() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Brake::has_is_brake_force_exist() const {
  return _internal_has_is_brake_force_exist();
}
inline void Brake::clear_is_brake_force_exist() {
  is_brake_force_exist_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Brake::_internal_is_brake_force_exist() const {
  return is_brake_force_exist_;
}
inline bool Brake::is_brake_force_exist() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.is_brake_force_exist)
  return _internal_is_brake_force_exist();
}
inline void Brake::_internal_set_is_brake_force_exist(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_brake_force_exist_ = value;
}
inline void Brake::set_is_brake_force_exist(bool value) {
  _internal_set_is_brake_force_exist(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.is_brake_force_exist)
}

// optional bool is_brake_over_heat = 3;
inline bool Brake::_internal_has_is_brake_over_heat() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Brake::has_is_brake_over_heat() const {
  return _internal_has_is_brake_over_heat();
}
inline void Brake::clear_is_brake_over_heat() {
  is_brake_over_heat_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Brake::_internal_is_brake_over_heat() const {
  return is_brake_over_heat_;
}
inline bool Brake::is_brake_over_heat() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.is_brake_over_heat)
  return _internal_is_brake_over_heat();
}
inline void Brake::_internal_set_is_brake_over_heat(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_brake_over_heat_ = value;
}
inline void Brake::set_is_brake_over_heat(bool value) {
  _internal_set_is_brake_over_heat(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.is_brake_over_heat)
}

// optional bool is_hand_brake_on = 4;
inline bool Brake::_internal_has_is_hand_brake_on() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Brake::has_is_hand_brake_on() const {
  return _internal_has_is_hand_brake_on();
}
inline void Brake::clear_is_hand_brake_on() {
  is_hand_brake_on_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Brake::_internal_is_hand_brake_on() const {
  return is_hand_brake_on_;
}
inline bool Brake::is_hand_brake_on() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.is_hand_brake_on)
  return _internal_is_hand_brake_on();
}
inline void Brake::_internal_set_is_hand_brake_on(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_hand_brake_on_ = value;
}
inline void Brake::set_is_hand_brake_on(bool value) {
  _internal_set_is_hand_brake_on(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.is_hand_brake_on)
}

// optional double brake_pedal_position = 5;
inline bool Brake::_internal_has_brake_pedal_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Brake::has_brake_pedal_position() const {
  return _internal_has_brake_pedal_position();
}
inline void Brake::clear_brake_pedal_position() {
  brake_pedal_position_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Brake::_internal_brake_pedal_position() const {
  return brake_pedal_position_;
}
inline double Brake::brake_pedal_position() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_pedal_position)
  return _internal_brake_pedal_position();
}
inline void Brake::_internal_set_brake_pedal_position(double value) {
  _has_bits_[0] |= 0x00000001u;
  brake_pedal_position_ = value;
}
inline void Brake::set_brake_pedal_position(double value) {
  _internal_set_brake_pedal_position(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_pedal_position)
}

// optional bool is_brake_valid = 6;
inline bool Brake::_internal_has_is_brake_valid() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Brake::has_is_brake_valid() const {
  return _internal_has_is_brake_valid();
}
inline void Brake::clear_is_brake_valid() {
  is_brake_valid_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Brake::_internal_is_brake_valid() const {
  return is_brake_valid_;
}
inline bool Brake::is_brake_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.is_brake_valid)
  return _internal_is_brake_valid();
}
inline void Brake::_internal_set_is_brake_valid(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_brake_valid_ = value;
}
inline void Brake::set_is_brake_valid(bool value) {
  _internal_set_is_brake_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.is_brake_valid)
}

// optional double brake_input = 7;
inline bool Brake::_internal_has_brake_input() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Brake::has_brake_input() const {
  return _internal_has_brake_input();
}
inline void Brake::clear_brake_input() {
  brake_input_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double Brake::_internal_brake_input() const {
  return brake_input_;
}
inline double Brake::brake_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_input)
  return _internal_brake_input();
}
inline void Brake::_internal_set_brake_input(double value) {
  _has_bits_[0] |= 0x00000200u;
  brake_input_ = value;
}
inline void Brake::set_brake_input(double value) {
  _internal_set_brake_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_input)
}

// optional double brake_cmd = 8;
inline bool Brake::_internal_has_brake_cmd() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Brake::has_brake_cmd() const {
  return _internal_has_brake_cmd();
}
inline void Brake::clear_brake_cmd() {
  brake_cmd_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline double Brake::_internal_brake_cmd() const {
  return brake_cmd_;
}
inline double Brake::brake_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_cmd)
  return _internal_brake_cmd();
}
inline void Brake::_internal_set_brake_cmd(double value) {
  _has_bits_[0] |= 0x00000400u;
  brake_cmd_ = value;
}
inline void Brake::set_brake_cmd(double value) {
  _internal_set_brake_cmd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_cmd)
}

// optional double brake_output = 9;
inline bool Brake::_internal_has_brake_output() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Brake::has_brake_output() const {
  return _internal_has_brake_output();
}
inline void Brake::clear_brake_output() {
  brake_output_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline double Brake::_internal_brake_output() const {
  return brake_output_;
}
inline double Brake::brake_output() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_output)
  return _internal_brake_output();
}
inline void Brake::_internal_set_brake_output(double value) {
  _has_bits_[0] |= 0x00000800u;
  brake_output_ = value;
}
inline void Brake::set_brake_output(double value) {
  _internal_set_brake_output(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_output)
}

// optional bool boo_input = 10;
inline bool Brake::_internal_has_boo_input() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Brake::has_boo_input() const {
  return _internal_has_boo_input();
}
inline void Brake::clear_boo_input() {
  boo_input_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Brake::_internal_boo_input() const {
  return boo_input_;
}
inline bool Brake::boo_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.boo_input)
  return _internal_boo_input();
}
inline void Brake::_internal_set_boo_input(bool value) {
  _has_bits_[0] |= 0x00000040u;
  boo_input_ = value;
}
inline void Brake::set_boo_input(bool value) {
  _internal_set_boo_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.boo_input)
}

// optional bool boo_cmd = 11;
inline bool Brake::_internal_has_boo_cmd() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Brake::has_boo_cmd() const {
  return _internal_has_boo_cmd();
}
inline void Brake::clear_boo_cmd() {
  boo_cmd_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Brake::_internal_boo_cmd() const {
  return boo_cmd_;
}
inline bool Brake::boo_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.boo_cmd)
  return _internal_boo_cmd();
}
inline void Brake::_internal_set_boo_cmd(bool value) {
  _has_bits_[0] |= 0x00000080u;
  boo_cmd_ = value;
}
inline void Brake::set_boo_cmd(bool value) {
  _internal_set_boo_cmd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.boo_cmd)
}

// optional bool boo_output = 12;
inline bool Brake::_internal_has_boo_output() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Brake::has_boo_output() const {
  return _internal_has_boo_output();
}
inline void Brake::clear_boo_output() {
  boo_output_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Brake::_internal_boo_output() const {
  return boo_output_;
}
inline bool Brake::boo_output() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.boo_output)
  return _internal_boo_output();
}
inline void Brake::_internal_set_boo_output(bool value) {
  _has_bits_[0] |= 0x00000100u;
  boo_output_ = value;
}
inline void Brake::set_boo_output(bool value) {
  _internal_set_boo_output(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.boo_output)
}

// optional bool watchdog_applying_brakes = 13;
inline bool Brake::_internal_has_watchdog_applying_brakes() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Brake::has_watchdog_applying_brakes() const {
  return _internal_has_watchdog_applying_brakes();
}
inline void Brake::clear_watchdog_applying_brakes() {
  watchdog_applying_brakes_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool Brake::_internal_watchdog_applying_brakes() const {
  return watchdog_applying_brakes_;
}
inline bool Brake::watchdog_applying_brakes() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.watchdog_applying_brakes)
  return _internal_watchdog_applying_brakes();
}
inline void Brake::_internal_set_watchdog_applying_brakes(bool value) {
  _has_bits_[0] |= 0x00002000u;
  watchdog_applying_brakes_ = value;
}
inline void Brake::set_watchdog_applying_brakes(bool value) {
  _internal_set_watchdog_applying_brakes(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.watchdog_applying_brakes)
}

// optional int32 watchdog_source = 14;
inline bool Brake::_internal_has_watchdog_source() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Brake::has_watchdog_source() const {
  return _internal_has_watchdog_source();
}
inline void Brake::clear_watchdog_source() {
  watchdog_source_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Brake::_internal_watchdog_source() const {
  return watchdog_source_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Brake::watchdog_source() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.watchdog_source)
  return _internal_watchdog_source();
}
inline void Brake::_internal_set_watchdog_source(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00001000u;
  watchdog_source_ = value;
}
inline void Brake::set_watchdog_source(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_watchdog_source(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.watchdog_source)
}

// optional bool brake_enabled = 15;
inline bool Brake::_internal_has_brake_enabled() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Brake::has_brake_enabled() const {
  return _internal_has_brake_enabled();
}
inline void Brake::clear_brake_enabled() {
  brake_enabled_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool Brake::_internal_brake_enabled() const {
  return brake_enabled_;
}
inline bool Brake::brake_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_enabled)
  return _internal_brake_enabled();
}
inline void Brake::_internal_set_brake_enabled(bool value) {
  _has_bits_[0] |= 0x00004000u;
  brake_enabled_ = value;
}
inline void Brake::set_brake_enabled(bool value) {
  _internal_set_brake_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_enabled)
}

// optional bool driver_override = 16;
inline bool Brake::_internal_has_driver_override() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Brake::has_driver_override() const {
  return _internal_has_driver_override();
}
inline void Brake::clear_driver_override() {
  driver_override_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool Brake::_internal_driver_override() const {
  return driver_override_;
}
inline bool Brake::driver_override() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.driver_override)
  return _internal_driver_override();
}
inline void Brake::_internal_set_driver_override(bool value) {
  _has_bits_[0] |= 0x00008000u;
  driver_override_ = value;
}
inline void Brake::set_driver_override(bool value) {
  _internal_set_driver_override(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.driver_override)
}

// optional bool driver_activity = 17;
inline bool Brake::_internal_has_driver_activity() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Brake::has_driver_activity() const {
  return _internal_has_driver_activity();
}
inline void Brake::clear_driver_activity() {
  driver_activity_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool Brake::_internal_driver_activity() const {
  return driver_activity_;
}
inline bool Brake::driver_activity() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.driver_activity)
  return _internal_driver_activity();
}
inline void Brake::_internal_set_driver_activity(bool value) {
  _has_bits_[0] |= 0x00010000u;
  driver_activity_ = value;
}
inline void Brake::set_driver_activity(bool value) {
  _internal_set_driver_activity(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.driver_activity)
}

// optional bool watchdog_fault = 18;
inline bool Brake::_internal_has_watchdog_fault() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Brake::has_watchdog_fault() const {
  return _internal_has_watchdog_fault();
}
inline void Brake::clear_watchdog_fault() {
  watchdog_fault_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool Brake::_internal_watchdog_fault() const {
  return watchdog_fault_;
}
inline bool Brake::watchdog_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.watchdog_fault)
  return _internal_watchdog_fault();
}
inline void Brake::_internal_set_watchdog_fault(bool value) {
  _has_bits_[0] |= 0x00020000u;
  watchdog_fault_ = value;
}
inline void Brake::set_watchdog_fault(bool value) {
  _internal_set_watchdog_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.watchdog_fault)
}

// optional bool channel_1_fault = 19;
inline bool Brake::_internal_has_channel_1_fault() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Brake::has_channel_1_fault() const {
  return _internal_has_channel_1_fault();
}
inline void Brake::clear_channel_1_fault() {
  channel_1_fault_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool Brake::_internal_channel_1_fault() const {
  return channel_1_fault_;
}
inline bool Brake::channel_1_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.channel_1_fault)
  return _internal_channel_1_fault();
}
inline void Brake::_internal_set_channel_1_fault(bool value) {
  _has_bits_[0] |= 0x00040000u;
  channel_1_fault_ = value;
}
inline void Brake::set_channel_1_fault(bool value) {
  _internal_set_channel_1_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.channel_1_fault)
}

// optional bool channel_2_fault = 20;
inline bool Brake::_internal_has_channel_2_fault() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Brake::has_channel_2_fault() const {
  return _internal_has_channel_2_fault();
}
inline void Brake::clear_channel_2_fault() {
  channel_2_fault_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool Brake::_internal_channel_2_fault() const {
  return channel_2_fault_;
}
inline bool Brake::channel_2_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.channel_2_fault)
  return _internal_channel_2_fault();
}
inline void Brake::_internal_set_channel_2_fault(bool value) {
  _has_bits_[0] |= 0x00080000u;
  channel_2_fault_ = value;
}
inline void Brake::set_channel_2_fault(bool value) {
  _internal_set_channel_2_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.channel_2_fault)
}

// optional bool boo_fault = 21;
inline bool Brake::_internal_has_boo_fault() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Brake::has_boo_fault() const {
  return _internal_has_boo_fault();
}
inline void Brake::clear_boo_fault() {
  boo_fault_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool Brake::_internal_boo_fault() const {
  return boo_fault_;
}
inline bool Brake::boo_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.boo_fault)
  return _internal_boo_fault();
}
inline void Brake::_internal_set_boo_fault(bool value) {
  _has_bits_[0] |= 0x00100000u;
  boo_fault_ = value;
}
inline void Brake::set_boo_fault(bool value) {
  _internal_set_boo_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.boo_fault)
}

// optional bool connector_fault = 22;
inline bool Brake::_internal_has_connector_fault() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Brake::has_connector_fault() const {
  return _internal_has_connector_fault();
}
inline void Brake::clear_connector_fault() {
  connector_fault_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool Brake::_internal_connector_fault() const {
  return connector_fault_;
}
inline bool Brake::connector_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.connector_fault)
  return _internal_connector_fault();
}
inline void Brake::_internal_set_connector_fault(bool value) {
  _has_bits_[0] |= 0x00200000u;
  connector_fault_ = value;
}
inline void Brake::set_connector_fault(bool value) {
  _internal_set_connector_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.connector_fault)
}

// optional double brake_torque_req = 23;
inline bool Brake::_internal_has_brake_torque_req() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Brake::has_brake_torque_req() const {
  return _internal_has_brake_torque_req();
}
inline void Brake::clear_brake_torque_req() {
  brake_torque_req_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline double Brake::_internal_brake_torque_req() const {
  return brake_torque_req_;
}
inline double Brake::brake_torque_req() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_torque_req)
  return _internal_brake_torque_req();
}
inline void Brake::_internal_set_brake_torque_req(double value) {
  _has_bits_[0] |= 0x00400000u;
  brake_torque_req_ = value;
}
inline void Brake::set_brake_torque_req(double value) {
  _internal_set_brake_torque_req(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_torque_req)
}

// optional .apollo.canbus.Brake.HSAStatusType hsa_status = 24;
inline bool Brake::_internal_has_hsa_status() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool Brake::has_hsa_status() const {
  return _internal_has_hsa_status();
}
inline void Brake::clear_hsa_status() {
  hsa_status_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::apollo::canbus::Brake_HSAStatusType Brake::_internal_hsa_status() const {
  return static_cast< ::apollo::canbus::Brake_HSAStatusType >(hsa_status_);
}
inline ::apollo::canbus::Brake_HSAStatusType Brake::hsa_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.hsa_status)
  return _internal_hsa_status();
}
inline void Brake::_internal_set_hsa_status(::apollo::canbus::Brake_HSAStatusType value) {
  assert(::apollo::canbus::Brake_HSAStatusType_IsValid(value));
  _has_bits_[0] |= 0x01000000u;
  hsa_status_ = value;
}
inline void Brake::set_hsa_status(::apollo::canbus::Brake_HSAStatusType value) {
  _internal_set_hsa_status(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.hsa_status)
}

// optional double brake_torque_act = 25;
inline bool Brake::_internal_has_brake_torque_act() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Brake::has_brake_torque_act() const {
  return _internal_has_brake_torque_act();
}
inline void Brake::clear_brake_torque_act() {
  brake_torque_act_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline double Brake::_internal_brake_torque_act() const {
  return brake_torque_act_;
}
inline double Brake::brake_torque_act() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_torque_act)
  return _internal_brake_torque_act();
}
inline void Brake::_internal_set_brake_torque_act(double value) {
  _has_bits_[0] |= 0x00800000u;
  brake_torque_act_ = value;
}
inline void Brake::set_brake_torque_act(double value) {
  _internal_set_brake_torque_act(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_torque_act)
}

// optional .apollo.canbus.Brake.HSAModeType hsa_mode = 26;
inline bool Brake::_internal_has_hsa_mode() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool Brake::has_hsa_mode() const {
  return _internal_has_hsa_mode();
}
inline void Brake::clear_hsa_mode() {
  hsa_mode_ = 0;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::apollo::canbus::Brake_HSAModeType Brake::_internal_hsa_mode() const {
  return static_cast< ::apollo::canbus::Brake_HSAModeType >(hsa_mode_);
}
inline ::apollo::canbus::Brake_HSAModeType Brake::hsa_mode() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.hsa_mode)
  return _internal_hsa_mode();
}
inline void Brake::_internal_set_hsa_mode(::apollo::canbus::Brake_HSAModeType value) {
  assert(::apollo::canbus::Brake_HSAModeType_IsValid(value));
  _has_bits_[0] |= 0x02000000u;
  hsa_mode_ = value;
}
inline void Brake::set_hsa_mode(::apollo::canbus::Brake_HSAModeType value) {
  _internal_set_hsa_mode(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.hsa_mode)
}

// optional double wheel_torque_act = 27;
inline bool Brake::_internal_has_wheel_torque_act() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool Brake::has_wheel_torque_act() const {
  return _internal_has_wheel_torque_act();
}
inline void Brake::clear_wheel_torque_act() {
  wheel_torque_act_ = 0;
  _has_bits_[0] &= ~0x04000000u;
}
inline double Brake::_internal_wheel_torque_act() const {
  return wheel_torque_act_;
}
inline double Brake::wheel_torque_act() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.wheel_torque_act)
  return _internal_wheel_torque_act();
}
inline void Brake::_internal_set_wheel_torque_act(double value) {
  _has_bits_[0] |= 0x04000000u;
  wheel_torque_act_ = value;
}
inline void Brake::set_wheel_torque_act(double value) {
  _internal_set_wheel_torque_act(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.wheel_torque_act)
}

// optional int32 major_version = 28;
inline bool Brake::_internal_has_major_version() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool Brake::has_major_version() const {
  return _internal_has_major_version();
}
inline void Brake::clear_major_version() {
  major_version_ = 0;
  _has_bits_[0] &= ~0x08000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Brake::_internal_major_version() const {
  return major_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Brake::major_version() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.major_version)
  return _internal_major_version();
}
inline void Brake::_internal_set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x08000000u;
  major_version_ = value;
}
inline void Brake::set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_major_version(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.major_version)
}

// optional int32 minor_version = 29;
inline bool Brake::_internal_has_minor_version() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool Brake::has_minor_version() const {
  return _internal_has_minor_version();
}
inline void Brake::clear_minor_version() {
  minor_version_ = 0;
  _has_bits_[0] &= ~0x10000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Brake::_internal_minor_version() const {
  return minor_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Brake::minor_version() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.minor_version)
  return _internal_minor_version();
}
inline void Brake::_internal_set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x10000000u;
  minor_version_ = value;
}
inline void Brake::set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_minor_version(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.minor_version)
}

// optional int32 build_number = 30;
inline bool Brake::_internal_has_build_number() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool Brake::has_build_number() const {
  return _internal_has_build_number();
}
inline void Brake::clear_build_number() {
  build_number_ = 0;
  _has_bits_[0] &= ~0x20000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Brake::_internal_build_number() const {
  return build_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Brake::build_number() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.build_number)
  return _internal_build_number();
}
inline void Brake::_internal_set_build_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x20000000u;
  build_number_ = value;
}
inline void Brake::set_build_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_build_number(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.build_number)
}

// -------------------------------------------------------------------

// Epb

// optional bool is_epb_error = 1;
inline bool Epb::_internal_has_is_epb_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Epb::has_is_epb_error() const {
  return _internal_has_is_epb_error();
}
inline void Epb::clear_is_epb_error() {
  is_epb_error_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool Epb::_internal_is_epb_error() const {
  return is_epb_error_;
}
inline bool Epb::is_epb_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Epb.is_epb_error)
  return _internal_is_epb_error();
}
inline void Epb::_internal_set_is_epb_error(bool value) {
  _has_bits_[0] |= 0x00000001u;
  is_epb_error_ = value;
}
inline void Epb::set_is_epb_error(bool value) {
  _internal_set_is_epb_error(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Epb.is_epb_error)
}

// optional bool is_epb_released = 2;
inline bool Epb::_internal_has_is_epb_released() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Epb::has_is_epb_released() const {
  return _internal_has_is_epb_released();
}
inline void Epb::clear_is_epb_released() {
  is_epb_released_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Epb::_internal_is_epb_released() const {
  return is_epb_released_;
}
inline bool Epb::is_epb_released() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Epb.is_epb_released)
  return _internal_is_epb_released();
}
inline void Epb::_internal_set_is_epb_released(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_epb_released_ = value;
}
inline void Epb::set_is_epb_released(bool value) {
  _internal_set_is_epb_released(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Epb.is_epb_released)
}

// optional int32 epb_status = 3;
inline bool Epb::_internal_has_epb_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Epb::has_epb_status() const {
  return _internal_has_epb_status();
}
inline void Epb::clear_epb_status() {
  epb_status_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Epb::_internal_epb_status() const {
  return epb_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Epb::epb_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Epb.epb_status)
  return _internal_epb_status();
}
inline void Epb::_internal_set_epb_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  epb_status_ = value;
}
inline void Epb::set_epb_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_epb_status(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Epb.epb_status)
}

// optional .apollo.canbus.Epb.PBrakeType parking_brake_status = 4;
inline bool Epb::_internal_has_parking_brake_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Epb::has_parking_brake_status() const {
  return _internal_has_parking_brake_status();
}
inline void Epb::clear_parking_brake_status() {
  parking_brake_status_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::apollo::canbus::Epb_PBrakeType Epb::_internal_parking_brake_status() const {
  return static_cast< ::apollo::canbus::Epb_PBrakeType >(parking_brake_status_);
}
inline ::apollo::canbus::Epb_PBrakeType Epb::parking_brake_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Epb.parking_brake_status)
  return _internal_parking_brake_status();
}
inline void Epb::_internal_set_parking_brake_status(::apollo::canbus::Epb_PBrakeType value) {
  assert(::apollo::canbus::Epb_PBrakeType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  parking_brake_status_ = value;
}
inline void Epb::set_parking_brake_status(::apollo::canbus::Epb_PBrakeType value) {
  _internal_set_parking_brake_status(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Epb.parking_brake_status)
}

// -------------------------------------------------------------------

// Gas

// optional bool is_gas_pedal_error = 1;
inline bool Gas::_internal_has_is_gas_pedal_error() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Gas::has_is_gas_pedal_error() const {
  return _internal_has_is_gas_pedal_error();
}
inline void Gas::clear_is_gas_pedal_error() {
  is_gas_pedal_error_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Gas::_internal_is_gas_pedal_error() const {
  return is_gas_pedal_error_;
}
inline bool Gas::is_gas_pedal_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.is_gas_pedal_error)
  return _internal_is_gas_pedal_error();
}
inline void Gas::_internal_set_is_gas_pedal_error(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_gas_pedal_error_ = value;
}
inline void Gas::set_is_gas_pedal_error(bool value) {
  _internal_set_is_gas_pedal_error(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.is_gas_pedal_error)
}

// optional bool is_gas_pedal_pressed_more = 2;
inline bool Gas::_internal_has_is_gas_pedal_pressed_more() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Gas::has_is_gas_pedal_pressed_more() const {
  return _internal_has_is_gas_pedal_pressed_more();
}
inline void Gas::clear_is_gas_pedal_pressed_more() {
  is_gas_pedal_pressed_more_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Gas::_internal_is_gas_pedal_pressed_more() const {
  return is_gas_pedal_pressed_more_;
}
inline bool Gas::is_gas_pedal_pressed_more() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.is_gas_pedal_pressed_more)
  return _internal_is_gas_pedal_pressed_more();
}
inline void Gas::_internal_set_is_gas_pedal_pressed_more(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_gas_pedal_pressed_more_ = value;
}
inline void Gas::set_is_gas_pedal_pressed_more(bool value) {
  _internal_set_is_gas_pedal_pressed_more(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.is_gas_pedal_pressed_more)
}

// optional double gas_pedal_position = 3 [default = 0];
inline bool Gas::_internal_has_gas_pedal_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Gas::has_gas_pedal_position() const {
  return _internal_has_gas_pedal_position();
}
inline void Gas::clear_gas_pedal_position() {
  gas_pedal_position_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Gas::_internal_gas_pedal_position() const {
  return gas_pedal_position_;
}
inline double Gas::gas_pedal_position() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.gas_pedal_position)
  return _internal_gas_pedal_position();
}
inline void Gas::_internal_set_gas_pedal_position(double value) {
  _has_bits_[0] |= 0x00000001u;
  gas_pedal_position_ = value;
}
inline void Gas::set_gas_pedal_position(double value) {
  _internal_set_gas_pedal_position(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.gas_pedal_position)
}

// optional bool is_gas_valid = 4 [default = false];
inline bool Gas::_internal_has_is_gas_valid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Gas::has_is_gas_valid() const {
  return _internal_has_is_gas_valid();
}
inline void Gas::clear_is_gas_valid() {
  is_gas_valid_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Gas::_internal_is_gas_valid() const {
  return is_gas_valid_;
}
inline bool Gas::is_gas_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.is_gas_valid)
  return _internal_is_gas_valid();
}
inline void Gas::_internal_set_is_gas_valid(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_gas_valid_ = value;
}
inline void Gas::set_is_gas_valid(bool value) {
  _internal_set_is_gas_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.is_gas_valid)
}

// optional double throttle_input = 5;
inline bool Gas::_internal_has_throttle_input() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Gas::has_throttle_input() const {
  return _internal_has_throttle_input();
}
inline void Gas::clear_throttle_input() {
  throttle_input_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double Gas::_internal_throttle_input() const {
  return throttle_input_;
}
inline double Gas::throttle_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.throttle_input)
  return _internal_throttle_input();
}
inline void Gas::_internal_set_throttle_input(double value) {
  _has_bits_[0] |= 0x00000040u;
  throttle_input_ = value;
}
inline void Gas::set_throttle_input(double value) {
  _internal_set_throttle_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.throttle_input)
}

// optional double throttle_cmd = 6;
inline bool Gas::_internal_has_throttle_cmd() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Gas::has_throttle_cmd() const {
  return _internal_has_throttle_cmd();
}
inline void Gas::clear_throttle_cmd() {
  throttle_cmd_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double Gas::_internal_throttle_cmd() const {
  return throttle_cmd_;
}
inline double Gas::throttle_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.throttle_cmd)
  return _internal_throttle_cmd();
}
inline void Gas::_internal_set_throttle_cmd(double value) {
  _has_bits_[0] |= 0x00000080u;
  throttle_cmd_ = value;
}
inline void Gas::set_throttle_cmd(double value) {
  _internal_set_throttle_cmd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.throttle_cmd)
}

// optional double throttle_output = 7;
inline bool Gas::_internal_has_throttle_output() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Gas::has_throttle_output() const {
  return _internal_has_throttle_output();
}
inline void Gas::clear_throttle_output() {
  throttle_output_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double Gas::_internal_throttle_output() const {
  return throttle_output_;
}
inline double Gas::throttle_output() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.throttle_output)
  return _internal_throttle_output();
}
inline void Gas::_internal_set_throttle_output(double value) {
  _has_bits_[0] |= 0x00000100u;
  throttle_output_ = value;
}
inline void Gas::set_throttle_output(double value) {
  _internal_set_throttle_output(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.throttle_output)
}

// optional int32 watchdog_source = 8;
inline bool Gas::_internal_has_watchdog_source() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Gas::has_watchdog_source() const {
  return _internal_has_watchdog_source();
}
inline void Gas::clear_watchdog_source() {
  watchdog_source_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gas::_internal_watchdog_source() const {
  return watchdog_source_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gas::watchdog_source() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.watchdog_source)
  return _internal_watchdog_source();
}
inline void Gas::_internal_set_watchdog_source(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  watchdog_source_ = value;
}
inline void Gas::set_watchdog_source(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_watchdog_source(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.watchdog_source)
}

// optional bool throttle_enabled = 9;
inline bool Gas::_internal_has_throttle_enabled() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Gas::has_throttle_enabled() const {
  return _internal_has_throttle_enabled();
}
inline void Gas::clear_throttle_enabled() {
  throttle_enabled_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Gas::_internal_throttle_enabled() const {
  return throttle_enabled_;
}
inline bool Gas::throttle_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.throttle_enabled)
  return _internal_throttle_enabled();
}
inline void Gas::_internal_set_throttle_enabled(bool value) {
  _has_bits_[0] |= 0x00000010u;
  throttle_enabled_ = value;
}
inline void Gas::set_throttle_enabled(bool value) {
  _internal_set_throttle_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.throttle_enabled)
}

// optional bool driver_override = 10;
inline bool Gas::_internal_has_driver_override() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Gas::has_driver_override() const {
  return _internal_has_driver_override();
}
inline void Gas::clear_driver_override() {
  driver_override_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool Gas::_internal_driver_override() const {
  return driver_override_;
}
inline bool Gas::driver_override() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.driver_override)
  return _internal_driver_override();
}
inline void Gas::_internal_set_driver_override(bool value) {
  _has_bits_[0] |= 0x00000200u;
  driver_override_ = value;
}
inline void Gas::set_driver_override(bool value) {
  _internal_set_driver_override(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.driver_override)
}

// optional bool driver_activity = 11;
inline bool Gas::_internal_has_driver_activity() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Gas::has_driver_activity() const {
  return _internal_has_driver_activity();
}
inline void Gas::clear_driver_activity() {
  driver_activity_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool Gas::_internal_driver_activity() const {
  return driver_activity_;
}
inline bool Gas::driver_activity() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.driver_activity)
  return _internal_driver_activity();
}
inline void Gas::_internal_set_driver_activity(bool value) {
  _has_bits_[0] |= 0x00000400u;
  driver_activity_ = value;
}
inline void Gas::set_driver_activity(bool value) {
  _internal_set_driver_activity(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.driver_activity)
}

// optional bool watchdog_fault = 12;
inline bool Gas::_internal_has_watchdog_fault() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Gas::has_watchdog_fault() const {
  return _internal_has_watchdog_fault();
}
inline void Gas::clear_watchdog_fault() {
  watchdog_fault_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool Gas::_internal_watchdog_fault() const {
  return watchdog_fault_;
}
inline bool Gas::watchdog_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.watchdog_fault)
  return _internal_watchdog_fault();
}
inline void Gas::_internal_set_watchdog_fault(bool value) {
  _has_bits_[0] |= 0x00000800u;
  watchdog_fault_ = value;
}
inline void Gas::set_watchdog_fault(bool value) {
  _internal_set_watchdog_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.watchdog_fault)
}

// optional bool channel_1_fault = 13;
inline bool Gas::_internal_has_channel_1_fault() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Gas::has_channel_1_fault() const {
  return _internal_has_channel_1_fault();
}
inline void Gas::clear_channel_1_fault() {
  channel_1_fault_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool Gas::_internal_channel_1_fault() const {
  return channel_1_fault_;
}
inline bool Gas::channel_1_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.channel_1_fault)
  return _internal_channel_1_fault();
}
inline void Gas::_internal_set_channel_1_fault(bool value) {
  _has_bits_[0] |= 0x00001000u;
  channel_1_fault_ = value;
}
inline void Gas::set_channel_1_fault(bool value) {
  _internal_set_channel_1_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.channel_1_fault)
}

// optional bool channel_2_fault = 14;
inline bool Gas::_internal_has_channel_2_fault() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Gas::has_channel_2_fault() const {
  return _internal_has_channel_2_fault();
}
inline void Gas::clear_channel_2_fault() {
  channel_2_fault_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool Gas::_internal_channel_2_fault() const {
  return channel_2_fault_;
}
inline bool Gas::channel_2_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.channel_2_fault)
  return _internal_channel_2_fault();
}
inline void Gas::_internal_set_channel_2_fault(bool value) {
  _has_bits_[0] |= 0x00002000u;
  channel_2_fault_ = value;
}
inline void Gas::set_channel_2_fault(bool value) {
  _internal_set_channel_2_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.channel_2_fault)
}

// optional bool connector_fault = 15;
inline bool Gas::_internal_has_connector_fault() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Gas::has_connector_fault() const {
  return _internal_has_connector_fault();
}
inline void Gas::clear_connector_fault() {
  connector_fault_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool Gas::_internal_connector_fault() const {
  return connector_fault_;
}
inline bool Gas::connector_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.connector_fault)
  return _internal_connector_fault();
}
inline void Gas::_internal_set_connector_fault(bool value) {
  _has_bits_[0] |= 0x00004000u;
  connector_fault_ = value;
}
inline void Gas::set_connector_fault(bool value) {
  _internal_set_connector_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.connector_fault)
}

// optional double accelerator_pedal = 16;
inline bool Gas::_internal_has_accelerator_pedal() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Gas::has_accelerator_pedal() const {
  return _internal_has_accelerator_pedal();
}
inline void Gas::clear_accelerator_pedal() {
  accelerator_pedal_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline double Gas::_internal_accelerator_pedal() const {
  return accelerator_pedal_;
}
inline double Gas::accelerator_pedal() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.accelerator_pedal)
  return _internal_accelerator_pedal();
}
inline void Gas::_internal_set_accelerator_pedal(double value) {
  _has_bits_[0] |= 0x00008000u;
  accelerator_pedal_ = value;
}
inline void Gas::set_accelerator_pedal(double value) {
  _internal_set_accelerator_pedal(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.accelerator_pedal)
}

// optional double accelerator_pedal_rate = 17;
inline bool Gas::_internal_has_accelerator_pedal_rate() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Gas::has_accelerator_pedal_rate() const {
  return _internal_has_accelerator_pedal_rate();
}
inline void Gas::clear_accelerator_pedal_rate() {
  accelerator_pedal_rate_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline double Gas::_internal_accelerator_pedal_rate() const {
  return accelerator_pedal_rate_;
}
inline double Gas::accelerator_pedal_rate() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.accelerator_pedal_rate)
  return _internal_accelerator_pedal_rate();
}
inline void Gas::_internal_set_accelerator_pedal_rate(double value) {
  _has_bits_[0] |= 0x00010000u;
  accelerator_pedal_rate_ = value;
}
inline void Gas::set_accelerator_pedal_rate(double value) {
  _internal_set_accelerator_pedal_rate(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.accelerator_pedal_rate)
}

// optional int32 major_version = 18;
inline bool Gas::_internal_has_major_version() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Gas::has_major_version() const {
  return _internal_has_major_version();
}
inline void Gas::clear_major_version() {
  major_version_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gas::_internal_major_version() const {
  return major_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gas::major_version() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.major_version)
  return _internal_major_version();
}
inline void Gas::_internal_set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00020000u;
  major_version_ = value;
}
inline void Gas::set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_major_version(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.major_version)
}

// optional int32 minor_version = 19;
inline bool Gas::_internal_has_minor_version() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Gas::has_minor_version() const {
  return _internal_has_minor_version();
}
inline void Gas::clear_minor_version() {
  minor_version_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gas::_internal_minor_version() const {
  return minor_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gas::minor_version() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.minor_version)
  return _internal_minor_version();
}
inline void Gas::_internal_set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00040000u;
  minor_version_ = value;
}
inline void Gas::set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_minor_version(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.minor_version)
}

// optional int32 build_number = 20;
inline bool Gas::_internal_has_build_number() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Gas::has_build_number() const {
  return _internal_has_build_number();
}
inline void Gas::clear_build_number() {
  build_number_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gas::_internal_build_number() const {
  return build_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Gas::build_number() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.build_number)
  return _internal_build_number();
}
inline void Gas::_internal_set_build_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00080000u;
  build_number_ = value;
}
inline void Gas::set_build_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_build_number(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.build_number)
}

// -------------------------------------------------------------------

// Esp

// optional bool is_esp_acc_error = 1;
inline bool Esp::_internal_has_is_esp_acc_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Esp::has_is_esp_acc_error() const {
  return _internal_has_is_esp_acc_error();
}
inline void Esp::clear_is_esp_acc_error() {
  is_esp_acc_error_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool Esp::_internal_is_esp_acc_error() const {
  return is_esp_acc_error_;
}
inline bool Esp::is_esp_acc_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_esp_acc_error)
  return _internal_is_esp_acc_error();
}
inline void Esp::_internal_set_is_esp_acc_error(bool value) {
  _has_bits_[0] |= 0x00000001u;
  is_esp_acc_error_ = value;
}
inline void Esp::set_is_esp_acc_error(bool value) {
  _internal_set_is_esp_acc_error(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_esp_acc_error)
}

// optional bool is_esp_on = 2;
inline bool Esp::_internal_has_is_esp_on() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Esp::has_is_esp_on() const {
  return _internal_has_is_esp_on();
}
inline void Esp::clear_is_esp_on() {
  is_esp_on_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Esp::_internal_is_esp_on() const {
  return is_esp_on_;
}
inline bool Esp::is_esp_on() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_esp_on)
  return _internal_is_esp_on();
}
inline void Esp::_internal_set_is_esp_on(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_esp_on_ = value;
}
inline void Esp::set_is_esp_on(bool value) {
  _internal_set_is_esp_on(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_esp_on)
}

// optional bool is_esp_active = 3;
inline bool Esp::_internal_has_is_esp_active() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Esp::has_is_esp_active() const {
  return _internal_has_is_esp_active();
}
inline void Esp::clear_is_esp_active() {
  is_esp_active_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Esp::_internal_is_esp_active() const {
  return is_esp_active_;
}
inline bool Esp::is_esp_active() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_esp_active)
  return _internal_is_esp_active();
}
inline void Esp::_internal_set_is_esp_active(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_esp_active_ = value;
}
inline void Esp::set_is_esp_active(bool value) {
  _internal_set_is_esp_active(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_esp_active)
}

// optional bool is_abs_error = 4;
inline bool Esp::_internal_has_is_abs_error() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Esp::has_is_abs_error() const {
  return _internal_has_is_abs_error();
}
inline void Esp::clear_is_abs_error() {
  is_abs_error_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Esp::_internal_is_abs_error() const {
  return is_abs_error_;
}
inline bool Esp::is_abs_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_abs_error)
  return _internal_is_abs_error();
}
inline void Esp::_internal_set_is_abs_error(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_abs_error_ = value;
}
inline void Esp::set_is_abs_error(bool value) {
  _internal_set_is_abs_error(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_abs_error)
}

// optional bool is_abs_active = 5;
inline bool Esp::_internal_has_is_abs_active() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Esp::has_is_abs_active() const {
  return _internal_has_is_abs_active();
}
inline void Esp::clear_is_abs_active() {
  is_abs_active_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Esp::_internal_is_abs_active() const {
  return is_abs_active_;
}
inline bool Esp::is_abs_active() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_abs_active)
  return _internal_is_abs_active();
}
inline void Esp::_internal_set_is_abs_active(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_abs_active_ = value;
}
inline void Esp::set_is_abs_active(bool value) {
  _internal_set_is_abs_active(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_abs_active)
}

// optional bool is_tcsvdc_fail = 6;
inline bool Esp::_internal_has_is_tcsvdc_fail() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Esp::has_is_tcsvdc_fail() const {
  return _internal_has_is_tcsvdc_fail();
}
inline void Esp::clear_is_tcsvdc_fail() {
  is_tcsvdc_fail_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Esp::_internal_is_tcsvdc_fail() const {
  return is_tcsvdc_fail_;
}
inline bool Esp::is_tcsvdc_fail() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_tcsvdc_fail)
  return _internal_is_tcsvdc_fail();
}
inline void Esp::_internal_set_is_tcsvdc_fail(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_tcsvdc_fail_ = value;
}
inline void Esp::set_is_tcsvdc_fail(bool value) {
  _internal_set_is_tcsvdc_fail(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_tcsvdc_fail)
}

// optional bool is_abs_enabled = 7;
inline bool Esp::_internal_has_is_abs_enabled() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Esp::has_is_abs_enabled() const {
  return _internal_has_is_abs_enabled();
}
inline void Esp::clear_is_abs_enabled() {
  is_abs_enabled_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Esp::_internal_is_abs_enabled() const {
  return is_abs_enabled_;
}
inline bool Esp::is_abs_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_abs_enabled)
  return _internal_is_abs_enabled();
}
inline void Esp::_internal_set_is_abs_enabled(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_abs_enabled_ = value;
}
inline void Esp::set_is_abs_enabled(bool value) {
  _internal_set_is_abs_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_abs_enabled)
}

// optional bool is_stab_active = 8;
inline bool Esp::_internal_has_is_stab_active() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Esp::has_is_stab_active() const {
  return _internal_has_is_stab_active();
}
inline void Esp::clear_is_stab_active() {
  is_stab_active_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Esp::_internal_is_stab_active() const {
  return is_stab_active_;
}
inline bool Esp::is_stab_active() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_stab_active)
  return _internal_is_stab_active();
}
inline void Esp::_internal_set_is_stab_active(bool value) {
  _has_bits_[0] |= 0x00000080u;
  is_stab_active_ = value;
}
inline void Esp::set_is_stab_active(bool value) {
  _internal_set_is_stab_active(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_stab_active)
}

// optional bool is_stab_enabled = 9;
inline bool Esp::_internal_has_is_stab_enabled() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Esp::has_is_stab_enabled() const {
  return _internal_has_is_stab_enabled();
}
inline void Esp::clear_is_stab_enabled() {
  is_stab_enabled_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Esp::_internal_is_stab_enabled() const {
  return is_stab_enabled_;
}
inline bool Esp::is_stab_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_stab_enabled)
  return _internal_is_stab_enabled();
}
inline void Esp::_internal_set_is_stab_enabled(bool value) {
  _has_bits_[0] |= 0x00000100u;
  is_stab_enabled_ = value;
}
inline void Esp::set_is_stab_enabled(bool value) {
  _internal_set_is_stab_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_stab_enabled)
}

// optional bool is_trac_active = 10;
inline bool Esp::_internal_has_is_trac_active() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Esp::has_is_trac_active() const {
  return _internal_has_is_trac_active();
}
inline void Esp::clear_is_trac_active() {
  is_trac_active_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool Esp::_internal_is_trac_active() const {
  return is_trac_active_;
}
inline bool Esp::is_trac_active() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_trac_active)
  return _internal_is_trac_active();
}
inline void Esp::_internal_set_is_trac_active(bool value) {
  _has_bits_[0] |= 0x00000200u;
  is_trac_active_ = value;
}
inline void Esp::set_is_trac_active(bool value) {
  _internal_set_is_trac_active(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_trac_active)
}

// optional bool is_trac_enabled = 11;
inline bool Esp::_internal_has_is_trac_enabled() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Esp::has_is_trac_enabled() const {
  return _internal_has_is_trac_enabled();
}
inline void Esp::clear_is_trac_enabled() {
  is_trac_enabled_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool Esp::_internal_is_trac_enabled() const {
  return is_trac_enabled_;
}
inline bool Esp::is_trac_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_trac_enabled)
  return _internal_is_trac_enabled();
}
inline void Esp::_internal_set_is_trac_enabled(bool value) {
  _has_bits_[0] |= 0x00000400u;
  is_trac_enabled_ = value;
}
inline void Esp::set_is_trac_enabled(bool value) {
  _internal_set_is_trac_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_trac_enabled)
}

// -------------------------------------------------------------------

// Ems

// optional bool is_engine_acc_available = 1;
inline bool Ems::_internal_has_is_engine_acc_available() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Ems::has_is_engine_acc_available() const {
  return _internal_has_is_engine_acc_available();
}
inline void Ems::clear_is_engine_acc_available() {
  is_engine_acc_available_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Ems::_internal_is_engine_acc_available() const {
  return is_engine_acc_available_;
}
inline bool Ems::is_engine_acc_available() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.is_engine_acc_available)
  return _internal_is_engine_acc_available();
}
inline void Ems::_internal_set_is_engine_acc_available(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_engine_acc_available_ = value;
}
inline void Ems::set_is_engine_acc_available(bool value) {
  _internal_set_is_engine_acc_available(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.is_engine_acc_available)
}

// optional bool is_engine_acc_error = 2;
inline bool Ems::_internal_has_is_engine_acc_error() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Ems::has_is_engine_acc_error() const {
  return _internal_has_is_engine_acc_error();
}
inline void Ems::clear_is_engine_acc_error() {
  is_engine_acc_error_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Ems::_internal_is_engine_acc_error() const {
  return is_engine_acc_error_;
}
inline bool Ems::is_engine_acc_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.is_engine_acc_error)
  return _internal_is_engine_acc_error();
}
inline void Ems::_internal_set_is_engine_acc_error(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_engine_acc_error_ = value;
}
inline void Ems::set_is_engine_acc_error(bool value) {
  _internal_set_is_engine_acc_error(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.is_engine_acc_error)
}

// optional .apollo.canbus.Ems.Type engine_state = 3;
inline bool Ems::_internal_has_engine_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Ems::has_engine_state() const {
  return _internal_has_engine_state();
}
inline void Ems::clear_engine_state() {
  engine_state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Ems_Type Ems::_internal_engine_state() const {
  return static_cast< ::apollo::canbus::Ems_Type >(engine_state_);
}
inline ::apollo::canbus::Ems_Type Ems::engine_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.engine_state)
  return _internal_engine_state();
}
inline void Ems::_internal_set_engine_state(::apollo::canbus::Ems_Type value) {
  assert(::apollo::canbus::Ems_Type_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  engine_state_ = value;
}
inline void Ems::set_engine_state(::apollo::canbus::Ems_Type value) {
  _internal_set_engine_state(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.engine_state)
}

// optional double max_engine_torq_percent = 4;
inline bool Ems::_internal_has_max_engine_torq_percent() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Ems::has_max_engine_torq_percent() const {
  return _internal_has_max_engine_torq_percent();
}
inline void Ems::clear_max_engine_torq_percent() {
  max_engine_torq_percent_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Ems::_internal_max_engine_torq_percent() const {
  return max_engine_torq_percent_;
}
inline double Ems::max_engine_torq_percent() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.max_engine_torq_percent)
  return _internal_max_engine_torq_percent();
}
inline void Ems::_internal_set_max_engine_torq_percent(double value) {
  _has_bits_[0] |= 0x00000001u;
  max_engine_torq_percent_ = value;
}
inline void Ems::set_max_engine_torq_percent(double value) {
  _internal_set_max_engine_torq_percent(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.max_engine_torq_percent)
}

// optional double min_engine_torq_percent = 5;
inline bool Ems::_internal_has_min_engine_torq_percent() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Ems::has_min_engine_torq_percent() const {
  return _internal_has_min_engine_torq_percent();
}
inline void Ems::clear_min_engine_torq_percent() {
  min_engine_torq_percent_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double Ems::_internal_min_engine_torq_percent() const {
  return min_engine_torq_percent_;
}
inline double Ems::min_engine_torq_percent() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.min_engine_torq_percent)
  return _internal_min_engine_torq_percent();
}
inline void Ems::_internal_set_min_engine_torq_percent(double value) {
  _has_bits_[0] |= 0x00000040u;
  min_engine_torq_percent_ = value;
}
inline void Ems::set_min_engine_torq_percent(double value) {
  _internal_set_min_engine_torq_percent(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.min_engine_torq_percent)
}

// optional int32 base_engine_torq_constant = 6;
inline bool Ems::_internal_has_base_engine_torq_constant() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Ems::has_base_engine_torq_constant() const {
  return _internal_has_base_engine_torq_constant();
}
inline void Ems::clear_base_engine_torq_constant() {
  base_engine_torq_constant_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Ems::_internal_base_engine_torq_constant() const {
  return base_engine_torq_constant_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Ems::base_engine_torq_constant() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.base_engine_torq_constant)
  return _internal_base_engine_torq_constant();
}
inline void Ems::_internal_set_base_engine_torq_constant(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  base_engine_torq_constant_ = value;
}
inline void Ems::set_base_engine_torq_constant(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_base_engine_torq_constant(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.base_engine_torq_constant)
}

// optional bool is_engine_speed_error = 7;
inline bool Ems::_internal_has_is_engine_speed_error() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Ems::has_is_engine_speed_error() const {
  return _internal_has_is_engine_speed_error();
}
inline void Ems::clear_is_engine_speed_error() {
  is_engine_speed_error_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Ems::_internal_is_engine_speed_error() const {
  return is_engine_speed_error_;
}
inline bool Ems::is_engine_speed_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.is_engine_speed_error)
  return _internal_is_engine_speed_error();
}
inline void Ems::_internal_set_is_engine_speed_error(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_engine_speed_error_ = value;
}
inline void Ems::set_is_engine_speed_error(bool value) {
  _internal_set_is_engine_speed_error(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.is_engine_speed_error)
}

// optional double engine_speed = 8;
inline bool Ems::_internal_has_engine_speed() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Ems::has_engine_speed() const {
  return _internal_has_engine_speed();
}
inline void Ems::clear_engine_speed() {
  engine_speed_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double Ems::_internal_engine_speed() const {
  return engine_speed_;
}
inline double Ems::engine_speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.engine_speed)
  return _internal_engine_speed();
}
inline void Ems::_internal_set_engine_speed(double value) {
  _has_bits_[0] |= 0x00000200u;
  engine_speed_ = value;
}
inline void Ems::set_engine_speed(double value) {
  _internal_set_engine_speed(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.engine_speed)
}

// optional int32 engine_torque = 9;
inline bool Ems::_internal_has_engine_torque() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Ems::has_engine_torque() const {
  return _internal_has_engine_torque();
}
inline void Ems::clear_engine_torque() {
  engine_torque_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Ems::_internal_engine_torque() const {
  return engine_torque_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Ems::engine_torque() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.engine_torque)
  return _internal_engine_torque();
}
inline void Ems::_internal_set_engine_torque(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  engine_torque_ = value;
}
inline void Ems::set_engine_torque(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_engine_torque(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.engine_torque)
}

// optional bool is_over_engine_torque = 10;
inline bool Ems::_internal_has_is_over_engine_torque() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Ems::has_is_over_engine_torque() const {
  return _internal_has_is_over_engine_torque();
}
inline void Ems::clear_is_over_engine_torque() {
  is_over_engine_torque_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Ems::_internal_is_over_engine_torque() const {
  return is_over_engine_torque_;
}
inline bool Ems::is_over_engine_torque() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.is_over_engine_torque)
  return _internal_is_over_engine_torque();
}
inline void Ems::_internal_set_is_over_engine_torque(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_over_engine_torque_ = value;
}
inline void Ems::set_is_over_engine_torque(bool value) {
  _internal_set_is_over_engine_torque(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.is_over_engine_torque)
}

// optional double engine_rpm = 11;
inline bool Ems::_internal_has_engine_rpm() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Ems::has_engine_rpm() const {
  return _internal_has_engine_rpm();
}
inline void Ems::clear_engine_rpm() {
  engine_rpm_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline double Ems::_internal_engine_rpm() const {
  return engine_rpm_;
}
inline double Ems::engine_rpm() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.engine_rpm)
  return _internal_engine_rpm();
}
inline void Ems::_internal_set_engine_rpm(double value) {
  _has_bits_[0] |= 0x00000400u;
  engine_rpm_ = value;
}
inline void Ems::set_engine_rpm(double value) {
  _internal_set_engine_rpm(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.engine_rpm)
}

// -------------------------------------------------------------------

// Gear

// optional bool is_shift_position_valid = 1;
inline bool Gear::_internal_has_is_shift_position_valid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Gear::has_is_shift_position_valid() const {
  return _internal_has_is_shift_position_valid();
}
inline void Gear::clear_is_shift_position_valid() {
  is_shift_position_valid_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Gear::_internal_is_shift_position_valid() const {
  return is_shift_position_valid_;
}
inline bool Gear::is_shift_position_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear.is_shift_position_valid)
  return _internal_is_shift_position_valid();
}
inline void Gear::_internal_set_is_shift_position_valid(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_shift_position_valid_ = value;
}
inline void Gear::set_is_shift_position_valid(bool value) {
  _internal_set_is_shift_position_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear.is_shift_position_valid)
}

// optional .apollo.canbus.Chassis.GearPosition gear_state = 2;
inline bool Gear::_internal_has_gear_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Gear::has_gear_state() const {
  return _internal_has_gear_state();
}
inline void Gear::clear_gear_state() {
  gear_state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Chassis_GearPosition Gear::_internal_gear_state() const {
  return static_cast< ::apollo::canbus::Chassis_GearPosition >(gear_state_);
}
inline ::apollo::canbus::Chassis_GearPosition Gear::gear_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear.gear_state)
  return _internal_gear_state();
}
inline void Gear::_internal_set_gear_state(::apollo::canbus::Chassis_GearPosition value) {
  assert(::apollo::canbus::Chassis_GearPosition_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  gear_state_ = value;
}
inline void Gear::set_gear_state(::apollo::canbus::Chassis_GearPosition value) {
  _internal_set_gear_state(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear.gear_state)
}

// optional bool driver_override = 3;
inline bool Gear::_internal_has_driver_override() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Gear::has_driver_override() const {
  return _internal_has_driver_override();
}
inline void Gear::clear_driver_override() {
  driver_override_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Gear::_internal_driver_override() const {
  return driver_override_;
}
inline bool Gear::driver_override() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear.driver_override)
  return _internal_driver_override();
}
inline void Gear::_internal_set_driver_override(bool value) {
  _has_bits_[0] |= 0x00000004u;
  driver_override_ = value;
}
inline void Gear::set_driver_override(bool value) {
  _internal_set_driver_override(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear.driver_override)
}

// optional .apollo.canbus.Chassis.GearPosition gear_cmd = 4;
inline bool Gear::_internal_has_gear_cmd() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Gear::has_gear_cmd() const {
  return _internal_has_gear_cmd();
}
inline void Gear::clear_gear_cmd() {
  gear_cmd_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::apollo::canbus::Chassis_GearPosition Gear::_internal_gear_cmd() const {
  return static_cast< ::apollo::canbus::Chassis_GearPosition >(gear_cmd_);
}
inline ::apollo::canbus::Chassis_GearPosition Gear::gear_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear.gear_cmd)
  return _internal_gear_cmd();
}
inline void Gear::_internal_set_gear_cmd(::apollo::canbus::Chassis_GearPosition value) {
  assert(::apollo::canbus::Chassis_GearPosition_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  gear_cmd_ = value;
}
inline void Gear::set_gear_cmd(::apollo::canbus::Chassis_GearPosition value) {
  _internal_set_gear_cmd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear.gear_cmd)
}

// optional bool canbus_fault = 5;
inline bool Gear::_internal_has_canbus_fault() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Gear::has_canbus_fault() const {
  return _internal_has_canbus_fault();
}
inline void Gear::clear_canbus_fault() {
  canbus_fault_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Gear::_internal_canbus_fault() const {
  return canbus_fault_;
}
inline bool Gear::canbus_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear.canbus_fault)
  return _internal_canbus_fault();
}
inline void Gear::_internal_set_canbus_fault(bool value) {
  _has_bits_[0] |= 0x00000008u;
  canbus_fault_ = value;
}
inline void Gear::set_canbus_fault(bool value) {
  _internal_set_canbus_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear.canbus_fault)
}

// -------------------------------------------------------------------

// Safety

// optional bool is_driver_car_door_close = 1;
inline bool Safety::_internal_has_is_driver_car_door_close() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Safety::has_is_driver_car_door_close() const {
  return _internal_has_is_driver_car_door_close();
}
inline void Safety::clear_is_driver_car_door_close() {
  is_driver_car_door_close_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Safety::_internal_is_driver_car_door_close() const {
  return is_driver_car_door_close_;
}
inline bool Safety::is_driver_car_door_close() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_driver_car_door_close)
  return _internal_is_driver_car_door_close();
}
inline void Safety::_internal_set_is_driver_car_door_close(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_driver_car_door_close_ = value;
}
inline void Safety::set_is_driver_car_door_close(bool value) {
  _internal_set_is_driver_car_door_close(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_driver_car_door_close)
}

// optional bool is_driver_buckled = 2;
inline bool Safety::_internal_has_is_driver_buckled() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Safety::has_is_driver_buckled() const {
  return _internal_has_is_driver_buckled();
}
inline void Safety::clear_is_driver_buckled() {
  is_driver_buckled_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Safety::_internal_is_driver_buckled() const {
  return is_driver_buckled_;
}
inline bool Safety::is_driver_buckled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_driver_buckled)
  return _internal_is_driver_buckled();
}
inline void Safety::_internal_set_is_driver_buckled(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_driver_buckled_ = value;
}
inline void Safety::set_is_driver_buckled(bool value) {
  _internal_set_is_driver_buckled(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_driver_buckled)
}

// optional int32 emergency_button = 3;
inline bool Safety::_internal_has_emergency_button() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Safety::has_emergency_button() const {
  return _internal_has_emergency_button();
}
inline void Safety::clear_emergency_button() {
  emergency_button_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Safety::_internal_emergency_button() const {
  return emergency_button_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Safety::emergency_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.emergency_button)
  return _internal_emergency_button();
}
inline void Safety::_internal_set_emergency_button(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  emergency_button_ = value;
}
inline void Safety::set_emergency_button(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_emergency_button(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.emergency_button)
}

// optional bool has_error = 4 [default = false];
inline bool Safety::_internal_has_has_error() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Safety::has_has_error() const {
  return _internal_has_has_error();
}
inline void Safety::clear_has_error() {
  has_error_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Safety::_internal_has_error() const {
  return has_error_;
}
inline bool Safety::has_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.has_error)
  return _internal_has_error();
}
inline void Safety::_internal_set_has_error(bool value) {
  _has_bits_[0] |= 0x00000008u;
  has_error_ = value;
}
inline void Safety::set_has_error(bool value) {
  _internal_set_has_error(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.has_error)
}

// optional bool is_motor_invertor_fault = 5;
inline bool Safety::_internal_has_is_motor_invertor_fault() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Safety::has_is_motor_invertor_fault() const {
  return _internal_has_is_motor_invertor_fault();
}
inline void Safety::clear_is_motor_invertor_fault() {
  is_motor_invertor_fault_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Safety::_internal_is_motor_invertor_fault() const {
  return is_motor_invertor_fault_;
}
inline bool Safety::is_motor_invertor_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_motor_invertor_fault)
  return _internal_is_motor_invertor_fault();
}
inline void Safety::_internal_set_is_motor_invertor_fault(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_motor_invertor_fault_ = value;
}
inline void Safety::set_is_motor_invertor_fault(bool value) {
  _internal_set_is_motor_invertor_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_motor_invertor_fault)
}

// optional bool is_system_fault = 6;
inline bool Safety::_internal_has_is_system_fault() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Safety::has_is_system_fault() const {
  return _internal_has_is_system_fault();
}
inline void Safety::clear_is_system_fault() {
  is_system_fault_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Safety::_internal_is_system_fault() const {
  return is_system_fault_;
}
inline bool Safety::is_system_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_system_fault)
  return _internal_is_system_fault();
}
inline void Safety::_internal_set_is_system_fault(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_system_fault_ = value;
}
inline void Safety::set_is_system_fault(bool value) {
  _internal_set_is_system_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_system_fault)
}

// optional bool is_power_battery_fault = 7;
inline bool Safety::_internal_has_is_power_battery_fault() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Safety::has_is_power_battery_fault() const {
  return _internal_has_is_power_battery_fault();
}
inline void Safety::clear_is_power_battery_fault() {
  is_power_battery_fault_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Safety::_internal_is_power_battery_fault() const {
  return is_power_battery_fault_;
}
inline bool Safety::is_power_battery_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_power_battery_fault)
  return _internal_is_power_battery_fault();
}
inline void Safety::_internal_set_is_power_battery_fault(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_power_battery_fault_ = value;
}
inline void Safety::set_is_power_battery_fault(bool value) {
  _internal_set_is_power_battery_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_power_battery_fault)
}

// optional bool is_motor_invertor_over_temperature = 8;
inline bool Safety::_internal_has_is_motor_invertor_over_temperature() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Safety::has_is_motor_invertor_over_temperature() const {
  return _internal_has_is_motor_invertor_over_temperature();
}
inline void Safety::clear_is_motor_invertor_over_temperature() {
  is_motor_invertor_over_temperature_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Safety::_internal_is_motor_invertor_over_temperature() const {
  return is_motor_invertor_over_temperature_;
}
inline bool Safety::is_motor_invertor_over_temperature() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_motor_invertor_over_temperature)
  return _internal_is_motor_invertor_over_temperature();
}
inline void Safety::_internal_set_is_motor_invertor_over_temperature(bool value) {
  _has_bits_[0] |= 0x00000080u;
  is_motor_invertor_over_temperature_ = value;
}
inline void Safety::set_is_motor_invertor_over_temperature(bool value) {
  _internal_set_is_motor_invertor_over_temperature(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_motor_invertor_over_temperature)
}

// optional bool is_small_battery_charge_discharge_fault = 9;
inline bool Safety::_internal_has_is_small_battery_charge_discharge_fault() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Safety::has_is_small_battery_charge_discharge_fault() const {
  return _internal_has_is_small_battery_charge_discharge_fault();
}
inline void Safety::clear_is_small_battery_charge_discharge_fault() {
  is_small_battery_charge_discharge_fault_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Safety::_internal_is_small_battery_charge_discharge_fault() const {
  return is_small_battery_charge_discharge_fault_;
}
inline bool Safety::is_small_battery_charge_discharge_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_small_battery_charge_discharge_fault)
  return _internal_is_small_battery_charge_discharge_fault();
}
inline void Safety::_internal_set_is_small_battery_charge_discharge_fault(bool value) {
  _has_bits_[0] |= 0x00000100u;
  is_small_battery_charge_discharge_fault_ = value;
}
inline void Safety::set_is_small_battery_charge_discharge_fault(bool value) {
  _internal_set_is_small_battery_charge_discharge_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_small_battery_charge_discharge_fault)
}

// optional int32 driving_mode = 10;
inline bool Safety::_internal_has_driving_mode() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Safety::has_driving_mode() const {
  return _internal_has_driving_mode();
}
inline void Safety::clear_driving_mode() {
  driving_mode_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Safety::_internal_driving_mode() const {
  return driving_mode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Safety::driving_mode() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.driving_mode)
  return _internal_driving_mode();
}
inline void Safety::_internal_set_driving_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  driving_mode_ = value;
}
inline void Safety::set_driving_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_driving_mode(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.driving_mode)
}

// optional bool is_passenger_door_open = 11;
inline bool Safety::_internal_has_is_passenger_door_open() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Safety::has_is_passenger_door_open() const {
  return _internal_has_is_passenger_door_open();
}
inline void Safety::clear_is_passenger_door_open() {
  is_passenger_door_open_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool Safety::_internal_is_passenger_door_open() const {
  return is_passenger_door_open_;
}
inline bool Safety::is_passenger_door_open() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_passenger_door_open)
  return _internal_is_passenger_door_open();
}
inline void Safety::_internal_set_is_passenger_door_open(bool value) {
  _has_bits_[0] |= 0x00000400u;
  is_passenger_door_open_ = value;
}
inline void Safety::set_is_passenger_door_open(bool value) {
  _internal_set_is_passenger_door_open(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_passenger_door_open)
}

// optional bool is_rearleft_door_open = 12;
inline bool Safety::_internal_has_is_rearleft_door_open() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Safety::has_is_rearleft_door_open() const {
  return _internal_has_is_rearleft_door_open();
}
inline void Safety::clear_is_rearleft_door_open() {
  is_rearleft_door_open_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool Safety::_internal_is_rearleft_door_open() const {
  return is_rearleft_door_open_;
}
inline bool Safety::is_rearleft_door_open() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_rearleft_door_open)
  return _internal_is_rearleft_door_open();
}
inline void Safety::_internal_set_is_rearleft_door_open(bool value) {
  _has_bits_[0] |= 0x00000800u;
  is_rearleft_door_open_ = value;
}
inline void Safety::set_is_rearleft_door_open(bool value) {
  _internal_set_is_rearleft_door_open(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_rearleft_door_open)
}

// optional bool is_rearright_door_open = 13;
inline bool Safety::_internal_has_is_rearright_door_open() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Safety::has_is_rearright_door_open() const {
  return _internal_has_is_rearright_door_open();
}
inline void Safety::clear_is_rearright_door_open() {
  is_rearright_door_open_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool Safety::_internal_is_rearright_door_open() const {
  return is_rearright_door_open_;
}
inline bool Safety::is_rearright_door_open() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_rearright_door_open)
  return _internal_is_rearright_door_open();
}
inline void Safety::_internal_set_is_rearright_door_open(bool value) {
  _has_bits_[0] |= 0x00001000u;
  is_rearright_door_open_ = value;
}
inline void Safety::set_is_rearright_door_open(bool value) {
  _internal_set_is_rearright_door_open(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_rearright_door_open)
}

// optional bool is_hood_open = 14;
inline bool Safety::_internal_has_is_hood_open() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Safety::has_is_hood_open() const {
  return _internal_has_is_hood_open();
}
inline void Safety::clear_is_hood_open() {
  is_hood_open_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool Safety::_internal_is_hood_open() const {
  return is_hood_open_;
}
inline bool Safety::is_hood_open() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_hood_open)
  return _internal_is_hood_open();
}
inline void Safety::_internal_set_is_hood_open(bool value) {
  _has_bits_[0] |= 0x00002000u;
  is_hood_open_ = value;
}
inline void Safety::set_is_hood_open(bool value) {
  _internal_set_is_hood_open(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_hood_open)
}

// optional bool is_trunk_open = 15;
inline bool Safety::_internal_has_is_trunk_open() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Safety::has_is_trunk_open() const {
  return _internal_has_is_trunk_open();
}
inline void Safety::clear_is_trunk_open() {
  is_trunk_open_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool Safety::_internal_is_trunk_open() const {
  return is_trunk_open_;
}
inline bool Safety::is_trunk_open() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_trunk_open)
  return _internal_is_trunk_open();
}
inline void Safety::_internal_set_is_trunk_open(bool value) {
  _has_bits_[0] |= 0x00004000u;
  is_trunk_open_ = value;
}
inline void Safety::set_is_trunk_open(bool value) {
  _internal_set_is_trunk_open(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_trunk_open)
}

// optional bool is_passenger_detected = 16;
inline bool Safety::_internal_has_is_passenger_detected() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Safety::has_is_passenger_detected() const {
  return _internal_has_is_passenger_detected();
}
inline void Safety::clear_is_passenger_detected() {
  is_passenger_detected_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool Safety::_internal_is_passenger_detected() const {
  return is_passenger_detected_;
}
inline bool Safety::is_passenger_detected() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_passenger_detected)
  return _internal_is_passenger_detected();
}
inline void Safety::_internal_set_is_passenger_detected(bool value) {
  _has_bits_[0] |= 0x00008000u;
  is_passenger_detected_ = value;
}
inline void Safety::set_is_passenger_detected(bool value) {
  _internal_set_is_passenger_detected(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_passenger_detected)
}

// optional bool is_passenger_airbag_enabled = 17;
inline bool Safety::_internal_has_is_passenger_airbag_enabled() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Safety::has_is_passenger_airbag_enabled() const {
  return _internal_has_is_passenger_airbag_enabled();
}
inline void Safety::clear_is_passenger_airbag_enabled() {
  is_passenger_airbag_enabled_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool Safety::_internal_is_passenger_airbag_enabled() const {
  return is_passenger_airbag_enabled_;
}
inline bool Safety::is_passenger_airbag_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_passenger_airbag_enabled)
  return _internal_is_passenger_airbag_enabled();
}
inline void Safety::_internal_set_is_passenger_airbag_enabled(bool value) {
  _has_bits_[0] |= 0x00010000u;
  is_passenger_airbag_enabled_ = value;
}
inline void Safety::set_is_passenger_airbag_enabled(bool value) {
  _internal_set_is_passenger_airbag_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_passenger_airbag_enabled)
}

// optional bool is_passenger_buckled = 18;
inline bool Safety::_internal_has_is_passenger_buckled() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Safety::has_is_passenger_buckled() const {
  return _internal_has_is_passenger_buckled();
}
inline void Safety::clear_is_passenger_buckled() {
  is_passenger_buckled_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool Safety::_internal_is_passenger_buckled() const {
  return is_passenger_buckled_;
}
inline bool Safety::is_passenger_buckled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_passenger_buckled)
  return _internal_is_passenger_buckled();
}
inline void Safety::_internal_set_is_passenger_buckled(bool value) {
  _has_bits_[0] |= 0x00020000u;
  is_passenger_buckled_ = value;
}
inline void Safety::set_is_passenger_buckled(bool value) {
  _internal_set_is_passenger_buckled(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_passenger_buckled)
}

// optional int32 front_left_tire_press = 19;
inline bool Safety::_internal_has_front_left_tire_press() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Safety::has_front_left_tire_press() const {
  return _internal_has_front_left_tire_press();
}
inline void Safety::clear_front_left_tire_press() {
  front_left_tire_press_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Safety::_internal_front_left_tire_press() const {
  return front_left_tire_press_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Safety::front_left_tire_press() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.front_left_tire_press)
  return _internal_front_left_tire_press();
}
inline void Safety::_internal_set_front_left_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00040000u;
  front_left_tire_press_ = value;
}
inline void Safety::set_front_left_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_front_left_tire_press(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.front_left_tire_press)
}

// optional int32 front_right_tire_press = 20;
inline bool Safety::_internal_has_front_right_tire_press() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Safety::has_front_right_tire_press() const {
  return _internal_has_front_right_tire_press();
}
inline void Safety::clear_front_right_tire_press() {
  front_right_tire_press_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Safety::_internal_front_right_tire_press() const {
  return front_right_tire_press_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Safety::front_right_tire_press() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.front_right_tire_press)
  return _internal_front_right_tire_press();
}
inline void Safety::_internal_set_front_right_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00080000u;
  front_right_tire_press_ = value;
}
inline void Safety::set_front_right_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_front_right_tire_press(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.front_right_tire_press)
}

// optional int32 rear_left_tire_press = 21;
inline bool Safety::_internal_has_rear_left_tire_press() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Safety::has_rear_left_tire_press() const {
  return _internal_has_rear_left_tire_press();
}
inline void Safety::clear_rear_left_tire_press() {
  rear_left_tire_press_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Safety::_internal_rear_left_tire_press() const {
  return rear_left_tire_press_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Safety::rear_left_tire_press() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.rear_left_tire_press)
  return _internal_rear_left_tire_press();
}
inline void Safety::_internal_set_rear_left_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00100000u;
  rear_left_tire_press_ = value;
}
inline void Safety::set_rear_left_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rear_left_tire_press(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.rear_left_tire_press)
}

// optional int32 rear_right_tire_press = 22;
inline bool Safety::_internal_has_rear_right_tire_press() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Safety::has_rear_right_tire_press() const {
  return _internal_has_rear_right_tire_press();
}
inline void Safety::clear_rear_right_tire_press() {
  rear_right_tire_press_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Safety::_internal_rear_right_tire_press() const {
  return rear_right_tire_press_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Safety::rear_right_tire_press() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.rear_right_tire_press)
  return _internal_rear_right_tire_press();
}
inline void Safety::_internal_set_rear_right_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00200000u;
  rear_right_tire_press_ = value;
}
inline void Safety::set_rear_right_tire_press(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rear_right_tire_press(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.rear_right_tire_press)
}

// optional .apollo.canbus.Chassis.DrivingMode car_driving_mode = 23;
inline bool Safety::_internal_has_car_driving_mode() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Safety::has_car_driving_mode() const {
  return _internal_has_car_driving_mode();
}
inline void Safety::clear_car_driving_mode() {
  car_driving_mode_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::apollo::canbus::Chassis_DrivingMode Safety::_internal_car_driving_mode() const {
  return static_cast< ::apollo::canbus::Chassis_DrivingMode >(car_driving_mode_);
}
inline ::apollo::canbus::Chassis_DrivingMode Safety::car_driving_mode() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.car_driving_mode)
  return _internal_car_driving_mode();
}
inline void Safety::_internal_set_car_driving_mode(::apollo::canbus::Chassis_DrivingMode value) {
  assert(::apollo::canbus::Chassis_DrivingMode_IsValid(value));
  _has_bits_[0] |= 0x00400000u;
  car_driving_mode_ = value;
}
inline void Safety::set_car_driving_mode(::apollo::canbus::Chassis_DrivingMode value) {
  _internal_set_car_driving_mode(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.car_driving_mode)
}

// -------------------------------------------------------------------

// BasicInfo

// optional bool is_auto_mode = 1;
inline bool BasicInfo::_internal_has_is_auto_mode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BasicInfo::has_is_auto_mode() const {
  return _internal_has_is_auto_mode();
}
inline void BasicInfo::clear_is_auto_mode() {
  is_auto_mode_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool BasicInfo::_internal_is_auto_mode() const {
  return is_auto_mode_;
}
inline bool BasicInfo::is_auto_mode() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.is_auto_mode)
  return _internal_is_auto_mode();
}
inline void BasicInfo::_internal_set_is_auto_mode(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_auto_mode_ = value;
}
inline void BasicInfo::set_is_auto_mode(bool value) {
  _internal_set_is_auto_mode(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.is_auto_mode)
}

// optional .apollo.canbus.BasicInfo.Type power_state = 2;
inline bool BasicInfo::_internal_has_power_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BasicInfo::has_power_state() const {
  return _internal_has_power_state();
}
inline void BasicInfo::clear_power_state() {
  power_state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::BasicInfo_Type BasicInfo::_internal_power_state() const {
  return static_cast< ::apollo::canbus::BasicInfo_Type >(power_state_);
}
inline ::apollo::canbus::BasicInfo_Type BasicInfo::power_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.power_state)
  return _internal_power_state();
}
inline void BasicInfo::_internal_set_power_state(::apollo::canbus::BasicInfo_Type value) {
  assert(::apollo::canbus::BasicInfo_Type_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  power_state_ = value;
}
inline void BasicInfo::set_power_state(::apollo::canbus::BasicInfo_Type value) {
  _internal_set_power_state(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.power_state)
}

// optional bool is_air_bag_deployed = 3;
inline bool BasicInfo::_internal_has_is_air_bag_deployed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BasicInfo::has_is_air_bag_deployed() const {
  return _internal_has_is_air_bag_deployed();
}
inline void BasicInfo::clear_is_air_bag_deployed() {
  is_air_bag_deployed_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool BasicInfo::_internal_is_air_bag_deployed() const {
  return is_air_bag_deployed_;
}
inline bool BasicInfo::is_air_bag_deployed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.is_air_bag_deployed)
  return _internal_is_air_bag_deployed();
}
inline void BasicInfo::_internal_set_is_air_bag_deployed(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_air_bag_deployed_ = value;
}
inline void BasicInfo::set_is_air_bag_deployed(bool value) {
  _internal_set_is_air_bag_deployed(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.is_air_bag_deployed)
}

// optional double odo_meter = 4;
inline bool BasicInfo::_internal_has_odo_meter() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BasicInfo::has_odo_meter() const {
  return _internal_has_odo_meter();
}
inline void BasicInfo::clear_odo_meter() {
  odo_meter_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double BasicInfo::_internal_odo_meter() const {
  return odo_meter_;
}
inline double BasicInfo::odo_meter() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.odo_meter)
  return _internal_odo_meter();
}
inline void BasicInfo::_internal_set_odo_meter(double value) {
  _has_bits_[0] |= 0x00000020u;
  odo_meter_ = value;
}
inline void BasicInfo::set_odo_meter(double value) {
  _internal_set_odo_meter(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.odo_meter)
}

// optional double drive_range = 5;
inline bool BasicInfo::_internal_has_drive_range() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BasicInfo::has_drive_range() const {
  return _internal_has_drive_range();
}
inline void BasicInfo::clear_drive_range() {
  drive_range_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double BasicInfo::_internal_drive_range() const {
  return drive_range_;
}
inline double BasicInfo::drive_range() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.drive_range)
  return _internal_drive_range();
}
inline void BasicInfo::_internal_set_drive_range(double value) {
  _has_bits_[0] |= 0x00000040u;
  drive_range_ = value;
}
inline void BasicInfo::set_drive_range(double value) {
  _internal_set_drive_range(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.drive_range)
}

// optional bool is_system_error = 6;
inline bool BasicInfo::_internal_has_is_system_error() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BasicInfo::has_is_system_error() const {
  return _internal_has_is_system_error();
}
inline void BasicInfo::clear_is_system_error() {
  is_system_error_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool BasicInfo::_internal_is_system_error() const {
  return is_system_error_;
}
inline bool BasicInfo::is_system_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.is_system_error)
  return _internal_is_system_error();
}
inline void BasicInfo::_internal_set_is_system_error(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_system_error_ = value;
}
inline void BasicInfo::set_is_system_error(bool value) {
  _internal_set_is_system_error(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.is_system_error)
}

// optional bool is_human_interrupt = 7;
inline bool BasicInfo::_internal_has_is_human_interrupt() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BasicInfo::has_is_human_interrupt() const {
  return _internal_has_is_human_interrupt();
}
inline void BasicInfo::clear_is_human_interrupt() {
  is_human_interrupt_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool BasicInfo::_internal_is_human_interrupt() const {
  return is_human_interrupt_;
}
inline bool BasicInfo::is_human_interrupt() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.is_human_interrupt)
  return _internal_is_human_interrupt();
}
inline void BasicInfo::_internal_set_is_human_interrupt(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_human_interrupt_ = value;
}
inline void BasicInfo::set_is_human_interrupt(bool value) {
  _internal_set_is_human_interrupt(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.is_human_interrupt)
}

// optional bool acc_on_button = 8;
inline bool BasicInfo::_internal_has_acc_on_button() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BasicInfo::has_acc_on_button() const {
  return _internal_has_acc_on_button();
}
inline void BasicInfo::clear_acc_on_button() {
  acc_on_button_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool BasicInfo::_internal_acc_on_button() const {
  return acc_on_button_;
}
inline bool BasicInfo::acc_on_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_on_button)
  return _internal_acc_on_button();
}
inline void BasicInfo::_internal_set_acc_on_button(bool value) {
  _has_bits_[0] |= 0x00000080u;
  acc_on_button_ = value;
}
inline void BasicInfo::set_acc_on_button(bool value) {
  _internal_set_acc_on_button(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_on_button)
}

// optional bool acc_off_button = 9;
inline bool BasicInfo::_internal_has_acc_off_button() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool BasicInfo::has_acc_off_button() const {
  return _internal_has_acc_off_button();
}
inline void BasicInfo::clear_acc_off_button() {
  acc_off_button_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool BasicInfo::_internal_acc_off_button() const {
  return acc_off_button_;
}
inline bool BasicInfo::acc_off_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_off_button)
  return _internal_acc_off_button();
}
inline void BasicInfo::_internal_set_acc_off_button(bool value) {
  _has_bits_[0] |= 0x00000100u;
  acc_off_button_ = value;
}
inline void BasicInfo::set_acc_off_button(bool value) {
  _internal_set_acc_off_button(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_off_button)
}

// optional bool acc_res_button = 10;
inline bool BasicInfo::_internal_has_acc_res_button() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool BasicInfo::has_acc_res_button() const {
  return _internal_has_acc_res_button();
}
inline void BasicInfo::clear_acc_res_button() {
  acc_res_button_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool BasicInfo::_internal_acc_res_button() const {
  return acc_res_button_;
}
inline bool BasicInfo::acc_res_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_res_button)
  return _internal_acc_res_button();
}
inline void BasicInfo::_internal_set_acc_res_button(bool value) {
  _has_bits_[0] |= 0x00000200u;
  acc_res_button_ = value;
}
inline void BasicInfo::set_acc_res_button(bool value) {
  _internal_set_acc_res_button(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_res_button)
}

// optional bool acc_cancel_button = 11;
inline bool BasicInfo::_internal_has_acc_cancel_button() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool BasicInfo::has_acc_cancel_button() const {
  return _internal_has_acc_cancel_button();
}
inline void BasicInfo::clear_acc_cancel_button() {
  acc_cancel_button_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool BasicInfo::_internal_acc_cancel_button() const {
  return acc_cancel_button_;
}
inline bool BasicInfo::acc_cancel_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_cancel_button)
  return _internal_acc_cancel_button();
}
inline void BasicInfo::_internal_set_acc_cancel_button(bool value) {
  _has_bits_[0] |= 0x00000400u;
  acc_cancel_button_ = value;
}
inline void BasicInfo::set_acc_cancel_button(bool value) {
  _internal_set_acc_cancel_button(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_cancel_button)
}

// optional bool acc_on_off_button = 12;
inline bool BasicInfo::_internal_has_acc_on_off_button() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool BasicInfo::has_acc_on_off_button() const {
  return _internal_has_acc_on_off_button();
}
inline void BasicInfo::clear_acc_on_off_button() {
  acc_on_off_button_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool BasicInfo::_internal_acc_on_off_button() const {
  return acc_on_off_button_;
}
inline bool BasicInfo::acc_on_off_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_on_off_button)
  return _internal_acc_on_off_button();
}
inline void BasicInfo::_internal_set_acc_on_off_button(bool value) {
  _has_bits_[0] |= 0x00000800u;
  acc_on_off_button_ = value;
}
inline void BasicInfo::set_acc_on_off_button(bool value) {
  _internal_set_acc_on_off_button(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_on_off_button)
}

// optional bool acc_res_cancel_button = 13;
inline bool BasicInfo::_internal_has_acc_res_cancel_button() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool BasicInfo::has_acc_res_cancel_button() const {
  return _internal_has_acc_res_cancel_button();
}
inline void BasicInfo::clear_acc_res_cancel_button() {
  acc_res_cancel_button_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool BasicInfo::_internal_acc_res_cancel_button() const {
  return acc_res_cancel_button_;
}
inline bool BasicInfo::acc_res_cancel_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_res_cancel_button)
  return _internal_acc_res_cancel_button();
}
inline void BasicInfo::_internal_set_acc_res_cancel_button(bool value) {
  _has_bits_[0] |= 0x00001000u;
  acc_res_cancel_button_ = value;
}
inline void BasicInfo::set_acc_res_cancel_button(bool value) {
  _internal_set_acc_res_cancel_button(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_res_cancel_button)
}

// optional bool acc_inc_spd_button = 14;
inline bool BasicInfo::_internal_has_acc_inc_spd_button() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool BasicInfo::has_acc_inc_spd_button() const {
  return _internal_has_acc_inc_spd_button();
}
inline void BasicInfo::clear_acc_inc_spd_button() {
  acc_inc_spd_button_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool BasicInfo::_internal_acc_inc_spd_button() const {
  return acc_inc_spd_button_;
}
inline bool BasicInfo::acc_inc_spd_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_inc_spd_button)
  return _internal_acc_inc_spd_button();
}
inline void BasicInfo::_internal_set_acc_inc_spd_button(bool value) {
  _has_bits_[0] |= 0x00002000u;
  acc_inc_spd_button_ = value;
}
inline void BasicInfo::set_acc_inc_spd_button(bool value) {
  _internal_set_acc_inc_spd_button(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_inc_spd_button)
}

// optional bool acc_dec_spd_button = 15;
inline bool BasicInfo::_internal_has_acc_dec_spd_button() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool BasicInfo::has_acc_dec_spd_button() const {
  return _internal_has_acc_dec_spd_button();
}
inline void BasicInfo::clear_acc_dec_spd_button() {
  acc_dec_spd_button_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool BasicInfo::_internal_acc_dec_spd_button() const {
  return acc_dec_spd_button_;
}
inline bool BasicInfo::acc_dec_spd_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_dec_spd_button)
  return _internal_acc_dec_spd_button();
}
inline void BasicInfo::_internal_set_acc_dec_spd_button(bool value) {
  _has_bits_[0] |= 0x00004000u;
  acc_dec_spd_button_ = value;
}
inline void BasicInfo::set_acc_dec_spd_button(bool value) {
  _internal_set_acc_dec_spd_button(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_dec_spd_button)
}

// optional bool acc_inc_gap_button = 16;
inline bool BasicInfo::_internal_has_acc_inc_gap_button() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool BasicInfo::has_acc_inc_gap_button() const {
  return _internal_has_acc_inc_gap_button();
}
inline void BasicInfo::clear_acc_inc_gap_button() {
  acc_inc_gap_button_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool BasicInfo::_internal_acc_inc_gap_button() const {
  return acc_inc_gap_button_;
}
inline bool BasicInfo::acc_inc_gap_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_inc_gap_button)
  return _internal_acc_inc_gap_button();
}
inline void BasicInfo::_internal_set_acc_inc_gap_button(bool value) {
  _has_bits_[0] |= 0x00008000u;
  acc_inc_gap_button_ = value;
}
inline void BasicInfo::set_acc_inc_gap_button(bool value) {
  _internal_set_acc_inc_gap_button(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_inc_gap_button)
}

// optional bool acc_dec_gap_button = 17;
inline bool BasicInfo::_internal_has_acc_dec_gap_button() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool BasicInfo::has_acc_dec_gap_button() const {
  return _internal_has_acc_dec_gap_button();
}
inline void BasicInfo::clear_acc_dec_gap_button() {
  acc_dec_gap_button_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool BasicInfo::_internal_acc_dec_gap_button() const {
  return acc_dec_gap_button_;
}
inline bool BasicInfo::acc_dec_gap_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_dec_gap_button)
  return _internal_acc_dec_gap_button();
}
inline void BasicInfo::_internal_set_acc_dec_gap_button(bool value) {
  _has_bits_[0] |= 0x00010000u;
  acc_dec_gap_button_ = value;
}
inline void BasicInfo::set_acc_dec_gap_button(bool value) {
  _internal_set_acc_dec_gap_button(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_dec_gap_button)
}

// optional bool lka_button = 18;
inline bool BasicInfo::_internal_has_lka_button() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool BasicInfo::has_lka_button() const {
  return _internal_has_lka_button();
}
inline void BasicInfo::clear_lka_button() {
  lka_button_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool BasicInfo::_internal_lka_button() const {
  return lka_button_;
}
inline bool BasicInfo::lka_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.lka_button)
  return _internal_lka_button();
}
inline void BasicInfo::_internal_set_lka_button(bool value) {
  _has_bits_[0] |= 0x00020000u;
  lka_button_ = value;
}
inline void BasicInfo::set_lka_button(bool value) {
  _internal_set_lka_button(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.lka_button)
}

// optional bool canbus_fault = 19;
inline bool BasicInfo::_internal_has_canbus_fault() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool BasicInfo::has_canbus_fault() const {
  return _internal_has_canbus_fault();
}
inline void BasicInfo::clear_canbus_fault() {
  canbus_fault_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool BasicInfo::_internal_canbus_fault() const {
  return canbus_fault_;
}
inline bool BasicInfo::canbus_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.canbus_fault)
  return _internal_canbus_fault();
}
inline void BasicInfo::_internal_set_canbus_fault(bool value) {
  _has_bits_[0] |= 0x00040000u;
  canbus_fault_ = value;
}
inline void BasicInfo::set_canbus_fault(bool value) {
  _internal_set_canbus_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.canbus_fault)
}

// optional double latitude = 20;
inline bool BasicInfo::_internal_has_latitude() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool BasicInfo::has_latitude() const {
  return _internal_has_latitude();
}
inline void BasicInfo::clear_latitude() {
  latitude_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline double BasicInfo::_internal_latitude() const {
  return latitude_;
}
inline double BasicInfo::latitude() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.latitude)
  return _internal_latitude();
}
inline void BasicInfo::_internal_set_latitude(double value) {
  _has_bits_[0] |= 0x00100000u;
  latitude_ = value;
}
inline void BasicInfo::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.latitude)
}

// optional double longitude = 21;
inline bool BasicInfo::_internal_has_longitude() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool BasicInfo::has_longitude() const {
  return _internal_has_longitude();
}
inline void BasicInfo::clear_longitude() {
  longitude_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline double BasicInfo::_internal_longitude() const {
  return longitude_;
}
inline double BasicInfo::longitude() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.longitude)
  return _internal_longitude();
}
inline void BasicInfo::_internal_set_longitude(double value) {
  _has_bits_[0] |= 0x00200000u;
  longitude_ = value;
}
inline void BasicInfo::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.longitude)
}

// optional bool gps_valid = 22;
inline bool BasicInfo::_internal_has_gps_valid() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool BasicInfo::has_gps_valid() const {
  return _internal_has_gps_valid();
}
inline void BasicInfo::clear_gps_valid() {
  gps_valid_ = false;
  _has_bits_[0] &= ~0x08000000u;
}
inline bool BasicInfo::_internal_gps_valid() const {
  return gps_valid_;
}
inline bool BasicInfo::gps_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.gps_valid)
  return _internal_gps_valid();
}
inline void BasicInfo::_internal_set_gps_valid(bool value) {
  _has_bits_[0] |= 0x08000000u;
  gps_valid_ = value;
}
inline void BasicInfo::set_gps_valid(bool value) {
  _internal_set_gps_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.gps_valid)
}

// optional int32 year = 23;
inline bool BasicInfo::_internal_has_year() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool BasicInfo::has_year() const {
  return _internal_has_year();
}
inline void BasicInfo::clear_year() {
  year_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::_internal_year() const {
  return year_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::year() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.year)
  return _internal_year();
}
inline void BasicInfo::_internal_set_year(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00080000u;
  year_ = value;
}
inline void BasicInfo::set_year(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.year)
}

// optional int32 month = 24;
inline bool BasicInfo::_internal_has_month() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool BasicInfo::has_month() const {
  return _internal_has_month();
}
inline void BasicInfo::clear_month() {
  month_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::_internal_month() const {
  return month_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::month() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.month)
  return _internal_month();
}
inline void BasicInfo::_internal_set_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00400000u;
  month_ = value;
}
inline void BasicInfo::set_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.month)
}

// optional int32 day = 25;
inline bool BasicInfo::_internal_has_day() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool BasicInfo::has_day() const {
  return _internal_has_day();
}
inline void BasicInfo::clear_day() {
  day_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::_internal_day() const {
  return day_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::day() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.day)
  return _internal_day();
}
inline void BasicInfo::_internal_set_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00800000u;
  day_ = value;
}
inline void BasicInfo::set_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.day)
}

// optional int32 hours = 26;
inline bool BasicInfo::_internal_has_hours() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool BasicInfo::has_hours() const {
  return _internal_has_hours();
}
inline void BasicInfo::clear_hours() {
  hours_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::_internal_hours() const {
  return hours_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::hours() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.hours)
  return _internal_hours();
}
inline void BasicInfo::_internal_set_hours(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x01000000u;
  hours_ = value;
}
inline void BasicInfo::set_hours(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hours(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.hours)
}

// optional int32 minutes = 27;
inline bool BasicInfo::_internal_has_minutes() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool BasicInfo::has_minutes() const {
  return _internal_has_minutes();
}
inline void BasicInfo::clear_minutes() {
  minutes_ = 0;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::_internal_minutes() const {
  return minutes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::minutes() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.minutes)
  return _internal_minutes();
}
inline void BasicInfo::_internal_set_minutes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x02000000u;
  minutes_ = value;
}
inline void BasicInfo::set_minutes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_minutes(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.minutes)
}

// optional int32 seconds = 28;
inline bool BasicInfo::_internal_has_seconds() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool BasicInfo::has_seconds() const {
  return _internal_has_seconds();
}
inline void BasicInfo::clear_seconds() {
  seconds_ = 0;
  _has_bits_[0] &= ~0x04000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::_internal_seconds() const {
  return seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::seconds() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.seconds)
  return _internal_seconds();
}
inline void BasicInfo::_internal_set_seconds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x04000000u;
  seconds_ = value;
}
inline void BasicInfo::set_seconds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.seconds)
}

// optional double compass_direction = 29;
inline bool BasicInfo::_internal_has_compass_direction() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool BasicInfo::has_compass_direction() const {
  return _internal_has_compass_direction();
}
inline void BasicInfo::clear_compass_direction() {
  compass_direction_ = 0;
  _has_bits_[0] &= ~0x40000000u;
}
inline double BasicInfo::_internal_compass_direction() const {
  return compass_direction_;
}
inline double BasicInfo::compass_direction() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.compass_direction)
  return _internal_compass_direction();
}
inline void BasicInfo::_internal_set_compass_direction(double value) {
  _has_bits_[0] |= 0x40000000u;
  compass_direction_ = value;
}
inline void BasicInfo::set_compass_direction(double value) {
  _internal_set_compass_direction(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.compass_direction)
}

// optional double pdop = 30;
inline bool BasicInfo::_internal_has_pdop() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool BasicInfo::has_pdop() const {
  return _internal_has_pdop();
}
inline void BasicInfo::clear_pdop() {
  pdop_ = 0;
  _has_bits_[0] &= ~0x80000000u;
}
inline double BasicInfo::_internal_pdop() const {
  return pdop_;
}
inline double BasicInfo::pdop() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.pdop)
  return _internal_pdop();
}
inline void BasicInfo::_internal_set_pdop(double value) {
  _has_bits_[0] |= 0x80000000u;
  pdop_ = value;
}
inline void BasicInfo::set_pdop(double value) {
  _internal_set_pdop(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.pdop)
}

// optional bool is_gps_fault = 31;
inline bool BasicInfo::_internal_has_is_gps_fault() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool BasicInfo::has_is_gps_fault() const {
  return _internal_has_is_gps_fault();
}
inline void BasicInfo::clear_is_gps_fault() {
  is_gps_fault_ = false;
  _has_bits_[0] &= ~0x10000000u;
}
inline bool BasicInfo::_internal_is_gps_fault() const {
  return is_gps_fault_;
}
inline bool BasicInfo::is_gps_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.is_gps_fault)
  return _internal_is_gps_fault();
}
inline void BasicInfo::_internal_set_is_gps_fault(bool value) {
  _has_bits_[0] |= 0x10000000u;
  is_gps_fault_ = value;
}
inline void BasicInfo::set_is_gps_fault(bool value) {
  _internal_set_is_gps_fault(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.is_gps_fault)
}

// optional bool is_inferred = 32;
inline bool BasicInfo::_internal_has_is_inferred() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool BasicInfo::has_is_inferred() const {
  return _internal_has_is_inferred();
}
inline void BasicInfo::clear_is_inferred() {
  is_inferred_ = false;
  _has_bits_[0] &= ~0x20000000u;
}
inline bool BasicInfo::_internal_is_inferred() const {
  return is_inferred_;
}
inline bool BasicInfo::is_inferred() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.is_inferred)
  return _internal_is_inferred();
}
inline void BasicInfo::_internal_set_is_inferred(bool value) {
  _has_bits_[0] |= 0x20000000u;
  is_inferred_ = value;
}
inline void BasicInfo::set_is_inferred(bool value) {
  _internal_set_is_inferred(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.is_inferred)
}

// optional double altitude = 33;
inline bool BasicInfo::_internal_has_altitude() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool BasicInfo::has_altitude() const {
  return _internal_has_altitude();
}
inline void BasicInfo::clear_altitude() {
  altitude_ = 0;
  _has_bits_[1] &= ~0x00000001u;
}
inline double BasicInfo::_internal_altitude() const {
  return altitude_;
}
inline double BasicInfo::altitude() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.altitude)
  return _internal_altitude();
}
inline void BasicInfo::_internal_set_altitude(double value) {
  _has_bits_[1] |= 0x00000001u;
  altitude_ = value;
}
inline void BasicInfo::set_altitude(double value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.altitude)
}

// optional double heading = 34;
inline bool BasicInfo::_internal_has_heading() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool BasicInfo::has_heading() const {
  return _internal_has_heading();
}
inline void BasicInfo::clear_heading() {
  heading_ = 0;
  _has_bits_[1] &= ~0x00000002u;
}
inline double BasicInfo::_internal_heading() const {
  return heading_;
}
inline double BasicInfo::heading() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.heading)
  return _internal_heading();
}
inline void BasicInfo::_internal_set_heading(double value) {
  _has_bits_[1] |= 0x00000002u;
  heading_ = value;
}
inline void BasicInfo::set_heading(double value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.heading)
}

// optional double hdop = 35;
inline bool BasicInfo::_internal_has_hdop() const {
  bool value = (_has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool BasicInfo::has_hdop() const {
  return _internal_has_hdop();
}
inline void BasicInfo::clear_hdop() {
  hdop_ = 0;
  _has_bits_[1] &= ~0x00000004u;
}
inline double BasicInfo::_internal_hdop() const {
  return hdop_;
}
inline double BasicInfo::hdop() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.hdop)
  return _internal_hdop();
}
inline void BasicInfo::_internal_set_hdop(double value) {
  _has_bits_[1] |= 0x00000004u;
  hdop_ = value;
}
inline void BasicInfo::set_hdop(double value) {
  _internal_set_hdop(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.hdop)
}

// optional double vdop = 36;
inline bool BasicInfo::_internal_has_vdop() const {
  bool value = (_has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool BasicInfo::has_vdop() const {
  return _internal_has_vdop();
}
inline void BasicInfo::clear_vdop() {
  vdop_ = 0;
  _has_bits_[1] &= ~0x00000008u;
}
inline double BasicInfo::_internal_vdop() const {
  return vdop_;
}
inline double BasicInfo::vdop() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.vdop)
  return _internal_vdop();
}
inline void BasicInfo::_internal_set_vdop(double value) {
  _has_bits_[1] |= 0x00000008u;
  vdop_ = value;
}
inline void BasicInfo::set_vdop(double value) {
  _internal_set_vdop(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.vdop)
}

// optional .apollo.canbus.GpsQuality quality = 37;
inline bool BasicInfo::_internal_has_quality() const {
  bool value = (_has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool BasicInfo::has_quality() const {
  return _internal_has_quality();
}
inline void BasicInfo::clear_quality() {
  quality_ = 0;
  _has_bits_[1] &= ~0x00000010u;
}
inline ::apollo::canbus::GpsQuality BasicInfo::_internal_quality() const {
  return static_cast< ::apollo::canbus::GpsQuality >(quality_);
}
inline ::apollo::canbus::GpsQuality BasicInfo::quality() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.quality)
  return _internal_quality();
}
inline void BasicInfo::_internal_set_quality(::apollo::canbus::GpsQuality value) {
  assert(::apollo::canbus::GpsQuality_IsValid(value));
  _has_bits_[1] |= 0x00000010u;
  quality_ = value;
}
inline void BasicInfo::set_quality(::apollo::canbus::GpsQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.quality)
}

// optional int32 num_satellites = 38;
inline bool BasicInfo::_internal_has_num_satellites() const {
  bool value = (_has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool BasicInfo::has_num_satellites() const {
  return _internal_has_num_satellites();
}
inline void BasicInfo::clear_num_satellites() {
  num_satellites_ = 0;
  _has_bits_[1] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::_internal_num_satellites() const {
  return num_satellites_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BasicInfo::num_satellites() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.num_satellites)
  return _internal_num_satellites();
}
inline void BasicInfo::_internal_set_num_satellites(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000020u;
  num_satellites_ = value;
}
inline void BasicInfo::set_num_satellites(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_satellites(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.num_satellites)
}

// optional double gps_speed = 39;
inline bool BasicInfo::_internal_has_gps_speed() const {
  bool value = (_has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool BasicInfo::has_gps_speed() const {
  return _internal_has_gps_speed();
}
inline void BasicInfo::clear_gps_speed() {
  gps_speed_ = 0;
  _has_bits_[1] &= ~0x00000040u;
}
inline double BasicInfo::_internal_gps_speed() const {
  return gps_speed_;
}
inline double BasicInfo::gps_speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.gps_speed)
  return _internal_gps_speed();
}
inline void BasicInfo::_internal_set_gps_speed(double value) {
  _has_bits_[1] |= 0x00000040u;
  gps_speed_ = value;
}
inline void BasicInfo::set_gps_speed(double value) {
  _internal_set_gps_speed(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.gps_speed)
}

// -------------------------------------------------------------------

// Global_rpt_6a

// optional .apollo.canbus.Global_rpt_6a.Pacmod_statusType pacmod_status = 1;
inline bool Global_rpt_6a::_internal_has_pacmod_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Global_rpt_6a::has_pacmod_status() const {
  return _internal_has_pacmod_status();
}
inline void Global_rpt_6a::clear_pacmod_status() {
  pacmod_status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Global_rpt_6a_Pacmod_statusType Global_rpt_6a::_internal_pacmod_status() const {
  return static_cast< ::apollo::canbus::Global_rpt_6a_Pacmod_statusType >(pacmod_status_);
}
inline ::apollo::canbus::Global_rpt_6a_Pacmod_statusType Global_rpt_6a::pacmod_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Global_rpt_6a.pacmod_status)
  return _internal_pacmod_status();
}
inline void Global_rpt_6a::_internal_set_pacmod_status(::apollo::canbus::Global_rpt_6a_Pacmod_statusType value) {
  assert(::apollo::canbus::Global_rpt_6a_Pacmod_statusType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  pacmod_status_ = value;
}
inline void Global_rpt_6a::set_pacmod_status(::apollo::canbus::Global_rpt_6a_Pacmod_statusType value) {
  _internal_set_pacmod_status(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Global_rpt_6a.pacmod_status)
}

// optional .apollo.canbus.Global_rpt_6a.Override_statusType override_status = 2;
inline bool Global_rpt_6a::_internal_has_override_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Global_rpt_6a::has_override_status() const {
  return _internal_has_override_status();
}
inline void Global_rpt_6a::clear_override_status() {
  override_status_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Global_rpt_6a_Override_statusType Global_rpt_6a::_internal_override_status() const {
  return static_cast< ::apollo::canbus::Global_rpt_6a_Override_statusType >(override_status_);
}
inline ::apollo::canbus::Global_rpt_6a_Override_statusType Global_rpt_6a::override_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Global_rpt_6a.override_status)
  return _internal_override_status();
}
inline void Global_rpt_6a::_internal_set_override_status(::apollo::canbus::Global_rpt_6a_Override_statusType value) {
  assert(::apollo::canbus::Global_rpt_6a_Override_statusType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  override_status_ = value;
}
inline void Global_rpt_6a::set_override_status(::apollo::canbus::Global_rpt_6a_Override_statusType value) {
  _internal_set_override_status(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Global_rpt_6a.override_status)
}

// optional bool veh_can_timeout = 3;
inline bool Global_rpt_6a::_internal_has_veh_can_timeout() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Global_rpt_6a::has_veh_can_timeout() const {
  return _internal_has_veh_can_timeout();
}
inline void Global_rpt_6a::clear_veh_can_timeout() {
  veh_can_timeout_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Global_rpt_6a::_internal_veh_can_timeout() const {
  return veh_can_timeout_;
}
inline bool Global_rpt_6a::veh_can_timeout() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Global_rpt_6a.veh_can_timeout)
  return _internal_veh_can_timeout();
}
inline void Global_rpt_6a::_internal_set_veh_can_timeout(bool value) {
  _has_bits_[0] |= 0x00000004u;
  veh_can_timeout_ = value;
}
inline void Global_rpt_6a::set_veh_can_timeout(bool value) {
  _internal_set_veh_can_timeout(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Global_rpt_6a.veh_can_timeout)
}

// optional bool str_can_timeout = 4;
inline bool Global_rpt_6a::_internal_has_str_can_timeout() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Global_rpt_6a::has_str_can_timeout() const {
  return _internal_has_str_can_timeout();
}
inline void Global_rpt_6a::clear_str_can_timeout() {
  str_can_timeout_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Global_rpt_6a::_internal_str_can_timeout() const {
  return str_can_timeout_;
}
inline bool Global_rpt_6a::str_can_timeout() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Global_rpt_6a.str_can_timeout)
  return _internal_str_can_timeout();
}
inline void Global_rpt_6a::_internal_set_str_can_timeout(bool value) {
  _has_bits_[0] |= 0x00000008u;
  str_can_timeout_ = value;
}
inline void Global_rpt_6a::set_str_can_timeout(bool value) {
  _internal_set_str_can_timeout(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Global_rpt_6a.str_can_timeout)
}

// optional .apollo.canbus.Global_rpt_6a.Brk_can_timeoutType brk_can_timeout = 5;
inline bool Global_rpt_6a::_internal_has_brk_can_timeout() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Global_rpt_6a::has_brk_can_timeout() const {
  return _internal_has_brk_can_timeout();
}
inline void Global_rpt_6a::clear_brk_can_timeout() {
  brk_can_timeout_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType Global_rpt_6a::_internal_brk_can_timeout() const {
  return static_cast< ::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType >(brk_can_timeout_);
}
inline ::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType Global_rpt_6a::brk_can_timeout() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Global_rpt_6a.brk_can_timeout)
  return _internal_brk_can_timeout();
}
inline void Global_rpt_6a::_internal_set_brk_can_timeout(::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType value) {
  assert(::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  brk_can_timeout_ = value;
}
inline void Global_rpt_6a::set_brk_can_timeout(::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType value) {
  _internal_set_brk_can_timeout(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Global_rpt_6a.brk_can_timeout)
}

// optional bool usr_can_timeout = 6;
inline bool Global_rpt_6a::_internal_has_usr_can_timeout() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Global_rpt_6a::has_usr_can_timeout() const {
  return _internal_has_usr_can_timeout();
}
inline void Global_rpt_6a::clear_usr_can_timeout() {
  usr_can_timeout_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Global_rpt_6a::_internal_usr_can_timeout() const {
  return usr_can_timeout_;
}
inline bool Global_rpt_6a::usr_can_timeout() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Global_rpt_6a.usr_can_timeout)
  return _internal_usr_can_timeout();
}
inline void Global_rpt_6a::_internal_set_usr_can_timeout(bool value) {
  _has_bits_[0] |= 0x00000010u;
  usr_can_timeout_ = value;
}
inline void Global_rpt_6a::set_usr_can_timeout(bool value) {
  _internal_set_usr_can_timeout(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Global_rpt_6a.usr_can_timeout)
}

// optional int32 usr_can_read_errors = 7;
inline bool Global_rpt_6a::_internal_has_usr_can_read_errors() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Global_rpt_6a::has_usr_can_read_errors() const {
  return _internal_has_usr_can_read_errors();
}
inline void Global_rpt_6a::clear_usr_can_read_errors() {
  usr_can_read_errors_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Global_rpt_6a::_internal_usr_can_read_errors() const {
  return usr_can_read_errors_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Global_rpt_6a::usr_can_read_errors() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Global_rpt_6a.usr_can_read_errors)
  return _internal_usr_can_read_errors();
}
inline void Global_rpt_6a::_internal_set_usr_can_read_errors(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  usr_can_read_errors_ = value;
}
inline void Global_rpt_6a::set_usr_can_read_errors(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_usr_can_read_errors(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Global_rpt_6a.usr_can_read_errors)
}

// -------------------------------------------------------------------

// Brake_cmd_6b

// optional double brake_cmd = 1;
inline bool Brake_cmd_6b::_internal_has_brake_cmd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Brake_cmd_6b::has_brake_cmd() const {
  return _internal_has_brake_cmd();
}
inline void Brake_cmd_6b::clear_brake_cmd() {
  brake_cmd_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Brake_cmd_6b::_internal_brake_cmd() const {
  return brake_cmd_;
}
inline double Brake_cmd_6b::brake_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_cmd_6b.brake_cmd)
  return _internal_brake_cmd();
}
inline void Brake_cmd_6b::_internal_set_brake_cmd(double value) {
  _has_bits_[0] |= 0x00000001u;
  brake_cmd_ = value;
}
inline void Brake_cmd_6b::set_brake_cmd(double value) {
  _internal_set_brake_cmd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_cmd_6b.brake_cmd)
}

// -------------------------------------------------------------------

// Brake_rpt_6c

// optional double manual_input = 1;
inline bool Brake_rpt_6c::_internal_has_manual_input() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Brake_rpt_6c::has_manual_input() const {
  return _internal_has_manual_input();
}
inline void Brake_rpt_6c::clear_manual_input() {
  manual_input_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Brake_rpt_6c::_internal_manual_input() const {
  return manual_input_;
}
inline double Brake_rpt_6c::manual_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_rpt_6c.manual_input)
  return _internal_manual_input();
}
inline void Brake_rpt_6c::_internal_set_manual_input(double value) {
  _has_bits_[0] |= 0x00000001u;
  manual_input_ = value;
}
inline void Brake_rpt_6c::set_manual_input(double value) {
  _internal_set_manual_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_rpt_6c.manual_input)
}

// optional double commanded_value = 2;
inline bool Brake_rpt_6c::_internal_has_commanded_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Brake_rpt_6c::has_commanded_value() const {
  return _internal_has_commanded_value();
}
inline void Brake_rpt_6c::clear_commanded_value() {
  commanded_value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Brake_rpt_6c::_internal_commanded_value() const {
  return commanded_value_;
}
inline double Brake_rpt_6c::commanded_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_rpt_6c.commanded_value)
  return _internal_commanded_value();
}
inline void Brake_rpt_6c::_internal_set_commanded_value(double value) {
  _has_bits_[0] |= 0x00000002u;
  commanded_value_ = value;
}
inline void Brake_rpt_6c::set_commanded_value(double value) {
  _internal_set_commanded_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_rpt_6c.commanded_value)
}

// optional double output_value = 3;
inline bool Brake_rpt_6c::_internal_has_output_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Brake_rpt_6c::has_output_value() const {
  return _internal_has_output_value();
}
inline void Brake_rpt_6c::clear_output_value() {
  output_value_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Brake_rpt_6c::_internal_output_value() const {
  return output_value_;
}
inline double Brake_rpt_6c::output_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_rpt_6c.output_value)
  return _internal_output_value();
}
inline void Brake_rpt_6c::_internal_set_output_value(double value) {
  _has_bits_[0] |= 0x00000004u;
  output_value_ = value;
}
inline void Brake_rpt_6c::set_output_value(double value) {
  _internal_set_output_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_rpt_6c.output_value)
}

// optional .apollo.canbus.Brake_rpt_6c.Brake_on_offType brake_on_off = 4;
inline bool Brake_rpt_6c::_internal_has_brake_on_off() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Brake_rpt_6c::has_brake_on_off() const {
  return _internal_has_brake_on_off();
}
inline void Brake_rpt_6c::clear_brake_on_off() {
  brake_on_off_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::apollo::canbus::Brake_rpt_6c_Brake_on_offType Brake_rpt_6c::_internal_brake_on_off() const {
  return static_cast< ::apollo::canbus::Brake_rpt_6c_Brake_on_offType >(brake_on_off_);
}
inline ::apollo::canbus::Brake_rpt_6c_Brake_on_offType Brake_rpt_6c::brake_on_off() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_rpt_6c.brake_on_off)
  return _internal_brake_on_off();
}
inline void Brake_rpt_6c::_internal_set_brake_on_off(::apollo::canbus::Brake_rpt_6c_Brake_on_offType value) {
  assert(::apollo::canbus::Brake_rpt_6c_Brake_on_offType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  brake_on_off_ = value;
}
inline void Brake_rpt_6c::set_brake_on_off(::apollo::canbus::Brake_rpt_6c_Brake_on_offType value) {
  _internal_set_brake_on_off(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_rpt_6c.brake_on_off)
}

// -------------------------------------------------------------------

// Steering_cmd_6d

// optional double position_value = 1;
inline bool Steering_cmd_6d::_internal_has_position_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Steering_cmd_6d::has_position_value() const {
  return _internal_has_position_value();
}
inline void Steering_cmd_6d::clear_position_value() {
  position_value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Steering_cmd_6d::_internal_position_value() const {
  return position_value_;
}
inline double Steering_cmd_6d::position_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_cmd_6d.position_value)
  return _internal_position_value();
}
inline void Steering_cmd_6d::_internal_set_position_value(double value) {
  _has_bits_[0] |= 0x00000001u;
  position_value_ = value;
}
inline void Steering_cmd_6d::set_position_value(double value) {
  _internal_set_position_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_cmd_6d.position_value)
}

// optional double speed_limit = 2;
inline bool Steering_cmd_6d::_internal_has_speed_limit() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Steering_cmd_6d::has_speed_limit() const {
  return _internal_has_speed_limit();
}
inline void Steering_cmd_6d::clear_speed_limit() {
  speed_limit_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Steering_cmd_6d::_internal_speed_limit() const {
  return speed_limit_;
}
inline double Steering_cmd_6d::speed_limit() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_cmd_6d.speed_limit)
  return _internal_speed_limit();
}
inline void Steering_cmd_6d::_internal_set_speed_limit(double value) {
  _has_bits_[0] |= 0x00000002u;
  speed_limit_ = value;
}
inline void Steering_cmd_6d::set_speed_limit(double value) {
  _internal_set_speed_limit(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_cmd_6d.speed_limit)
}

// -------------------------------------------------------------------

// Steering_rpt_1_6e

// optional double manual_input = 1;
inline bool Steering_rpt_1_6e::_internal_has_manual_input() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Steering_rpt_1_6e::has_manual_input() const {
  return _internal_has_manual_input();
}
inline void Steering_rpt_1_6e::clear_manual_input() {
  manual_input_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Steering_rpt_1_6e::_internal_manual_input() const {
  return manual_input_;
}
inline double Steering_rpt_1_6e::manual_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_rpt_1_6e.manual_input)
  return _internal_manual_input();
}
inline void Steering_rpt_1_6e::_internal_set_manual_input(double value) {
  _has_bits_[0] |= 0x00000001u;
  manual_input_ = value;
}
inline void Steering_rpt_1_6e::set_manual_input(double value) {
  _internal_set_manual_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_rpt_1_6e.manual_input)
}

// optional double commanded_value = 2;
inline bool Steering_rpt_1_6e::_internal_has_commanded_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Steering_rpt_1_6e::has_commanded_value() const {
  return _internal_has_commanded_value();
}
inline void Steering_rpt_1_6e::clear_commanded_value() {
  commanded_value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Steering_rpt_1_6e::_internal_commanded_value() const {
  return commanded_value_;
}
inline double Steering_rpt_1_6e::commanded_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_rpt_1_6e.commanded_value)
  return _internal_commanded_value();
}
inline void Steering_rpt_1_6e::_internal_set_commanded_value(double value) {
  _has_bits_[0] |= 0x00000002u;
  commanded_value_ = value;
}
inline void Steering_rpt_1_6e::set_commanded_value(double value) {
  _internal_set_commanded_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_rpt_1_6e.commanded_value)
}

// optional double output_value = 3;
inline bool Steering_rpt_1_6e::_internal_has_output_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Steering_rpt_1_6e::has_output_value() const {
  return _internal_has_output_value();
}
inline void Steering_rpt_1_6e::clear_output_value() {
  output_value_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Steering_rpt_1_6e::_internal_output_value() const {
  return output_value_;
}
inline double Steering_rpt_1_6e::output_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_rpt_1_6e.output_value)
  return _internal_output_value();
}
inline void Steering_rpt_1_6e::_internal_set_output_value(double value) {
  _has_bits_[0] |= 0x00000004u;
  output_value_ = value;
}
inline void Steering_rpt_1_6e::set_output_value(double value) {
  _internal_set_output_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_rpt_1_6e.output_value)
}

// -------------------------------------------------------------------

// Wheel_speed_rpt_7a

// optional int32 wheel_spd_rear_right = 1;
inline bool Wheel_speed_rpt_7a::_internal_has_wheel_spd_rear_right() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Wheel_speed_rpt_7a::has_wheel_spd_rear_right() const {
  return _internal_has_wheel_spd_rear_right();
}
inline void Wheel_speed_rpt_7a::clear_wheel_spd_rear_right() {
  wheel_spd_rear_right_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Wheel_speed_rpt_7a::_internal_wheel_spd_rear_right() const {
  return wheel_spd_rear_right_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Wheel_speed_rpt_7a::wheel_spd_rear_right() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Wheel_speed_rpt_7a.wheel_spd_rear_right)
  return _internal_wheel_spd_rear_right();
}
inline void Wheel_speed_rpt_7a::_internal_set_wheel_spd_rear_right(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  wheel_spd_rear_right_ = value;
}
inline void Wheel_speed_rpt_7a::set_wheel_spd_rear_right(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wheel_spd_rear_right(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Wheel_speed_rpt_7a.wheel_spd_rear_right)
}

// optional int32 wheel_spd_rear_left = 2;
inline bool Wheel_speed_rpt_7a::_internal_has_wheel_spd_rear_left() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Wheel_speed_rpt_7a::has_wheel_spd_rear_left() const {
  return _internal_has_wheel_spd_rear_left();
}
inline void Wheel_speed_rpt_7a::clear_wheel_spd_rear_left() {
  wheel_spd_rear_left_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Wheel_speed_rpt_7a::_internal_wheel_spd_rear_left() const {
  return wheel_spd_rear_left_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Wheel_speed_rpt_7a::wheel_spd_rear_left() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Wheel_speed_rpt_7a.wheel_spd_rear_left)
  return _internal_wheel_spd_rear_left();
}
inline void Wheel_speed_rpt_7a::_internal_set_wheel_spd_rear_left(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  wheel_spd_rear_left_ = value;
}
inline void Wheel_speed_rpt_7a::set_wheel_spd_rear_left(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wheel_spd_rear_left(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Wheel_speed_rpt_7a.wheel_spd_rear_left)
}

// optional int32 wheel_spd_front_right = 3;
inline bool Wheel_speed_rpt_7a::_internal_has_wheel_spd_front_right() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Wheel_speed_rpt_7a::has_wheel_spd_front_right() const {
  return _internal_has_wheel_spd_front_right();
}
inline void Wheel_speed_rpt_7a::clear_wheel_spd_front_right() {
  wheel_spd_front_right_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Wheel_speed_rpt_7a::_internal_wheel_spd_front_right() const {
  return wheel_spd_front_right_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Wheel_speed_rpt_7a::wheel_spd_front_right() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Wheel_speed_rpt_7a.wheel_spd_front_right)
  return _internal_wheel_spd_front_right();
}
inline void Wheel_speed_rpt_7a::_internal_set_wheel_spd_front_right(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  wheel_spd_front_right_ = value;
}
inline void Wheel_speed_rpt_7a::set_wheel_spd_front_right(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wheel_spd_front_right(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Wheel_speed_rpt_7a.wheel_spd_front_right)
}

// optional int32 wheel_spd_front_left = 4;
inline bool Wheel_speed_rpt_7a::_internal_has_wheel_spd_front_left() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Wheel_speed_rpt_7a::has_wheel_spd_front_left() const {
  return _internal_has_wheel_spd_front_left();
}
inline void Wheel_speed_rpt_7a::clear_wheel_spd_front_left() {
  wheel_spd_front_left_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Wheel_speed_rpt_7a::_internal_wheel_spd_front_left() const {
  return wheel_spd_front_left_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Wheel_speed_rpt_7a::wheel_spd_front_left() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Wheel_speed_rpt_7a.wheel_spd_front_left)
  return _internal_wheel_spd_front_left();
}
inline void Wheel_speed_rpt_7a::_internal_set_wheel_spd_front_left(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  wheel_spd_front_left_ = value;
}
inline void Wheel_speed_rpt_7a::set_wheel_spd_front_left(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wheel_spd_front_left(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Wheel_speed_rpt_7a.wheel_spd_front_left)
}

// -------------------------------------------------------------------

// Date_time_rpt_83

// optional int32 time_second = 1;
inline bool Date_time_rpt_83::_internal_has_time_second() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Date_time_rpt_83::has_time_second() const {
  return _internal_has_time_second();
}
inline void Date_time_rpt_83::clear_time_second() {
  time_second_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date_time_rpt_83::_internal_time_second() const {
  return time_second_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date_time_rpt_83::time_second() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Date_time_rpt_83.time_second)
  return _internal_time_second();
}
inline void Date_time_rpt_83::_internal_set_time_second(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  time_second_ = value;
}
inline void Date_time_rpt_83::set_time_second(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_time_second(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Date_time_rpt_83.time_second)
}

// optional int32 time_minute = 2;
inline bool Date_time_rpt_83::_internal_has_time_minute() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Date_time_rpt_83::has_time_minute() const {
  return _internal_has_time_minute();
}
inline void Date_time_rpt_83::clear_time_minute() {
  time_minute_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date_time_rpt_83::_internal_time_minute() const {
  return time_minute_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date_time_rpt_83::time_minute() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Date_time_rpt_83.time_minute)
  return _internal_time_minute();
}
inline void Date_time_rpt_83::_internal_set_time_minute(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  time_minute_ = value;
}
inline void Date_time_rpt_83::set_time_minute(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_time_minute(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Date_time_rpt_83.time_minute)
}

// optional int32 time_hour = 3;
inline bool Date_time_rpt_83::_internal_has_time_hour() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Date_time_rpt_83::has_time_hour() const {
  return _internal_has_time_hour();
}
inline void Date_time_rpt_83::clear_time_hour() {
  time_hour_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date_time_rpt_83::_internal_time_hour() const {
  return time_hour_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date_time_rpt_83::time_hour() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Date_time_rpt_83.time_hour)
  return _internal_time_hour();
}
inline void Date_time_rpt_83::_internal_set_time_hour(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  time_hour_ = value;
}
inline void Date_time_rpt_83::set_time_hour(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_time_hour(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Date_time_rpt_83.time_hour)
}

// optional int32 date_day = 4;
inline bool Date_time_rpt_83::_internal_has_date_day() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Date_time_rpt_83::has_date_day() const {
  return _internal_has_date_day();
}
inline void Date_time_rpt_83::clear_date_day() {
  date_day_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date_time_rpt_83::_internal_date_day() const {
  return date_day_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date_time_rpt_83::date_day() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Date_time_rpt_83.date_day)
  return _internal_date_day();
}
inline void Date_time_rpt_83::_internal_set_date_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  date_day_ = value;
}
inline void Date_time_rpt_83::set_date_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_date_day(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Date_time_rpt_83.date_day)
}

// optional int32 date_month = 5;
inline bool Date_time_rpt_83::_internal_has_date_month() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Date_time_rpt_83::has_date_month() const {
  return _internal_has_date_month();
}
inline void Date_time_rpt_83::clear_date_month() {
  date_month_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date_time_rpt_83::_internal_date_month() const {
  return date_month_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date_time_rpt_83::date_month() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Date_time_rpt_83.date_month)
  return _internal_date_month();
}
inline void Date_time_rpt_83::_internal_set_date_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  date_month_ = value;
}
inline void Date_time_rpt_83::set_date_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_date_month(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Date_time_rpt_83.date_month)
}

// optional int32 date_year = 6;
inline bool Date_time_rpt_83::_internal_has_date_year() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Date_time_rpt_83::has_date_year() const {
  return _internal_has_date_year();
}
inline void Date_time_rpt_83::clear_date_year() {
  date_year_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date_time_rpt_83::_internal_date_year() const {
  return date_year_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date_time_rpt_83::date_year() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Date_time_rpt_83.date_year)
  return _internal_date_year();
}
inline void Date_time_rpt_83::_internal_set_date_year(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  date_year_ = value;
}
inline void Date_time_rpt_83::set_date_year(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_date_year(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Date_time_rpt_83.date_year)
}

// -------------------------------------------------------------------

// Brake_motor_rpt_1_70

// optional double motor_current = 1;
inline bool Brake_motor_rpt_1_70::_internal_has_motor_current() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Brake_motor_rpt_1_70::has_motor_current() const {
  return _internal_has_motor_current();
}
inline void Brake_motor_rpt_1_70::clear_motor_current() {
  motor_current_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Brake_motor_rpt_1_70::_internal_motor_current() const {
  return motor_current_;
}
inline double Brake_motor_rpt_1_70::motor_current() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_motor_rpt_1_70.motor_current)
  return _internal_motor_current();
}
inline void Brake_motor_rpt_1_70::_internal_set_motor_current(double value) {
  _has_bits_[0] |= 0x00000001u;
  motor_current_ = value;
}
inline void Brake_motor_rpt_1_70::set_motor_current(double value) {
  _internal_set_motor_current(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_motor_rpt_1_70.motor_current)
}

// optional double shaft_position = 2;
inline bool Brake_motor_rpt_1_70::_internal_has_shaft_position() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Brake_motor_rpt_1_70::has_shaft_position() const {
  return _internal_has_shaft_position();
}
inline void Brake_motor_rpt_1_70::clear_shaft_position() {
  shaft_position_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Brake_motor_rpt_1_70::_internal_shaft_position() const {
  return shaft_position_;
}
inline double Brake_motor_rpt_1_70::shaft_position() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_motor_rpt_1_70.shaft_position)
  return _internal_shaft_position();
}
inline void Brake_motor_rpt_1_70::_internal_set_shaft_position(double value) {
  _has_bits_[0] |= 0x00000002u;
  shaft_position_ = value;
}
inline void Brake_motor_rpt_1_70::set_shaft_position(double value) {
  _internal_set_shaft_position(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_motor_rpt_1_70.shaft_position)
}

// -------------------------------------------------------------------

// Headlight_rpt_77

// optional .apollo.canbus.Headlight_rpt_77.Output_valueType output_value = 1;
inline bool Headlight_rpt_77::_internal_has_output_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Headlight_rpt_77::has_output_value() const {
  return _internal_has_output_value();
}
inline void Headlight_rpt_77::clear_output_value() {
  output_value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Headlight_rpt_77_Output_valueType Headlight_rpt_77::_internal_output_value() const {
  return static_cast< ::apollo::canbus::Headlight_rpt_77_Output_valueType >(output_value_);
}
inline ::apollo::canbus::Headlight_rpt_77_Output_valueType Headlight_rpt_77::output_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Headlight_rpt_77.output_value)
  return _internal_output_value();
}
inline void Headlight_rpt_77::_internal_set_output_value(::apollo::canbus::Headlight_rpt_77_Output_valueType value) {
  assert(::apollo::canbus::Headlight_rpt_77_Output_valueType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  output_value_ = value;
}
inline void Headlight_rpt_77::set_output_value(::apollo::canbus::Headlight_rpt_77_Output_valueType value) {
  _internal_set_output_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Headlight_rpt_77.output_value)
}

// optional .apollo.canbus.Headlight_rpt_77.Manual_inputType manual_input = 2;
inline bool Headlight_rpt_77::_internal_has_manual_input() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Headlight_rpt_77::has_manual_input() const {
  return _internal_has_manual_input();
}
inline void Headlight_rpt_77::clear_manual_input() {
  manual_input_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Headlight_rpt_77_Manual_inputType Headlight_rpt_77::_internal_manual_input() const {
  return static_cast< ::apollo::canbus::Headlight_rpt_77_Manual_inputType >(manual_input_);
}
inline ::apollo::canbus::Headlight_rpt_77_Manual_inputType Headlight_rpt_77::manual_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Headlight_rpt_77.manual_input)
  return _internal_manual_input();
}
inline void Headlight_rpt_77::_internal_set_manual_input(::apollo::canbus::Headlight_rpt_77_Manual_inputType value) {
  assert(::apollo::canbus::Headlight_rpt_77_Manual_inputType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  manual_input_ = value;
}
inline void Headlight_rpt_77::set_manual_input(::apollo::canbus::Headlight_rpt_77_Manual_inputType value) {
  _internal_set_manual_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Headlight_rpt_77.manual_input)
}

// optional .apollo.canbus.Headlight_rpt_77.Commanded_valueType commanded_value = 3;
inline bool Headlight_rpt_77::_internal_has_commanded_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Headlight_rpt_77::has_commanded_value() const {
  return _internal_has_commanded_value();
}
inline void Headlight_rpt_77::clear_commanded_value() {
  commanded_value_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::canbus::Headlight_rpt_77_Commanded_valueType Headlight_rpt_77::_internal_commanded_value() const {
  return static_cast< ::apollo::canbus::Headlight_rpt_77_Commanded_valueType >(commanded_value_);
}
inline ::apollo::canbus::Headlight_rpt_77_Commanded_valueType Headlight_rpt_77::commanded_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Headlight_rpt_77.commanded_value)
  return _internal_commanded_value();
}
inline void Headlight_rpt_77::_internal_set_commanded_value(::apollo::canbus::Headlight_rpt_77_Commanded_valueType value) {
  assert(::apollo::canbus::Headlight_rpt_77_Commanded_valueType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  commanded_value_ = value;
}
inline void Headlight_rpt_77::set_commanded_value(::apollo::canbus::Headlight_rpt_77_Commanded_valueType value) {
  _internal_set_commanded_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Headlight_rpt_77.commanded_value)
}

// -------------------------------------------------------------------

// Accel_rpt_68

// optional double manual_input = 1;
inline bool Accel_rpt_68::_internal_has_manual_input() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Accel_rpt_68::has_manual_input() const {
  return _internal_has_manual_input();
}
inline void Accel_rpt_68::clear_manual_input() {
  manual_input_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Accel_rpt_68::_internal_manual_input() const {
  return manual_input_;
}
inline double Accel_rpt_68::manual_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Accel_rpt_68.manual_input)
  return _internal_manual_input();
}
inline void Accel_rpt_68::_internal_set_manual_input(double value) {
  _has_bits_[0] |= 0x00000001u;
  manual_input_ = value;
}
inline void Accel_rpt_68::set_manual_input(double value) {
  _internal_set_manual_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Accel_rpt_68.manual_input)
}

// optional double commanded_value = 2;
inline bool Accel_rpt_68::_internal_has_commanded_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Accel_rpt_68::has_commanded_value() const {
  return _internal_has_commanded_value();
}
inline void Accel_rpt_68::clear_commanded_value() {
  commanded_value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Accel_rpt_68::_internal_commanded_value() const {
  return commanded_value_;
}
inline double Accel_rpt_68::commanded_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Accel_rpt_68.commanded_value)
  return _internal_commanded_value();
}
inline void Accel_rpt_68::_internal_set_commanded_value(double value) {
  _has_bits_[0] |= 0x00000002u;
  commanded_value_ = value;
}
inline void Accel_rpt_68::set_commanded_value(double value) {
  _internal_set_commanded_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Accel_rpt_68.commanded_value)
}

// optional double output_value = 3;
inline bool Accel_rpt_68::_internal_has_output_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Accel_rpt_68::has_output_value() const {
  return _internal_has_output_value();
}
inline void Accel_rpt_68::clear_output_value() {
  output_value_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Accel_rpt_68::_internal_output_value() const {
  return output_value_;
}
inline double Accel_rpt_68::output_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Accel_rpt_68.output_value)
  return _internal_output_value();
}
inline void Accel_rpt_68::_internal_set_output_value(double value) {
  _has_bits_[0] |= 0x00000004u;
  output_value_ = value;
}
inline void Accel_rpt_68::set_output_value(double value) {
  _internal_set_output_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Accel_rpt_68.output_value)
}

// -------------------------------------------------------------------

// Steering_motor_rpt_3_75

// optional double torque_output = 1;
inline bool Steering_motor_rpt_3_75::_internal_has_torque_output() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Steering_motor_rpt_3_75::has_torque_output() const {
  return _internal_has_torque_output();
}
inline void Steering_motor_rpt_3_75::clear_torque_output() {
  torque_output_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Steering_motor_rpt_3_75::_internal_torque_output() const {
  return torque_output_;
}
inline double Steering_motor_rpt_3_75::torque_output() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_motor_rpt_3_75.torque_output)
  return _internal_torque_output();
}
inline void Steering_motor_rpt_3_75::_internal_set_torque_output(double value) {
  _has_bits_[0] |= 0x00000001u;
  torque_output_ = value;
}
inline void Steering_motor_rpt_3_75::set_torque_output(double value) {
  _internal_set_torque_output(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_motor_rpt_3_75.torque_output)
}

// optional double torque_input = 2;
inline bool Steering_motor_rpt_3_75::_internal_has_torque_input() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Steering_motor_rpt_3_75::has_torque_input() const {
  return _internal_has_torque_input();
}
inline void Steering_motor_rpt_3_75::clear_torque_input() {
  torque_input_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Steering_motor_rpt_3_75::_internal_torque_input() const {
  return torque_input_;
}
inline double Steering_motor_rpt_3_75::torque_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_motor_rpt_3_75.torque_input)
  return _internal_torque_input();
}
inline void Steering_motor_rpt_3_75::_internal_set_torque_input(double value) {
  _has_bits_[0] |= 0x00000002u;
  torque_input_ = value;
}
inline void Steering_motor_rpt_3_75::set_torque_input(double value) {
  _internal_set_torque_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_motor_rpt_3_75.torque_input)
}

// -------------------------------------------------------------------

// Turn_cmd_63

// optional .apollo.canbus.Turn_cmd_63.Turn_signal_cmdType turn_signal_cmd = 1;
inline bool Turn_cmd_63::_internal_has_turn_signal_cmd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Turn_cmd_63::has_turn_signal_cmd() const {
  return _internal_has_turn_signal_cmd();
}
inline void Turn_cmd_63::clear_turn_signal_cmd() {
  turn_signal_cmd_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType Turn_cmd_63::_internal_turn_signal_cmd() const {
  return static_cast< ::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType >(turn_signal_cmd_);
}
inline ::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType Turn_cmd_63::turn_signal_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Turn_cmd_63.turn_signal_cmd)
  return _internal_turn_signal_cmd();
}
inline void Turn_cmd_63::_internal_set_turn_signal_cmd(::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType value) {
  assert(::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  turn_signal_cmd_ = value;
}
inline void Turn_cmd_63::set_turn_signal_cmd(::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType value) {
  _internal_set_turn_signal_cmd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Turn_cmd_63.turn_signal_cmd)
}

// -------------------------------------------------------------------

// Turn_rpt_64

// optional .apollo.canbus.Turn_rpt_64.Manual_inputType manual_input = 1;
inline bool Turn_rpt_64::_internal_has_manual_input() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Turn_rpt_64::has_manual_input() const {
  return _internal_has_manual_input();
}
inline void Turn_rpt_64::clear_manual_input() {
  manual_input_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Turn_rpt_64_Manual_inputType Turn_rpt_64::_internal_manual_input() const {
  return static_cast< ::apollo::canbus::Turn_rpt_64_Manual_inputType >(manual_input_);
}
inline ::apollo::canbus::Turn_rpt_64_Manual_inputType Turn_rpt_64::manual_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Turn_rpt_64.manual_input)
  return _internal_manual_input();
}
inline void Turn_rpt_64::_internal_set_manual_input(::apollo::canbus::Turn_rpt_64_Manual_inputType value) {
  assert(::apollo::canbus::Turn_rpt_64_Manual_inputType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  manual_input_ = value;
}
inline void Turn_rpt_64::set_manual_input(::apollo::canbus::Turn_rpt_64_Manual_inputType value) {
  _internal_set_manual_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Turn_rpt_64.manual_input)
}

// optional .apollo.canbus.Turn_rpt_64.Commanded_valueType commanded_value = 2;
inline bool Turn_rpt_64::_internal_has_commanded_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Turn_rpt_64::has_commanded_value() const {
  return _internal_has_commanded_value();
}
inline void Turn_rpt_64::clear_commanded_value() {
  commanded_value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Turn_rpt_64_Commanded_valueType Turn_rpt_64::_internal_commanded_value() const {
  return static_cast< ::apollo::canbus::Turn_rpt_64_Commanded_valueType >(commanded_value_);
}
inline ::apollo::canbus::Turn_rpt_64_Commanded_valueType Turn_rpt_64::commanded_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Turn_rpt_64.commanded_value)
  return _internal_commanded_value();
}
inline void Turn_rpt_64::_internal_set_commanded_value(::apollo::canbus::Turn_rpt_64_Commanded_valueType value) {
  assert(::apollo::canbus::Turn_rpt_64_Commanded_valueType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  commanded_value_ = value;
}
inline void Turn_rpt_64::set_commanded_value(::apollo::canbus::Turn_rpt_64_Commanded_valueType value) {
  _internal_set_commanded_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Turn_rpt_64.commanded_value)
}

// optional .apollo.canbus.Turn_rpt_64.Output_valueType output_value = 3;
inline bool Turn_rpt_64::_internal_has_output_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Turn_rpt_64::has_output_value() const {
  return _internal_has_output_value();
}
inline void Turn_rpt_64::clear_output_value() {
  output_value_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::canbus::Turn_rpt_64_Output_valueType Turn_rpt_64::_internal_output_value() const {
  return static_cast< ::apollo::canbus::Turn_rpt_64_Output_valueType >(output_value_);
}
inline ::apollo::canbus::Turn_rpt_64_Output_valueType Turn_rpt_64::output_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Turn_rpt_64.output_value)
  return _internal_output_value();
}
inline void Turn_rpt_64::_internal_set_output_value(::apollo::canbus::Turn_rpt_64_Output_valueType value) {
  assert(::apollo::canbus::Turn_rpt_64_Output_valueType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  output_value_ = value;
}
inline void Turn_rpt_64::set_output_value(::apollo::canbus::Turn_rpt_64_Output_valueType value) {
  _internal_set_output_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Turn_rpt_64.output_value)
}

// -------------------------------------------------------------------

// Shift_cmd_65

// optional .apollo.canbus.Shift_cmd_65.Shift_cmdType shift_cmd = 1;
inline bool Shift_cmd_65::_internal_has_shift_cmd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Shift_cmd_65::has_shift_cmd() const {
  return _internal_has_shift_cmd();
}
inline void Shift_cmd_65::clear_shift_cmd() {
  shift_cmd_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Shift_cmd_65_Shift_cmdType Shift_cmd_65::_internal_shift_cmd() const {
  return static_cast< ::apollo::canbus::Shift_cmd_65_Shift_cmdType >(shift_cmd_);
}
inline ::apollo::canbus::Shift_cmd_65_Shift_cmdType Shift_cmd_65::shift_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Shift_cmd_65.shift_cmd)
  return _internal_shift_cmd();
}
inline void Shift_cmd_65::_internal_set_shift_cmd(::apollo::canbus::Shift_cmd_65_Shift_cmdType value) {
  assert(::apollo::canbus::Shift_cmd_65_Shift_cmdType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  shift_cmd_ = value;
}
inline void Shift_cmd_65::set_shift_cmd(::apollo::canbus::Shift_cmd_65_Shift_cmdType value) {
  _internal_set_shift_cmd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Shift_cmd_65.shift_cmd)
}

// -------------------------------------------------------------------

// Shift_rpt_66

// optional .apollo.canbus.Shift_rpt_66.Manual_inputType manual_input = 1;
inline bool Shift_rpt_66::_internal_has_manual_input() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Shift_rpt_66::has_manual_input() const {
  return _internal_has_manual_input();
}
inline void Shift_rpt_66::clear_manual_input() {
  manual_input_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Shift_rpt_66_Manual_inputType Shift_rpt_66::_internal_manual_input() const {
  return static_cast< ::apollo::canbus::Shift_rpt_66_Manual_inputType >(manual_input_);
}
inline ::apollo::canbus::Shift_rpt_66_Manual_inputType Shift_rpt_66::manual_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Shift_rpt_66.manual_input)
  return _internal_manual_input();
}
inline void Shift_rpt_66::_internal_set_manual_input(::apollo::canbus::Shift_rpt_66_Manual_inputType value) {
  assert(::apollo::canbus::Shift_rpt_66_Manual_inputType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  manual_input_ = value;
}
inline void Shift_rpt_66::set_manual_input(::apollo::canbus::Shift_rpt_66_Manual_inputType value) {
  _internal_set_manual_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Shift_rpt_66.manual_input)
}

// optional .apollo.canbus.Shift_rpt_66.Commanded_valueType commanded_value = 2;
inline bool Shift_rpt_66::_internal_has_commanded_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Shift_rpt_66::has_commanded_value() const {
  return _internal_has_commanded_value();
}
inline void Shift_rpt_66::clear_commanded_value() {
  commanded_value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Shift_rpt_66_Commanded_valueType Shift_rpt_66::_internal_commanded_value() const {
  return static_cast< ::apollo::canbus::Shift_rpt_66_Commanded_valueType >(commanded_value_);
}
inline ::apollo::canbus::Shift_rpt_66_Commanded_valueType Shift_rpt_66::commanded_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Shift_rpt_66.commanded_value)
  return _internal_commanded_value();
}
inline void Shift_rpt_66::_internal_set_commanded_value(::apollo::canbus::Shift_rpt_66_Commanded_valueType value) {
  assert(::apollo::canbus::Shift_rpt_66_Commanded_valueType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  commanded_value_ = value;
}
inline void Shift_rpt_66::set_commanded_value(::apollo::canbus::Shift_rpt_66_Commanded_valueType value) {
  _internal_set_commanded_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Shift_rpt_66.commanded_value)
}

// optional .apollo.canbus.Shift_rpt_66.Output_valueType output_value = 3;
inline bool Shift_rpt_66::_internal_has_output_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Shift_rpt_66::has_output_value() const {
  return _internal_has_output_value();
}
inline void Shift_rpt_66::clear_output_value() {
  output_value_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::canbus::Shift_rpt_66_Output_valueType Shift_rpt_66::_internal_output_value() const {
  return static_cast< ::apollo::canbus::Shift_rpt_66_Output_valueType >(output_value_);
}
inline ::apollo::canbus::Shift_rpt_66_Output_valueType Shift_rpt_66::output_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Shift_rpt_66.output_value)
  return _internal_output_value();
}
inline void Shift_rpt_66::_internal_set_output_value(::apollo::canbus::Shift_rpt_66_Output_valueType value) {
  assert(::apollo::canbus::Shift_rpt_66_Output_valueType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  output_value_ = value;
}
inline void Shift_rpt_66::set_output_value(::apollo::canbus::Shift_rpt_66_Output_valueType value) {
  _internal_set_output_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Shift_rpt_66.output_value)
}

// -------------------------------------------------------------------

// Accel_cmd_67

// optional double accel_cmd = 1;
inline bool Accel_cmd_67::_internal_has_accel_cmd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Accel_cmd_67::has_accel_cmd() const {
  return _internal_has_accel_cmd();
}
inline void Accel_cmd_67::clear_accel_cmd() {
  accel_cmd_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Accel_cmd_67::_internal_accel_cmd() const {
  return accel_cmd_;
}
inline double Accel_cmd_67::accel_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Accel_cmd_67.accel_cmd)
  return _internal_accel_cmd();
}
inline void Accel_cmd_67::_internal_set_accel_cmd(double value) {
  _has_bits_[0] |= 0x00000001u;
  accel_cmd_ = value;
}
inline void Accel_cmd_67::set_accel_cmd(double value) {
  _internal_set_accel_cmd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Accel_cmd_67.accel_cmd)
}

// -------------------------------------------------------------------

// Lat_lon_heading_rpt_82

// optional double heading = 1;
inline bool Lat_lon_heading_rpt_82::_internal_has_heading() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Lat_lon_heading_rpt_82::has_heading() const {
  return _internal_has_heading();
}
inline void Lat_lon_heading_rpt_82::clear_heading() {
  heading_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Lat_lon_heading_rpt_82::_internal_heading() const {
  return heading_;
}
inline double Lat_lon_heading_rpt_82::heading() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Lat_lon_heading_rpt_82.heading)
  return _internal_heading();
}
inline void Lat_lon_heading_rpt_82::_internal_set_heading(double value) {
  _has_bits_[0] |= 0x00000001u;
  heading_ = value;
}
inline void Lat_lon_heading_rpt_82::set_heading(double value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Lat_lon_heading_rpt_82.heading)
}

// optional int32 longitude_seconds = 2;
inline bool Lat_lon_heading_rpt_82::_internal_has_longitude_seconds() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Lat_lon_heading_rpt_82::has_longitude_seconds() const {
  return _internal_has_longitude_seconds();
}
inline void Lat_lon_heading_rpt_82::clear_longitude_seconds() {
  longitude_seconds_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lat_lon_heading_rpt_82::_internal_longitude_seconds() const {
  return longitude_seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lat_lon_heading_rpt_82::longitude_seconds() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Lat_lon_heading_rpt_82.longitude_seconds)
  return _internal_longitude_seconds();
}
inline void Lat_lon_heading_rpt_82::_internal_set_longitude_seconds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  longitude_seconds_ = value;
}
inline void Lat_lon_heading_rpt_82::set_longitude_seconds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_longitude_seconds(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Lat_lon_heading_rpt_82.longitude_seconds)
}

// optional int32 longitude_minutes = 3;
inline bool Lat_lon_heading_rpt_82::_internal_has_longitude_minutes() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Lat_lon_heading_rpt_82::has_longitude_minutes() const {
  return _internal_has_longitude_minutes();
}
inline void Lat_lon_heading_rpt_82::clear_longitude_minutes() {
  longitude_minutes_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lat_lon_heading_rpt_82::_internal_longitude_minutes() const {
  return longitude_minutes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lat_lon_heading_rpt_82::longitude_minutes() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Lat_lon_heading_rpt_82.longitude_minutes)
  return _internal_longitude_minutes();
}
inline void Lat_lon_heading_rpt_82::_internal_set_longitude_minutes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  longitude_minutes_ = value;
}
inline void Lat_lon_heading_rpt_82::set_longitude_minutes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_longitude_minutes(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Lat_lon_heading_rpt_82.longitude_minutes)
}

// optional int32 longitude_degrees = 4;
inline bool Lat_lon_heading_rpt_82::_internal_has_longitude_degrees() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Lat_lon_heading_rpt_82::has_longitude_degrees() const {
  return _internal_has_longitude_degrees();
}
inline void Lat_lon_heading_rpt_82::clear_longitude_degrees() {
  longitude_degrees_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lat_lon_heading_rpt_82::_internal_longitude_degrees() const {
  return longitude_degrees_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lat_lon_heading_rpt_82::longitude_degrees() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Lat_lon_heading_rpt_82.longitude_degrees)
  return _internal_longitude_degrees();
}
inline void Lat_lon_heading_rpt_82::_internal_set_longitude_degrees(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  longitude_degrees_ = value;
}
inline void Lat_lon_heading_rpt_82::set_longitude_degrees(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_longitude_degrees(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Lat_lon_heading_rpt_82.longitude_degrees)
}

// optional int32 latitude_seconds = 5;
inline bool Lat_lon_heading_rpt_82::_internal_has_latitude_seconds() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Lat_lon_heading_rpt_82::has_latitude_seconds() const {
  return _internal_has_latitude_seconds();
}
inline void Lat_lon_heading_rpt_82::clear_latitude_seconds() {
  latitude_seconds_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lat_lon_heading_rpt_82::_internal_latitude_seconds() const {
  return latitude_seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lat_lon_heading_rpt_82::latitude_seconds() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Lat_lon_heading_rpt_82.latitude_seconds)
  return _internal_latitude_seconds();
}
inline void Lat_lon_heading_rpt_82::_internal_set_latitude_seconds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  latitude_seconds_ = value;
}
inline void Lat_lon_heading_rpt_82::set_latitude_seconds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_latitude_seconds(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Lat_lon_heading_rpt_82.latitude_seconds)
}

// optional int32 latitude_minutes = 6;
inline bool Lat_lon_heading_rpt_82::_internal_has_latitude_minutes() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Lat_lon_heading_rpt_82::has_latitude_minutes() const {
  return _internal_has_latitude_minutes();
}
inline void Lat_lon_heading_rpt_82::clear_latitude_minutes() {
  latitude_minutes_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lat_lon_heading_rpt_82::_internal_latitude_minutes() const {
  return latitude_minutes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lat_lon_heading_rpt_82::latitude_minutes() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Lat_lon_heading_rpt_82.latitude_minutes)
  return _internal_latitude_minutes();
}
inline void Lat_lon_heading_rpt_82::_internal_set_latitude_minutes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  latitude_minutes_ = value;
}
inline void Lat_lon_heading_rpt_82::set_latitude_minutes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_latitude_minutes(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Lat_lon_heading_rpt_82.latitude_minutes)
}

// optional int32 latitude_degrees = 7;
inline bool Lat_lon_heading_rpt_82::_internal_has_latitude_degrees() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Lat_lon_heading_rpt_82::has_latitude_degrees() const {
  return _internal_has_latitude_degrees();
}
inline void Lat_lon_heading_rpt_82::clear_latitude_degrees() {
  latitude_degrees_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lat_lon_heading_rpt_82::_internal_latitude_degrees() const {
  return latitude_degrees_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Lat_lon_heading_rpt_82::latitude_degrees() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Lat_lon_heading_rpt_82.latitude_degrees)
  return _internal_latitude_degrees();
}
inline void Lat_lon_heading_rpt_82::_internal_set_latitude_degrees(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  latitude_degrees_ = value;
}
inline void Lat_lon_heading_rpt_82::set_latitude_degrees(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_latitude_degrees(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Lat_lon_heading_rpt_82.latitude_degrees)
}

// -------------------------------------------------------------------

// Global_cmd_69

// optional .apollo.canbus.Global_cmd_69.Pacmod_enableType pacmod_enable = 1;
inline bool Global_cmd_69::_internal_has_pacmod_enable() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Global_cmd_69::has_pacmod_enable() const {
  return _internal_has_pacmod_enable();
}
inline void Global_cmd_69::clear_pacmod_enable() {
  pacmod_enable_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Global_cmd_69_Pacmod_enableType Global_cmd_69::_internal_pacmod_enable() const {
  return static_cast< ::apollo::canbus::Global_cmd_69_Pacmod_enableType >(pacmod_enable_);
}
inline ::apollo::canbus::Global_cmd_69_Pacmod_enableType Global_cmd_69::pacmod_enable() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Global_cmd_69.pacmod_enable)
  return _internal_pacmod_enable();
}
inline void Global_cmd_69::_internal_set_pacmod_enable(::apollo::canbus::Global_cmd_69_Pacmod_enableType value) {
  assert(::apollo::canbus::Global_cmd_69_Pacmod_enableType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  pacmod_enable_ = value;
}
inline void Global_cmd_69::set_pacmod_enable(::apollo::canbus::Global_cmd_69_Pacmod_enableType value) {
  _internal_set_pacmod_enable(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Global_cmd_69.pacmod_enable)
}

// optional .apollo.canbus.Global_cmd_69.Clear_overrideType clear_override = 2;
inline bool Global_cmd_69::_internal_has_clear_override() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Global_cmd_69::has_clear_override() const {
  return _internal_has_clear_override();
}
inline void Global_cmd_69::clear_clear_override() {
  clear_override_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Global_cmd_69_Clear_overrideType Global_cmd_69::_internal_clear_override() const {
  return static_cast< ::apollo::canbus::Global_cmd_69_Clear_overrideType >(clear_override_);
}
inline ::apollo::canbus::Global_cmd_69_Clear_overrideType Global_cmd_69::clear_override() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Global_cmd_69.clear_override)
  return _internal_clear_override();
}
inline void Global_cmd_69::_internal_set_clear_override(::apollo::canbus::Global_cmd_69_Clear_overrideType value) {
  assert(::apollo::canbus::Global_cmd_69_Clear_overrideType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  clear_override_ = value;
}
inline void Global_cmd_69::set_clear_override(::apollo::canbus::Global_cmd_69_Clear_overrideType value) {
  _internal_set_clear_override(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Global_cmd_69.clear_override)
}

// optional .apollo.canbus.Global_cmd_69.Ignore_overrideType ignore_override = 3;
inline bool Global_cmd_69::_internal_has_ignore_override() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Global_cmd_69::has_ignore_override() const {
  return _internal_has_ignore_override();
}
inline void Global_cmd_69::clear_ignore_override() {
  ignore_override_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::canbus::Global_cmd_69_Ignore_overrideType Global_cmd_69::_internal_ignore_override() const {
  return static_cast< ::apollo::canbus::Global_cmd_69_Ignore_overrideType >(ignore_override_);
}
inline ::apollo::canbus::Global_cmd_69_Ignore_overrideType Global_cmd_69::ignore_override() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Global_cmd_69.ignore_override)
  return _internal_ignore_override();
}
inline void Global_cmd_69::_internal_set_ignore_override(::apollo::canbus::Global_cmd_69_Ignore_overrideType value) {
  assert(::apollo::canbus::Global_cmd_69_Ignore_overrideType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  ignore_override_ = value;
}
inline void Global_cmd_69::set_ignore_override(::apollo::canbus::Global_cmd_69_Ignore_overrideType value) {
  _internal_set_ignore_override(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Global_cmd_69.ignore_override)
}

// -------------------------------------------------------------------

// Parking_brake_status_rpt_80

// optional .apollo.canbus.Parking_brake_status_rpt_80.Parking_brake_enabledType parking_brake_enabled = 1;
inline bool Parking_brake_status_rpt_80::_internal_has_parking_brake_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Parking_brake_status_rpt_80::has_parking_brake_enabled() const {
  return _internal_has_parking_brake_enabled();
}
inline void Parking_brake_status_rpt_80::clear_parking_brake_enabled() {
  parking_brake_enabled_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType Parking_brake_status_rpt_80::_internal_parking_brake_enabled() const {
  return static_cast< ::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType >(parking_brake_enabled_);
}
inline ::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType Parking_brake_status_rpt_80::parking_brake_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Parking_brake_status_rpt_80.parking_brake_enabled)
  return _internal_parking_brake_enabled();
}
inline void Parking_brake_status_rpt_80::_internal_set_parking_brake_enabled(::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType value) {
  assert(::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  parking_brake_enabled_ = value;
}
inline void Parking_brake_status_rpt_80::set_parking_brake_enabled(::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType value) {
  _internal_set_parking_brake_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Parking_brake_status_rpt_80.parking_brake_enabled)
}

// -------------------------------------------------------------------

// Yaw_rate_rpt_81

// optional double yaw_rate = 1;
inline bool Yaw_rate_rpt_81::_internal_has_yaw_rate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Yaw_rate_rpt_81::has_yaw_rate() const {
  return _internal_has_yaw_rate();
}
inline void Yaw_rate_rpt_81::clear_yaw_rate() {
  yaw_rate_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Yaw_rate_rpt_81::_internal_yaw_rate() const {
  return yaw_rate_;
}
inline double Yaw_rate_rpt_81::yaw_rate() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Yaw_rate_rpt_81.yaw_rate)
  return _internal_yaw_rate();
}
inline void Yaw_rate_rpt_81::_internal_set_yaw_rate(double value) {
  _has_bits_[0] |= 0x00000001u;
  yaw_rate_ = value;
}
inline void Yaw_rate_rpt_81::set_yaw_rate(double value) {
  _internal_set_yaw_rate(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Yaw_rate_rpt_81.yaw_rate)
}

// -------------------------------------------------------------------

// Horn_rpt_79

// optional .apollo.canbus.Horn_rpt_79.Output_valueType output_value = 1;
inline bool Horn_rpt_79::_internal_has_output_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Horn_rpt_79::has_output_value() const {
  return _internal_has_output_value();
}
inline void Horn_rpt_79::clear_output_value() {
  output_value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Horn_rpt_79_Output_valueType Horn_rpt_79::_internal_output_value() const {
  return static_cast< ::apollo::canbus::Horn_rpt_79_Output_valueType >(output_value_);
}
inline ::apollo::canbus::Horn_rpt_79_Output_valueType Horn_rpt_79::output_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Horn_rpt_79.output_value)
  return _internal_output_value();
}
inline void Horn_rpt_79::_internal_set_output_value(::apollo::canbus::Horn_rpt_79_Output_valueType value) {
  assert(::apollo::canbus::Horn_rpt_79_Output_valueType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  output_value_ = value;
}
inline void Horn_rpt_79::set_output_value(::apollo::canbus::Horn_rpt_79_Output_valueType value) {
  _internal_set_output_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Horn_rpt_79.output_value)
}

// optional .apollo.canbus.Horn_rpt_79.Commanded_valueType commanded_value = 2;
inline bool Horn_rpt_79::_internal_has_commanded_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Horn_rpt_79::has_commanded_value() const {
  return _internal_has_commanded_value();
}
inline void Horn_rpt_79::clear_commanded_value() {
  commanded_value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Horn_rpt_79_Commanded_valueType Horn_rpt_79::_internal_commanded_value() const {
  return static_cast< ::apollo::canbus::Horn_rpt_79_Commanded_valueType >(commanded_value_);
}
inline ::apollo::canbus::Horn_rpt_79_Commanded_valueType Horn_rpt_79::commanded_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Horn_rpt_79.commanded_value)
  return _internal_commanded_value();
}
inline void Horn_rpt_79::_internal_set_commanded_value(::apollo::canbus::Horn_rpt_79_Commanded_valueType value) {
  assert(::apollo::canbus::Horn_rpt_79_Commanded_valueType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  commanded_value_ = value;
}
inline void Horn_rpt_79::set_commanded_value(::apollo::canbus::Horn_rpt_79_Commanded_valueType value) {
  _internal_set_commanded_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Horn_rpt_79.commanded_value)
}

// optional .apollo.canbus.Horn_rpt_79.Manual_inputType manual_input = 3;
inline bool Horn_rpt_79::_internal_has_manual_input() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Horn_rpt_79::has_manual_input() const {
  return _internal_has_manual_input();
}
inline void Horn_rpt_79::clear_manual_input() {
  manual_input_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::canbus::Horn_rpt_79_Manual_inputType Horn_rpt_79::_internal_manual_input() const {
  return static_cast< ::apollo::canbus::Horn_rpt_79_Manual_inputType >(manual_input_);
}
inline ::apollo::canbus::Horn_rpt_79_Manual_inputType Horn_rpt_79::manual_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Horn_rpt_79.manual_input)
  return _internal_manual_input();
}
inline void Horn_rpt_79::_internal_set_manual_input(::apollo::canbus::Horn_rpt_79_Manual_inputType value) {
  assert(::apollo::canbus::Horn_rpt_79_Manual_inputType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  manual_input_ = value;
}
inline void Horn_rpt_79::set_manual_input(::apollo::canbus::Horn_rpt_79_Manual_inputType value) {
  _internal_set_manual_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Horn_rpt_79.manual_input)
}

// -------------------------------------------------------------------

// Horn_cmd_78

// optional .apollo.canbus.Horn_cmd_78.Horn_cmdType horn_cmd = 1;
inline bool Horn_cmd_78::_internal_has_horn_cmd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Horn_cmd_78::has_horn_cmd() const {
  return _internal_has_horn_cmd();
}
inline void Horn_cmd_78::clear_horn_cmd() {
  horn_cmd_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Horn_cmd_78_Horn_cmdType Horn_cmd_78::_internal_horn_cmd() const {
  return static_cast< ::apollo::canbus::Horn_cmd_78_Horn_cmdType >(horn_cmd_);
}
inline ::apollo::canbus::Horn_cmd_78_Horn_cmdType Horn_cmd_78::horn_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Horn_cmd_78.horn_cmd)
  return _internal_horn_cmd();
}
inline void Horn_cmd_78::_internal_set_horn_cmd(::apollo::canbus::Horn_cmd_78_Horn_cmdType value) {
  assert(::apollo::canbus::Horn_cmd_78_Horn_cmdType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  horn_cmd_ = value;
}
inline void Horn_cmd_78::set_horn_cmd(::apollo::canbus::Horn_cmd_78_Horn_cmdType value) {
  _internal_set_horn_cmd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Horn_cmd_78.horn_cmd)
}

// -------------------------------------------------------------------

// Wiper_rpt_91

// optional .apollo.canbus.Wiper_rpt_91.Output_valueType output_value = 1;
inline bool Wiper_rpt_91::_internal_has_output_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Wiper_rpt_91::has_output_value() const {
  return _internal_has_output_value();
}
inline void Wiper_rpt_91::clear_output_value() {
  output_value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Wiper_rpt_91_Output_valueType Wiper_rpt_91::_internal_output_value() const {
  return static_cast< ::apollo::canbus::Wiper_rpt_91_Output_valueType >(output_value_);
}
inline ::apollo::canbus::Wiper_rpt_91_Output_valueType Wiper_rpt_91::output_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Wiper_rpt_91.output_value)
  return _internal_output_value();
}
inline void Wiper_rpt_91::_internal_set_output_value(::apollo::canbus::Wiper_rpt_91_Output_valueType value) {
  assert(::apollo::canbus::Wiper_rpt_91_Output_valueType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  output_value_ = value;
}
inline void Wiper_rpt_91::set_output_value(::apollo::canbus::Wiper_rpt_91_Output_valueType value) {
  _internal_set_output_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Wiper_rpt_91.output_value)
}

// optional .apollo.canbus.Wiper_rpt_91.Commanded_valueType commanded_value = 2;
inline bool Wiper_rpt_91::_internal_has_commanded_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Wiper_rpt_91::has_commanded_value() const {
  return _internal_has_commanded_value();
}
inline void Wiper_rpt_91::clear_commanded_value() {
  commanded_value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Wiper_rpt_91_Commanded_valueType Wiper_rpt_91::_internal_commanded_value() const {
  return static_cast< ::apollo::canbus::Wiper_rpt_91_Commanded_valueType >(commanded_value_);
}
inline ::apollo::canbus::Wiper_rpt_91_Commanded_valueType Wiper_rpt_91::commanded_value() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Wiper_rpt_91.commanded_value)
  return _internal_commanded_value();
}
inline void Wiper_rpt_91::_internal_set_commanded_value(::apollo::canbus::Wiper_rpt_91_Commanded_valueType value) {
  assert(::apollo::canbus::Wiper_rpt_91_Commanded_valueType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  commanded_value_ = value;
}
inline void Wiper_rpt_91::set_commanded_value(::apollo::canbus::Wiper_rpt_91_Commanded_valueType value) {
  _internal_set_commanded_value(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Wiper_rpt_91.commanded_value)
}

// optional .apollo.canbus.Wiper_rpt_91.Manual_inputType manual_input = 3;
inline bool Wiper_rpt_91::_internal_has_manual_input() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Wiper_rpt_91::has_manual_input() const {
  return _internal_has_manual_input();
}
inline void Wiper_rpt_91::clear_manual_input() {
  manual_input_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::canbus::Wiper_rpt_91_Manual_inputType Wiper_rpt_91::_internal_manual_input() const {
  return static_cast< ::apollo::canbus::Wiper_rpt_91_Manual_inputType >(manual_input_);
}
inline ::apollo::canbus::Wiper_rpt_91_Manual_inputType Wiper_rpt_91::manual_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Wiper_rpt_91.manual_input)
  return _internal_manual_input();
}
inline void Wiper_rpt_91::_internal_set_manual_input(::apollo::canbus::Wiper_rpt_91_Manual_inputType value) {
  assert(::apollo::canbus::Wiper_rpt_91_Manual_inputType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  manual_input_ = value;
}
inline void Wiper_rpt_91::set_manual_input(::apollo::canbus::Wiper_rpt_91_Manual_inputType value) {
  _internal_set_manual_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Wiper_rpt_91.manual_input)
}

// -------------------------------------------------------------------

// Vehicle_speed_rpt_6f

// optional double vehicle_speed = 1;
inline bool Vehicle_speed_rpt_6f::_internal_has_vehicle_speed() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Vehicle_speed_rpt_6f::has_vehicle_speed() const {
  return _internal_has_vehicle_speed();
}
inline void Vehicle_speed_rpt_6f::clear_vehicle_speed() {
  vehicle_speed_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Vehicle_speed_rpt_6f::_internal_vehicle_speed() const {
  return vehicle_speed_;
}
inline double Vehicle_speed_rpt_6f::vehicle_speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_speed_rpt_6f.vehicle_speed)
  return _internal_vehicle_speed();
}
inline void Vehicle_speed_rpt_6f::_internal_set_vehicle_speed(double value) {
  _has_bits_[0] |= 0x00000001u;
  vehicle_speed_ = value;
}
inline void Vehicle_speed_rpt_6f::set_vehicle_speed(double value) {
  _internal_set_vehicle_speed(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_speed_rpt_6f.vehicle_speed)
}

// optional .apollo.canbus.Vehicle_speed_rpt_6f.Vehicle_speed_validType vehicle_speed_valid = 2;
inline bool Vehicle_speed_rpt_6f::_internal_has_vehicle_speed_valid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Vehicle_speed_rpt_6f::has_vehicle_speed_valid() const {
  return _internal_has_vehicle_speed_valid();
}
inline void Vehicle_speed_rpt_6f::clear_vehicle_speed_valid() {
  vehicle_speed_valid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType Vehicle_speed_rpt_6f::_internal_vehicle_speed_valid() const {
  return static_cast< ::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType >(vehicle_speed_valid_);
}
inline ::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType Vehicle_speed_rpt_6f::vehicle_speed_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_speed_rpt_6f.vehicle_speed_valid)
  return _internal_vehicle_speed_valid();
}
inline void Vehicle_speed_rpt_6f::_internal_set_vehicle_speed_valid(::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType value) {
  assert(::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  vehicle_speed_valid_ = value;
}
inline void Vehicle_speed_rpt_6f::set_vehicle_speed_valid(::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType value) {
  _internal_set_vehicle_speed_valid(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_speed_rpt_6f.vehicle_speed_valid)
}

// -------------------------------------------------------------------

// Headlight_cmd_76

// optional .apollo.canbus.Headlight_cmd_76.Headlight_cmdType headlight_cmd = 1;
inline bool Headlight_cmd_76::_internal_has_headlight_cmd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Headlight_cmd_76::has_headlight_cmd() const {
  return _internal_has_headlight_cmd();
}
inline void Headlight_cmd_76::clear_headlight_cmd() {
  headlight_cmd_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Headlight_cmd_76_Headlight_cmdType Headlight_cmd_76::_internal_headlight_cmd() const {
  return static_cast< ::apollo::canbus::Headlight_cmd_76_Headlight_cmdType >(headlight_cmd_);
}
inline ::apollo::canbus::Headlight_cmd_76_Headlight_cmdType Headlight_cmd_76::headlight_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Headlight_cmd_76.headlight_cmd)
  return _internal_headlight_cmd();
}
inline void Headlight_cmd_76::_internal_set_headlight_cmd(::apollo::canbus::Headlight_cmd_76_Headlight_cmdType value) {
  assert(::apollo::canbus::Headlight_cmd_76_Headlight_cmdType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  headlight_cmd_ = value;
}
inline void Headlight_cmd_76::set_headlight_cmd(::apollo::canbus::Headlight_cmd_76_Headlight_cmdType value) {
  _internal_set_headlight_cmd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Headlight_cmd_76.headlight_cmd)
}

// -------------------------------------------------------------------

// Steering_motor_rpt_2_74

// optional int32 encoder_temperature = 1;
inline bool Steering_motor_rpt_2_74::_internal_has_encoder_temperature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Steering_motor_rpt_2_74::has_encoder_temperature() const {
  return _internal_has_encoder_temperature();
}
inline void Steering_motor_rpt_2_74::clear_encoder_temperature() {
  encoder_temperature_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Steering_motor_rpt_2_74::_internal_encoder_temperature() const {
  return encoder_temperature_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Steering_motor_rpt_2_74::encoder_temperature() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_motor_rpt_2_74.encoder_temperature)
  return _internal_encoder_temperature();
}
inline void Steering_motor_rpt_2_74::_internal_set_encoder_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  encoder_temperature_ = value;
}
inline void Steering_motor_rpt_2_74::set_encoder_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_encoder_temperature(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_motor_rpt_2_74.encoder_temperature)
}

// optional int32 motor_temperature = 2;
inline bool Steering_motor_rpt_2_74::_internal_has_motor_temperature() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Steering_motor_rpt_2_74::has_motor_temperature() const {
  return _internal_has_motor_temperature();
}
inline void Steering_motor_rpt_2_74::clear_motor_temperature() {
  motor_temperature_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Steering_motor_rpt_2_74::_internal_motor_temperature() const {
  return motor_temperature_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Steering_motor_rpt_2_74::motor_temperature() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_motor_rpt_2_74.motor_temperature)
  return _internal_motor_temperature();
}
inline void Steering_motor_rpt_2_74::_internal_set_motor_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  motor_temperature_ = value;
}
inline void Steering_motor_rpt_2_74::set_motor_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_motor_temperature(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_motor_rpt_2_74.motor_temperature)
}

// optional double angular_speed = 3;
inline bool Steering_motor_rpt_2_74::_internal_has_angular_speed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Steering_motor_rpt_2_74::has_angular_speed() const {
  return _internal_has_angular_speed();
}
inline void Steering_motor_rpt_2_74::clear_angular_speed() {
  angular_speed_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Steering_motor_rpt_2_74::_internal_angular_speed() const {
  return angular_speed_;
}
inline double Steering_motor_rpt_2_74::angular_speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_motor_rpt_2_74.angular_speed)
  return _internal_angular_speed();
}
inline void Steering_motor_rpt_2_74::_internal_set_angular_speed(double value) {
  _has_bits_[0] |= 0x00000004u;
  angular_speed_ = value;
}
inline void Steering_motor_rpt_2_74::set_angular_speed(double value) {
  _internal_set_angular_speed(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_motor_rpt_2_74.angular_speed)
}

// -------------------------------------------------------------------

// Brake_motor_rpt_2_71

// optional int32 encoder_temperature = 1;
inline bool Brake_motor_rpt_2_71::_internal_has_encoder_temperature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Brake_motor_rpt_2_71::has_encoder_temperature() const {
  return _internal_has_encoder_temperature();
}
inline void Brake_motor_rpt_2_71::clear_encoder_temperature() {
  encoder_temperature_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Brake_motor_rpt_2_71::_internal_encoder_temperature() const {
  return encoder_temperature_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Brake_motor_rpt_2_71::encoder_temperature() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_motor_rpt_2_71.encoder_temperature)
  return _internal_encoder_temperature();
}
inline void Brake_motor_rpt_2_71::_internal_set_encoder_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  encoder_temperature_ = value;
}
inline void Brake_motor_rpt_2_71::set_encoder_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_encoder_temperature(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_motor_rpt_2_71.encoder_temperature)
}

// optional int32 motor_temperature = 2;
inline bool Brake_motor_rpt_2_71::_internal_has_motor_temperature() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Brake_motor_rpt_2_71::has_motor_temperature() const {
  return _internal_has_motor_temperature();
}
inline void Brake_motor_rpt_2_71::clear_motor_temperature() {
  motor_temperature_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Brake_motor_rpt_2_71::_internal_motor_temperature() const {
  return motor_temperature_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Brake_motor_rpt_2_71::motor_temperature() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_motor_rpt_2_71.motor_temperature)
  return _internal_motor_temperature();
}
inline void Brake_motor_rpt_2_71::_internal_set_motor_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  motor_temperature_ = value;
}
inline void Brake_motor_rpt_2_71::set_motor_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_motor_temperature(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_motor_rpt_2_71.motor_temperature)
}

// optional double angular_speed = 3;
inline bool Brake_motor_rpt_2_71::_internal_has_angular_speed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Brake_motor_rpt_2_71::has_angular_speed() const {
  return _internal_has_angular_speed();
}
inline void Brake_motor_rpt_2_71::clear_angular_speed() {
  angular_speed_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Brake_motor_rpt_2_71::_internal_angular_speed() const {
  return angular_speed_;
}
inline double Brake_motor_rpt_2_71::angular_speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_motor_rpt_2_71.angular_speed)
  return _internal_angular_speed();
}
inline void Brake_motor_rpt_2_71::_internal_set_angular_speed(double value) {
  _has_bits_[0] |= 0x00000004u;
  angular_speed_ = value;
}
inline void Brake_motor_rpt_2_71::set_angular_speed(double value) {
  _internal_set_angular_speed(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_motor_rpt_2_71.angular_speed)
}

// -------------------------------------------------------------------

// Steering_motor_rpt_1_73

// optional double motor_current = 1;
inline bool Steering_motor_rpt_1_73::_internal_has_motor_current() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Steering_motor_rpt_1_73::has_motor_current() const {
  return _internal_has_motor_current();
}
inline void Steering_motor_rpt_1_73::clear_motor_current() {
  motor_current_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Steering_motor_rpt_1_73::_internal_motor_current() const {
  return motor_current_;
}
inline double Steering_motor_rpt_1_73::motor_current() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_motor_rpt_1_73.motor_current)
  return _internal_motor_current();
}
inline void Steering_motor_rpt_1_73::_internal_set_motor_current(double value) {
  _has_bits_[0] |= 0x00000001u;
  motor_current_ = value;
}
inline void Steering_motor_rpt_1_73::set_motor_current(double value) {
  _internal_set_motor_current(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_motor_rpt_1_73.motor_current)
}

// optional double shaft_position = 2;
inline bool Steering_motor_rpt_1_73::_internal_has_shaft_position() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Steering_motor_rpt_1_73::has_shaft_position() const {
  return _internal_has_shaft_position();
}
inline void Steering_motor_rpt_1_73::clear_shaft_position() {
  shaft_position_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Steering_motor_rpt_1_73::_internal_shaft_position() const {
  return shaft_position_;
}
inline double Steering_motor_rpt_1_73::shaft_position() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_motor_rpt_1_73.shaft_position)
  return _internal_shaft_position();
}
inline void Steering_motor_rpt_1_73::_internal_set_shaft_position(double value) {
  _has_bits_[0] |= 0x00000002u;
  shaft_position_ = value;
}
inline void Steering_motor_rpt_1_73::set_shaft_position(double value) {
  _internal_set_shaft_position(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_motor_rpt_1_73.shaft_position)
}

// -------------------------------------------------------------------

// Wiper_cmd_90

// optional .apollo.canbus.Wiper_cmd_90.Wiper_cmdType wiper_cmd = 1;
inline bool Wiper_cmd_90::_internal_has_wiper_cmd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Wiper_cmd_90::has_wiper_cmd() const {
  return _internal_has_wiper_cmd();
}
inline void Wiper_cmd_90::clear_wiper_cmd() {
  wiper_cmd_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::canbus::Wiper_cmd_90_Wiper_cmdType Wiper_cmd_90::_internal_wiper_cmd() const {
  return static_cast< ::apollo::canbus::Wiper_cmd_90_Wiper_cmdType >(wiper_cmd_);
}
inline ::apollo::canbus::Wiper_cmd_90_Wiper_cmdType Wiper_cmd_90::wiper_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Wiper_cmd_90.wiper_cmd)
  return _internal_wiper_cmd();
}
inline void Wiper_cmd_90::_internal_set_wiper_cmd(::apollo::canbus::Wiper_cmd_90_Wiper_cmdType value) {
  assert(::apollo::canbus::Wiper_cmd_90_Wiper_cmdType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  wiper_cmd_ = value;
}
inline void Wiper_cmd_90::set_wiper_cmd(::apollo::canbus::Wiper_cmd_90_Wiper_cmdType value) {
  _internal_set_wiper_cmd(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Wiper_cmd_90.wiper_cmd)
}

// -------------------------------------------------------------------

// Brake_motor_rpt_3_72

// optional double torque_output = 1;
inline bool Brake_motor_rpt_3_72::_internal_has_torque_output() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Brake_motor_rpt_3_72::has_torque_output() const {
  return _internal_has_torque_output();
}
inline void Brake_motor_rpt_3_72::clear_torque_output() {
  torque_output_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Brake_motor_rpt_3_72::_internal_torque_output() const {
  return torque_output_;
}
inline double Brake_motor_rpt_3_72::torque_output() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_motor_rpt_3_72.torque_output)
  return _internal_torque_output();
}
inline void Brake_motor_rpt_3_72::_internal_set_torque_output(double value) {
  _has_bits_[0] |= 0x00000001u;
  torque_output_ = value;
}
inline void Brake_motor_rpt_3_72::set_torque_output(double value) {
  _internal_set_torque_output(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_motor_rpt_3_72.torque_output)
}

// optional double torque_input = 2;
inline bool Brake_motor_rpt_3_72::_internal_has_torque_input() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Brake_motor_rpt_3_72::has_torque_input() const {
  return _internal_has_torque_input();
}
inline void Brake_motor_rpt_3_72::clear_torque_input() {
  torque_input_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Brake_motor_rpt_3_72::_internal_torque_input() const {
  return torque_input_;
}
inline double Brake_motor_rpt_3_72::torque_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_motor_rpt_3_72.torque_input)
  return _internal_torque_input();
}
inline void Brake_motor_rpt_3_72::_internal_set_torque_input(double value) {
  _has_bits_[0] |= 0x00000002u;
  torque_input_ = value;
}
inline void Brake_motor_rpt_3_72::set_torque_input(double value) {
  _internal_set_torque_input(value);
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_motor_rpt_3_72.torque_input)
}

// -------------------------------------------------------------------

// Gem

// optional .apollo.canbus.Global_rpt_6a global_rpt_6a = 1;
inline bool Gem::_internal_has_global_rpt_6a() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || global_rpt_6a_ != nullptr);
  return value;
}
inline bool Gem::has_global_rpt_6a() const {
  return _internal_has_global_rpt_6a();
}
inline void Gem::clear_global_rpt_6a() {
  if (global_rpt_6a_ != nullptr) global_rpt_6a_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::canbus::Global_rpt_6a& Gem::_internal_global_rpt_6a() const {
  const ::apollo::canbus::Global_rpt_6a* p = global_rpt_6a_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Global_rpt_6a*>(
      &::apollo::canbus::_Global_rpt_6a_default_instance_);
}
inline const ::apollo::canbus::Global_rpt_6a& Gem::global_rpt_6a() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.global_rpt_6a)
  return _internal_global_rpt_6a();
}
inline ::apollo::canbus::Global_rpt_6a* Gem::release_global_rpt_6a() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.global_rpt_6a)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::canbus::Global_rpt_6a* temp = global_rpt_6a_;
  global_rpt_6a_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Global_rpt_6a* Gem::_internal_mutable_global_rpt_6a() {
  _has_bits_[0] |= 0x00000001u;
  if (global_rpt_6a_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Global_rpt_6a>(GetArenaNoVirtual());
    global_rpt_6a_ = p;
  }
  return global_rpt_6a_;
}
inline ::apollo::canbus::Global_rpt_6a* Gem::mutable_global_rpt_6a() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.global_rpt_6a)
  return _internal_mutable_global_rpt_6a();
}
inline void Gem::set_allocated_global_rpt_6a(::apollo::canbus::Global_rpt_6a* global_rpt_6a) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete global_rpt_6a_;
  }
  if (global_rpt_6a) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      global_rpt_6a = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, global_rpt_6a, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  global_rpt_6a_ = global_rpt_6a;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.global_rpt_6a)
}

// optional .apollo.canbus.Brake_cmd_6b brake_cmd_6b = 2;
inline bool Gem::_internal_has_brake_cmd_6b() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || brake_cmd_6b_ != nullptr);
  return value;
}
inline bool Gem::has_brake_cmd_6b() const {
  return _internal_has_brake_cmd_6b();
}
inline void Gem::clear_brake_cmd_6b() {
  if (brake_cmd_6b_ != nullptr) brake_cmd_6b_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::canbus::Brake_cmd_6b& Gem::_internal_brake_cmd_6b() const {
  const ::apollo::canbus::Brake_cmd_6b* p = brake_cmd_6b_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Brake_cmd_6b*>(
      &::apollo::canbus::_Brake_cmd_6b_default_instance_);
}
inline const ::apollo::canbus::Brake_cmd_6b& Gem::brake_cmd_6b() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.brake_cmd_6b)
  return _internal_brake_cmd_6b();
}
inline ::apollo::canbus::Brake_cmd_6b* Gem::release_brake_cmd_6b() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.brake_cmd_6b)
  _has_bits_[0] &= ~0x00000002u;
  ::apollo::canbus::Brake_cmd_6b* temp = brake_cmd_6b_;
  brake_cmd_6b_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Brake_cmd_6b* Gem::_internal_mutable_brake_cmd_6b() {
  _has_bits_[0] |= 0x00000002u;
  if (brake_cmd_6b_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Brake_cmd_6b>(GetArenaNoVirtual());
    brake_cmd_6b_ = p;
  }
  return brake_cmd_6b_;
}
inline ::apollo::canbus::Brake_cmd_6b* Gem::mutable_brake_cmd_6b() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.brake_cmd_6b)
  return _internal_mutable_brake_cmd_6b();
}
inline void Gem::set_allocated_brake_cmd_6b(::apollo::canbus::Brake_cmd_6b* brake_cmd_6b) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete brake_cmd_6b_;
  }
  if (brake_cmd_6b) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      brake_cmd_6b = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brake_cmd_6b, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  brake_cmd_6b_ = brake_cmd_6b;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.brake_cmd_6b)
}

// optional .apollo.canbus.Brake_rpt_6c brake_rpt_6c = 3;
inline bool Gem::_internal_has_brake_rpt_6c() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || brake_rpt_6c_ != nullptr);
  return value;
}
inline bool Gem::has_brake_rpt_6c() const {
  return _internal_has_brake_rpt_6c();
}
inline void Gem::clear_brake_rpt_6c() {
  if (brake_rpt_6c_ != nullptr) brake_rpt_6c_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::canbus::Brake_rpt_6c& Gem::_internal_brake_rpt_6c() const {
  const ::apollo::canbus::Brake_rpt_6c* p = brake_rpt_6c_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Brake_rpt_6c*>(
      &::apollo::canbus::_Brake_rpt_6c_default_instance_);
}
inline const ::apollo::canbus::Brake_rpt_6c& Gem::brake_rpt_6c() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.brake_rpt_6c)
  return _internal_brake_rpt_6c();
}
inline ::apollo::canbus::Brake_rpt_6c* Gem::release_brake_rpt_6c() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.brake_rpt_6c)
  _has_bits_[0] &= ~0x00000004u;
  ::apollo::canbus::Brake_rpt_6c* temp = brake_rpt_6c_;
  brake_rpt_6c_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Brake_rpt_6c* Gem::_internal_mutable_brake_rpt_6c() {
  _has_bits_[0] |= 0x00000004u;
  if (brake_rpt_6c_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Brake_rpt_6c>(GetArenaNoVirtual());
    brake_rpt_6c_ = p;
  }
  return brake_rpt_6c_;
}
inline ::apollo::canbus::Brake_rpt_6c* Gem::mutable_brake_rpt_6c() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.brake_rpt_6c)
  return _internal_mutable_brake_rpt_6c();
}
inline void Gem::set_allocated_brake_rpt_6c(::apollo::canbus::Brake_rpt_6c* brake_rpt_6c) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete brake_rpt_6c_;
  }
  if (brake_rpt_6c) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      brake_rpt_6c = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brake_rpt_6c, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  brake_rpt_6c_ = brake_rpt_6c;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.brake_rpt_6c)
}

// optional .apollo.canbus.Steering_cmd_6d steering_cmd_6d = 4;
inline bool Gem::_internal_has_steering_cmd_6d() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || steering_cmd_6d_ != nullptr);
  return value;
}
inline bool Gem::has_steering_cmd_6d() const {
  return _internal_has_steering_cmd_6d();
}
inline void Gem::clear_steering_cmd_6d() {
  if (steering_cmd_6d_ != nullptr) steering_cmd_6d_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::canbus::Steering_cmd_6d& Gem::_internal_steering_cmd_6d() const {
  const ::apollo::canbus::Steering_cmd_6d* p = steering_cmd_6d_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Steering_cmd_6d*>(
      &::apollo::canbus::_Steering_cmd_6d_default_instance_);
}
inline const ::apollo::canbus::Steering_cmd_6d& Gem::steering_cmd_6d() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.steering_cmd_6d)
  return _internal_steering_cmd_6d();
}
inline ::apollo::canbus::Steering_cmd_6d* Gem::release_steering_cmd_6d() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.steering_cmd_6d)
  _has_bits_[0] &= ~0x00000008u;
  ::apollo::canbus::Steering_cmd_6d* temp = steering_cmd_6d_;
  steering_cmd_6d_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Steering_cmd_6d* Gem::_internal_mutable_steering_cmd_6d() {
  _has_bits_[0] |= 0x00000008u;
  if (steering_cmd_6d_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Steering_cmd_6d>(GetArenaNoVirtual());
    steering_cmd_6d_ = p;
  }
  return steering_cmd_6d_;
}
inline ::apollo::canbus::Steering_cmd_6d* Gem::mutable_steering_cmd_6d() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.steering_cmd_6d)
  return _internal_mutable_steering_cmd_6d();
}
inline void Gem::set_allocated_steering_cmd_6d(::apollo::canbus::Steering_cmd_6d* steering_cmd_6d) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete steering_cmd_6d_;
  }
  if (steering_cmd_6d) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      steering_cmd_6d = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steering_cmd_6d, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  steering_cmd_6d_ = steering_cmd_6d;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.steering_cmd_6d)
}

// optional .apollo.canbus.Steering_rpt_1_6e steering_rpt_1_6e = 5;
inline bool Gem::_internal_has_steering_rpt_1_6e() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || steering_rpt_1_6e_ != nullptr);
  return value;
}
inline bool Gem::has_steering_rpt_1_6e() const {
  return _internal_has_steering_rpt_1_6e();
}
inline void Gem::clear_steering_rpt_1_6e() {
  if (steering_rpt_1_6e_ != nullptr) steering_rpt_1_6e_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::apollo::canbus::Steering_rpt_1_6e& Gem::_internal_steering_rpt_1_6e() const {
  const ::apollo::canbus::Steering_rpt_1_6e* p = steering_rpt_1_6e_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Steering_rpt_1_6e*>(
      &::apollo::canbus::_Steering_rpt_1_6e_default_instance_);
}
inline const ::apollo::canbus::Steering_rpt_1_6e& Gem::steering_rpt_1_6e() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.steering_rpt_1_6e)
  return _internal_steering_rpt_1_6e();
}
inline ::apollo::canbus::Steering_rpt_1_6e* Gem::release_steering_rpt_1_6e() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.steering_rpt_1_6e)
  _has_bits_[0] &= ~0x00000010u;
  ::apollo::canbus::Steering_rpt_1_6e* temp = steering_rpt_1_6e_;
  steering_rpt_1_6e_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Steering_rpt_1_6e* Gem::_internal_mutable_steering_rpt_1_6e() {
  _has_bits_[0] |= 0x00000010u;
  if (steering_rpt_1_6e_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Steering_rpt_1_6e>(GetArenaNoVirtual());
    steering_rpt_1_6e_ = p;
  }
  return steering_rpt_1_6e_;
}
inline ::apollo::canbus::Steering_rpt_1_6e* Gem::mutable_steering_rpt_1_6e() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.steering_rpt_1_6e)
  return _internal_mutable_steering_rpt_1_6e();
}
inline void Gem::set_allocated_steering_rpt_1_6e(::apollo::canbus::Steering_rpt_1_6e* steering_rpt_1_6e) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete steering_rpt_1_6e_;
  }
  if (steering_rpt_1_6e) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      steering_rpt_1_6e = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steering_rpt_1_6e, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  steering_rpt_1_6e_ = steering_rpt_1_6e;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.steering_rpt_1_6e)
}

// optional .apollo.canbus.Wheel_speed_rpt_7a wheel_speed_rpt_7a = 6;
inline bool Gem::_internal_has_wheel_speed_rpt_7a() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || wheel_speed_rpt_7a_ != nullptr);
  return value;
}
inline bool Gem::has_wheel_speed_rpt_7a() const {
  return _internal_has_wheel_speed_rpt_7a();
}
inline void Gem::clear_wheel_speed_rpt_7a() {
  if (wheel_speed_rpt_7a_ != nullptr) wheel_speed_rpt_7a_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::apollo::canbus::Wheel_speed_rpt_7a& Gem::_internal_wheel_speed_rpt_7a() const {
  const ::apollo::canbus::Wheel_speed_rpt_7a* p = wheel_speed_rpt_7a_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Wheel_speed_rpt_7a*>(
      &::apollo::canbus::_Wheel_speed_rpt_7a_default_instance_);
}
inline const ::apollo::canbus::Wheel_speed_rpt_7a& Gem::wheel_speed_rpt_7a() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.wheel_speed_rpt_7a)
  return _internal_wheel_speed_rpt_7a();
}
inline ::apollo::canbus::Wheel_speed_rpt_7a* Gem::release_wheel_speed_rpt_7a() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.wheel_speed_rpt_7a)
  _has_bits_[0] &= ~0x00000020u;
  ::apollo::canbus::Wheel_speed_rpt_7a* temp = wheel_speed_rpt_7a_;
  wheel_speed_rpt_7a_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Wheel_speed_rpt_7a* Gem::_internal_mutable_wheel_speed_rpt_7a() {
  _has_bits_[0] |= 0x00000020u;
  if (wheel_speed_rpt_7a_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Wheel_speed_rpt_7a>(GetArenaNoVirtual());
    wheel_speed_rpt_7a_ = p;
  }
  return wheel_speed_rpt_7a_;
}
inline ::apollo::canbus::Wheel_speed_rpt_7a* Gem::mutable_wheel_speed_rpt_7a() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.wheel_speed_rpt_7a)
  return _internal_mutable_wheel_speed_rpt_7a();
}
inline void Gem::set_allocated_wheel_speed_rpt_7a(::apollo::canbus::Wheel_speed_rpt_7a* wheel_speed_rpt_7a) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete wheel_speed_rpt_7a_;
  }
  if (wheel_speed_rpt_7a) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      wheel_speed_rpt_7a = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wheel_speed_rpt_7a, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  wheel_speed_rpt_7a_ = wheel_speed_rpt_7a;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.wheel_speed_rpt_7a)
}

// optional .apollo.canbus.Date_time_rpt_83 date_time_rpt_83 = 7;
inline bool Gem::_internal_has_date_time_rpt_83() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || date_time_rpt_83_ != nullptr);
  return value;
}
inline bool Gem::has_date_time_rpt_83() const {
  return _internal_has_date_time_rpt_83();
}
inline void Gem::clear_date_time_rpt_83() {
  if (date_time_rpt_83_ != nullptr) date_time_rpt_83_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::apollo::canbus::Date_time_rpt_83& Gem::_internal_date_time_rpt_83() const {
  const ::apollo::canbus::Date_time_rpt_83* p = date_time_rpt_83_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Date_time_rpt_83*>(
      &::apollo::canbus::_Date_time_rpt_83_default_instance_);
}
inline const ::apollo::canbus::Date_time_rpt_83& Gem::date_time_rpt_83() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.date_time_rpt_83)
  return _internal_date_time_rpt_83();
}
inline ::apollo::canbus::Date_time_rpt_83* Gem::release_date_time_rpt_83() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.date_time_rpt_83)
  _has_bits_[0] &= ~0x00000040u;
  ::apollo::canbus::Date_time_rpt_83* temp = date_time_rpt_83_;
  date_time_rpt_83_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Date_time_rpt_83* Gem::_internal_mutable_date_time_rpt_83() {
  _has_bits_[0] |= 0x00000040u;
  if (date_time_rpt_83_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Date_time_rpt_83>(GetArenaNoVirtual());
    date_time_rpt_83_ = p;
  }
  return date_time_rpt_83_;
}
inline ::apollo::canbus::Date_time_rpt_83* Gem::mutable_date_time_rpt_83() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.date_time_rpt_83)
  return _internal_mutable_date_time_rpt_83();
}
inline void Gem::set_allocated_date_time_rpt_83(::apollo::canbus::Date_time_rpt_83* date_time_rpt_83) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete date_time_rpt_83_;
  }
  if (date_time_rpt_83) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      date_time_rpt_83 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_time_rpt_83, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  date_time_rpt_83_ = date_time_rpt_83;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.date_time_rpt_83)
}

// optional .apollo.canbus.Brake_motor_rpt_1_70 brake_motor_rpt_1_70 = 8;
inline bool Gem::_internal_has_brake_motor_rpt_1_70() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || brake_motor_rpt_1_70_ != nullptr);
  return value;
}
inline bool Gem::has_brake_motor_rpt_1_70() const {
  return _internal_has_brake_motor_rpt_1_70();
}
inline void Gem::clear_brake_motor_rpt_1_70() {
  if (brake_motor_rpt_1_70_ != nullptr) brake_motor_rpt_1_70_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::apollo::canbus::Brake_motor_rpt_1_70& Gem::_internal_brake_motor_rpt_1_70() const {
  const ::apollo::canbus::Brake_motor_rpt_1_70* p = brake_motor_rpt_1_70_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Brake_motor_rpt_1_70*>(
      &::apollo::canbus::_Brake_motor_rpt_1_70_default_instance_);
}
inline const ::apollo::canbus::Brake_motor_rpt_1_70& Gem::brake_motor_rpt_1_70() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.brake_motor_rpt_1_70)
  return _internal_brake_motor_rpt_1_70();
}
inline ::apollo::canbus::Brake_motor_rpt_1_70* Gem::release_brake_motor_rpt_1_70() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.brake_motor_rpt_1_70)
  _has_bits_[0] &= ~0x00000080u;
  ::apollo::canbus::Brake_motor_rpt_1_70* temp = brake_motor_rpt_1_70_;
  brake_motor_rpt_1_70_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Brake_motor_rpt_1_70* Gem::_internal_mutable_brake_motor_rpt_1_70() {
  _has_bits_[0] |= 0x00000080u;
  if (brake_motor_rpt_1_70_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Brake_motor_rpt_1_70>(GetArenaNoVirtual());
    brake_motor_rpt_1_70_ = p;
  }
  return brake_motor_rpt_1_70_;
}
inline ::apollo::canbus::Brake_motor_rpt_1_70* Gem::mutable_brake_motor_rpt_1_70() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.brake_motor_rpt_1_70)
  return _internal_mutable_brake_motor_rpt_1_70();
}
inline void Gem::set_allocated_brake_motor_rpt_1_70(::apollo::canbus::Brake_motor_rpt_1_70* brake_motor_rpt_1_70) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete brake_motor_rpt_1_70_;
  }
  if (brake_motor_rpt_1_70) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      brake_motor_rpt_1_70 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brake_motor_rpt_1_70, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  brake_motor_rpt_1_70_ = brake_motor_rpt_1_70;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.brake_motor_rpt_1_70)
}

// optional .apollo.canbus.Headlight_rpt_77 headlight_rpt_77 = 9;
inline bool Gem::_internal_has_headlight_rpt_77() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || headlight_rpt_77_ != nullptr);
  return value;
}
inline bool Gem::has_headlight_rpt_77() const {
  return _internal_has_headlight_rpt_77();
}
inline void Gem::clear_headlight_rpt_77() {
  if (headlight_rpt_77_ != nullptr) headlight_rpt_77_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::apollo::canbus::Headlight_rpt_77& Gem::_internal_headlight_rpt_77() const {
  const ::apollo::canbus::Headlight_rpt_77* p = headlight_rpt_77_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Headlight_rpt_77*>(
      &::apollo::canbus::_Headlight_rpt_77_default_instance_);
}
inline const ::apollo::canbus::Headlight_rpt_77& Gem::headlight_rpt_77() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.headlight_rpt_77)
  return _internal_headlight_rpt_77();
}
inline ::apollo::canbus::Headlight_rpt_77* Gem::release_headlight_rpt_77() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.headlight_rpt_77)
  _has_bits_[0] &= ~0x00000100u;
  ::apollo::canbus::Headlight_rpt_77* temp = headlight_rpt_77_;
  headlight_rpt_77_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Headlight_rpt_77* Gem::_internal_mutable_headlight_rpt_77() {
  _has_bits_[0] |= 0x00000100u;
  if (headlight_rpt_77_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Headlight_rpt_77>(GetArenaNoVirtual());
    headlight_rpt_77_ = p;
  }
  return headlight_rpt_77_;
}
inline ::apollo::canbus::Headlight_rpt_77* Gem::mutable_headlight_rpt_77() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.headlight_rpt_77)
  return _internal_mutable_headlight_rpt_77();
}
inline void Gem::set_allocated_headlight_rpt_77(::apollo::canbus::Headlight_rpt_77* headlight_rpt_77) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete headlight_rpt_77_;
  }
  if (headlight_rpt_77) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      headlight_rpt_77 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headlight_rpt_77, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  headlight_rpt_77_ = headlight_rpt_77;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.headlight_rpt_77)
}

// optional .apollo.canbus.Accel_rpt_68 accel_rpt_68 = 10;
inline bool Gem::_internal_has_accel_rpt_68() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || accel_rpt_68_ != nullptr);
  return value;
}
inline bool Gem::has_accel_rpt_68() const {
  return _internal_has_accel_rpt_68();
}
inline void Gem::clear_accel_rpt_68() {
  if (accel_rpt_68_ != nullptr) accel_rpt_68_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::apollo::canbus::Accel_rpt_68& Gem::_internal_accel_rpt_68() const {
  const ::apollo::canbus::Accel_rpt_68* p = accel_rpt_68_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Accel_rpt_68*>(
      &::apollo::canbus::_Accel_rpt_68_default_instance_);
}
inline const ::apollo::canbus::Accel_rpt_68& Gem::accel_rpt_68() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.accel_rpt_68)
  return _internal_accel_rpt_68();
}
inline ::apollo::canbus::Accel_rpt_68* Gem::release_accel_rpt_68() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.accel_rpt_68)
  _has_bits_[0] &= ~0x00000200u;
  ::apollo::canbus::Accel_rpt_68* temp = accel_rpt_68_;
  accel_rpt_68_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Accel_rpt_68* Gem::_internal_mutable_accel_rpt_68() {
  _has_bits_[0] |= 0x00000200u;
  if (accel_rpt_68_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Accel_rpt_68>(GetArenaNoVirtual());
    accel_rpt_68_ = p;
  }
  return accel_rpt_68_;
}
inline ::apollo::canbus::Accel_rpt_68* Gem::mutable_accel_rpt_68() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.accel_rpt_68)
  return _internal_mutable_accel_rpt_68();
}
inline void Gem::set_allocated_accel_rpt_68(::apollo::canbus::Accel_rpt_68* accel_rpt_68) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete accel_rpt_68_;
  }
  if (accel_rpt_68) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      accel_rpt_68 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accel_rpt_68, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  accel_rpt_68_ = accel_rpt_68;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.accel_rpt_68)
}

// optional .apollo.canbus.Steering_motor_rpt_3_75 steering_motor_rpt_3_75 = 11;
inline bool Gem::_internal_has_steering_motor_rpt_3_75() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || steering_motor_rpt_3_75_ != nullptr);
  return value;
}
inline bool Gem::has_steering_motor_rpt_3_75() const {
  return _internal_has_steering_motor_rpt_3_75();
}
inline void Gem::clear_steering_motor_rpt_3_75() {
  if (steering_motor_rpt_3_75_ != nullptr) steering_motor_rpt_3_75_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::apollo::canbus::Steering_motor_rpt_3_75& Gem::_internal_steering_motor_rpt_3_75() const {
  const ::apollo::canbus::Steering_motor_rpt_3_75* p = steering_motor_rpt_3_75_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Steering_motor_rpt_3_75*>(
      &::apollo::canbus::_Steering_motor_rpt_3_75_default_instance_);
}
inline const ::apollo::canbus::Steering_motor_rpt_3_75& Gem::steering_motor_rpt_3_75() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.steering_motor_rpt_3_75)
  return _internal_steering_motor_rpt_3_75();
}
inline ::apollo::canbus::Steering_motor_rpt_3_75* Gem::release_steering_motor_rpt_3_75() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.steering_motor_rpt_3_75)
  _has_bits_[0] &= ~0x00000400u;
  ::apollo::canbus::Steering_motor_rpt_3_75* temp = steering_motor_rpt_3_75_;
  steering_motor_rpt_3_75_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Steering_motor_rpt_3_75* Gem::_internal_mutable_steering_motor_rpt_3_75() {
  _has_bits_[0] |= 0x00000400u;
  if (steering_motor_rpt_3_75_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Steering_motor_rpt_3_75>(GetArenaNoVirtual());
    steering_motor_rpt_3_75_ = p;
  }
  return steering_motor_rpt_3_75_;
}
inline ::apollo::canbus::Steering_motor_rpt_3_75* Gem::mutable_steering_motor_rpt_3_75() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.steering_motor_rpt_3_75)
  return _internal_mutable_steering_motor_rpt_3_75();
}
inline void Gem::set_allocated_steering_motor_rpt_3_75(::apollo::canbus::Steering_motor_rpt_3_75* steering_motor_rpt_3_75) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete steering_motor_rpt_3_75_;
  }
  if (steering_motor_rpt_3_75) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      steering_motor_rpt_3_75 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steering_motor_rpt_3_75, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  steering_motor_rpt_3_75_ = steering_motor_rpt_3_75;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.steering_motor_rpt_3_75)
}

// optional .apollo.canbus.Turn_cmd_63 turn_cmd_63 = 12;
inline bool Gem::_internal_has_turn_cmd_63() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || turn_cmd_63_ != nullptr);
  return value;
}
inline bool Gem::has_turn_cmd_63() const {
  return _internal_has_turn_cmd_63();
}
inline void Gem::clear_turn_cmd_63() {
  if (turn_cmd_63_ != nullptr) turn_cmd_63_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::apollo::canbus::Turn_cmd_63& Gem::_internal_turn_cmd_63() const {
  const ::apollo::canbus::Turn_cmd_63* p = turn_cmd_63_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Turn_cmd_63*>(
      &::apollo::canbus::_Turn_cmd_63_default_instance_);
}
inline const ::apollo::canbus::Turn_cmd_63& Gem::turn_cmd_63() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.turn_cmd_63)
  return _internal_turn_cmd_63();
}
inline ::apollo::canbus::Turn_cmd_63* Gem::release_turn_cmd_63() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.turn_cmd_63)
  _has_bits_[0] &= ~0x00000800u;
  ::apollo::canbus::Turn_cmd_63* temp = turn_cmd_63_;
  turn_cmd_63_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Turn_cmd_63* Gem::_internal_mutable_turn_cmd_63() {
  _has_bits_[0] |= 0x00000800u;
  if (turn_cmd_63_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Turn_cmd_63>(GetArenaNoVirtual());
    turn_cmd_63_ = p;
  }
  return turn_cmd_63_;
}
inline ::apollo::canbus::Turn_cmd_63* Gem::mutable_turn_cmd_63() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.turn_cmd_63)
  return _internal_mutable_turn_cmd_63();
}
inline void Gem::set_allocated_turn_cmd_63(::apollo::canbus::Turn_cmd_63* turn_cmd_63) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete turn_cmd_63_;
  }
  if (turn_cmd_63) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      turn_cmd_63 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn_cmd_63, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  turn_cmd_63_ = turn_cmd_63;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.turn_cmd_63)
}

// optional .apollo.canbus.Turn_rpt_64 turn_rpt_64 = 13;
inline bool Gem::_internal_has_turn_rpt_64() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || turn_rpt_64_ != nullptr);
  return value;
}
inline bool Gem::has_turn_rpt_64() const {
  return _internal_has_turn_rpt_64();
}
inline void Gem::clear_turn_rpt_64() {
  if (turn_rpt_64_ != nullptr) turn_rpt_64_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::apollo::canbus::Turn_rpt_64& Gem::_internal_turn_rpt_64() const {
  const ::apollo::canbus::Turn_rpt_64* p = turn_rpt_64_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Turn_rpt_64*>(
      &::apollo::canbus::_Turn_rpt_64_default_instance_);
}
inline const ::apollo::canbus::Turn_rpt_64& Gem::turn_rpt_64() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.turn_rpt_64)
  return _internal_turn_rpt_64();
}
inline ::apollo::canbus::Turn_rpt_64* Gem::release_turn_rpt_64() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.turn_rpt_64)
  _has_bits_[0] &= ~0x00001000u;
  ::apollo::canbus::Turn_rpt_64* temp = turn_rpt_64_;
  turn_rpt_64_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Turn_rpt_64* Gem::_internal_mutable_turn_rpt_64() {
  _has_bits_[0] |= 0x00001000u;
  if (turn_rpt_64_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Turn_rpt_64>(GetArenaNoVirtual());
    turn_rpt_64_ = p;
  }
  return turn_rpt_64_;
}
inline ::apollo::canbus::Turn_rpt_64* Gem::mutable_turn_rpt_64() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.turn_rpt_64)
  return _internal_mutable_turn_rpt_64();
}
inline void Gem::set_allocated_turn_rpt_64(::apollo::canbus::Turn_rpt_64* turn_rpt_64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete turn_rpt_64_;
  }
  if (turn_rpt_64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      turn_rpt_64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn_rpt_64, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  turn_rpt_64_ = turn_rpt_64;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.turn_rpt_64)
}

// optional .apollo.canbus.Shift_cmd_65 shift_cmd_65 = 14;
inline bool Gem::_internal_has_shift_cmd_65() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || shift_cmd_65_ != nullptr);
  return value;
}
inline bool Gem::has_shift_cmd_65() const {
  return _internal_has_shift_cmd_65();
}
inline void Gem::clear_shift_cmd_65() {
  if (shift_cmd_65_ != nullptr) shift_cmd_65_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::apollo::canbus::Shift_cmd_65& Gem::_internal_shift_cmd_65() const {
  const ::apollo::canbus::Shift_cmd_65* p = shift_cmd_65_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Shift_cmd_65*>(
      &::apollo::canbus::_Shift_cmd_65_default_instance_);
}
inline const ::apollo::canbus::Shift_cmd_65& Gem::shift_cmd_65() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.shift_cmd_65)
  return _internal_shift_cmd_65();
}
inline ::apollo::canbus::Shift_cmd_65* Gem::release_shift_cmd_65() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.shift_cmd_65)
  _has_bits_[0] &= ~0x00002000u;
  ::apollo::canbus::Shift_cmd_65* temp = shift_cmd_65_;
  shift_cmd_65_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Shift_cmd_65* Gem::_internal_mutable_shift_cmd_65() {
  _has_bits_[0] |= 0x00002000u;
  if (shift_cmd_65_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Shift_cmd_65>(GetArenaNoVirtual());
    shift_cmd_65_ = p;
  }
  return shift_cmd_65_;
}
inline ::apollo::canbus::Shift_cmd_65* Gem::mutable_shift_cmd_65() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.shift_cmd_65)
  return _internal_mutable_shift_cmd_65();
}
inline void Gem::set_allocated_shift_cmd_65(::apollo::canbus::Shift_cmd_65* shift_cmd_65) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete shift_cmd_65_;
  }
  if (shift_cmd_65) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      shift_cmd_65 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shift_cmd_65, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  shift_cmd_65_ = shift_cmd_65;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.shift_cmd_65)
}

// optional .apollo.canbus.Shift_rpt_66 shift_rpt_66 = 15;
inline bool Gem::_internal_has_shift_rpt_66() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || shift_rpt_66_ != nullptr);
  return value;
}
inline bool Gem::has_shift_rpt_66() const {
  return _internal_has_shift_rpt_66();
}
inline void Gem::clear_shift_rpt_66() {
  if (shift_rpt_66_ != nullptr) shift_rpt_66_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::apollo::canbus::Shift_rpt_66& Gem::_internal_shift_rpt_66() const {
  const ::apollo::canbus::Shift_rpt_66* p = shift_rpt_66_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Shift_rpt_66*>(
      &::apollo::canbus::_Shift_rpt_66_default_instance_);
}
inline const ::apollo::canbus::Shift_rpt_66& Gem::shift_rpt_66() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.shift_rpt_66)
  return _internal_shift_rpt_66();
}
inline ::apollo::canbus::Shift_rpt_66* Gem::release_shift_rpt_66() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.shift_rpt_66)
  _has_bits_[0] &= ~0x00004000u;
  ::apollo::canbus::Shift_rpt_66* temp = shift_rpt_66_;
  shift_rpt_66_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Shift_rpt_66* Gem::_internal_mutable_shift_rpt_66() {
  _has_bits_[0] |= 0x00004000u;
  if (shift_rpt_66_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Shift_rpt_66>(GetArenaNoVirtual());
    shift_rpt_66_ = p;
  }
  return shift_rpt_66_;
}
inline ::apollo::canbus::Shift_rpt_66* Gem::mutable_shift_rpt_66() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.shift_rpt_66)
  return _internal_mutable_shift_rpt_66();
}
inline void Gem::set_allocated_shift_rpt_66(::apollo::canbus::Shift_rpt_66* shift_rpt_66) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete shift_rpt_66_;
  }
  if (shift_rpt_66) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      shift_rpt_66 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shift_rpt_66, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  shift_rpt_66_ = shift_rpt_66;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.shift_rpt_66)
}

// optional .apollo.canbus.Accel_cmd_67 accel_cmd_67 = 16;
inline bool Gem::_internal_has_accel_cmd_67() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || accel_cmd_67_ != nullptr);
  return value;
}
inline bool Gem::has_accel_cmd_67() const {
  return _internal_has_accel_cmd_67();
}
inline void Gem::clear_accel_cmd_67() {
  if (accel_cmd_67_ != nullptr) accel_cmd_67_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::apollo::canbus::Accel_cmd_67& Gem::_internal_accel_cmd_67() const {
  const ::apollo::canbus::Accel_cmd_67* p = accel_cmd_67_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Accel_cmd_67*>(
      &::apollo::canbus::_Accel_cmd_67_default_instance_);
}
inline const ::apollo::canbus::Accel_cmd_67& Gem::accel_cmd_67() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.accel_cmd_67)
  return _internal_accel_cmd_67();
}
inline ::apollo::canbus::Accel_cmd_67* Gem::release_accel_cmd_67() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.accel_cmd_67)
  _has_bits_[0] &= ~0x00008000u;
  ::apollo::canbus::Accel_cmd_67* temp = accel_cmd_67_;
  accel_cmd_67_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Accel_cmd_67* Gem::_internal_mutable_accel_cmd_67() {
  _has_bits_[0] |= 0x00008000u;
  if (accel_cmd_67_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Accel_cmd_67>(GetArenaNoVirtual());
    accel_cmd_67_ = p;
  }
  return accel_cmd_67_;
}
inline ::apollo::canbus::Accel_cmd_67* Gem::mutable_accel_cmd_67() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.accel_cmd_67)
  return _internal_mutable_accel_cmd_67();
}
inline void Gem::set_allocated_accel_cmd_67(::apollo::canbus::Accel_cmd_67* accel_cmd_67) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete accel_cmd_67_;
  }
  if (accel_cmd_67) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      accel_cmd_67 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accel_cmd_67, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  accel_cmd_67_ = accel_cmd_67;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.accel_cmd_67)
}

// optional .apollo.canbus.Lat_lon_heading_rpt_82 lat_lon_heading_rpt_82 = 17;
inline bool Gem::_internal_has_lat_lon_heading_rpt_82() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || lat_lon_heading_rpt_82_ != nullptr);
  return value;
}
inline bool Gem::has_lat_lon_heading_rpt_82() const {
  return _internal_has_lat_lon_heading_rpt_82();
}
inline void Gem::clear_lat_lon_heading_rpt_82() {
  if (lat_lon_heading_rpt_82_ != nullptr) lat_lon_heading_rpt_82_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::apollo::canbus::Lat_lon_heading_rpt_82& Gem::_internal_lat_lon_heading_rpt_82() const {
  const ::apollo::canbus::Lat_lon_heading_rpt_82* p = lat_lon_heading_rpt_82_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Lat_lon_heading_rpt_82*>(
      &::apollo::canbus::_Lat_lon_heading_rpt_82_default_instance_);
}
inline const ::apollo::canbus::Lat_lon_heading_rpt_82& Gem::lat_lon_heading_rpt_82() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.lat_lon_heading_rpt_82)
  return _internal_lat_lon_heading_rpt_82();
}
inline ::apollo::canbus::Lat_lon_heading_rpt_82* Gem::release_lat_lon_heading_rpt_82() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.lat_lon_heading_rpt_82)
  _has_bits_[0] &= ~0x00010000u;
  ::apollo::canbus::Lat_lon_heading_rpt_82* temp = lat_lon_heading_rpt_82_;
  lat_lon_heading_rpt_82_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Lat_lon_heading_rpt_82* Gem::_internal_mutable_lat_lon_heading_rpt_82() {
  _has_bits_[0] |= 0x00010000u;
  if (lat_lon_heading_rpt_82_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Lat_lon_heading_rpt_82>(GetArenaNoVirtual());
    lat_lon_heading_rpt_82_ = p;
  }
  return lat_lon_heading_rpt_82_;
}
inline ::apollo::canbus::Lat_lon_heading_rpt_82* Gem::mutable_lat_lon_heading_rpt_82() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.lat_lon_heading_rpt_82)
  return _internal_mutable_lat_lon_heading_rpt_82();
}
inline void Gem::set_allocated_lat_lon_heading_rpt_82(::apollo::canbus::Lat_lon_heading_rpt_82* lat_lon_heading_rpt_82) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete lat_lon_heading_rpt_82_;
  }
  if (lat_lon_heading_rpt_82) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lat_lon_heading_rpt_82 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lat_lon_heading_rpt_82, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  lat_lon_heading_rpt_82_ = lat_lon_heading_rpt_82;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.lat_lon_heading_rpt_82)
}

// optional .apollo.canbus.Global_cmd_69 global_cmd_69 = 18;
inline bool Gem::_internal_has_global_cmd_69() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || global_cmd_69_ != nullptr);
  return value;
}
inline bool Gem::has_global_cmd_69() const {
  return _internal_has_global_cmd_69();
}
inline void Gem::clear_global_cmd_69() {
  if (global_cmd_69_ != nullptr) global_cmd_69_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::apollo::canbus::Global_cmd_69& Gem::_internal_global_cmd_69() const {
  const ::apollo::canbus::Global_cmd_69* p = global_cmd_69_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Global_cmd_69*>(
      &::apollo::canbus::_Global_cmd_69_default_instance_);
}
inline const ::apollo::canbus::Global_cmd_69& Gem::global_cmd_69() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.global_cmd_69)
  return _internal_global_cmd_69();
}
inline ::apollo::canbus::Global_cmd_69* Gem::release_global_cmd_69() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.global_cmd_69)
  _has_bits_[0] &= ~0x00020000u;
  ::apollo::canbus::Global_cmd_69* temp = global_cmd_69_;
  global_cmd_69_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Global_cmd_69* Gem::_internal_mutable_global_cmd_69() {
  _has_bits_[0] |= 0x00020000u;
  if (global_cmd_69_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Global_cmd_69>(GetArenaNoVirtual());
    global_cmd_69_ = p;
  }
  return global_cmd_69_;
}
inline ::apollo::canbus::Global_cmd_69* Gem::mutable_global_cmd_69() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.global_cmd_69)
  return _internal_mutable_global_cmd_69();
}
inline void Gem::set_allocated_global_cmd_69(::apollo::canbus::Global_cmd_69* global_cmd_69) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete global_cmd_69_;
  }
  if (global_cmd_69) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      global_cmd_69 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, global_cmd_69, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  global_cmd_69_ = global_cmd_69;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.global_cmd_69)
}

// optional .apollo.canbus.Parking_brake_status_rpt_80 parking_brake_status_rpt_80 = 19;
inline bool Gem::_internal_has_parking_brake_status_rpt_80() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || parking_brake_status_rpt_80_ != nullptr);
  return value;
}
inline bool Gem::has_parking_brake_status_rpt_80() const {
  return _internal_has_parking_brake_status_rpt_80();
}
inline void Gem::clear_parking_brake_status_rpt_80() {
  if (parking_brake_status_rpt_80_ != nullptr) parking_brake_status_rpt_80_->Clear();
  _has_bits_[0] &= ~0x00040000u;
}
inline const ::apollo::canbus::Parking_brake_status_rpt_80& Gem::_internal_parking_brake_status_rpt_80() const {
  const ::apollo::canbus::Parking_brake_status_rpt_80* p = parking_brake_status_rpt_80_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Parking_brake_status_rpt_80*>(
      &::apollo::canbus::_Parking_brake_status_rpt_80_default_instance_);
}
inline const ::apollo::canbus::Parking_brake_status_rpt_80& Gem::parking_brake_status_rpt_80() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.parking_brake_status_rpt_80)
  return _internal_parking_brake_status_rpt_80();
}
inline ::apollo::canbus::Parking_brake_status_rpt_80* Gem::release_parking_brake_status_rpt_80() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.parking_brake_status_rpt_80)
  _has_bits_[0] &= ~0x00040000u;
  ::apollo::canbus::Parking_brake_status_rpt_80* temp = parking_brake_status_rpt_80_;
  parking_brake_status_rpt_80_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Parking_brake_status_rpt_80* Gem::_internal_mutable_parking_brake_status_rpt_80() {
  _has_bits_[0] |= 0x00040000u;
  if (parking_brake_status_rpt_80_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Parking_brake_status_rpt_80>(GetArenaNoVirtual());
    parking_brake_status_rpt_80_ = p;
  }
  return parking_brake_status_rpt_80_;
}
inline ::apollo::canbus::Parking_brake_status_rpt_80* Gem::mutable_parking_brake_status_rpt_80() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.parking_brake_status_rpt_80)
  return _internal_mutable_parking_brake_status_rpt_80();
}
inline void Gem::set_allocated_parking_brake_status_rpt_80(::apollo::canbus::Parking_brake_status_rpt_80* parking_brake_status_rpt_80) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete parking_brake_status_rpt_80_;
  }
  if (parking_brake_status_rpt_80) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      parking_brake_status_rpt_80 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parking_brake_status_rpt_80, submessage_arena);
    }
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  parking_brake_status_rpt_80_ = parking_brake_status_rpt_80;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.parking_brake_status_rpt_80)
}

// optional .apollo.canbus.Yaw_rate_rpt_81 yaw_rate_rpt_81 = 20;
inline bool Gem::_internal_has_yaw_rate_rpt_81() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || yaw_rate_rpt_81_ != nullptr);
  return value;
}
inline bool Gem::has_yaw_rate_rpt_81() const {
  return _internal_has_yaw_rate_rpt_81();
}
inline void Gem::clear_yaw_rate_rpt_81() {
  if (yaw_rate_rpt_81_ != nullptr) yaw_rate_rpt_81_->Clear();
  _has_bits_[0] &= ~0x00080000u;
}
inline const ::apollo::canbus::Yaw_rate_rpt_81& Gem::_internal_yaw_rate_rpt_81() const {
  const ::apollo::canbus::Yaw_rate_rpt_81* p = yaw_rate_rpt_81_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Yaw_rate_rpt_81*>(
      &::apollo::canbus::_Yaw_rate_rpt_81_default_instance_);
}
inline const ::apollo::canbus::Yaw_rate_rpt_81& Gem::yaw_rate_rpt_81() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.yaw_rate_rpt_81)
  return _internal_yaw_rate_rpt_81();
}
inline ::apollo::canbus::Yaw_rate_rpt_81* Gem::release_yaw_rate_rpt_81() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.yaw_rate_rpt_81)
  _has_bits_[0] &= ~0x00080000u;
  ::apollo::canbus::Yaw_rate_rpt_81* temp = yaw_rate_rpt_81_;
  yaw_rate_rpt_81_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Yaw_rate_rpt_81* Gem::_internal_mutable_yaw_rate_rpt_81() {
  _has_bits_[0] |= 0x00080000u;
  if (yaw_rate_rpt_81_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Yaw_rate_rpt_81>(GetArenaNoVirtual());
    yaw_rate_rpt_81_ = p;
  }
  return yaw_rate_rpt_81_;
}
inline ::apollo::canbus::Yaw_rate_rpt_81* Gem::mutable_yaw_rate_rpt_81() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.yaw_rate_rpt_81)
  return _internal_mutable_yaw_rate_rpt_81();
}
inline void Gem::set_allocated_yaw_rate_rpt_81(::apollo::canbus::Yaw_rate_rpt_81* yaw_rate_rpt_81) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete yaw_rate_rpt_81_;
  }
  if (yaw_rate_rpt_81) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      yaw_rate_rpt_81 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yaw_rate_rpt_81, submessage_arena);
    }
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  yaw_rate_rpt_81_ = yaw_rate_rpt_81;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.yaw_rate_rpt_81)
}

// optional .apollo.canbus.Horn_rpt_79 horn_rpt_79 = 21;
inline bool Gem::_internal_has_horn_rpt_79() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || horn_rpt_79_ != nullptr);
  return value;
}
inline bool Gem::has_horn_rpt_79() const {
  return _internal_has_horn_rpt_79();
}
inline void Gem::clear_horn_rpt_79() {
  if (horn_rpt_79_ != nullptr) horn_rpt_79_->Clear();
  _has_bits_[0] &= ~0x00100000u;
}
inline const ::apollo::canbus::Horn_rpt_79& Gem::_internal_horn_rpt_79() const {
  const ::apollo::canbus::Horn_rpt_79* p = horn_rpt_79_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Horn_rpt_79*>(
      &::apollo::canbus::_Horn_rpt_79_default_instance_);
}
inline const ::apollo::canbus::Horn_rpt_79& Gem::horn_rpt_79() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.horn_rpt_79)
  return _internal_horn_rpt_79();
}
inline ::apollo::canbus::Horn_rpt_79* Gem::release_horn_rpt_79() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.horn_rpt_79)
  _has_bits_[0] &= ~0x00100000u;
  ::apollo::canbus::Horn_rpt_79* temp = horn_rpt_79_;
  horn_rpt_79_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Horn_rpt_79* Gem::_internal_mutable_horn_rpt_79() {
  _has_bits_[0] |= 0x00100000u;
  if (horn_rpt_79_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Horn_rpt_79>(GetArenaNoVirtual());
    horn_rpt_79_ = p;
  }
  return horn_rpt_79_;
}
inline ::apollo::canbus::Horn_rpt_79* Gem::mutable_horn_rpt_79() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.horn_rpt_79)
  return _internal_mutable_horn_rpt_79();
}
inline void Gem::set_allocated_horn_rpt_79(::apollo::canbus::Horn_rpt_79* horn_rpt_79) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete horn_rpt_79_;
  }
  if (horn_rpt_79) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      horn_rpt_79 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, horn_rpt_79, submessage_arena);
    }
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  horn_rpt_79_ = horn_rpt_79;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.horn_rpt_79)
}

// optional .apollo.canbus.Horn_cmd_78 horn_cmd_78 = 22;
inline bool Gem::_internal_has_horn_cmd_78() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || horn_cmd_78_ != nullptr);
  return value;
}
inline bool Gem::has_horn_cmd_78() const {
  return _internal_has_horn_cmd_78();
}
inline void Gem::clear_horn_cmd_78() {
  if (horn_cmd_78_ != nullptr) horn_cmd_78_->Clear();
  _has_bits_[0] &= ~0x00200000u;
}
inline const ::apollo::canbus::Horn_cmd_78& Gem::_internal_horn_cmd_78() const {
  const ::apollo::canbus::Horn_cmd_78* p = horn_cmd_78_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Horn_cmd_78*>(
      &::apollo::canbus::_Horn_cmd_78_default_instance_);
}
inline const ::apollo::canbus::Horn_cmd_78& Gem::horn_cmd_78() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.horn_cmd_78)
  return _internal_horn_cmd_78();
}
inline ::apollo::canbus::Horn_cmd_78* Gem::release_horn_cmd_78() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.horn_cmd_78)
  _has_bits_[0] &= ~0x00200000u;
  ::apollo::canbus::Horn_cmd_78* temp = horn_cmd_78_;
  horn_cmd_78_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Horn_cmd_78* Gem::_internal_mutable_horn_cmd_78() {
  _has_bits_[0] |= 0x00200000u;
  if (horn_cmd_78_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Horn_cmd_78>(GetArenaNoVirtual());
    horn_cmd_78_ = p;
  }
  return horn_cmd_78_;
}
inline ::apollo::canbus::Horn_cmd_78* Gem::mutable_horn_cmd_78() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.horn_cmd_78)
  return _internal_mutable_horn_cmd_78();
}
inline void Gem::set_allocated_horn_cmd_78(::apollo::canbus::Horn_cmd_78* horn_cmd_78) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete horn_cmd_78_;
  }
  if (horn_cmd_78) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      horn_cmd_78 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, horn_cmd_78, submessage_arena);
    }
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  horn_cmd_78_ = horn_cmd_78;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.horn_cmd_78)
}

// optional .apollo.canbus.Wiper_rpt_91 wiper_rpt_91 = 23;
inline bool Gem::_internal_has_wiper_rpt_91() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || wiper_rpt_91_ != nullptr);
  return value;
}
inline bool Gem::has_wiper_rpt_91() const {
  return _internal_has_wiper_rpt_91();
}
inline void Gem::clear_wiper_rpt_91() {
  if (wiper_rpt_91_ != nullptr) wiper_rpt_91_->Clear();
  _has_bits_[0] &= ~0x00400000u;
}
inline const ::apollo::canbus::Wiper_rpt_91& Gem::_internal_wiper_rpt_91() const {
  const ::apollo::canbus::Wiper_rpt_91* p = wiper_rpt_91_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Wiper_rpt_91*>(
      &::apollo::canbus::_Wiper_rpt_91_default_instance_);
}
inline const ::apollo::canbus::Wiper_rpt_91& Gem::wiper_rpt_91() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.wiper_rpt_91)
  return _internal_wiper_rpt_91();
}
inline ::apollo::canbus::Wiper_rpt_91* Gem::release_wiper_rpt_91() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.wiper_rpt_91)
  _has_bits_[0] &= ~0x00400000u;
  ::apollo::canbus::Wiper_rpt_91* temp = wiper_rpt_91_;
  wiper_rpt_91_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Wiper_rpt_91* Gem::_internal_mutable_wiper_rpt_91() {
  _has_bits_[0] |= 0x00400000u;
  if (wiper_rpt_91_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Wiper_rpt_91>(GetArenaNoVirtual());
    wiper_rpt_91_ = p;
  }
  return wiper_rpt_91_;
}
inline ::apollo::canbus::Wiper_rpt_91* Gem::mutable_wiper_rpt_91() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.wiper_rpt_91)
  return _internal_mutable_wiper_rpt_91();
}
inline void Gem::set_allocated_wiper_rpt_91(::apollo::canbus::Wiper_rpt_91* wiper_rpt_91) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete wiper_rpt_91_;
  }
  if (wiper_rpt_91) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      wiper_rpt_91 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wiper_rpt_91, submessage_arena);
    }
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  wiper_rpt_91_ = wiper_rpt_91;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.wiper_rpt_91)
}

// optional .apollo.canbus.Vehicle_speed_rpt_6f vehicle_speed_rpt_6f = 24;
inline bool Gem::_internal_has_vehicle_speed_rpt_6f() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || vehicle_speed_rpt_6f_ != nullptr);
  return value;
}
inline bool Gem::has_vehicle_speed_rpt_6f() const {
  return _internal_has_vehicle_speed_rpt_6f();
}
inline void Gem::clear_vehicle_speed_rpt_6f() {
  if (vehicle_speed_rpt_6f_ != nullptr) vehicle_speed_rpt_6f_->Clear();
  _has_bits_[0] &= ~0x00800000u;
}
inline const ::apollo::canbus::Vehicle_speed_rpt_6f& Gem::_internal_vehicle_speed_rpt_6f() const {
  const ::apollo::canbus::Vehicle_speed_rpt_6f* p = vehicle_speed_rpt_6f_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Vehicle_speed_rpt_6f*>(
      &::apollo::canbus::_Vehicle_speed_rpt_6f_default_instance_);
}
inline const ::apollo::canbus::Vehicle_speed_rpt_6f& Gem::vehicle_speed_rpt_6f() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.vehicle_speed_rpt_6f)
  return _internal_vehicle_speed_rpt_6f();
}
inline ::apollo::canbus::Vehicle_speed_rpt_6f* Gem::release_vehicle_speed_rpt_6f() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.vehicle_speed_rpt_6f)
  _has_bits_[0] &= ~0x00800000u;
  ::apollo::canbus::Vehicle_speed_rpt_6f* temp = vehicle_speed_rpt_6f_;
  vehicle_speed_rpt_6f_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Vehicle_speed_rpt_6f* Gem::_internal_mutable_vehicle_speed_rpt_6f() {
  _has_bits_[0] |= 0x00800000u;
  if (vehicle_speed_rpt_6f_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Vehicle_speed_rpt_6f>(GetArenaNoVirtual());
    vehicle_speed_rpt_6f_ = p;
  }
  return vehicle_speed_rpt_6f_;
}
inline ::apollo::canbus::Vehicle_speed_rpt_6f* Gem::mutable_vehicle_speed_rpt_6f() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.vehicle_speed_rpt_6f)
  return _internal_mutable_vehicle_speed_rpt_6f();
}
inline void Gem::set_allocated_vehicle_speed_rpt_6f(::apollo::canbus::Vehicle_speed_rpt_6f* vehicle_speed_rpt_6f) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vehicle_speed_rpt_6f_;
  }
  if (vehicle_speed_rpt_6f) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vehicle_speed_rpt_6f = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle_speed_rpt_6f, submessage_arena);
    }
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  vehicle_speed_rpt_6f_ = vehicle_speed_rpt_6f;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.vehicle_speed_rpt_6f)
}

// optional .apollo.canbus.Headlight_cmd_76 headlight_cmd_76 = 25;
inline bool Gem::_internal_has_headlight_cmd_76() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || headlight_cmd_76_ != nullptr);
  return value;
}
inline bool Gem::has_headlight_cmd_76() const {
  return _internal_has_headlight_cmd_76();
}
inline void Gem::clear_headlight_cmd_76() {
  if (headlight_cmd_76_ != nullptr) headlight_cmd_76_->Clear();
  _has_bits_[0] &= ~0x01000000u;
}
inline const ::apollo::canbus::Headlight_cmd_76& Gem::_internal_headlight_cmd_76() const {
  const ::apollo::canbus::Headlight_cmd_76* p = headlight_cmd_76_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Headlight_cmd_76*>(
      &::apollo::canbus::_Headlight_cmd_76_default_instance_);
}
inline const ::apollo::canbus::Headlight_cmd_76& Gem::headlight_cmd_76() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.headlight_cmd_76)
  return _internal_headlight_cmd_76();
}
inline ::apollo::canbus::Headlight_cmd_76* Gem::release_headlight_cmd_76() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.headlight_cmd_76)
  _has_bits_[0] &= ~0x01000000u;
  ::apollo::canbus::Headlight_cmd_76* temp = headlight_cmd_76_;
  headlight_cmd_76_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Headlight_cmd_76* Gem::_internal_mutable_headlight_cmd_76() {
  _has_bits_[0] |= 0x01000000u;
  if (headlight_cmd_76_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Headlight_cmd_76>(GetArenaNoVirtual());
    headlight_cmd_76_ = p;
  }
  return headlight_cmd_76_;
}
inline ::apollo::canbus::Headlight_cmd_76* Gem::mutable_headlight_cmd_76() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.headlight_cmd_76)
  return _internal_mutable_headlight_cmd_76();
}
inline void Gem::set_allocated_headlight_cmd_76(::apollo::canbus::Headlight_cmd_76* headlight_cmd_76) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete headlight_cmd_76_;
  }
  if (headlight_cmd_76) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      headlight_cmd_76 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headlight_cmd_76, submessage_arena);
    }
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  headlight_cmd_76_ = headlight_cmd_76;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.headlight_cmd_76)
}

// optional .apollo.canbus.Steering_motor_rpt_2_74 steering_motor_rpt_2_74 = 26;
inline bool Gem::_internal_has_steering_motor_rpt_2_74() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || steering_motor_rpt_2_74_ != nullptr);
  return value;
}
inline bool Gem::has_steering_motor_rpt_2_74() const {
  return _internal_has_steering_motor_rpt_2_74();
}
inline void Gem::clear_steering_motor_rpt_2_74() {
  if (steering_motor_rpt_2_74_ != nullptr) steering_motor_rpt_2_74_->Clear();
  _has_bits_[0] &= ~0x02000000u;
}
inline const ::apollo::canbus::Steering_motor_rpt_2_74& Gem::_internal_steering_motor_rpt_2_74() const {
  const ::apollo::canbus::Steering_motor_rpt_2_74* p = steering_motor_rpt_2_74_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Steering_motor_rpt_2_74*>(
      &::apollo::canbus::_Steering_motor_rpt_2_74_default_instance_);
}
inline const ::apollo::canbus::Steering_motor_rpt_2_74& Gem::steering_motor_rpt_2_74() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.steering_motor_rpt_2_74)
  return _internal_steering_motor_rpt_2_74();
}
inline ::apollo::canbus::Steering_motor_rpt_2_74* Gem::release_steering_motor_rpt_2_74() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.steering_motor_rpt_2_74)
  _has_bits_[0] &= ~0x02000000u;
  ::apollo::canbus::Steering_motor_rpt_2_74* temp = steering_motor_rpt_2_74_;
  steering_motor_rpt_2_74_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Steering_motor_rpt_2_74* Gem::_internal_mutable_steering_motor_rpt_2_74() {
  _has_bits_[0] |= 0x02000000u;
  if (steering_motor_rpt_2_74_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Steering_motor_rpt_2_74>(GetArenaNoVirtual());
    steering_motor_rpt_2_74_ = p;
  }
  return steering_motor_rpt_2_74_;
}
inline ::apollo::canbus::Steering_motor_rpt_2_74* Gem::mutable_steering_motor_rpt_2_74() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.steering_motor_rpt_2_74)
  return _internal_mutable_steering_motor_rpt_2_74();
}
inline void Gem::set_allocated_steering_motor_rpt_2_74(::apollo::canbus::Steering_motor_rpt_2_74* steering_motor_rpt_2_74) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete steering_motor_rpt_2_74_;
  }
  if (steering_motor_rpt_2_74) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      steering_motor_rpt_2_74 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steering_motor_rpt_2_74, submessage_arena);
    }
    _has_bits_[0] |= 0x02000000u;
  } else {
    _has_bits_[0] &= ~0x02000000u;
  }
  steering_motor_rpt_2_74_ = steering_motor_rpt_2_74;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.steering_motor_rpt_2_74)
}

// optional .apollo.canbus.Brake_motor_rpt_2_71 brake_motor_rpt_2_71 = 27;
inline bool Gem::_internal_has_brake_motor_rpt_2_71() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || brake_motor_rpt_2_71_ != nullptr);
  return value;
}
inline bool Gem::has_brake_motor_rpt_2_71() const {
  return _internal_has_brake_motor_rpt_2_71();
}
inline void Gem::clear_brake_motor_rpt_2_71() {
  if (brake_motor_rpt_2_71_ != nullptr) brake_motor_rpt_2_71_->Clear();
  _has_bits_[0] &= ~0x04000000u;
}
inline const ::apollo::canbus::Brake_motor_rpt_2_71& Gem::_internal_brake_motor_rpt_2_71() const {
  const ::apollo::canbus::Brake_motor_rpt_2_71* p = brake_motor_rpt_2_71_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Brake_motor_rpt_2_71*>(
      &::apollo::canbus::_Brake_motor_rpt_2_71_default_instance_);
}
inline const ::apollo::canbus::Brake_motor_rpt_2_71& Gem::brake_motor_rpt_2_71() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.brake_motor_rpt_2_71)
  return _internal_brake_motor_rpt_2_71();
}
inline ::apollo::canbus::Brake_motor_rpt_2_71* Gem::release_brake_motor_rpt_2_71() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.brake_motor_rpt_2_71)
  _has_bits_[0] &= ~0x04000000u;
  ::apollo::canbus::Brake_motor_rpt_2_71* temp = brake_motor_rpt_2_71_;
  brake_motor_rpt_2_71_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Brake_motor_rpt_2_71* Gem::_internal_mutable_brake_motor_rpt_2_71() {
  _has_bits_[0] |= 0x04000000u;
  if (brake_motor_rpt_2_71_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Brake_motor_rpt_2_71>(GetArenaNoVirtual());
    brake_motor_rpt_2_71_ = p;
  }
  return brake_motor_rpt_2_71_;
}
inline ::apollo::canbus::Brake_motor_rpt_2_71* Gem::mutable_brake_motor_rpt_2_71() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.brake_motor_rpt_2_71)
  return _internal_mutable_brake_motor_rpt_2_71();
}
inline void Gem::set_allocated_brake_motor_rpt_2_71(::apollo::canbus::Brake_motor_rpt_2_71* brake_motor_rpt_2_71) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete brake_motor_rpt_2_71_;
  }
  if (brake_motor_rpt_2_71) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      brake_motor_rpt_2_71 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brake_motor_rpt_2_71, submessage_arena);
    }
    _has_bits_[0] |= 0x04000000u;
  } else {
    _has_bits_[0] &= ~0x04000000u;
  }
  brake_motor_rpt_2_71_ = brake_motor_rpt_2_71;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.brake_motor_rpt_2_71)
}

// optional .apollo.canbus.Steering_motor_rpt_1_73 steering_motor_rpt_1_73 = 28;
inline bool Gem::_internal_has_steering_motor_rpt_1_73() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || steering_motor_rpt_1_73_ != nullptr);
  return value;
}
inline bool Gem::has_steering_motor_rpt_1_73() const {
  return _internal_has_steering_motor_rpt_1_73();
}
inline void Gem::clear_steering_motor_rpt_1_73() {
  if (steering_motor_rpt_1_73_ != nullptr) steering_motor_rpt_1_73_->Clear();
  _has_bits_[0] &= ~0x08000000u;
}
inline const ::apollo::canbus::Steering_motor_rpt_1_73& Gem::_internal_steering_motor_rpt_1_73() const {
  const ::apollo::canbus::Steering_motor_rpt_1_73* p = steering_motor_rpt_1_73_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Steering_motor_rpt_1_73*>(
      &::apollo::canbus::_Steering_motor_rpt_1_73_default_instance_);
}
inline const ::apollo::canbus::Steering_motor_rpt_1_73& Gem::steering_motor_rpt_1_73() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.steering_motor_rpt_1_73)
  return _internal_steering_motor_rpt_1_73();
}
inline ::apollo::canbus::Steering_motor_rpt_1_73* Gem::release_steering_motor_rpt_1_73() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.steering_motor_rpt_1_73)
  _has_bits_[0] &= ~0x08000000u;
  ::apollo::canbus::Steering_motor_rpt_1_73* temp = steering_motor_rpt_1_73_;
  steering_motor_rpt_1_73_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Steering_motor_rpt_1_73* Gem::_internal_mutable_steering_motor_rpt_1_73() {
  _has_bits_[0] |= 0x08000000u;
  if (steering_motor_rpt_1_73_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Steering_motor_rpt_1_73>(GetArenaNoVirtual());
    steering_motor_rpt_1_73_ = p;
  }
  return steering_motor_rpt_1_73_;
}
inline ::apollo::canbus::Steering_motor_rpt_1_73* Gem::mutable_steering_motor_rpt_1_73() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.steering_motor_rpt_1_73)
  return _internal_mutable_steering_motor_rpt_1_73();
}
inline void Gem::set_allocated_steering_motor_rpt_1_73(::apollo::canbus::Steering_motor_rpt_1_73* steering_motor_rpt_1_73) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete steering_motor_rpt_1_73_;
  }
  if (steering_motor_rpt_1_73) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      steering_motor_rpt_1_73 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steering_motor_rpt_1_73, submessage_arena);
    }
    _has_bits_[0] |= 0x08000000u;
  } else {
    _has_bits_[0] &= ~0x08000000u;
  }
  steering_motor_rpt_1_73_ = steering_motor_rpt_1_73;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.steering_motor_rpt_1_73)
}

// optional .apollo.canbus.Wiper_cmd_90 wiper_cmd_90 = 29;
inline bool Gem::_internal_has_wiper_cmd_90() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || wiper_cmd_90_ != nullptr);
  return value;
}
inline bool Gem::has_wiper_cmd_90() const {
  return _internal_has_wiper_cmd_90();
}
inline void Gem::clear_wiper_cmd_90() {
  if (wiper_cmd_90_ != nullptr) wiper_cmd_90_->Clear();
  _has_bits_[0] &= ~0x10000000u;
}
inline const ::apollo::canbus::Wiper_cmd_90& Gem::_internal_wiper_cmd_90() const {
  const ::apollo::canbus::Wiper_cmd_90* p = wiper_cmd_90_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Wiper_cmd_90*>(
      &::apollo::canbus::_Wiper_cmd_90_default_instance_);
}
inline const ::apollo::canbus::Wiper_cmd_90& Gem::wiper_cmd_90() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.wiper_cmd_90)
  return _internal_wiper_cmd_90();
}
inline ::apollo::canbus::Wiper_cmd_90* Gem::release_wiper_cmd_90() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.wiper_cmd_90)
  _has_bits_[0] &= ~0x10000000u;
  ::apollo::canbus::Wiper_cmd_90* temp = wiper_cmd_90_;
  wiper_cmd_90_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Wiper_cmd_90* Gem::_internal_mutable_wiper_cmd_90() {
  _has_bits_[0] |= 0x10000000u;
  if (wiper_cmd_90_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Wiper_cmd_90>(GetArenaNoVirtual());
    wiper_cmd_90_ = p;
  }
  return wiper_cmd_90_;
}
inline ::apollo::canbus::Wiper_cmd_90* Gem::mutable_wiper_cmd_90() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.wiper_cmd_90)
  return _internal_mutable_wiper_cmd_90();
}
inline void Gem::set_allocated_wiper_cmd_90(::apollo::canbus::Wiper_cmd_90* wiper_cmd_90) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete wiper_cmd_90_;
  }
  if (wiper_cmd_90) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      wiper_cmd_90 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wiper_cmd_90, submessage_arena);
    }
    _has_bits_[0] |= 0x10000000u;
  } else {
    _has_bits_[0] &= ~0x10000000u;
  }
  wiper_cmd_90_ = wiper_cmd_90;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.wiper_cmd_90)
}

// optional .apollo.canbus.Brake_motor_rpt_3_72 brake_motor_rpt_3_72 = 30;
inline bool Gem::_internal_has_brake_motor_rpt_3_72() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || brake_motor_rpt_3_72_ != nullptr);
  return value;
}
inline bool Gem::has_brake_motor_rpt_3_72() const {
  return _internal_has_brake_motor_rpt_3_72();
}
inline void Gem::clear_brake_motor_rpt_3_72() {
  if (brake_motor_rpt_3_72_ != nullptr) brake_motor_rpt_3_72_->Clear();
  _has_bits_[0] &= ~0x20000000u;
}
inline const ::apollo::canbus::Brake_motor_rpt_3_72& Gem::_internal_brake_motor_rpt_3_72() const {
  const ::apollo::canbus::Brake_motor_rpt_3_72* p = brake_motor_rpt_3_72_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apollo::canbus::Brake_motor_rpt_3_72*>(
      &::apollo::canbus::_Brake_motor_rpt_3_72_default_instance_);
}
inline const ::apollo::canbus::Brake_motor_rpt_3_72& Gem::brake_motor_rpt_3_72() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gem.brake_motor_rpt_3_72)
  return _internal_brake_motor_rpt_3_72();
}
inline ::apollo::canbus::Brake_motor_rpt_3_72* Gem::release_brake_motor_rpt_3_72() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Gem.brake_motor_rpt_3_72)
  _has_bits_[0] &= ~0x20000000u;
  ::apollo::canbus::Brake_motor_rpt_3_72* temp = brake_motor_rpt_3_72_;
  brake_motor_rpt_3_72_ = nullptr;
  return temp;
}
inline ::apollo::canbus::Brake_motor_rpt_3_72* Gem::_internal_mutable_brake_motor_rpt_3_72() {
  _has_bits_[0] |= 0x20000000u;
  if (brake_motor_rpt_3_72_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Brake_motor_rpt_3_72>(GetArenaNoVirtual());
    brake_motor_rpt_3_72_ = p;
  }
  return brake_motor_rpt_3_72_;
}
inline ::apollo::canbus::Brake_motor_rpt_3_72* Gem::mutable_brake_motor_rpt_3_72() {
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Gem.brake_motor_rpt_3_72)
  return _internal_mutable_brake_motor_rpt_3_72();
}
inline void Gem::set_allocated_brake_motor_rpt_3_72(::apollo::canbus::Brake_motor_rpt_3_72* brake_motor_rpt_3_72) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete brake_motor_rpt_3_72_;
  }
  if (brake_motor_rpt_3_72) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      brake_motor_rpt_3_72 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brake_motor_rpt_3_72, submessage_arena);
    }
    _has_bits_[0] |= 0x20000000u;
  } else {
    _has_bits_[0] &= ~0x20000000u;
  }
  brake_motor_rpt_3_72_ = brake_motor_rpt_3_72;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Gem.brake_motor_rpt_3_72)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace canbus
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::canbus::ChassisDetail_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::ChassisDetail_Type>() {
  return ::apollo::canbus::ChassisDetail_Type_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Light_TurnLightType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Light_TurnLightType>() {
  return ::apollo::canbus::Light_TurnLightType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Light_BeamLampType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Light_BeamLampType>() {
  return ::apollo::canbus::Light_BeamLampType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Light_LincolnLampType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Light_LincolnLampType>() {
  return ::apollo::canbus::Light_LincolnLampType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Light_LincolnWiperType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Light_LincolnWiperType>() {
  return ::apollo::canbus::Light_LincolnWiperType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Light_LincolnAmbientType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Light_LincolnAmbientType>() {
  return ::apollo::canbus::Light_LincolnAmbientType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Eps_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Eps_Type>() {
  return ::apollo::canbus::Eps_Type_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Brake_HSAStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Brake_HSAStatusType>() {
  return ::apollo::canbus::Brake_HSAStatusType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Brake_HSAModeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Brake_HSAModeType>() {
  return ::apollo::canbus::Brake_HSAModeType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Epb_PBrakeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Epb_PBrakeType>() {
  return ::apollo::canbus::Epb_PBrakeType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Ems_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Ems_Type>() {
  return ::apollo::canbus::Ems_Type_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::BasicInfo_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::BasicInfo_Type>() {
  return ::apollo::canbus::BasicInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Global_rpt_6a_Pacmod_statusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Global_rpt_6a_Pacmod_statusType>() {
  return ::apollo::canbus::Global_rpt_6a_Pacmod_statusType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Global_rpt_6a_Override_statusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Global_rpt_6a_Override_statusType>() {
  return ::apollo::canbus::Global_rpt_6a_Override_statusType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType>() {
  return ::apollo::canbus::Global_rpt_6a_Brk_can_timeoutType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Brake_rpt_6c_Brake_on_offType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Brake_rpt_6c_Brake_on_offType>() {
  return ::apollo::canbus::Brake_rpt_6c_Brake_on_offType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Headlight_rpt_77_Output_valueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Headlight_rpt_77_Output_valueType>() {
  return ::apollo::canbus::Headlight_rpt_77_Output_valueType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Headlight_rpt_77_Manual_inputType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Headlight_rpt_77_Manual_inputType>() {
  return ::apollo::canbus::Headlight_rpt_77_Manual_inputType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Headlight_rpt_77_Commanded_valueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Headlight_rpt_77_Commanded_valueType>() {
  return ::apollo::canbus::Headlight_rpt_77_Commanded_valueType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType>() {
  return ::apollo::canbus::Turn_cmd_63_Turn_signal_cmdType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Turn_rpt_64_Manual_inputType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Turn_rpt_64_Manual_inputType>() {
  return ::apollo::canbus::Turn_rpt_64_Manual_inputType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Turn_rpt_64_Commanded_valueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Turn_rpt_64_Commanded_valueType>() {
  return ::apollo::canbus::Turn_rpt_64_Commanded_valueType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Turn_rpt_64_Output_valueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Turn_rpt_64_Output_valueType>() {
  return ::apollo::canbus::Turn_rpt_64_Output_valueType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Shift_cmd_65_Shift_cmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Shift_cmd_65_Shift_cmdType>() {
  return ::apollo::canbus::Shift_cmd_65_Shift_cmdType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Shift_rpt_66_Manual_inputType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Shift_rpt_66_Manual_inputType>() {
  return ::apollo::canbus::Shift_rpt_66_Manual_inputType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Shift_rpt_66_Commanded_valueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Shift_rpt_66_Commanded_valueType>() {
  return ::apollo::canbus::Shift_rpt_66_Commanded_valueType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Shift_rpt_66_Output_valueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Shift_rpt_66_Output_valueType>() {
  return ::apollo::canbus::Shift_rpt_66_Output_valueType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Global_cmd_69_Pacmod_enableType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Global_cmd_69_Pacmod_enableType>() {
  return ::apollo::canbus::Global_cmd_69_Pacmod_enableType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Global_cmd_69_Clear_overrideType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Global_cmd_69_Clear_overrideType>() {
  return ::apollo::canbus::Global_cmd_69_Clear_overrideType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Global_cmd_69_Ignore_overrideType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Global_cmd_69_Ignore_overrideType>() {
  return ::apollo::canbus::Global_cmd_69_Ignore_overrideType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType>() {
  return ::apollo::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Horn_rpt_79_Output_valueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Horn_rpt_79_Output_valueType>() {
  return ::apollo::canbus::Horn_rpt_79_Output_valueType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Horn_rpt_79_Commanded_valueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Horn_rpt_79_Commanded_valueType>() {
  return ::apollo::canbus::Horn_rpt_79_Commanded_valueType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Horn_rpt_79_Manual_inputType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Horn_rpt_79_Manual_inputType>() {
  return ::apollo::canbus::Horn_rpt_79_Manual_inputType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Horn_cmd_78_Horn_cmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Horn_cmd_78_Horn_cmdType>() {
  return ::apollo::canbus::Horn_cmd_78_Horn_cmdType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Wiper_rpt_91_Output_valueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Wiper_rpt_91_Output_valueType>() {
  return ::apollo::canbus::Wiper_rpt_91_Output_valueType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Wiper_rpt_91_Commanded_valueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Wiper_rpt_91_Commanded_valueType>() {
  return ::apollo::canbus::Wiper_rpt_91_Commanded_valueType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Wiper_rpt_91_Manual_inputType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Wiper_rpt_91_Manual_inputType>() {
  return ::apollo::canbus::Wiper_rpt_91_Manual_inputType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType>() {
  return ::apollo::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Headlight_cmd_76_Headlight_cmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Headlight_cmd_76_Headlight_cmdType>() {
  return ::apollo::canbus::Headlight_cmd_76_Headlight_cmdType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Wiper_cmd_90_Wiper_cmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Wiper_cmd_90_Wiper_cmdType>() {
  return ::apollo::canbus::Wiper_cmd_90_Wiper_cmdType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto
