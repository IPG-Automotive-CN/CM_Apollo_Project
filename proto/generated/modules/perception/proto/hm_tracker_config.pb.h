// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/perception/proto/hm_tracker_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto;
namespace apollo {
namespace perception {
namespace lidar {
class HmMultiTargetTrackerConfig;
class HmMultiTargetTrackerConfigDefaultTypeInternal;
extern HmMultiTargetTrackerConfigDefaultTypeInternal _HmMultiTargetTrackerConfig_default_instance_;
class KalmanFilterConfig;
class KalmanFilterConfigDefaultTypeInternal;
extern KalmanFilterConfigDefaultTypeInternal _KalmanFilterConfig_default_instance_;
class ObjectTrackMatcherConfig;
class ObjectTrackMatcherConfigDefaultTypeInternal;
extern ObjectTrackMatcherConfigDefaultTypeInternal _ObjectTrackMatcherConfig_default_instance_;
class TrackerConfig;
class TrackerConfigDefaultTypeInternal;
extern TrackerConfigDefaultTypeInternal _TrackerConfig_default_instance_;
}  // namespace lidar
}  // namespace perception
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::perception::lidar::HmMultiTargetTrackerConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::HmMultiTargetTrackerConfig>(Arena*);
template<> ::apollo::perception::lidar::KalmanFilterConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::KalmanFilterConfig>(Arena*);
template<> ::apollo::perception::lidar::ObjectTrackMatcherConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::ObjectTrackMatcherConfig>(Arena*);
template<> ::apollo::perception::lidar::TrackerConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::TrackerConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace perception {
namespace lidar {

// ===================================================================

class ObjectTrackMatcherConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.ObjectTrackMatcherConfig) */ {
 public:
  ObjectTrackMatcherConfig();
  virtual ~ObjectTrackMatcherConfig();

  ObjectTrackMatcherConfig(const ObjectTrackMatcherConfig& from);
  ObjectTrackMatcherConfig(ObjectTrackMatcherConfig&& from) noexcept
    : ObjectTrackMatcherConfig() {
    *this = ::std::move(from);
  }

  inline ObjectTrackMatcherConfig& operator=(const ObjectTrackMatcherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectTrackMatcherConfig& operator=(ObjectTrackMatcherConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectTrackMatcherConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectTrackMatcherConfig* internal_default_instance() {
    return reinterpret_cast<const ObjectTrackMatcherConfig*>(
               &_ObjectTrackMatcherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ObjectTrackMatcherConfig& a, ObjectTrackMatcherConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectTrackMatcherConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectTrackMatcherConfig* New() const final {
    return CreateMaybeMessage<ObjectTrackMatcherConfig>(nullptr);
  }

  ObjectTrackMatcherConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectTrackMatcherConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectTrackMatcherConfig& from);
  void MergeFrom(const ObjectTrackMatcherConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectTrackMatcherConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.perception.lidar.ObjectTrackMatcherConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto);
    return ::descriptor_table_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBgWeightLocationDistFieldNumber = 2,
    kBgWeightDirectionDistFieldNumber = 3,
    kBgWeightBboxSizeDistFieldNumber = 4,
    kBgWeightPointNumDistFieldNumber = 5,
    kBgWeightHistogramDistFieldNumber = 6,
    kFgWeightCentroidShiftDistFieldNumber = 15,
    kFgWeightBboxIouDistFieldNumber = 16,
    kMaxMatchDistFieldNumber = 1,
    kBgWeightCentroidShiftDistFieldNumber = 7,
    kBgWeightBboxIouDistFieldNumber = 8,
    kBgBackgroundObjectMatchThresholdFieldNumber = 9,
    kFgWeightLocationDistFieldNumber = 10,
    kFgWeightDirectionDistFieldNumber = 11,
    kFgWeightBboxSizeDistFieldNumber = 12,
    kFgWeightPointNumDistFieldNumber = 13,
    kFgWeightHistogramDistFieldNumber = 14,
    kBoundValueFieldNumber = 17,
  };
  // optional float bg_weight_location_dist = 2 [default = 0];
  bool has_bg_weight_location_dist() const;
  private:
  bool _internal_has_bg_weight_location_dist() const;
  public:
  void clear_bg_weight_location_dist();
  float bg_weight_location_dist() const;
  void set_bg_weight_location_dist(float value);
  private:
  float _internal_bg_weight_location_dist() const;
  void _internal_set_bg_weight_location_dist(float value);
  public:

  // optional float bg_weight_direction_dist = 3 [default = 0];
  bool has_bg_weight_direction_dist() const;
  private:
  bool _internal_has_bg_weight_direction_dist() const;
  public:
  void clear_bg_weight_direction_dist();
  float bg_weight_direction_dist() const;
  void set_bg_weight_direction_dist(float value);
  private:
  float _internal_bg_weight_direction_dist() const;
  void _internal_set_bg_weight_direction_dist(float value);
  public:

  // optional float bg_weight_bbox_size_dist = 4 [default = 0];
  bool has_bg_weight_bbox_size_dist() const;
  private:
  bool _internal_has_bg_weight_bbox_size_dist() const;
  public:
  void clear_bg_weight_bbox_size_dist();
  float bg_weight_bbox_size_dist() const;
  void set_bg_weight_bbox_size_dist(float value);
  private:
  float _internal_bg_weight_bbox_size_dist() const;
  void _internal_set_bg_weight_bbox_size_dist(float value);
  public:

  // optional float bg_weight_point_num_dist = 5 [default = 0];
  bool has_bg_weight_point_num_dist() const;
  private:
  bool _internal_has_bg_weight_point_num_dist() const;
  public:
  void clear_bg_weight_point_num_dist();
  float bg_weight_point_num_dist() const;
  void set_bg_weight_point_num_dist(float value);
  private:
  float _internal_bg_weight_point_num_dist() const;
  void _internal_set_bg_weight_point_num_dist(float value);
  public:

  // optional float bg_weight_histogram_dist = 6 [default = 0];
  bool has_bg_weight_histogram_dist() const;
  private:
  bool _internal_has_bg_weight_histogram_dist() const;
  public:
  void clear_bg_weight_histogram_dist();
  float bg_weight_histogram_dist() const;
  void set_bg_weight_histogram_dist(float value);
  private:
  float _internal_bg_weight_histogram_dist() const;
  void _internal_set_bg_weight_histogram_dist(float value);
  public:

  // optional float fg_weight_centroid_shift_dist = 15 [default = 0];
  bool has_fg_weight_centroid_shift_dist() const;
  private:
  bool _internal_has_fg_weight_centroid_shift_dist() const;
  public:
  void clear_fg_weight_centroid_shift_dist();
  float fg_weight_centroid_shift_dist() const;
  void set_fg_weight_centroid_shift_dist(float value);
  private:
  float _internal_fg_weight_centroid_shift_dist() const;
  void _internal_set_fg_weight_centroid_shift_dist(float value);
  public:

  // optional float fg_weight_bbox_iou_dist = 16 [default = 0];
  bool has_fg_weight_bbox_iou_dist() const;
  private:
  bool _internal_has_fg_weight_bbox_iou_dist() const;
  public:
  void clear_fg_weight_bbox_iou_dist();
  float fg_weight_bbox_iou_dist() const;
  void set_fg_weight_bbox_iou_dist(float value);
  private:
  float _internal_fg_weight_bbox_iou_dist() const;
  void _internal_set_fg_weight_bbox_iou_dist(float value);
  public:

  // optional float max_match_dist = 1 [default = 4];
  bool has_max_match_dist() const;
  private:
  bool _internal_has_max_match_dist() const;
  public:
  void clear_max_match_dist();
  float max_match_dist() const;
  void set_max_match_dist(float value);
  private:
  float _internal_max_match_dist() const;
  void _internal_set_max_match_dist(float value);
  public:

  // optional float bg_weight_centroid_shift_dist = 7 [default = 0.2];
  bool has_bg_weight_centroid_shift_dist() const;
  private:
  bool _internal_has_bg_weight_centroid_shift_dist() const;
  public:
  void clear_bg_weight_centroid_shift_dist();
  float bg_weight_centroid_shift_dist() const;
  void set_bg_weight_centroid_shift_dist(float value);
  private:
  float _internal_bg_weight_centroid_shift_dist() const;
  void _internal_set_bg_weight_centroid_shift_dist(float value);
  public:

  // optional float bg_weight_bbox_iou_dist = 8 [default = 0.8];
  bool has_bg_weight_bbox_iou_dist() const;
  private:
  bool _internal_has_bg_weight_bbox_iou_dist() const;
  public:
  void clear_bg_weight_bbox_iou_dist();
  float bg_weight_bbox_iou_dist() const;
  void set_bg_weight_bbox_iou_dist(float value);
  private:
  float _internal_bg_weight_bbox_iou_dist() const;
  void _internal_set_bg_weight_bbox_iou_dist(float value);
  public:

  // optional float bg_background_object_match_threshold = 9 [default = 4];
  bool has_bg_background_object_match_threshold() const;
  private:
  bool _internal_has_bg_background_object_match_threshold() const;
  public:
  void clear_bg_background_object_match_threshold();
  float bg_background_object_match_threshold() const;
  void set_bg_background_object_match_threshold(float value);
  private:
  float _internal_bg_background_object_match_threshold() const;
  void _internal_set_bg_background_object_match_threshold(float value);
  public:

  // optional float fg_weight_location_dist = 10 [default = 0.6];
  bool has_fg_weight_location_dist() const;
  private:
  bool _internal_has_fg_weight_location_dist() const;
  public:
  void clear_fg_weight_location_dist();
  float fg_weight_location_dist() const;
  void set_fg_weight_location_dist(float value);
  private:
  float _internal_fg_weight_location_dist() const;
  void _internal_set_fg_weight_location_dist(float value);
  public:

  // optional float fg_weight_direction_dist = 11 [default = 0.2];
  bool has_fg_weight_direction_dist() const;
  private:
  bool _internal_has_fg_weight_direction_dist() const;
  public:
  void clear_fg_weight_direction_dist();
  float fg_weight_direction_dist() const;
  void set_fg_weight_direction_dist(float value);
  private:
  float _internal_fg_weight_direction_dist() const;
  void _internal_set_fg_weight_direction_dist(float value);
  public:

  // optional float fg_weight_bbox_size_dist = 12 [default = 0.1];
  bool has_fg_weight_bbox_size_dist() const;
  private:
  bool _internal_has_fg_weight_bbox_size_dist() const;
  public:
  void clear_fg_weight_bbox_size_dist();
  float fg_weight_bbox_size_dist() const;
  void set_fg_weight_bbox_size_dist(float value);
  private:
  float _internal_fg_weight_bbox_size_dist() const;
  void _internal_set_fg_weight_bbox_size_dist(float value);
  public:

  // optional float fg_weight_point_num_dist = 13 [default = 0.1];
  bool has_fg_weight_point_num_dist() const;
  private:
  bool _internal_has_fg_weight_point_num_dist() const;
  public:
  void clear_fg_weight_point_num_dist();
  float fg_weight_point_num_dist() const;
  void set_fg_weight_point_num_dist(float value);
  private:
  float _internal_fg_weight_point_num_dist() const;
  void _internal_set_fg_weight_point_num_dist(float value);
  public:

  // optional float fg_weight_histogram_dist = 14 [default = 0.5];
  bool has_fg_weight_histogram_dist() const;
  private:
  bool _internal_has_fg_weight_histogram_dist() const;
  public:
  void clear_fg_weight_histogram_dist();
  float fg_weight_histogram_dist() const;
  void set_fg_weight_histogram_dist(float value);
  private:
  float _internal_fg_weight_histogram_dist() const;
  void _internal_set_fg_weight_histogram_dist(float value);
  public:

  // optional float bound_value = 17 [default = 100];
  bool has_bound_value() const;
  private:
  bool _internal_has_bound_value() const;
  public:
  void clear_bound_value();
  float bound_value() const;
  void set_bound_value(float value);
  private:
  float _internal_bound_value() const;
  void _internal_set_bound_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.ObjectTrackMatcherConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float bg_weight_location_dist_;
  float bg_weight_direction_dist_;
  float bg_weight_bbox_size_dist_;
  float bg_weight_point_num_dist_;
  float bg_weight_histogram_dist_;
  float fg_weight_centroid_shift_dist_;
  float fg_weight_bbox_iou_dist_;
  float max_match_dist_;
  float bg_weight_centroid_shift_dist_;
  float bg_weight_bbox_iou_dist_;
  float bg_background_object_match_threshold_;
  float fg_weight_location_dist_;
  float fg_weight_direction_dist_;
  float fg_weight_bbox_size_dist_;
  float fg_weight_point_num_dist_;
  float fg_weight_histogram_dist_;
  float bound_value_;
  friend struct ::TableStruct_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class KalmanFilterConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.KalmanFilterConfig) */ {
 public:
  KalmanFilterConfig();
  virtual ~KalmanFilterConfig();

  KalmanFilterConfig(const KalmanFilterConfig& from);
  KalmanFilterConfig(KalmanFilterConfig&& from) noexcept
    : KalmanFilterConfig() {
    *this = ::std::move(from);
  }

  inline KalmanFilterConfig& operator=(const KalmanFilterConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline KalmanFilterConfig& operator=(KalmanFilterConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KalmanFilterConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KalmanFilterConfig* internal_default_instance() {
    return reinterpret_cast<const KalmanFilterConfig*>(
               &_KalmanFilterConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(KalmanFilterConfig& a, KalmanFilterConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(KalmanFilterConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KalmanFilterConfig* New() const final {
    return CreateMaybeMessage<KalmanFilterConfig>(nullptr);
  }

  KalmanFilterConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KalmanFilterConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KalmanFilterConfig& from);
  void MergeFrom(const KalmanFilterConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KalmanFilterConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.perception.lidar.KalmanFilterConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto);
    return ::descriptor_table_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseAdaptiveFieldNumber = 2,
    kUseConvergenceBoostupFieldNumber = 7,
    kConvergedConfidenceMinimumFieldNumber = 9,
    kNoiseMaximumFieldNumber = 1,
    kCentroidMeasurementNoiseFieldNumber = 3,
    kCentroidInitVelocityVarianceFieldNumber = 4,
    kPropagationVarianceXyFieldNumber = 5,
    kPropagationVarianceZFieldNumber = 6,
    kBoostupHistorySizeMinimumFieldNumber = 8,
  };
  // optional bool use_adaptive = 2 [default = false];
  bool has_use_adaptive() const;
  private:
  bool _internal_has_use_adaptive() const;
  public:
  void clear_use_adaptive();
  bool use_adaptive() const;
  void set_use_adaptive(bool value);
  private:
  bool _internal_use_adaptive() const;
  void _internal_set_use_adaptive(bool value);
  public:

  // optional bool use_convergence_boostup = 7 [default = false];
  bool has_use_convergence_boostup() const;
  private:
  bool _internal_has_use_convergence_boostup() const;
  public:
  void clear_use_convergence_boostup();
  bool use_convergence_boostup() const;
  void set_use_convergence_boostup(bool value);
  private:
  bool _internal_use_convergence_boostup() const;
  void _internal_set_use_convergence_boostup(bool value);
  public:

  // optional float converged_confidence_minimum = 9 [default = 0.9];
  bool has_converged_confidence_minimum() const;
  private:
  bool _internal_has_converged_confidence_minimum() const;
  public:
  void clear_converged_confidence_minimum();
  float converged_confidence_minimum() const;
  void set_converged_confidence_minimum(float value);
  private:
  float _internal_converged_confidence_minimum() const;
  void _internal_set_converged_confidence_minimum(float value);
  public:

  // optional float noise_maximum = 1 [default = 0.1];
  bool has_noise_maximum() const;
  private:
  bool _internal_has_noise_maximum() const;
  public:
  void clear_noise_maximum();
  float noise_maximum() const;
  void set_noise_maximum(float value);
  private:
  float _internal_noise_maximum() const;
  void _internal_set_noise_maximum(float value);
  public:

  // optional float centroid_measurement_noise = 3 [default = 0.4];
  bool has_centroid_measurement_noise() const;
  private:
  bool _internal_has_centroid_measurement_noise() const;
  public:
  void clear_centroid_measurement_noise();
  float centroid_measurement_noise() const;
  void set_centroid_measurement_noise(float value);
  private:
  float _internal_centroid_measurement_noise() const;
  void _internal_set_centroid_measurement_noise(float value);
  public:

  // optional float centroid_init_velocity_variance = 4 [default = 5];
  bool has_centroid_init_velocity_variance() const;
  private:
  bool _internal_has_centroid_init_velocity_variance() const;
  public:
  void clear_centroid_init_velocity_variance();
  float centroid_init_velocity_variance() const;
  void set_centroid_init_velocity_variance(float value);
  private:
  float _internal_centroid_init_velocity_variance() const;
  void _internal_set_centroid_init_velocity_variance(float value);
  public:

  // optional float propagation_variance_xy = 5 [default = 10];
  bool has_propagation_variance_xy() const;
  private:
  bool _internal_has_propagation_variance_xy() const;
  public:
  void clear_propagation_variance_xy();
  float propagation_variance_xy() const;
  void set_propagation_variance_xy(float value);
  private:
  float _internal_propagation_variance_xy() const;
  void _internal_set_propagation_variance_xy(float value);
  public:

  // optional float propagation_variance_z = 6 [default = 10];
  bool has_propagation_variance_z() const;
  private:
  bool _internal_has_propagation_variance_z() const;
  public:
  void clear_propagation_variance_z();
  float propagation_variance_z() const;
  void set_propagation_variance_z(float value);
  private:
  float _internal_propagation_variance_z() const;
  void _internal_set_propagation_variance_z(float value);
  public:

  // optional int32 boostup_history_size_minimum = 8 [default = 3];
  bool has_boostup_history_size_minimum() const;
  private:
  bool _internal_has_boostup_history_size_minimum() const;
  public:
  void clear_boostup_history_size_minimum();
  ::PROTOBUF_NAMESPACE_ID::int32 boostup_history_size_minimum() const;
  void set_boostup_history_size_minimum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_boostup_history_size_minimum() const;
  void _internal_set_boostup_history_size_minimum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.KalmanFilterConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool use_adaptive_;
  bool use_convergence_boostup_;
  float converged_confidence_minimum_;
  float noise_maximum_;
  float centroid_measurement_noise_;
  float centroid_init_velocity_variance_;
  float propagation_variance_xy_;
  float propagation_variance_z_;
  ::PROTOBUF_NAMESPACE_ID::int32 boostup_history_size_minimum_;
  friend struct ::TableStruct_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TrackerConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.TrackerConfig) */ {
 public:
  TrackerConfig();
  virtual ~TrackerConfig();

  TrackerConfig(const TrackerConfig& from);
  TrackerConfig(TrackerConfig&& from) noexcept
    : TrackerConfig() {
    *this = ::std::move(from);
  }

  inline TrackerConfig& operator=(const TrackerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackerConfig& operator=(TrackerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrackerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrackerConfig* internal_default_instance() {
    return reinterpret_cast<const TrackerConfig*>(
               &_TrackerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TrackerConfig& a, TrackerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackerConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrackerConfig* New() const final {
    return CreateMaybeMessage<TrackerConfig>(nullptr);
  }

  TrackerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrackerConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrackerConfig& from);
  void MergeFrom(const TrackerConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackerConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.perception.lidar.TrackerConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto);
    return ::descriptor_table_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterNameFieldNumber = 1,
    kSeparateForeBackgroundFieldNumber = 2,
  };
  // optional string filter_name = 1 [default = "KalmanFilter"];
  bool has_filter_name() const;
  private:
  bool _internal_has_filter_name() const;
  public:
  void clear_filter_name();
  const std::string& filter_name() const;
  void set_filter_name(const std::string& value);
  void set_filter_name(std::string&& value);
  void set_filter_name(const char* value);
  void set_filter_name(const char* value, size_t size);
  std::string* mutable_filter_name();
  std::string* release_filter_name();
  void set_allocated_filter_name(std::string* filter_name);
  private:
  const std::string& _internal_filter_name() const;
  void _internal_set_filter_name(const std::string& value);
  std::string* _internal_mutable_filter_name();
  public:

  // optional bool separate_fore_background = 2 [default = false];
  bool has_separate_fore_background() const;
  private:
  bool _internal_has_separate_fore_background() const;
  public:
  void clear_separate_fore_background();
  bool separate_fore_background() const;
  void set_separate_fore_background(bool value);
  private:
  bool _internal_separate_fore_background() const;
  void _internal_set_separate_fore_background(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.TrackerConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  public:
  static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_filter_name_;
  private:
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_name_;
  bool separate_fore_background_;
  friend struct ::TableStruct_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class HmMultiTargetTrackerConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.HmMultiTargetTrackerConfig) */ {
 public:
  HmMultiTargetTrackerConfig();
  virtual ~HmMultiTargetTrackerConfig();

  HmMultiTargetTrackerConfig(const HmMultiTargetTrackerConfig& from);
  HmMultiTargetTrackerConfig(HmMultiTargetTrackerConfig&& from) noexcept
    : HmMultiTargetTrackerConfig() {
    *this = ::std::move(from);
  }

  inline HmMultiTargetTrackerConfig& operator=(const HmMultiTargetTrackerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HmMultiTargetTrackerConfig& operator=(HmMultiTargetTrackerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HmMultiTargetTrackerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmMultiTargetTrackerConfig* internal_default_instance() {
    return reinterpret_cast<const HmMultiTargetTrackerConfig*>(
               &_HmMultiTargetTrackerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HmMultiTargetTrackerConfig& a, HmMultiTargetTrackerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(HmMultiTargetTrackerConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HmMultiTargetTrackerConfig* New() const final {
    return CreateMaybeMessage<HmMultiTargetTrackerConfig>(nullptr);
  }

  HmMultiTargetTrackerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HmMultiTargetTrackerConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HmMultiTargetTrackerConfig& from);
  void MergeFrom(const HmMultiTargetTrackerConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HmMultiTargetTrackerConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.perception.lidar.HmMultiTargetTrackerConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto);
    return ::descriptor_table_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterMethodFieldNumber = 1,
    kForegroundMathcerMethodFieldNumber = 2,
    kBackgroundMatcherMethodFieldNumber = 3,
    kUseHistogramForMatchFieldNumber = 4,
    kHistogramBinSizeFieldNumber = 5,
  };
  // optional string filter_method = 1 [default = "KalmanFilter"];
  bool has_filter_method() const;
  private:
  bool _internal_has_filter_method() const;
  public:
  void clear_filter_method();
  const std::string& filter_method() const;
  void set_filter_method(const std::string& value);
  void set_filter_method(std::string&& value);
  void set_filter_method(const char* value);
  void set_filter_method(const char* value, size_t size);
  std::string* mutable_filter_method();
  std::string* release_filter_method();
  void set_allocated_filter_method(std::string* filter_method);
  private:
  const std::string& _internal_filter_method() const;
  void _internal_set_filter_method(const std::string& value);
  std::string* _internal_mutable_filter_method();
  public:

  // optional string foreground_mathcer_method = 2 [default = "MultiHmBipartiteGraphMatcher"];
  bool has_foreground_mathcer_method() const;
  private:
  bool _internal_has_foreground_mathcer_method() const;
  public:
  void clear_foreground_mathcer_method();
  const std::string& foreground_mathcer_method() const;
  void set_foreground_mathcer_method(const std::string& value);
  void set_foreground_mathcer_method(std::string&& value);
  void set_foreground_mathcer_method(const char* value);
  void set_foreground_mathcer_method(const char* value, size_t size);
  std::string* mutable_foreground_mathcer_method();
  std::string* release_foreground_mathcer_method();
  void set_allocated_foreground_mathcer_method(std::string* foreground_mathcer_method);
  private:
  const std::string& _internal_foreground_mathcer_method() const;
  void _internal_set_foreground_mathcer_method(const std::string& value);
  std::string* _internal_mutable_foreground_mathcer_method();
  public:

  // optional string background_matcher_method = 3 [default = "GnnBipartiteGraphMatcher"];
  bool has_background_matcher_method() const;
  private:
  bool _internal_has_background_matcher_method() const;
  public:
  void clear_background_matcher_method();
  const std::string& background_matcher_method() const;
  void set_background_matcher_method(const std::string& value);
  void set_background_matcher_method(std::string&& value);
  void set_background_matcher_method(const char* value);
  void set_background_matcher_method(const char* value, size_t size);
  std::string* mutable_background_matcher_method();
  std::string* release_background_matcher_method();
  void set_allocated_background_matcher_method(std::string* background_matcher_method);
  private:
  const std::string& _internal_background_matcher_method() const;
  void _internal_set_background_matcher_method(const std::string& value);
  std::string* _internal_mutable_background_matcher_method();
  public:

  // optional bool use_histogram_for_match = 4 [default = true];
  bool has_use_histogram_for_match() const;
  private:
  bool _internal_has_use_histogram_for_match() const;
  public:
  void clear_use_histogram_for_match();
  bool use_histogram_for_match() const;
  void set_use_histogram_for_match(bool value);
  private:
  bool _internal_use_histogram_for_match() const;
  void _internal_set_use_histogram_for_match(bool value);
  public:

  // optional float histogram_bin_size = 5 [default = 10];
  bool has_histogram_bin_size() const;
  private:
  bool _internal_has_histogram_bin_size() const;
  public:
  void clear_histogram_bin_size();
  float histogram_bin_size() const;
  void set_histogram_bin_size(float value);
  private:
  float _internal_histogram_bin_size() const;
  void _internal_set_histogram_bin_size(float value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.HmMultiTargetTrackerConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  public:
  static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_filter_method_;
  private:
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_method_;
  public:
  static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_foreground_mathcer_method_;
  private:
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr foreground_mathcer_method_;
  public:
  static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_background_matcher_method_;
  private:
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr background_matcher_method_;
  bool use_histogram_for_match_;
  float histogram_bin_size_;
  friend struct ::TableStruct_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ObjectTrackMatcherConfig

// optional float max_match_dist = 1 [default = 4];
inline bool ObjectTrackMatcherConfig::_internal_has_max_match_dist() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_max_match_dist() const {
  return _internal_has_max_match_dist();
}
inline void ObjectTrackMatcherConfig::clear_max_match_dist() {
  max_match_dist_ = 4;
  _has_bits_[0] &= ~0x00000080u;
}
inline float ObjectTrackMatcherConfig::_internal_max_match_dist() const {
  return max_match_dist_;
}
inline float ObjectTrackMatcherConfig::max_match_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.max_match_dist)
  return _internal_max_match_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_max_match_dist(float value) {
  _has_bits_[0] |= 0x00000080u;
  max_match_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_max_match_dist(float value) {
  _internal_set_max_match_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.max_match_dist)
}

// optional float bg_weight_location_dist = 2 [default = 0];
inline bool ObjectTrackMatcherConfig::_internal_has_bg_weight_location_dist() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_bg_weight_location_dist() const {
  return _internal_has_bg_weight_location_dist();
}
inline void ObjectTrackMatcherConfig::clear_bg_weight_location_dist() {
  bg_weight_location_dist_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ObjectTrackMatcherConfig::_internal_bg_weight_location_dist() const {
  return bg_weight_location_dist_;
}
inline float ObjectTrackMatcherConfig::bg_weight_location_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_location_dist)
  return _internal_bg_weight_location_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_bg_weight_location_dist(float value) {
  _has_bits_[0] |= 0x00000001u;
  bg_weight_location_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_bg_weight_location_dist(float value) {
  _internal_set_bg_weight_location_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_location_dist)
}

// optional float bg_weight_direction_dist = 3 [default = 0];
inline bool ObjectTrackMatcherConfig::_internal_has_bg_weight_direction_dist() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_bg_weight_direction_dist() const {
  return _internal_has_bg_weight_direction_dist();
}
inline void ObjectTrackMatcherConfig::clear_bg_weight_direction_dist() {
  bg_weight_direction_dist_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ObjectTrackMatcherConfig::_internal_bg_weight_direction_dist() const {
  return bg_weight_direction_dist_;
}
inline float ObjectTrackMatcherConfig::bg_weight_direction_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_direction_dist)
  return _internal_bg_weight_direction_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_bg_weight_direction_dist(float value) {
  _has_bits_[0] |= 0x00000002u;
  bg_weight_direction_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_bg_weight_direction_dist(float value) {
  _internal_set_bg_weight_direction_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_direction_dist)
}

// optional float bg_weight_bbox_size_dist = 4 [default = 0];
inline bool ObjectTrackMatcherConfig::_internal_has_bg_weight_bbox_size_dist() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_bg_weight_bbox_size_dist() const {
  return _internal_has_bg_weight_bbox_size_dist();
}
inline void ObjectTrackMatcherConfig::clear_bg_weight_bbox_size_dist() {
  bg_weight_bbox_size_dist_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ObjectTrackMatcherConfig::_internal_bg_weight_bbox_size_dist() const {
  return bg_weight_bbox_size_dist_;
}
inline float ObjectTrackMatcherConfig::bg_weight_bbox_size_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_bbox_size_dist)
  return _internal_bg_weight_bbox_size_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_bg_weight_bbox_size_dist(float value) {
  _has_bits_[0] |= 0x00000004u;
  bg_weight_bbox_size_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_bg_weight_bbox_size_dist(float value) {
  _internal_set_bg_weight_bbox_size_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_bbox_size_dist)
}

// optional float bg_weight_point_num_dist = 5 [default = 0];
inline bool ObjectTrackMatcherConfig::_internal_has_bg_weight_point_num_dist() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_bg_weight_point_num_dist() const {
  return _internal_has_bg_weight_point_num_dist();
}
inline void ObjectTrackMatcherConfig::clear_bg_weight_point_num_dist() {
  bg_weight_point_num_dist_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float ObjectTrackMatcherConfig::_internal_bg_weight_point_num_dist() const {
  return bg_weight_point_num_dist_;
}
inline float ObjectTrackMatcherConfig::bg_weight_point_num_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_point_num_dist)
  return _internal_bg_weight_point_num_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_bg_weight_point_num_dist(float value) {
  _has_bits_[0] |= 0x00000008u;
  bg_weight_point_num_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_bg_weight_point_num_dist(float value) {
  _internal_set_bg_weight_point_num_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_point_num_dist)
}

// optional float bg_weight_histogram_dist = 6 [default = 0];
inline bool ObjectTrackMatcherConfig::_internal_has_bg_weight_histogram_dist() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_bg_weight_histogram_dist() const {
  return _internal_has_bg_weight_histogram_dist();
}
inline void ObjectTrackMatcherConfig::clear_bg_weight_histogram_dist() {
  bg_weight_histogram_dist_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float ObjectTrackMatcherConfig::_internal_bg_weight_histogram_dist() const {
  return bg_weight_histogram_dist_;
}
inline float ObjectTrackMatcherConfig::bg_weight_histogram_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_histogram_dist)
  return _internal_bg_weight_histogram_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_bg_weight_histogram_dist(float value) {
  _has_bits_[0] |= 0x00000010u;
  bg_weight_histogram_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_bg_weight_histogram_dist(float value) {
  _internal_set_bg_weight_histogram_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_histogram_dist)
}

// optional float bg_weight_centroid_shift_dist = 7 [default = 0.2];
inline bool ObjectTrackMatcherConfig::_internal_has_bg_weight_centroid_shift_dist() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_bg_weight_centroid_shift_dist() const {
  return _internal_has_bg_weight_centroid_shift_dist();
}
inline void ObjectTrackMatcherConfig::clear_bg_weight_centroid_shift_dist() {
  bg_weight_centroid_shift_dist_ = 0.2f;
  _has_bits_[0] &= ~0x00000100u;
}
inline float ObjectTrackMatcherConfig::_internal_bg_weight_centroid_shift_dist() const {
  return bg_weight_centroid_shift_dist_;
}
inline float ObjectTrackMatcherConfig::bg_weight_centroid_shift_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_centroid_shift_dist)
  return _internal_bg_weight_centroid_shift_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_bg_weight_centroid_shift_dist(float value) {
  _has_bits_[0] |= 0x00000100u;
  bg_weight_centroid_shift_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_bg_weight_centroid_shift_dist(float value) {
  _internal_set_bg_weight_centroid_shift_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_centroid_shift_dist)
}

// optional float bg_weight_bbox_iou_dist = 8 [default = 0.8];
inline bool ObjectTrackMatcherConfig::_internal_has_bg_weight_bbox_iou_dist() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_bg_weight_bbox_iou_dist() const {
  return _internal_has_bg_weight_bbox_iou_dist();
}
inline void ObjectTrackMatcherConfig::clear_bg_weight_bbox_iou_dist() {
  bg_weight_bbox_iou_dist_ = 0.8f;
  _has_bits_[0] &= ~0x00000200u;
}
inline float ObjectTrackMatcherConfig::_internal_bg_weight_bbox_iou_dist() const {
  return bg_weight_bbox_iou_dist_;
}
inline float ObjectTrackMatcherConfig::bg_weight_bbox_iou_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_bbox_iou_dist)
  return _internal_bg_weight_bbox_iou_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_bg_weight_bbox_iou_dist(float value) {
  _has_bits_[0] |= 0x00000200u;
  bg_weight_bbox_iou_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_bg_weight_bbox_iou_dist(float value) {
  _internal_set_bg_weight_bbox_iou_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_weight_bbox_iou_dist)
}

// optional float bg_background_object_match_threshold = 9 [default = 4];
inline bool ObjectTrackMatcherConfig::_internal_has_bg_background_object_match_threshold() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_bg_background_object_match_threshold() const {
  return _internal_has_bg_background_object_match_threshold();
}
inline void ObjectTrackMatcherConfig::clear_bg_background_object_match_threshold() {
  bg_background_object_match_threshold_ = 4;
  _has_bits_[0] &= ~0x00000400u;
}
inline float ObjectTrackMatcherConfig::_internal_bg_background_object_match_threshold() const {
  return bg_background_object_match_threshold_;
}
inline float ObjectTrackMatcherConfig::bg_background_object_match_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_background_object_match_threshold)
  return _internal_bg_background_object_match_threshold();
}
inline void ObjectTrackMatcherConfig::_internal_set_bg_background_object_match_threshold(float value) {
  _has_bits_[0] |= 0x00000400u;
  bg_background_object_match_threshold_ = value;
}
inline void ObjectTrackMatcherConfig::set_bg_background_object_match_threshold(float value) {
  _internal_set_bg_background_object_match_threshold(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.bg_background_object_match_threshold)
}

// optional float fg_weight_location_dist = 10 [default = 0.6];
inline bool ObjectTrackMatcherConfig::_internal_has_fg_weight_location_dist() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_fg_weight_location_dist() const {
  return _internal_has_fg_weight_location_dist();
}
inline void ObjectTrackMatcherConfig::clear_fg_weight_location_dist() {
  fg_weight_location_dist_ = 0.6f;
  _has_bits_[0] &= ~0x00000800u;
}
inline float ObjectTrackMatcherConfig::_internal_fg_weight_location_dist() const {
  return fg_weight_location_dist_;
}
inline float ObjectTrackMatcherConfig::fg_weight_location_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_location_dist)
  return _internal_fg_weight_location_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_fg_weight_location_dist(float value) {
  _has_bits_[0] |= 0x00000800u;
  fg_weight_location_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_fg_weight_location_dist(float value) {
  _internal_set_fg_weight_location_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_location_dist)
}

// optional float fg_weight_direction_dist = 11 [default = 0.2];
inline bool ObjectTrackMatcherConfig::_internal_has_fg_weight_direction_dist() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_fg_weight_direction_dist() const {
  return _internal_has_fg_weight_direction_dist();
}
inline void ObjectTrackMatcherConfig::clear_fg_weight_direction_dist() {
  fg_weight_direction_dist_ = 0.2f;
  _has_bits_[0] &= ~0x00001000u;
}
inline float ObjectTrackMatcherConfig::_internal_fg_weight_direction_dist() const {
  return fg_weight_direction_dist_;
}
inline float ObjectTrackMatcherConfig::fg_weight_direction_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_direction_dist)
  return _internal_fg_weight_direction_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_fg_weight_direction_dist(float value) {
  _has_bits_[0] |= 0x00001000u;
  fg_weight_direction_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_fg_weight_direction_dist(float value) {
  _internal_set_fg_weight_direction_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_direction_dist)
}

// optional float fg_weight_bbox_size_dist = 12 [default = 0.1];
inline bool ObjectTrackMatcherConfig::_internal_has_fg_weight_bbox_size_dist() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_fg_weight_bbox_size_dist() const {
  return _internal_has_fg_weight_bbox_size_dist();
}
inline void ObjectTrackMatcherConfig::clear_fg_weight_bbox_size_dist() {
  fg_weight_bbox_size_dist_ = 0.1f;
  _has_bits_[0] &= ~0x00002000u;
}
inline float ObjectTrackMatcherConfig::_internal_fg_weight_bbox_size_dist() const {
  return fg_weight_bbox_size_dist_;
}
inline float ObjectTrackMatcherConfig::fg_weight_bbox_size_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_bbox_size_dist)
  return _internal_fg_weight_bbox_size_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_fg_weight_bbox_size_dist(float value) {
  _has_bits_[0] |= 0x00002000u;
  fg_weight_bbox_size_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_fg_weight_bbox_size_dist(float value) {
  _internal_set_fg_weight_bbox_size_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_bbox_size_dist)
}

// optional float fg_weight_point_num_dist = 13 [default = 0.1];
inline bool ObjectTrackMatcherConfig::_internal_has_fg_weight_point_num_dist() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_fg_weight_point_num_dist() const {
  return _internal_has_fg_weight_point_num_dist();
}
inline void ObjectTrackMatcherConfig::clear_fg_weight_point_num_dist() {
  fg_weight_point_num_dist_ = 0.1f;
  _has_bits_[0] &= ~0x00004000u;
}
inline float ObjectTrackMatcherConfig::_internal_fg_weight_point_num_dist() const {
  return fg_weight_point_num_dist_;
}
inline float ObjectTrackMatcherConfig::fg_weight_point_num_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_point_num_dist)
  return _internal_fg_weight_point_num_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_fg_weight_point_num_dist(float value) {
  _has_bits_[0] |= 0x00004000u;
  fg_weight_point_num_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_fg_weight_point_num_dist(float value) {
  _internal_set_fg_weight_point_num_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_point_num_dist)
}

// optional float fg_weight_histogram_dist = 14 [default = 0.5];
inline bool ObjectTrackMatcherConfig::_internal_has_fg_weight_histogram_dist() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_fg_weight_histogram_dist() const {
  return _internal_has_fg_weight_histogram_dist();
}
inline void ObjectTrackMatcherConfig::clear_fg_weight_histogram_dist() {
  fg_weight_histogram_dist_ = 0.5f;
  _has_bits_[0] &= ~0x00008000u;
}
inline float ObjectTrackMatcherConfig::_internal_fg_weight_histogram_dist() const {
  return fg_weight_histogram_dist_;
}
inline float ObjectTrackMatcherConfig::fg_weight_histogram_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_histogram_dist)
  return _internal_fg_weight_histogram_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_fg_weight_histogram_dist(float value) {
  _has_bits_[0] |= 0x00008000u;
  fg_weight_histogram_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_fg_weight_histogram_dist(float value) {
  _internal_set_fg_weight_histogram_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_histogram_dist)
}

// optional float fg_weight_centroid_shift_dist = 15 [default = 0];
inline bool ObjectTrackMatcherConfig::_internal_has_fg_weight_centroid_shift_dist() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_fg_weight_centroid_shift_dist() const {
  return _internal_has_fg_weight_centroid_shift_dist();
}
inline void ObjectTrackMatcherConfig::clear_fg_weight_centroid_shift_dist() {
  fg_weight_centroid_shift_dist_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float ObjectTrackMatcherConfig::_internal_fg_weight_centroid_shift_dist() const {
  return fg_weight_centroid_shift_dist_;
}
inline float ObjectTrackMatcherConfig::fg_weight_centroid_shift_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_centroid_shift_dist)
  return _internal_fg_weight_centroid_shift_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_fg_weight_centroid_shift_dist(float value) {
  _has_bits_[0] |= 0x00000020u;
  fg_weight_centroid_shift_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_fg_weight_centroid_shift_dist(float value) {
  _internal_set_fg_weight_centroid_shift_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_centroid_shift_dist)
}

// optional float fg_weight_bbox_iou_dist = 16 [default = 0];
inline bool ObjectTrackMatcherConfig::_internal_has_fg_weight_bbox_iou_dist() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_fg_weight_bbox_iou_dist() const {
  return _internal_has_fg_weight_bbox_iou_dist();
}
inline void ObjectTrackMatcherConfig::clear_fg_weight_bbox_iou_dist() {
  fg_weight_bbox_iou_dist_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float ObjectTrackMatcherConfig::_internal_fg_weight_bbox_iou_dist() const {
  return fg_weight_bbox_iou_dist_;
}
inline float ObjectTrackMatcherConfig::fg_weight_bbox_iou_dist() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_bbox_iou_dist)
  return _internal_fg_weight_bbox_iou_dist();
}
inline void ObjectTrackMatcherConfig::_internal_set_fg_weight_bbox_iou_dist(float value) {
  _has_bits_[0] |= 0x00000040u;
  fg_weight_bbox_iou_dist_ = value;
}
inline void ObjectTrackMatcherConfig::set_fg_weight_bbox_iou_dist(float value) {
  _internal_set_fg_weight_bbox_iou_dist(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.fg_weight_bbox_iou_dist)
}

// optional float bound_value = 17 [default = 100];
inline bool ObjectTrackMatcherConfig::_internal_has_bound_value() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ObjectTrackMatcherConfig::has_bound_value() const {
  return _internal_has_bound_value();
}
inline void ObjectTrackMatcherConfig::clear_bound_value() {
  bound_value_ = 100;
  _has_bits_[0] &= ~0x00010000u;
}
inline float ObjectTrackMatcherConfig::_internal_bound_value() const {
  return bound_value_;
}
inline float ObjectTrackMatcherConfig::bound_value() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.ObjectTrackMatcherConfig.bound_value)
  return _internal_bound_value();
}
inline void ObjectTrackMatcherConfig::_internal_set_bound_value(float value) {
  _has_bits_[0] |= 0x00010000u;
  bound_value_ = value;
}
inline void ObjectTrackMatcherConfig::set_bound_value(float value) {
  _internal_set_bound_value(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.ObjectTrackMatcherConfig.bound_value)
}

// -------------------------------------------------------------------

// KalmanFilterConfig

// optional float noise_maximum = 1 [default = 0.1];
inline bool KalmanFilterConfig::_internal_has_noise_maximum() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KalmanFilterConfig::has_noise_maximum() const {
  return _internal_has_noise_maximum();
}
inline void KalmanFilterConfig::clear_noise_maximum() {
  noise_maximum_ = 0.1f;
  _has_bits_[0] &= ~0x00000008u;
}
inline float KalmanFilterConfig::_internal_noise_maximum() const {
  return noise_maximum_;
}
inline float KalmanFilterConfig::noise_maximum() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.KalmanFilterConfig.noise_maximum)
  return _internal_noise_maximum();
}
inline void KalmanFilterConfig::_internal_set_noise_maximum(float value) {
  _has_bits_[0] |= 0x00000008u;
  noise_maximum_ = value;
}
inline void KalmanFilterConfig::set_noise_maximum(float value) {
  _internal_set_noise_maximum(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.KalmanFilterConfig.noise_maximum)
}

// optional bool use_adaptive = 2 [default = false];
inline bool KalmanFilterConfig::_internal_has_use_adaptive() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KalmanFilterConfig::has_use_adaptive() const {
  return _internal_has_use_adaptive();
}
inline void KalmanFilterConfig::clear_use_adaptive() {
  use_adaptive_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool KalmanFilterConfig::_internal_use_adaptive() const {
  return use_adaptive_;
}
inline bool KalmanFilterConfig::use_adaptive() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.KalmanFilterConfig.use_adaptive)
  return _internal_use_adaptive();
}
inline void KalmanFilterConfig::_internal_set_use_adaptive(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_adaptive_ = value;
}
inline void KalmanFilterConfig::set_use_adaptive(bool value) {
  _internal_set_use_adaptive(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.KalmanFilterConfig.use_adaptive)
}

// optional float centroid_measurement_noise = 3 [default = 0.4];
inline bool KalmanFilterConfig::_internal_has_centroid_measurement_noise() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool KalmanFilterConfig::has_centroid_measurement_noise() const {
  return _internal_has_centroid_measurement_noise();
}
inline void KalmanFilterConfig::clear_centroid_measurement_noise() {
  centroid_measurement_noise_ = 0.4f;
  _has_bits_[0] &= ~0x00000010u;
}
inline float KalmanFilterConfig::_internal_centroid_measurement_noise() const {
  return centroid_measurement_noise_;
}
inline float KalmanFilterConfig::centroid_measurement_noise() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.KalmanFilterConfig.centroid_measurement_noise)
  return _internal_centroid_measurement_noise();
}
inline void KalmanFilterConfig::_internal_set_centroid_measurement_noise(float value) {
  _has_bits_[0] |= 0x00000010u;
  centroid_measurement_noise_ = value;
}
inline void KalmanFilterConfig::set_centroid_measurement_noise(float value) {
  _internal_set_centroid_measurement_noise(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.KalmanFilterConfig.centroid_measurement_noise)
}

// optional float centroid_init_velocity_variance = 4 [default = 5];
inline bool KalmanFilterConfig::_internal_has_centroid_init_velocity_variance() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool KalmanFilterConfig::has_centroid_init_velocity_variance() const {
  return _internal_has_centroid_init_velocity_variance();
}
inline void KalmanFilterConfig::clear_centroid_init_velocity_variance() {
  centroid_init_velocity_variance_ = 5;
  _has_bits_[0] &= ~0x00000020u;
}
inline float KalmanFilterConfig::_internal_centroid_init_velocity_variance() const {
  return centroid_init_velocity_variance_;
}
inline float KalmanFilterConfig::centroid_init_velocity_variance() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.KalmanFilterConfig.centroid_init_velocity_variance)
  return _internal_centroid_init_velocity_variance();
}
inline void KalmanFilterConfig::_internal_set_centroid_init_velocity_variance(float value) {
  _has_bits_[0] |= 0x00000020u;
  centroid_init_velocity_variance_ = value;
}
inline void KalmanFilterConfig::set_centroid_init_velocity_variance(float value) {
  _internal_set_centroid_init_velocity_variance(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.KalmanFilterConfig.centroid_init_velocity_variance)
}

// optional float propagation_variance_xy = 5 [default = 10];
inline bool KalmanFilterConfig::_internal_has_propagation_variance_xy() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool KalmanFilterConfig::has_propagation_variance_xy() const {
  return _internal_has_propagation_variance_xy();
}
inline void KalmanFilterConfig::clear_propagation_variance_xy() {
  propagation_variance_xy_ = 10;
  _has_bits_[0] &= ~0x00000040u;
}
inline float KalmanFilterConfig::_internal_propagation_variance_xy() const {
  return propagation_variance_xy_;
}
inline float KalmanFilterConfig::propagation_variance_xy() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.KalmanFilterConfig.propagation_variance_xy)
  return _internal_propagation_variance_xy();
}
inline void KalmanFilterConfig::_internal_set_propagation_variance_xy(float value) {
  _has_bits_[0] |= 0x00000040u;
  propagation_variance_xy_ = value;
}
inline void KalmanFilterConfig::set_propagation_variance_xy(float value) {
  _internal_set_propagation_variance_xy(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.KalmanFilterConfig.propagation_variance_xy)
}

// optional float propagation_variance_z = 6 [default = 10];
inline bool KalmanFilterConfig::_internal_has_propagation_variance_z() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool KalmanFilterConfig::has_propagation_variance_z() const {
  return _internal_has_propagation_variance_z();
}
inline void KalmanFilterConfig::clear_propagation_variance_z() {
  propagation_variance_z_ = 10;
  _has_bits_[0] &= ~0x00000080u;
}
inline float KalmanFilterConfig::_internal_propagation_variance_z() const {
  return propagation_variance_z_;
}
inline float KalmanFilterConfig::propagation_variance_z() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.KalmanFilterConfig.propagation_variance_z)
  return _internal_propagation_variance_z();
}
inline void KalmanFilterConfig::_internal_set_propagation_variance_z(float value) {
  _has_bits_[0] |= 0x00000080u;
  propagation_variance_z_ = value;
}
inline void KalmanFilterConfig::set_propagation_variance_z(float value) {
  _internal_set_propagation_variance_z(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.KalmanFilterConfig.propagation_variance_z)
}

// optional bool use_convergence_boostup = 7 [default = false];
inline bool KalmanFilterConfig::_internal_has_use_convergence_boostup() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KalmanFilterConfig::has_use_convergence_boostup() const {
  return _internal_has_use_convergence_boostup();
}
inline void KalmanFilterConfig::clear_use_convergence_boostup() {
  use_convergence_boostup_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool KalmanFilterConfig::_internal_use_convergence_boostup() const {
  return use_convergence_boostup_;
}
inline bool KalmanFilterConfig::use_convergence_boostup() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.KalmanFilterConfig.use_convergence_boostup)
  return _internal_use_convergence_boostup();
}
inline void KalmanFilterConfig::_internal_set_use_convergence_boostup(bool value) {
  _has_bits_[0] |= 0x00000002u;
  use_convergence_boostup_ = value;
}
inline void KalmanFilterConfig::set_use_convergence_boostup(bool value) {
  _internal_set_use_convergence_boostup(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.KalmanFilterConfig.use_convergence_boostup)
}

// optional int32 boostup_history_size_minimum = 8 [default = 3];
inline bool KalmanFilterConfig::_internal_has_boostup_history_size_minimum() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool KalmanFilterConfig::has_boostup_history_size_minimum() const {
  return _internal_has_boostup_history_size_minimum();
}
inline void KalmanFilterConfig::clear_boostup_history_size_minimum() {
  boostup_history_size_minimum_ = 3;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KalmanFilterConfig::_internal_boostup_history_size_minimum() const {
  return boostup_history_size_minimum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KalmanFilterConfig::boostup_history_size_minimum() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.KalmanFilterConfig.boostup_history_size_minimum)
  return _internal_boostup_history_size_minimum();
}
inline void KalmanFilterConfig::_internal_set_boostup_history_size_minimum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  boostup_history_size_minimum_ = value;
}
inline void KalmanFilterConfig::set_boostup_history_size_minimum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_boostup_history_size_minimum(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.KalmanFilterConfig.boostup_history_size_minimum)
}

// optional float converged_confidence_minimum = 9 [default = 0.9];
inline bool KalmanFilterConfig::_internal_has_converged_confidence_minimum() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KalmanFilterConfig::has_converged_confidence_minimum() const {
  return _internal_has_converged_confidence_minimum();
}
inline void KalmanFilterConfig::clear_converged_confidence_minimum() {
  converged_confidence_minimum_ = 0.9f;
  _has_bits_[0] &= ~0x00000004u;
}
inline float KalmanFilterConfig::_internal_converged_confidence_minimum() const {
  return converged_confidence_minimum_;
}
inline float KalmanFilterConfig::converged_confidence_minimum() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.KalmanFilterConfig.converged_confidence_minimum)
  return _internal_converged_confidence_minimum();
}
inline void KalmanFilterConfig::_internal_set_converged_confidence_minimum(float value) {
  _has_bits_[0] |= 0x00000004u;
  converged_confidence_minimum_ = value;
}
inline void KalmanFilterConfig::set_converged_confidence_minimum(float value) {
  _internal_set_converged_confidence_minimum(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.KalmanFilterConfig.converged_confidence_minimum)
}

// -------------------------------------------------------------------

// TrackerConfig

// optional string filter_name = 1 [default = "KalmanFilter"];
inline bool TrackerConfig::_internal_has_filter_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackerConfig::has_filter_name() const {
  return _internal_has_filter_name();
}
inline void TrackerConfig::clear_filter_name() {
  filter_name_.ClearToDefaultNoArena(&::apollo::perception::lidar::TrackerConfig::_i_give_permission_to_break_this_code_default_filter_name_.get());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackerConfig::filter_name() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.TrackerConfig.filter_name)
  return _internal_filter_name();
}
inline void TrackerConfig::set_filter_name(const std::string& value) {
  _internal_set_filter_name(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.TrackerConfig.filter_name)
}
inline std::string* TrackerConfig::mutable_filter_name() {
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.TrackerConfig.filter_name)
  return _internal_mutable_filter_name();
}
inline const std::string& TrackerConfig::_internal_filter_name() const {
  return filter_name_.GetNoArena();
}
inline void TrackerConfig::_internal_set_filter_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filter_name_.SetNoArena(&::apollo::perception::lidar::TrackerConfig::_i_give_permission_to_break_this_code_default_filter_name_.get(), value);
}
inline void TrackerConfig::set_filter_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  filter_name_.SetNoArena(
    &::apollo::perception::lidar::TrackerConfig::_i_give_permission_to_break_this_code_default_filter_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.perception.lidar.TrackerConfig.filter_name)
}
inline void TrackerConfig::set_filter_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  filter_name_.SetNoArena(&::apollo::perception::lidar::TrackerConfig::_i_give_permission_to_break_this_code_default_filter_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.perception.lidar.TrackerConfig.filter_name)
}
inline void TrackerConfig::set_filter_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  filter_name_.SetNoArena(&::apollo::perception::lidar::TrackerConfig::_i_give_permission_to_break_this_code_default_filter_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.perception.lidar.TrackerConfig.filter_name)
}
inline std::string* TrackerConfig::_internal_mutable_filter_name() {
  _has_bits_[0] |= 0x00000001u;
  return filter_name_.MutableNoArena(&::apollo::perception::lidar::TrackerConfig::_i_give_permission_to_break_this_code_default_filter_name_.get());
}
inline std::string* TrackerConfig::release_filter_name() {
  // @@protoc_insertion_point(field_release:apollo.perception.lidar.TrackerConfig.filter_name)
  if (!_internal_has_filter_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return filter_name_.ReleaseNonDefaultNoArena(&::apollo::perception::lidar::TrackerConfig::_i_give_permission_to_break_this_code_default_filter_name_.get());
}
inline void TrackerConfig::set_allocated_filter_name(std::string* filter_name) {
  if (filter_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_name_.SetAllocatedNoArena(&::apollo::perception::lidar::TrackerConfig::_i_give_permission_to_break_this_code_default_filter_name_.get(), filter_name);
  // @@protoc_insertion_point(field_set_allocated:apollo.perception.lidar.TrackerConfig.filter_name)
}

// optional bool separate_fore_background = 2 [default = false];
inline bool TrackerConfig::_internal_has_separate_fore_background() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrackerConfig::has_separate_fore_background() const {
  return _internal_has_separate_fore_background();
}
inline void TrackerConfig::clear_separate_fore_background() {
  separate_fore_background_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool TrackerConfig::_internal_separate_fore_background() const {
  return separate_fore_background_;
}
inline bool TrackerConfig::separate_fore_background() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.TrackerConfig.separate_fore_background)
  return _internal_separate_fore_background();
}
inline void TrackerConfig::_internal_set_separate_fore_background(bool value) {
  _has_bits_[0] |= 0x00000002u;
  separate_fore_background_ = value;
}
inline void TrackerConfig::set_separate_fore_background(bool value) {
  _internal_set_separate_fore_background(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.TrackerConfig.separate_fore_background)
}

// -------------------------------------------------------------------

// HmMultiTargetTrackerConfig

// optional string filter_method = 1 [default = "KalmanFilter"];
inline bool HmMultiTargetTrackerConfig::_internal_has_filter_method() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HmMultiTargetTrackerConfig::has_filter_method() const {
  return _internal_has_filter_method();
}
inline void HmMultiTargetTrackerConfig::clear_filter_method() {
  filter_method_.ClearToDefaultNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_filter_method_.get());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HmMultiTargetTrackerConfig::filter_method() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.HmMultiTargetTrackerConfig.filter_method)
  return _internal_filter_method();
}
inline void HmMultiTargetTrackerConfig::set_filter_method(const std::string& value) {
  _internal_set_filter_method(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.HmMultiTargetTrackerConfig.filter_method)
}
inline std::string* HmMultiTargetTrackerConfig::mutable_filter_method() {
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.HmMultiTargetTrackerConfig.filter_method)
  return _internal_mutable_filter_method();
}
inline const std::string& HmMultiTargetTrackerConfig::_internal_filter_method() const {
  return filter_method_.GetNoArena();
}
inline void HmMultiTargetTrackerConfig::_internal_set_filter_method(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filter_method_.SetNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_filter_method_.get(), value);
}
inline void HmMultiTargetTrackerConfig::set_filter_method(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  filter_method_.SetNoArena(
    &::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_filter_method_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.perception.lidar.HmMultiTargetTrackerConfig.filter_method)
}
inline void HmMultiTargetTrackerConfig::set_filter_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  filter_method_.SetNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_filter_method_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.perception.lidar.HmMultiTargetTrackerConfig.filter_method)
}
inline void HmMultiTargetTrackerConfig::set_filter_method(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  filter_method_.SetNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_filter_method_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.perception.lidar.HmMultiTargetTrackerConfig.filter_method)
}
inline std::string* HmMultiTargetTrackerConfig::_internal_mutable_filter_method() {
  _has_bits_[0] |= 0x00000001u;
  return filter_method_.MutableNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_filter_method_.get());
}
inline std::string* HmMultiTargetTrackerConfig::release_filter_method() {
  // @@protoc_insertion_point(field_release:apollo.perception.lidar.HmMultiTargetTrackerConfig.filter_method)
  if (!_internal_has_filter_method()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return filter_method_.ReleaseNonDefaultNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_filter_method_.get());
}
inline void HmMultiTargetTrackerConfig::set_allocated_filter_method(std::string* filter_method) {
  if (filter_method != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_method_.SetAllocatedNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_filter_method_.get(), filter_method);
  // @@protoc_insertion_point(field_set_allocated:apollo.perception.lidar.HmMultiTargetTrackerConfig.filter_method)
}

// optional string foreground_mathcer_method = 2 [default = "MultiHmBipartiteGraphMatcher"];
inline bool HmMultiTargetTrackerConfig::_internal_has_foreground_mathcer_method() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HmMultiTargetTrackerConfig::has_foreground_mathcer_method() const {
  return _internal_has_foreground_mathcer_method();
}
inline void HmMultiTargetTrackerConfig::clear_foreground_mathcer_method() {
  foreground_mathcer_method_.ClearToDefaultNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HmMultiTargetTrackerConfig::foreground_mathcer_method() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.HmMultiTargetTrackerConfig.foreground_mathcer_method)
  return _internal_foreground_mathcer_method();
}
inline void HmMultiTargetTrackerConfig::set_foreground_mathcer_method(const std::string& value) {
  _internal_set_foreground_mathcer_method(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.HmMultiTargetTrackerConfig.foreground_mathcer_method)
}
inline std::string* HmMultiTargetTrackerConfig::mutable_foreground_mathcer_method() {
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.HmMultiTargetTrackerConfig.foreground_mathcer_method)
  return _internal_mutable_foreground_mathcer_method();
}
inline const std::string& HmMultiTargetTrackerConfig::_internal_foreground_mathcer_method() const {
  return foreground_mathcer_method_.GetNoArena();
}
inline void HmMultiTargetTrackerConfig::_internal_set_foreground_mathcer_method(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  foreground_mathcer_method_.SetNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get(), value);
}
inline void HmMultiTargetTrackerConfig::set_foreground_mathcer_method(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  foreground_mathcer_method_.SetNoArena(
    &::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.perception.lidar.HmMultiTargetTrackerConfig.foreground_mathcer_method)
}
inline void HmMultiTargetTrackerConfig::set_foreground_mathcer_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  foreground_mathcer_method_.SetNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.perception.lidar.HmMultiTargetTrackerConfig.foreground_mathcer_method)
}
inline void HmMultiTargetTrackerConfig::set_foreground_mathcer_method(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  foreground_mathcer_method_.SetNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.perception.lidar.HmMultiTargetTrackerConfig.foreground_mathcer_method)
}
inline std::string* HmMultiTargetTrackerConfig::_internal_mutable_foreground_mathcer_method() {
  _has_bits_[0] |= 0x00000002u;
  return foreground_mathcer_method_.MutableNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get());
}
inline std::string* HmMultiTargetTrackerConfig::release_foreground_mathcer_method() {
  // @@protoc_insertion_point(field_release:apollo.perception.lidar.HmMultiTargetTrackerConfig.foreground_mathcer_method)
  if (!_internal_has_foreground_mathcer_method()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return foreground_mathcer_method_.ReleaseNonDefaultNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get());
}
inline void HmMultiTargetTrackerConfig::set_allocated_foreground_mathcer_method(std::string* foreground_mathcer_method) {
  if (foreground_mathcer_method != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  foreground_mathcer_method_.SetAllocatedNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get(), foreground_mathcer_method);
  // @@protoc_insertion_point(field_set_allocated:apollo.perception.lidar.HmMultiTargetTrackerConfig.foreground_mathcer_method)
}

// optional string background_matcher_method = 3 [default = "GnnBipartiteGraphMatcher"];
inline bool HmMultiTargetTrackerConfig::_internal_has_background_matcher_method() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HmMultiTargetTrackerConfig::has_background_matcher_method() const {
  return _internal_has_background_matcher_method();
}
inline void HmMultiTargetTrackerConfig::clear_background_matcher_method() {
  background_matcher_method_.ClearToDefaultNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& HmMultiTargetTrackerConfig::background_matcher_method() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.HmMultiTargetTrackerConfig.background_matcher_method)
  return _internal_background_matcher_method();
}
inline void HmMultiTargetTrackerConfig::set_background_matcher_method(const std::string& value) {
  _internal_set_background_matcher_method(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.HmMultiTargetTrackerConfig.background_matcher_method)
}
inline std::string* HmMultiTargetTrackerConfig::mutable_background_matcher_method() {
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.HmMultiTargetTrackerConfig.background_matcher_method)
  return _internal_mutable_background_matcher_method();
}
inline const std::string& HmMultiTargetTrackerConfig::_internal_background_matcher_method() const {
  return background_matcher_method_.GetNoArena();
}
inline void HmMultiTargetTrackerConfig::_internal_set_background_matcher_method(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  background_matcher_method_.SetNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get(), value);
}
inline void HmMultiTargetTrackerConfig::set_background_matcher_method(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  background_matcher_method_.SetNoArena(
    &::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.perception.lidar.HmMultiTargetTrackerConfig.background_matcher_method)
}
inline void HmMultiTargetTrackerConfig::set_background_matcher_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  background_matcher_method_.SetNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.perception.lidar.HmMultiTargetTrackerConfig.background_matcher_method)
}
inline void HmMultiTargetTrackerConfig::set_background_matcher_method(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  background_matcher_method_.SetNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.perception.lidar.HmMultiTargetTrackerConfig.background_matcher_method)
}
inline std::string* HmMultiTargetTrackerConfig::_internal_mutable_background_matcher_method() {
  _has_bits_[0] |= 0x00000004u;
  return background_matcher_method_.MutableNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get());
}
inline std::string* HmMultiTargetTrackerConfig::release_background_matcher_method() {
  // @@protoc_insertion_point(field_release:apollo.perception.lidar.HmMultiTargetTrackerConfig.background_matcher_method)
  if (!_internal_has_background_matcher_method()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return background_matcher_method_.ReleaseNonDefaultNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get());
}
inline void HmMultiTargetTrackerConfig::set_allocated_background_matcher_method(std::string* background_matcher_method) {
  if (background_matcher_method != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  background_matcher_method_.SetAllocatedNoArena(&::apollo::perception::lidar::HmMultiTargetTrackerConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get(), background_matcher_method);
  // @@protoc_insertion_point(field_set_allocated:apollo.perception.lidar.HmMultiTargetTrackerConfig.background_matcher_method)
}

// optional bool use_histogram_for_match = 4 [default = true];
inline bool HmMultiTargetTrackerConfig::_internal_has_use_histogram_for_match() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HmMultiTargetTrackerConfig::has_use_histogram_for_match() const {
  return _internal_has_use_histogram_for_match();
}
inline void HmMultiTargetTrackerConfig::clear_use_histogram_for_match() {
  use_histogram_for_match_ = true;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool HmMultiTargetTrackerConfig::_internal_use_histogram_for_match() const {
  return use_histogram_for_match_;
}
inline bool HmMultiTargetTrackerConfig::use_histogram_for_match() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.HmMultiTargetTrackerConfig.use_histogram_for_match)
  return _internal_use_histogram_for_match();
}
inline void HmMultiTargetTrackerConfig::_internal_set_use_histogram_for_match(bool value) {
  _has_bits_[0] |= 0x00000008u;
  use_histogram_for_match_ = value;
}
inline void HmMultiTargetTrackerConfig::set_use_histogram_for_match(bool value) {
  _internal_set_use_histogram_for_match(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.HmMultiTargetTrackerConfig.use_histogram_for_match)
}

// optional float histogram_bin_size = 5 [default = 10];
inline bool HmMultiTargetTrackerConfig::_internal_has_histogram_bin_size() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool HmMultiTargetTrackerConfig::has_histogram_bin_size() const {
  return _internal_has_histogram_bin_size();
}
inline void HmMultiTargetTrackerConfig::clear_histogram_bin_size() {
  histogram_bin_size_ = 10;
  _has_bits_[0] &= ~0x00000010u;
}
inline float HmMultiTargetTrackerConfig::_internal_histogram_bin_size() const {
  return histogram_bin_size_;
}
inline float HmMultiTargetTrackerConfig::histogram_bin_size() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.HmMultiTargetTrackerConfig.histogram_bin_size)
  return _internal_histogram_bin_size();
}
inline void HmMultiTargetTrackerConfig::_internal_set_histogram_bin_size(float value) {
  _has_bits_[0] |= 0x00000010u;
  histogram_bin_size_ = value;
}
inline void HmMultiTargetTrackerConfig::set_histogram_bin_size(float value) {
  _internal_set_histogram_bin_size(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.HmMultiTargetTrackerConfig.histogram_bin_size)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lidar
}  // namespace perception
}  // namespace apollo

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fperception_2fproto_2fhm_5ftracker_5fconfig_2eproto
